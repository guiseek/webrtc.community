;(window.webpackJsonp = window.webpackJsonp || []).push([
  [1],
  {
    0: function (t, e, n) {
      t.exports = n('Zr4m')
    },
    '0z79': function (t, e, n) {
      var i = n('AdPF'),
        s = n('CUme'),
        r = n('cpc2'),
        o = n('Yvos'),
        a = n('NOtv')('engine.io-client:polling-xhr'),
        l = n('2UHX')
      function c() {}
      function h(t) {
        if (
          (s.call(this, t),
          (this.requestTimeout = t.requestTimeout),
          (this.extraHeaders = t.extraHeaders),
          'undefined' != typeof location)
        ) {
          var e = 'https:' === location.protocol,
            n = location.port
          n || (n = e ? 443 : 80),
            (this.xd =
              ('undefined' != typeof location &&
                t.hostname !== location.hostname) ||
              n !== t.port),
            (this.xs = t.secure !== e)
        }
      }
      function u(t) {
        ;(this.method = t.method || 'GET'),
          (this.uri = t.uri),
          (this.xd = !!t.xd),
          (this.xs = !!t.xs),
          (this.async = !1 !== t.async),
          (this.data = void 0 !== t.data ? t.data : null),
          (this.agent = t.agent),
          (this.isBinary = t.isBinary),
          (this.supportsBinary = t.supportsBinary),
          (this.enablesXDR = t.enablesXDR),
          (this.withCredentials = t.withCredentials),
          (this.requestTimeout = t.requestTimeout),
          (this.pfx = t.pfx),
          (this.key = t.key),
          (this.passphrase = t.passphrase),
          (this.cert = t.cert),
          (this.ca = t.ca),
          (this.ciphers = t.ciphers),
          (this.rejectUnauthorized = t.rejectUnauthorized),
          (this.extraHeaders = t.extraHeaders),
          this.create()
      }
      function d() {
        for (var t in u.requests)
          u.requests.hasOwnProperty(t) && u.requests[t].abort()
      }
      ;(t.exports = h),
        (t.exports.Request = u),
        o(h, s),
        (h.prototype.supportsBinary = !0),
        (h.prototype.request = function (t) {
          return (
            ((t = t || {}).uri = this.uri()),
            (t.xd = this.xd),
            (t.xs = this.xs),
            (t.agent = this.agent || !1),
            (t.supportsBinary = this.supportsBinary),
            (t.enablesXDR = this.enablesXDR),
            (t.withCredentials = this.withCredentials),
            (t.pfx = this.pfx),
            (t.key = this.key),
            (t.passphrase = this.passphrase),
            (t.cert = this.cert),
            (t.ca = this.ca),
            (t.ciphers = this.ciphers),
            (t.rejectUnauthorized = this.rejectUnauthorized),
            (t.requestTimeout = this.requestTimeout),
            (t.extraHeaders = this.extraHeaders),
            new u(t)
          )
        }),
        (h.prototype.doWrite = function (t, e) {
          var n = this.request({
              method: 'POST',
              data: t,
              isBinary: 'string' != typeof t && void 0 !== t,
            }),
            i = this
          n.on('success', e),
            n.on('error', function (t) {
              i.onError('xhr post error', t)
            }),
            (this.sendXhr = n)
        }),
        (h.prototype.doPoll = function () {
          a('xhr poll')
          var t = this.request(),
            e = this
          t.on('data', function (t) {
            e.onData(t)
          }),
            t.on('error', function (t) {
              e.onError('xhr poll error', t)
            }),
            (this.pollXhr = t)
        }),
        r(u.prototype),
        (u.prototype.create = function () {
          var t = {
            agent: this.agent,
            xdomain: this.xd,
            xscheme: this.xs,
            enablesXDR: this.enablesXDR,
          }
          ;(t.pfx = this.pfx),
            (t.key = this.key),
            (t.passphrase = this.passphrase),
            (t.cert = this.cert),
            (t.ca = this.ca),
            (t.ciphers = this.ciphers),
            (t.rejectUnauthorized = this.rejectUnauthorized)
          var e = (this.xhr = new i(t)),
            n = this
          try {
            a('xhr open %s: %s', this.method, this.uri),
              e.open(this.method, this.uri, this.async)
            try {
              if (this.extraHeaders)
                for (var s in (e.setDisableHeaderCheck &&
                  e.setDisableHeaderCheck(!0),
                this.extraHeaders))
                  this.extraHeaders.hasOwnProperty(s) &&
                    e.setRequestHeader(s, this.extraHeaders[s])
            } catch (r) {}
            if ('POST' === this.method)
              try {
                e.setRequestHeader(
                  'Content-type',
                  this.isBinary
                    ? 'application/octet-stream'
                    : 'text/plain;charset=UTF-8'
                )
              } catch (r) {}
            try {
              e.setRequestHeader('Accept', '*/*')
            } catch (r) {}
            'withCredentials' in e &&
              (e.withCredentials = this.withCredentials),
              this.requestTimeout && (e.timeout = this.requestTimeout),
              this.hasXDR()
                ? ((e.onload = function () {
                    n.onLoad()
                  }),
                  (e.onerror = function () {
                    n.onError(e.responseText)
                  }))
                : (e.onreadystatechange = function () {
                    if (2 === e.readyState)
                      try {
                        var t = e.getResponseHeader('Content-Type')
                        ;((n.supportsBinary &&
                          'application/octet-stream' === t) ||
                          'application/octet-stream; charset=UTF-8' === t) &&
                          (e.responseType = 'arraybuffer')
                      } catch (r) {}
                    4 === e.readyState &&
                      (200 === e.status || 1223 === e.status
                        ? n.onLoad()
                        : setTimeout(function () {
                            n.onError(
                              'number' == typeof e.status ? e.status : 0
                            )
                          }, 0))
                  }),
              a('xhr data %s', this.data),
              e.send(this.data)
          } catch (r) {
            return void setTimeout(function () {
              n.onError(r)
            }, 0)
          }
          'undefined' != typeof document &&
            ((this.index = u.requestsCount++), (u.requests[this.index] = this))
        }),
        (u.prototype.onSuccess = function () {
          this.emit('success'), this.cleanup()
        }),
        (u.prototype.onData = function (t) {
          this.emit('data', t), this.onSuccess()
        }),
        (u.prototype.onError = function (t) {
          this.emit('error', t), this.cleanup(!0)
        }),
        (u.prototype.cleanup = function (t) {
          if (null != this.xhr) {
            if (
              (this.hasXDR()
                ? (this.xhr.onload = this.xhr.onerror = c)
                : (this.xhr.onreadystatechange = c),
              t)
            )
              try {
                this.xhr.abort()
              } catch (e) {}
            'undefined' != typeof document && delete u.requests[this.index],
              (this.xhr = null)
          }
        }),
        (u.prototype.onLoad = function () {
          var t
          try {
            var e
            try {
              e = this.xhr.getResponseHeader('Content-Type')
            } catch (n) {}
            t =
              (('application/octet-stream' === e ||
                'application/octet-stream; charset=UTF-8' === e) &&
                this.xhr.response) ||
              this.xhr.responseText
          } catch (n) {
            this.onError(n)
          }
          null != t && this.onData(t)
        }),
        (u.prototype.hasXDR = function () {
          return (
            'undefined' != typeof XDomainRequest && !this.xs && this.enablesXDR
          )
        }),
        (u.prototype.abort = function () {
          this.cleanup()
        }),
        (u.requestsCount = 0),
        (u.requests = {}),
        'undefined' != typeof document &&
          ('function' == typeof attachEvent
            ? attachEvent('onunload', d)
            : 'function' == typeof addEventListener &&
              addEventListener(
                'onpagehide' in l ? 'pagehide' : 'unload',
                d,
                !1
              ))
    },
    1: function (t, e) {},
    '14A5': function (t, e) {
      var n =
          void 0 !== n
            ? n
            : 'undefined' != typeof WebKitBlobBuilder
            ? WebKitBlobBuilder
            : 'undefined' != typeof MSBlobBuilder
            ? MSBlobBuilder
            : 'undefined' != typeof MozBlobBuilder && MozBlobBuilder,
        i = (function () {
          try {
            return 2 === new Blob(['hi']).size
          } catch (t) {
            return !1
          }
        })(),
        s =
          i &&
          (function () {
            try {
              return 2 === new Blob([new Uint8Array([1, 2])]).size
            } catch (t) {
              return !1
            }
          })(),
        r = n && n.prototype.append && n.prototype.getBlob
      function o(t) {
        return t.map(function (t) {
          if (t.buffer instanceof ArrayBuffer) {
            var e = t.buffer
            if (t.byteLength !== e.byteLength) {
              var n = new Uint8Array(t.byteLength)
              n.set(new Uint8Array(e, t.byteOffset, t.byteLength)),
                (e = n.buffer)
            }
            return e
          }
          return t
        })
      }
      function a(t, e) {
        e = e || {}
        var i = new n()
        return (
          o(t).forEach(function (t) {
            i.append(t)
          }),
          e.type ? i.getBlob(e.type) : i.getBlob()
        )
      }
      function l(t, e) {
        return new Blob(o(t), e || {})
      }
      'undefined' != typeof Blob &&
        ((a.prototype = Blob.prototype), (l.prototype = Blob.prototype)),
        (t.exports = i ? (s ? Blob : l) : r ? a : void 0)
    },
    '2Dig': function (t, e) {
      t.exports = function (t, e, n) {
        return (
          t.on(e, n),
          {
            destroy: function () {
              t.removeListener(e, n)
            },
          }
        )
      }
    },
    '2UHX': function (t, e) {
      t.exports =
        'undefined' != typeof self
          ? self
          : 'undefined' != typeof window
          ? window
          : Function('return this')()
    },
    '2pII': function (t, e, n) {
      var i = n('akSB'),
        s = n('cpc2'),
        r = n('NOtv')('engine.io-client:socket'),
        o = n('7jRU'),
        a = n('Wm4p'),
        l = n('Uxeu'),
        c = n('TypT')
      function h(t, e) {
        if (!(this instanceof h)) return new h(t, e)
        ;(e = e || {}),
          t && 'object' == typeof t && ((e = t), (t = null)),
          t
            ? ((t = l(t)),
              (e.hostname = t.host),
              (e.secure = 'https' === t.protocol || 'wss' === t.protocol),
              (e.port = t.port),
              t.query && (e.query = t.query))
            : e.host && (e.hostname = l(e.host).host),
          (this.secure =
            null != e.secure
              ? e.secure
              : 'undefined' != typeof location &&
                'https:' === location.protocol),
          e.hostname && !e.port && (e.port = this.secure ? '443' : '80'),
          (this.agent = e.agent || !1),
          (this.hostname =
            e.hostname ||
            ('undefined' != typeof location ? location.hostname : 'localhost')),
          (this.port =
            e.port ||
            ('undefined' != typeof location && location.port
              ? location.port
              : this.secure
              ? 443
              : 80)),
          (this.query = e.query || {}),
          'string' == typeof this.query && (this.query = c.decode(this.query)),
          (this.upgrade = !1 !== e.upgrade),
          (this.path = (e.path || '/engine.io').replace(/\/$/, '') + '/'),
          (this.forceJSONP = !!e.forceJSONP),
          (this.jsonp = !1 !== e.jsonp),
          (this.forceBase64 = !!e.forceBase64),
          (this.enablesXDR = !!e.enablesXDR),
          (this.withCredentials = !1 !== e.withCredentials),
          (this.timestampParam = e.timestampParam || 't'),
          (this.timestampRequests = e.timestampRequests),
          (this.transports = e.transports || ['polling', 'websocket']),
          (this.transportOptions = e.transportOptions || {}),
          (this.readyState = ''),
          (this.writeBuffer = []),
          (this.prevBufferLen = 0),
          (this.policyPort = e.policyPort || 843),
          (this.rememberUpgrade = e.rememberUpgrade || !1),
          (this.binaryType = null),
          (this.onlyBinaryUpgrades = e.onlyBinaryUpgrades),
          (this.perMessageDeflate =
            !1 !== e.perMessageDeflate && (e.perMessageDeflate || {})),
          !0 === this.perMessageDeflate && (this.perMessageDeflate = {}),
          this.perMessageDeflate &&
            null == this.perMessageDeflate.threshold &&
            (this.perMessageDeflate.threshold = 1024),
          (this.pfx = e.pfx || null),
          (this.key = e.key || null),
          (this.passphrase = e.passphrase || null),
          (this.cert = e.cert || null),
          (this.ca = e.ca || null),
          (this.ciphers = e.ciphers || null),
          (this.rejectUnauthorized =
            void 0 === e.rejectUnauthorized || e.rejectUnauthorized),
          (this.forceNode = !!e.forceNode),
          (this.isReactNative =
            'undefined' != typeof navigator &&
            'string' == typeof navigator.product &&
            'reactnative' === navigator.product.toLowerCase()),
          ('undefined' == typeof self || this.isReactNative) &&
            (e.extraHeaders &&
              Object.keys(e.extraHeaders).length > 0 &&
              (this.extraHeaders = e.extraHeaders),
            e.localAddress && (this.localAddress = e.localAddress)),
          (this.id = null),
          (this.upgrades = null),
          (this.pingInterval = null),
          (this.pingTimeout = null),
          (this.pingIntervalTimer = null),
          (this.pingTimeoutTimer = null),
          this.open()
      }
      ;(t.exports = h),
        (h.priorWebsocketSuccess = !1),
        s(h.prototype),
        (h.protocol = a.protocol),
        (h.Socket = h),
        (h.Transport = n('Gbct')),
        (h.transports = n('akSB')),
        (h.parser = n('Wm4p')),
        (h.prototype.createTransport = function (t) {
          r('creating transport "%s"', t)
          var e = (function (t) {
            var e = {}
            for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
            return e
          })(this.query)
          ;(e.EIO = a.protocol), (e.transport = t)
          var n = this.transportOptions[t] || {}
          return (
            this.id && (e.sid = this.id),
            new i[t]({
              query: e,
              socket: this,
              agent: n.agent || this.agent,
              hostname: n.hostname || this.hostname,
              port: n.port || this.port,
              secure: n.secure || this.secure,
              path: n.path || this.path,
              forceJSONP: n.forceJSONP || this.forceJSONP,
              jsonp: n.jsonp || this.jsonp,
              forceBase64: n.forceBase64 || this.forceBase64,
              enablesXDR: n.enablesXDR || this.enablesXDR,
              withCredentials: n.withCredentials || this.withCredentials,
              timestampRequests: n.timestampRequests || this.timestampRequests,
              timestampParam: n.timestampParam || this.timestampParam,
              policyPort: n.policyPort || this.policyPort,
              pfx: n.pfx || this.pfx,
              key: n.key || this.key,
              passphrase: n.passphrase || this.passphrase,
              cert: n.cert || this.cert,
              ca: n.ca || this.ca,
              ciphers: n.ciphers || this.ciphers,
              rejectUnauthorized:
                n.rejectUnauthorized || this.rejectUnauthorized,
              perMessageDeflate: n.perMessageDeflate || this.perMessageDeflate,
              extraHeaders: n.extraHeaders || this.extraHeaders,
              forceNode: n.forceNode || this.forceNode,
              localAddress: n.localAddress || this.localAddress,
              requestTimeout: n.requestTimeout || this.requestTimeout,
              protocols: n.protocols || void 0,
              isReactNative: this.isReactNative,
            })
          )
        }),
        (h.prototype.open = function () {
          var t
          if (
            this.rememberUpgrade &&
            h.priorWebsocketSuccess &&
            -1 !== this.transports.indexOf('websocket')
          )
            t = 'websocket'
          else {
            if (0 === this.transports.length) {
              var e = this
              return void setTimeout(function () {
                e.emit('error', 'No transports available')
              }, 0)
            }
            t = this.transports[0]
          }
          this.readyState = 'opening'
          try {
            t = this.createTransport(t)
          } catch (n) {
            return this.transports.shift(), void this.open()
          }
          t.open(), this.setTransport(t)
        }),
        (h.prototype.setTransport = function (t) {
          r('setting transport %s', t.name)
          var e = this
          this.transport &&
            (r('clearing existing transport %s', this.transport.name),
            this.transport.removeAllListeners()),
            (this.transport = t),
            t
              .on('drain', function () {
                e.onDrain()
              })
              .on('packet', function (t) {
                e.onPacket(t)
              })
              .on('error', function (t) {
                e.onError(t)
              })
              .on('close', function () {
                e.onClose('transport close')
              })
        }),
        (h.prototype.probe = function (t) {
          r('probing transport "%s"', t)
          var e = this.createTransport(t, { probe: 1 }),
            n = !1,
            i = this
          function s() {
            i.onlyBinaryUpgrades &&
              (n = n || (!this.supportsBinary && i.transport.supportsBinary)),
              n ||
                (r('probe transport "%s" opened', t),
                e.send([{ type: 'ping', data: 'probe' }]),
                e.once('packet', function (s) {
                  if (!n)
                    if ('pong' === s.type && 'probe' === s.data) {
                      if (
                        (r('probe transport "%s" pong', t),
                        (i.upgrading = !0),
                        i.emit('upgrading', e),
                        !e)
                      )
                        return
                      ;(h.priorWebsocketSuccess = 'websocket' === e.name),
                        r('pausing current transport "%s"', i.transport.name),
                        i.transport.pause(function () {
                          n ||
                            ('closed' !== i.readyState &&
                              (r(
                                'changing transport and sending upgrade packet'
                              ),
                              d(),
                              i.setTransport(e),
                              e.send([{ type: 'upgrade' }]),
                              i.emit('upgrade', e),
                              (e = null),
                              (i.upgrading = !1),
                              i.flush()))
                        })
                    } else {
                      r('probe transport "%s" failed', t)
                      var o = new Error('probe error')
                      ;(o.transport = e.name), i.emit('upgradeError', o)
                    }
                }))
          }
          function o() {
            n || ((n = !0), d(), e.close(), (e = null))
          }
          function a(n) {
            var s = new Error('probe error: ' + n)
            ;(s.transport = e.name),
              o(),
              r('probe transport "%s" failed because of error: %s', t, n),
              i.emit('upgradeError', s)
          }
          function l() {
            a('transport closed')
          }
          function c() {
            a('socket closed')
          }
          function u(t) {
            e &&
              t.name !== e.name &&
              (r('"%s" works - aborting "%s"', t.name, e.name), o())
          }
          function d() {
            e.removeListener('open', s),
              e.removeListener('error', a),
              e.removeListener('close', l),
              i.removeListener('close', c),
              i.removeListener('upgrading', u)
          }
          ;(h.priorWebsocketSuccess = !1),
            e.once('open', s),
            e.once('error', a),
            e.once('close', l),
            this.once('close', c),
            this.once('upgrading', u),
            e.open()
        }),
        (h.prototype.onOpen = function () {
          if (
            (r('socket open'),
            (this.readyState = 'open'),
            (h.priorWebsocketSuccess = 'websocket' === this.transport.name),
            this.emit('open'),
            this.flush(),
            'open' === this.readyState && this.upgrade && this.transport.pause)
          ) {
            r('starting upgrade probes')
            for (var t = 0, e = this.upgrades.length; t < e; t++)
              this.probe(this.upgrades[t])
          }
        }),
        (h.prototype.onPacket = function (t) {
          if (
            'opening' === this.readyState ||
            'open' === this.readyState ||
            'closing' === this.readyState
          )
            switch (
              (r('socket receive: type "%s", data "%s"', t.type, t.data),
              this.emit('packet', t),
              this.emit('heartbeat'),
              t.type)
            ) {
              case 'open':
                this.onHandshake(JSON.parse(t.data))
                break
              case 'pong':
                this.setPing(), this.emit('pong')
                break
              case 'error':
                var e = new Error('server error')
                ;(e.code = t.data), this.onError(e)
                break
              case 'message':
                this.emit('data', t.data), this.emit('message', t.data)
            }
          else r('packet received with socket readyState "%s"', this.readyState)
        }),
        (h.prototype.onHandshake = function (t) {
          this.emit('handshake', t),
            (this.id = t.sid),
            (this.transport.query.sid = t.sid),
            (this.upgrades = this.filterUpgrades(t.upgrades)),
            (this.pingInterval = t.pingInterval),
            (this.pingTimeout = t.pingTimeout),
            this.onOpen(),
            'closed' !== this.readyState &&
              (this.setPing(),
              this.removeListener('heartbeat', this.onHeartbeat),
              this.on('heartbeat', this.onHeartbeat))
        }),
        (h.prototype.onHeartbeat = function (t) {
          clearTimeout(this.pingTimeoutTimer)
          var e = this
          e.pingTimeoutTimer = setTimeout(function () {
            'closed' !== e.readyState && e.onClose('ping timeout')
          }, t || e.pingInterval + e.pingTimeout)
        }),
        (h.prototype.setPing = function () {
          var t = this
          clearTimeout(t.pingIntervalTimer),
            (t.pingIntervalTimer = setTimeout(function () {
              r(
                'writing ping packet - expecting pong within %sms',
                t.pingTimeout
              ),
                t.ping(),
                t.onHeartbeat(t.pingTimeout)
            }, t.pingInterval))
        }),
        (h.prototype.ping = function () {
          var t = this
          this.sendPacket('ping', function () {
            t.emit('ping')
          })
        }),
        (h.prototype.onDrain = function () {
          this.writeBuffer.splice(0, this.prevBufferLen),
            (this.prevBufferLen = 0),
            0 === this.writeBuffer.length ? this.emit('drain') : this.flush()
        }),
        (h.prototype.flush = function () {
          'closed' !== this.readyState &&
            this.transport.writable &&
            !this.upgrading &&
            this.writeBuffer.length &&
            (r('flushing %d packets in socket', this.writeBuffer.length),
            this.transport.send(this.writeBuffer),
            (this.prevBufferLen = this.writeBuffer.length),
            this.emit('flush'))
        }),
        (h.prototype.write = h.prototype.send = function (t, e, n) {
          return this.sendPacket('message', t, e, n), this
        }),
        (h.prototype.sendPacket = function (t, e, n, i) {
          if (
            ('function' == typeof e && ((i = e), (e = void 0)),
            'function' == typeof n && ((i = n), (n = null)),
            'closing' !== this.readyState && 'closed' !== this.readyState)
          ) {
            ;(n = n || {}).compress = !1 !== n.compress
            var s = { type: t, data: e, options: n }
            this.emit('packetCreate', s),
              this.writeBuffer.push(s),
              i && this.once('flush', i),
              this.flush()
          }
        }),
        (h.prototype.close = function () {
          if ('opening' === this.readyState || 'open' === this.readyState) {
            this.readyState = 'closing'
            var t = this
            this.writeBuffer.length
              ? this.once('drain', function () {
                  this.upgrading ? i() : e()
                })
              : this.upgrading
              ? i()
              : e()
          }
          function e() {
            t.onClose('forced close'),
              r('socket closing - telling transport to close'),
              t.transport.close()
          }
          function n() {
            t.removeListener('upgrade', n),
              t.removeListener('upgradeError', n),
              e()
          }
          function i() {
            t.once('upgrade', n), t.once('upgradeError', n)
          }
          return this
        }),
        (h.prototype.onError = function (t) {
          r('socket error %j', t),
            (h.priorWebsocketSuccess = !1),
            this.emit('error', t),
            this.onClose('transport error', t)
        }),
        (h.prototype.onClose = function (t, e) {
          ;('opening' !== this.readyState &&
            'open' !== this.readyState &&
            'closing' !== this.readyState) ||
            (r('socket close with reason: "%s"', t),
            clearTimeout(this.pingIntervalTimer),
            clearTimeout(this.pingTimeoutTimer),
            this.transport.removeAllListeners('close'),
            this.transport.close(),
            this.transport.removeAllListeners(),
            (this.readyState = 'closed'),
            (this.id = null),
            this.emit('close', t, e),
            (this.writeBuffer = []),
            (this.prevBufferLen = 0))
        }),
        (h.prototype.filterUpgrades = function (t) {
          for (var e = [], n = 0, i = t.length; n < i; n++)
            ~o(this.transports, t[n]) && e.push(t[n])
          return e
        })
    },
    '7jRU': function (t, e) {
      var n = [].indexOf
      t.exports = function (t, e) {
        if (n) return t.indexOf(e)
        for (var i = 0; i < t.length; ++i) if (t[i] === e) return i
        return -1
      }
    },
    AdPF: function (t, e, n) {
      var i = n('yeub'),
        s = n('2UHX')
      t.exports = function (t) {
        var e = t.xdomain,
          n = t.xscheme,
          r = t.enablesXDR
        try {
          if ('undefined' != typeof XMLHttpRequest && (!e || i))
            return new XMLHttpRequest()
        } catch (o) {}
        try {
          if ('undefined' != typeof XDomainRequest && !n && r)
            return new XDomainRequest()
        } catch (o) {}
        if (!e)
          try {
            return new s[['Active'].concat('Object').join('X')](
              'Microsoft.XMLHTTP'
            )
          } catch (o) {}
      }
    },
    Aplp: function (t, e, n) {
      'use strict'
      var i,
        s = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(
          ''
        ),
        r = {},
        o = 0,
        a = 0
      function l(t) {
        var e = ''
        do {
          ;(e = s[t % 64] + e), (t = Math.floor(t / 64))
        } while (t > 0)
        return e
      }
      function c() {
        var t = l(+new Date())
        return t !== i ? ((o = 0), (i = t)) : t + '.' + l(o++)
      }
      for (; a < 64; a++) r[s[a]] = a
      ;(c.encode = l),
        (c.decode = function (t) {
          var e = 0
          for (a = 0; a < t.length; a++) e = 64 * e + r[t.charAt(a)]
          return e
        }),
        (t.exports = c)
    },
    C2QD: function (t, e) {
      function n(t) {
        ;(this.ms = (t = t || {}).min || 100),
          (this.max = t.max || 1e4),
          (this.factor = t.factor || 2),
          (this.jitter = t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0),
          (this.attempts = 0)
      }
      ;(t.exports = n),
        (n.prototype.duration = function () {
          var t = this.ms * Math.pow(this.factor, this.attempts++)
          if (this.jitter) {
            var e = Math.random(),
              n = Math.floor(e * this.jitter * t)
            t = 0 == (1 & Math.floor(10 * e)) ? t - n : t + n
          }
          return 0 | Math.min(t, this.max)
        }),
        (n.prototype.reset = function () {
          this.attempts = 0
        }),
        (n.prototype.setMin = function (t) {
          this.ms = t
        }),
        (n.prototype.setMax = function (t) {
          this.max = t
        }),
        (n.prototype.setJitter = function (t) {
          this.jitter = t
        })
    },
    CIKq: function (t, e, n) {
      var i,
        s,
        r = n('Gbct'),
        o = n('Wm4p'),
        a = n('TypT'),
        l = n('Yvos'),
        c = n('Aplp'),
        h = n('NOtv')('engine.io-client:websocket')
      if (
        ('undefined' != typeof WebSocket
          ? (i = WebSocket)
          : 'undefined' != typeof self &&
            (i = self.WebSocket || self.MozWebSocket),
        'undefined' == typeof window)
      )
        try {
          s = n(1)
        } catch (p) {}
      var u = i || s
      function d(t) {
        t && t.forceBase64 && (this.supportsBinary = !1),
          (this.perMessageDeflate = t.perMessageDeflate),
          (this.usingBrowserWebSocket = i && !t.forceNode),
          (this.protocols = t.protocols),
          this.usingBrowserWebSocket || (u = s),
          r.call(this, t)
      }
      ;(t.exports = d),
        l(d, r),
        (d.prototype.name = 'websocket'),
        (d.prototype.supportsBinary = !0),
        (d.prototype.doOpen = function () {
          if (this.check()) {
            var t = this.uri(),
              e = this.protocols,
              n = {}
            this.isReactNative ||
              ((n.agent = this.agent),
              (n.perMessageDeflate = this.perMessageDeflate),
              (n.pfx = this.pfx),
              (n.key = this.key),
              (n.passphrase = this.passphrase),
              (n.cert = this.cert),
              (n.ca = this.ca),
              (n.ciphers = this.ciphers),
              (n.rejectUnauthorized = this.rejectUnauthorized)),
              this.extraHeaders && (n.headers = this.extraHeaders),
              this.localAddress && (n.localAddress = this.localAddress)
            try {
              this.ws =
                this.usingBrowserWebSocket && !this.isReactNative
                  ? e
                    ? new u(t, e)
                    : new u(t)
                  : new u(t, e, n)
            } catch (i) {
              return this.emit('error', i)
            }
            void 0 === this.ws.binaryType && (this.supportsBinary = !1),
              this.ws.supports && this.ws.supports.binary
                ? ((this.supportsBinary = !0),
                  (this.ws.binaryType = 'nodebuffer'))
                : (this.ws.binaryType = 'arraybuffer'),
              this.addEventListeners()
          }
        }),
        (d.prototype.addEventListeners = function () {
          var t = this
          ;(this.ws.onopen = function () {
            t.onOpen()
          }),
            (this.ws.onclose = function () {
              t.onClose()
            }),
            (this.ws.onmessage = function (e) {
              t.onData(e.data)
            }),
            (this.ws.onerror = function (e) {
              t.onError('websocket error', e)
            })
        }),
        (d.prototype.write = function (t) {
          var e = this
          this.writable = !1
          for (var n = t.length, i = 0, s = n; i < s; i++)
            !(function (t) {
              o.encodePacket(t, e.supportsBinary, function (i) {
                if (!e.usingBrowserWebSocket) {
                  var s = {}
                  t.options && (s.compress = t.options.compress),
                    e.perMessageDeflate &&
                      ('string' == typeof i ? Buffer.byteLength(i) : i.length) <
                        e.perMessageDeflate.threshold &&
                      (s.compress = !1)
                }
                try {
                  e.usingBrowserWebSocket ? e.ws.send(i) : e.ws.send(i, s)
                } catch (p) {
                  h('websocket closed before onclose event')
                }
                --n ||
                  (e.emit('flush'),
                  setTimeout(function () {
                    ;(e.writable = !0), e.emit('drain')
                  }, 0))
              })
            })(t[i])
        }),
        (d.prototype.onClose = function () {
          r.prototype.onClose.call(this)
        }),
        (d.prototype.doClose = function () {
          void 0 !== this.ws && this.ws.close()
        }),
        (d.prototype.uri = function () {
          var t = this.query || {},
            e = this.secure ? 'wss' : 'ws',
            n = ''
          return (
            this.port &&
              (('wss' === e && 443 !== Number(this.port)) ||
                ('ws' === e && 80 !== Number(this.port))) &&
              (n = ':' + this.port),
            this.timestampRequests && (t[this.timestampParam] = c()),
            this.supportsBinary || (t.b64 = 1),
            (t = a.encode(t)).length && (t = '?' + t),
            e +
              '://' +
              (-1 !== this.hostname.indexOf(':')
                ? '[' + this.hostname + ']'
                : this.hostname) +
              n +
              this.path +
              t
          )
        }),
        (d.prototype.check = function () {
          return !(
            !u ||
            ('__initialize' in u && this.name === d.prototype.name)
          )
        })
    },
    CUme: function (t, e, n) {
      var i = n('Gbct'),
        s = n('TypT'),
        r = n('Wm4p'),
        o = n('Yvos'),
        a = n('Aplp'),
        l = n('NOtv')('engine.io-client:polling')
      t.exports = h
      var c = null != new (n('AdPF'))({ xdomain: !1 }).responseType
      function h(t) {
        ;(c && !(t && t.forceBase64)) || (this.supportsBinary = !1),
          i.call(this, t)
      }
      o(h, i),
        (h.prototype.name = 'polling'),
        (h.prototype.doOpen = function () {
          this.poll()
        }),
        (h.prototype.pause = function (t) {
          var e = this
          function n() {
            l('paused'), (e.readyState = 'paused'), t()
          }
          if (((this.readyState = 'pausing'), this.polling || !this.writable)) {
            var i = 0
            this.polling &&
              (l('we are currently polling - waiting to pause'),
              i++,
              this.once('pollComplete', function () {
                l('pre-pause polling complete'), --i || n()
              })),
              this.writable ||
                (l('we are currently writing - waiting to pause'),
                i++,
                this.once('drain', function () {
                  l('pre-pause writing complete'), --i || n()
                }))
          } else n()
        }),
        (h.prototype.poll = function () {
          l('polling'), (this.polling = !0), this.doPoll(), this.emit('poll')
        }),
        (h.prototype.onData = function (t) {
          var e = this
          l('polling got data %s', t),
            r.decodePayload(t, this.socket.binaryType, function (t, n, i) {
              if (
                ('opening' === e.readyState && e.onOpen(), 'close' === t.type)
              )
                return e.onClose(), !1
              e.onPacket(t)
            }),
            'closed' !== this.readyState &&
              ((this.polling = !1),
              this.emit('pollComplete'),
              'open' === this.readyState
                ? this.poll()
                : l('ignoring poll - transport state "%s"', this.readyState))
        }),
        (h.prototype.doClose = function () {
          var t = this
          function e() {
            l('writing close packet'), t.write([{ type: 'close' }])
          }
          'open' === this.readyState
            ? (l('transport open - closing'), e())
            : (l('transport not open - deferring close'), this.once('open', e))
        }),
        (h.prototype.write = function (t) {
          var e = this
          this.writable = !1
          var n = function () {
            ;(e.writable = !0), e.emit('drain')
          }
          r.encodePayload(t, this.supportsBinary, function (t) {
            e.doWrite(t, n)
          })
        }),
        (h.prototype.uri = function () {
          var t = this.query || {},
            e = this.secure ? 'https' : 'http',
            n = ''
          return (
            !1 !== this.timestampRequests && (t[this.timestampParam] = a()),
            this.supportsBinary || t.sid || (t.b64 = 1),
            (t = s.encode(t)),
            this.port &&
              (('https' === e && 443 !== Number(this.port)) ||
                ('http' === e && 80 !== Number(this.port))) &&
              (n = ':' + this.port),
            t.length && (t = '?' + t),
            e +
              '://' +
              (-1 !== this.hostname.indexOf(':')
                ? '[' + this.hostname + ']'
                : this.hostname) +
              n +
              this.path +
              t
          )
        })
    },
    Cl5A: function (t, e, n) {
      var i = n('CUme'),
        s = n('Yvos'),
        r = n('2UHX')
      t.exports = h
      var o,
        a = /\n/g,
        l = /\\n/g
      function c() {}
      function h(t) {
        i.call(this, t),
          (this.query = this.query || {}),
          o || (o = r.___eio = r.___eio || []),
          (this.index = o.length)
        var e = this
        o.push(function (t) {
          e.onData(t)
        }),
          (this.query.j = this.index),
          'function' == typeof addEventListener &&
            addEventListener(
              'beforeunload',
              function () {
                e.script && (e.script.onerror = c)
              },
              !1
            )
      }
      s(h, i),
        (h.prototype.supportsBinary = !1),
        (h.prototype.doClose = function () {
          this.script &&
            (this.script.parentNode.removeChild(this.script),
            (this.script = null)),
            this.form &&
              (this.form.parentNode.removeChild(this.form),
              (this.form = null),
              (this.iframe = null)),
            i.prototype.doClose.call(this)
        }),
        (h.prototype.doPoll = function () {
          var t = this,
            e = document.createElement('script')
          this.script &&
            (this.script.parentNode.removeChild(this.script),
            (this.script = null)),
            (e.async = !0),
            (e.src = this.uri()),
            (e.onerror = function (e) {
              t.onError('jsonp poll error', e)
            })
          var n = document.getElementsByTagName('script')[0]
          n
            ? n.parentNode.insertBefore(e, n)
            : (document.head || document.body).appendChild(e),
            (this.script = e),
            'undefined' != typeof navigator &&
              /gecko/i.test(navigator.userAgent) &&
              setTimeout(function () {
                var t = document.createElement('iframe')
                document.body.appendChild(t), document.body.removeChild(t)
              }, 100)
        }),
        (h.prototype.doWrite = function (t, e) {
          var n = this
          if (!this.form) {
            var i,
              s = document.createElement('form'),
              r = document.createElement('textarea'),
              o = (this.iframeId = 'eio_iframe_' + this.index)
            ;(s.className = 'socketio'),
              (s.style.position = 'absolute'),
              (s.style.top = '-1000px'),
              (s.style.left = '-1000px'),
              (s.target = o),
              (s.method = 'POST'),
              s.setAttribute('accept-charset', 'utf-8'),
              (r.name = 'd'),
              s.appendChild(r),
              document.body.appendChild(s),
              (this.form = s),
              (this.area = r)
          }
          function c() {
            h(), e()
          }
          function h() {
            if (n.iframe)
              try {
                n.form.removeChild(n.iframe)
              } catch (t) {
                n.onError('jsonp polling iframe removal error', t)
              }
            try {
              i = document.createElement(
                '<iframe src="javascript:0" name="' + n.iframeId + '">'
              )
            } catch (t) {
              ;((i = document.createElement('iframe')).name = n.iframeId),
                (i.src = 'javascript:0')
            }
            ;(i.id = n.iframeId), n.form.appendChild(i), (n.iframe = i)
          }
          ;(this.form.action = this.uri()),
            h(),
            (t = t.replace(l, '\\\n')),
            (this.area.value = t.replace(a, '\\n'))
          try {
            this.form.submit()
          } catch (u) {}
          this.iframe.attachEvent
            ? (this.iframe.onreadystatechange = function () {
                'complete' === n.iframe.readyState && c()
              })
            : (this.iframe.onload = c)
        })
    },
    F1In: function (t, e) {
      function n(t) {
        return Promise.resolve().then(function () {
          var e = new Error("Cannot find module '" + t + "'")
          throw ((e.code = 'MODULE_NOT_FOUND'), e)
        })
      }
      ;(n.keys = function () {
        return []
      }),
        (n.resolve = n),
        (t.exports = n),
        (n.id = 'F1In')
    },
    FGiv: function (t, e) {
      var n = 1e3,
        i = 60 * n,
        s = 60 * i,
        r = 24 * s
      function o(t, e, n) {
        if (!(t < e))
          return t < 1.5 * e
            ? Math.floor(t / e) + ' ' + n
            : Math.ceil(t / e) + ' ' + n + 's'
      }
      t.exports = function (t, e) {
        e = e || {}
        var a,
          l = typeof t
        if ('string' === l && t.length > 0)
          return (function (t) {
            if (!((t = String(t)).length > 100)) {
              var e = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
                t
              )
              if (e) {
                var o = parseFloat(e[1])
                switch ((e[2] || 'ms').toLowerCase()) {
                  case 'years':
                  case 'year':
                  case 'yrs':
                  case 'yr':
                  case 'y':
                    return 315576e5 * o
                  case 'days':
                  case 'day':
                  case 'd':
                    return o * r
                  case 'hours':
                  case 'hour':
                  case 'hrs':
                  case 'hr':
                  case 'h':
                    return o * s
                  case 'minutes':
                  case 'minute':
                  case 'mins':
                  case 'min':
                  case 'm':
                    return o * i
                  case 'seconds':
                  case 'second':
                  case 'secs':
                  case 'sec':
                  case 's':
                    return o * n
                  case 'milliseconds':
                  case 'millisecond':
                  case 'msecs':
                  case 'msec':
                  case 'ms':
                    return o
                  default:
                    return
                }
              }
            }
          })(t)
        if ('number' === l && !1 === isNaN(t))
          return e.long
            ? o((a = t), r, 'day') ||
                o(a, s, 'hour') ||
                o(a, i, 'minute') ||
                o(a, n, 'second') ||
                a + ' ms'
            : (function (t) {
                return t >= r
                  ? Math.round(t / r) + 'd'
                  : t >= s
                  ? Math.round(t / s) + 'h'
                  : t >= i
                  ? Math.round(t / i) + 'm'
                  : t >= n
                  ? Math.round(t / n) + 's'
                  : t + 'ms'
              })(t)
        throw new Error(
          'val is not a non-empty string or a valid number. val=' +
            JSON.stringify(t)
        )
      }
    },
    Gbct: function (t, e, n) {
      var i = n('Wm4p'),
        s = n('cpc2')
      function r(t) {
        ;(this.path = t.path),
          (this.hostname = t.hostname),
          (this.port = t.port),
          (this.secure = t.secure),
          (this.query = t.query),
          (this.timestampParam = t.timestampParam),
          (this.timestampRequests = t.timestampRequests),
          (this.readyState = ''),
          (this.agent = t.agent || !1),
          (this.socket = t.socket),
          (this.enablesXDR = t.enablesXDR),
          (this.withCredentials = t.withCredentials),
          (this.pfx = t.pfx),
          (this.key = t.key),
          (this.passphrase = t.passphrase),
          (this.cert = t.cert),
          (this.ca = t.ca),
          (this.ciphers = t.ciphers),
          (this.rejectUnauthorized = t.rejectUnauthorized),
          (this.forceNode = t.forceNode),
          (this.isReactNative = t.isReactNative),
          (this.extraHeaders = t.extraHeaders),
          (this.localAddress = t.localAddress)
      }
      ;(t.exports = r),
        s(r.prototype),
        (r.prototype.onError = function (t, e) {
          var n = new Error(t)
          return (
            (n.type = 'TransportError'),
            (n.description = e),
            this.emit('error', n),
            this
          )
        }),
        (r.prototype.open = function () {
          return (
            ('closed' !== this.readyState && '' !== this.readyState) ||
              ((this.readyState = 'opening'), this.doOpen()),
            this
          )
        }),
        (r.prototype.close = function () {
          return (
            ('opening' !== this.readyState && 'open' !== this.readyState) ||
              (this.doClose(), this.onClose()),
            this
          )
        }),
        (r.prototype.send = function (t) {
          if ('open' !== this.readyState) throw new Error('Transport not open')
          this.write(t)
        }),
        (r.prototype.onOpen = function () {
          ;(this.readyState = 'open'), (this.writable = !0), this.emit('open')
        }),
        (r.prototype.onData = function (t) {
          var e = i.decodePacket(t, this.socket.binaryType)
          this.onPacket(e)
        }),
        (r.prototype.onPacket = function (t) {
          this.emit('packet', t)
        }),
        (r.prototype.onClose = function () {
          ;(this.readyState = 'closed'), this.emit('close')
        })
    },
    KFGy: function (t, e, n) {
      var i = n('Uwu7'),
        s = n('cpc2'),
        r = n('kSER'),
        o = n('2Dig'),
        a = n('QN7Q'),
        l = n('NOtv')('socket.io-client:socket'),
        c = n('TypT'),
        h = n('WLGk')
      t.exports = p
      var u = {
          connect: 1,
          connect_error: 1,
          connect_timeout: 1,
          connecting: 1,
          disconnect: 1,
          error: 1,
          reconnect: 1,
          reconnect_attempt: 1,
          reconnect_failed: 1,
          reconnect_error: 1,
          reconnecting: 1,
          ping: 1,
          pong: 1,
        },
        d = s.prototype.emit
      function p(t, e, n) {
        ;(this.io = t),
          (this.nsp = e),
          (this.json = this),
          (this.ids = 0),
          (this.acks = {}),
          (this.receiveBuffer = []),
          (this.sendBuffer = []),
          (this.connected = !1),
          (this.disconnected = !0),
          (this.flags = {}),
          n && n.query && (this.query = n.query),
          this.io.autoConnect && this.open()
      }
      s(p.prototype),
        (p.prototype.subEvents = function () {
          if (!this.subs) {
            var t = this.io
            this.subs = [
              o(t, 'open', a(this, 'onopen')),
              o(t, 'packet', a(this, 'onpacket')),
              o(t, 'close', a(this, 'onclose')),
            ]
          }
        }),
        (p.prototype.open = p.prototype.connect = function () {
          return (
            this.connected ||
              (this.subEvents(),
              this.io.reconnecting || this.io.open(),
              'open' === this.io.readyState && this.onopen(),
              this.emit('connecting')),
            this
          )
        }),
        (p.prototype.send = function () {
          var t = r(arguments)
          return t.unshift('message'), this.emit.apply(this, t), this
        }),
        (p.prototype.emit = function (t) {
          if (u.hasOwnProperty(t)) return d.apply(this, arguments), this
          var e = r(arguments),
            n = {
              type: (void 0 !== this.flags.binary ? this.flags.binary : h(e))
                ? i.BINARY_EVENT
                : i.EVENT,
              data: e,
              options: {},
            }
          return (
            (n.options.compress = !this.flags || !1 !== this.flags.compress),
            'function' == typeof e[e.length - 1] &&
              (l('emitting packet with ack id %d', this.ids),
              (this.acks[this.ids] = e.pop()),
              (n.id = this.ids++)),
            this.connected ? this.packet(n) : this.sendBuffer.push(n),
            (this.flags = {}),
            this
          )
        }),
        (p.prototype.packet = function (t) {
          ;(t.nsp = this.nsp), this.io.packet(t)
        }),
        (p.prototype.onopen = function () {
          if ((l('transport is open - connecting'), '/' !== this.nsp))
            if (this.query) {
              var t =
                'object' == typeof this.query
                  ? c.encode(this.query)
                  : this.query
              l('sending connect packet with query %s', t),
                this.packet({ type: i.CONNECT, query: t })
            } else this.packet({ type: i.CONNECT })
        }),
        (p.prototype.onclose = function (t) {
          l('close (%s)', t),
            (this.connected = !1),
            (this.disconnected = !0),
            delete this.id,
            this.emit('disconnect', t)
        }),
        (p.prototype.onpacket = function (t) {
          if (t.nsp === this.nsp || (t.type === i.ERROR && '/' === t.nsp))
            switch (t.type) {
              case i.CONNECT:
                this.onconnect()
                break
              case i.EVENT:
              case i.BINARY_EVENT:
                this.onevent(t)
                break
              case i.ACK:
              case i.BINARY_ACK:
                this.onack(t)
                break
              case i.DISCONNECT:
                this.ondisconnect()
                break
              case i.ERROR:
                this.emit('error', t.data)
            }
        }),
        (p.prototype.onevent = function (t) {
          var e = t.data || []
          l('emitting event %j', e),
            null != t.id &&
              (l('attaching ack callback to event'), e.push(this.ack(t.id))),
            this.connected ? d.apply(this, e) : this.receiveBuffer.push(e)
        }),
        (p.prototype.ack = function (t) {
          var e = this,
            n = !1
          return function () {
            if (!n) {
              n = !0
              var s = r(arguments)
              l('sending ack %j', s),
                e.packet({ type: h(s) ? i.BINARY_ACK : i.ACK, id: t, data: s })
            }
          }
        }),
        (p.prototype.onack = function (t) {
          var e = this.acks[t.id]
          'function' == typeof e
            ? (l('calling ack %s with %j', t.id, t.data),
              e.apply(this, t.data),
              delete this.acks[t.id])
            : l('bad ack %s', t.id)
        }),
        (p.prototype.onconnect = function () {
          ;(this.connected = !0),
            (this.disconnected = !1),
            this.emit('connect'),
            this.emitBuffered()
        }),
        (p.prototype.emitBuffered = function () {
          var t
          for (t = 0; t < this.receiveBuffer.length; t++)
            d.apply(this, this.receiveBuffer[t])
          for (this.receiveBuffer = [], t = 0; t < this.sendBuffer.length; t++)
            this.packet(this.sendBuffer[t])
          this.sendBuffer = []
        }),
        (p.prototype.ondisconnect = function () {
          l('server disconnect (%s)', this.nsp),
            this.destroy(),
            this.onclose('io server disconnect')
        }),
        (p.prototype.destroy = function () {
          if (this.subs) {
            for (var t = 0; t < this.subs.length; t++) this.subs[t].destroy()
            this.subs = null
          }
          this.io.destroy(this)
        }),
        (p.prototype.close = p.prototype.disconnect = function () {
          return (
            this.connected &&
              (l('performing disconnect (%s)', this.nsp),
              this.packet({ type: i.DISCONNECT })),
            this.destroy(),
            this.connected && this.onclose('io client disconnect'),
            this
          )
        }),
        (p.prototype.compress = function (t) {
          return (this.flags.compress = t), this
        }),
        (p.prototype.binary = function (t) {
          return (this.flags.binary = t), this
        })
    },
    NOtv: function (t, e, n) {
      function i() {
        var t
        try {
          t = e.storage.debug
        } catch (n) {}
        return (
          !t &&
            'undefined' != typeof process &&
            'env' in process &&
            (t = process.env.DEBUG),
          t
        )
      }
      ;((e = t.exports = n('lv48')).log = function () {
        return (
          'object' == typeof console &&
          console.log &&
          Function.prototype.apply.call(console.log, console, arguments)
        )
      }),
        (e.formatArgs = function (t) {
          var n = this.useColors
          if (
            ((t[0] =
              (n ? '%c' : '') +
              this.namespace +
              (n ? ' %c' : ' ') +
              t[0] +
              (n ? '%c ' : ' ') +
              '+' +
              e.humanize(this.diff)),
            n)
          ) {
            var i = 'color: ' + this.color
            t.splice(1, 0, i, 'color: inherit')
            var s = 0,
              r = 0
            t[0].replace(/%[a-zA-Z%]/g, function (t) {
              '%%' !== t && (s++, '%c' === t && (r = s))
            }),
              t.splice(r, 0, i)
          }
        }),
        (e.save = function (t) {
          try {
            null == t ? e.storage.removeItem('debug') : (e.storage.debug = t)
          } catch (n) {}
        }),
        (e.load = i),
        (e.useColors = function () {
          return (
            !(
              'undefined' == typeof window ||
              !window.process ||
              'renderer' !== window.process.type
            ) ||
            (('undefined' == typeof navigator ||
              !navigator.userAgent ||
              !navigator.userAgent
                .toLowerCase()
                .match(/(edge|trident)\/(\d+)/)) &&
              (('undefined' != typeof document &&
                document.documentElement &&
                document.documentElement.style &&
                document.documentElement.style.WebkitAppearance) ||
                ('undefined' != typeof window &&
                  window.console &&
                  (window.console.firebug ||
                    (window.console.exception && window.console.table))) ||
                ('undefined' != typeof navigator &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                  parseInt(RegExp.$1, 10) >= 31) ||
                ('undefined' != typeof navigator &&
                  navigator.userAgent &&
                  navigator.userAgent
                    .toLowerCase()
                    .match(/applewebkit\/(\d+)/))))
          )
        }),
        (e.storage =
          'undefined' != typeof chrome && void 0 !== chrome.storage
            ? chrome.storage.local
            : (function () {
                try {
                  return window.localStorage
                } catch (t) {}
              })()),
        (e.colors = [
          '#0000CC',
          '#0000FF',
          '#0033CC',
          '#0033FF',
          '#0066CC',
          '#0066FF',
          '#0099CC',
          '#0099FF',
          '#00CC00',
          '#00CC33',
          '#00CC66',
          '#00CC99',
          '#00CCCC',
          '#00CCFF',
          '#3300CC',
          '#3300FF',
          '#3333CC',
          '#3333FF',
          '#3366CC',
          '#3366FF',
          '#3399CC',
          '#3399FF',
          '#33CC00',
          '#33CC33',
          '#33CC66',
          '#33CC99',
          '#33CCCC',
          '#33CCFF',
          '#6600CC',
          '#6600FF',
          '#6633CC',
          '#6633FF',
          '#66CC00',
          '#66CC33',
          '#9900CC',
          '#9900FF',
          '#9933CC',
          '#9933FF',
          '#99CC00',
          '#99CC33',
          '#CC0000',
          '#CC0033',
          '#CC0066',
          '#CC0099',
          '#CC00CC',
          '#CC00FF',
          '#CC3300',
          '#CC3333',
          '#CC3366',
          '#CC3399',
          '#CC33CC',
          '#CC33FF',
          '#CC6600',
          '#CC6633',
          '#CC9900',
          '#CC9933',
          '#CCCC00',
          '#CCCC33',
          '#FF0000',
          '#FF0033',
          '#FF0066',
          '#FF0099',
          '#FF00CC',
          '#FF00FF',
          '#FF3300',
          '#FF3333',
          '#FF3366',
          '#FF3399',
          '#FF33CC',
          '#FF33FF',
          '#FF6600',
          '#FF6633',
          '#FF9900',
          '#FF9933',
          '#FFCC00',
          '#FFCC33',
        ]),
        (e.formatters.j = function (t) {
          try {
            return JSON.stringify(t)
          } catch (e) {
            return '[UnexpectedJSONParseError]: ' + e.message
          }
        }),
        e.enable(i())
    },
    Njrz: function (t, e, n) {
      var i = n('luTP'),
        s = n('qGlh'),
        r = Object.prototype.toString,
        o =
          'function' == typeof Blob ||
          ('undefined' != typeof Blob &&
            '[object BlobConstructor]' === r.call(Blob)),
        a =
          'function' == typeof File ||
          ('undefined' != typeof File &&
            '[object FileConstructor]' === r.call(File))
      function l(t, e) {
        if (!t) return t
        if (s(t)) {
          var n = { _placeholder: !0, num: e.length }
          return e.push(t), n
        }
        if (i(t)) {
          for (var r = new Array(t.length), o = 0; o < t.length; o++)
            r[o] = l(t[o], e)
          return r
        }
        if ('object' == typeof t && !(t instanceof Date)) {
          for (var a in ((r = {}), t)) r[a] = l(t[a], e)
          return r
        }
        return t
      }
      function c(t, e) {
        if (!t) return t
        if (t && t._placeholder) return e[t.num]
        if (i(t)) for (var n = 0; n < t.length; n++) t[n] = c(t[n], e)
        else if ('object' == typeof t) for (var s in t) t[s] = c(t[s], e)
        return t
      }
      ;(e.deconstructPacket = function (t) {
        var e = [],
          n = t
        return (
          (n.data = l(t.data, e)),
          (n.attachments = e.length),
          { packet: n, buffers: e }
        )
      }),
        (e.reconstructPacket = function (t, e) {
          return (t.data = c(t.data, e)), (t.attachments = void 0), t
        }),
        (e.removeBlobs = function (t, e) {
          var n = 0,
            r = t
          !(function t(l, c, h) {
            if (!l) return l
            if ((o && l instanceof Blob) || (a && l instanceof File)) {
              n++
              var u = new FileReader()
              ;(u.onload = function () {
                h ? (h[c] = this.result) : (r = this.result), --n || e(r)
              }),
                u.readAsArrayBuffer(l)
            } else if (i(l)) for (var d = 0; d < l.length; d++) t(l[d], d, l)
            else if ('object' == typeof l && !s(l))
              for (var p in l) t(l[p], p, l)
          })(r),
            n || e(r)
        })
    },
    QN7Q: function (t, e) {
      var n = [].slice
      t.exports = function (t, e) {
        if (('string' == typeof e && (e = t[e]), 'function' != typeof e))
          throw new Error('bind() requires a function')
        var i = n.call(arguments, 2)
        return function () {
          return e.apply(t, i.concat(n.call(arguments)))
        }
      }
    },
    TypT: function (t, e) {
      ;(e.encode = function (t) {
        var e = ''
        for (var n in t)
          t.hasOwnProperty(n) &&
            (e.length && (e += '&'),
            (e += encodeURIComponent(n) + '=' + encodeURIComponent(t[n])))
        return e
      }),
        (e.decode = function (t) {
          for (var e = {}, n = t.split('&'), i = 0, s = n.length; i < s; i++) {
            var r = n[i].split('=')
            e[decodeURIComponent(r[0])] = decodeURIComponent(r[1])
          }
          return e
        })
    },
    Uwu7: function (t, e, n) {
      var i = n('NOtv')('socket.io-parser'),
        s = n('cpc2'),
        r = n('Njrz'),
        o = n('luTP'),
        a = n('qGlh')
      function l() {}
      ;(e.protocol = 4),
        (e.types = [
          'CONNECT',
          'DISCONNECT',
          'EVENT',
          'ACK',
          'ERROR',
          'BINARY_EVENT',
          'BINARY_ACK',
        ]),
        (e.CONNECT = 0),
        (e.DISCONNECT = 1),
        (e.EVENT = 2),
        (e.ACK = 3),
        (e.ERROR = 4),
        (e.BINARY_EVENT = 5),
        (e.BINARY_ACK = 6),
        (e.Encoder = l),
        (e.Decoder = u)
      var c = e.ERROR + '"encode error"'
      function h(t) {
        var n = '' + t.type
        if (
          ((e.BINARY_EVENT !== t.type && e.BINARY_ACK !== t.type) ||
            (n += t.attachments + '-'),
          t.nsp && '/' !== t.nsp && (n += t.nsp + ','),
          null != t.id && (n += t.id),
          null != t.data)
        ) {
          var s = (function (t) {
            try {
              return JSON.stringify(t)
            } catch (e) {
              return !1
            }
          })(t.data)
          if (!1 === s) return c
          n += s
        }
        return i('encoded %j as %s', t, n), n
      }
      function u() {
        this.reconstructor = null
      }
      function d(t) {
        ;(this.reconPack = t), (this.buffers = [])
      }
      function p(t) {
        return { type: e.ERROR, data: 'parser error: ' + t }
      }
      ;(l.prototype.encode = function (t, n) {
        i('encoding packet %j', t),
          e.BINARY_EVENT === t.type || e.BINARY_ACK === t.type
            ? (function (t, e) {
                r.removeBlobs(t, function (t) {
                  var n = r.deconstructPacket(t),
                    i = h(n.packet),
                    s = n.buffers
                  s.unshift(i), e(s)
                })
              })(t, n)
            : n([h(t)])
      }),
        s(u.prototype),
        (u.prototype.add = function (t) {
          var n
          if ('string' == typeof t)
            (n = (function (t) {
              var n = 0,
                s = { type: Number(t.charAt(0)) }
              if (null == e.types[s.type])
                return p('unknown packet type ' + s.type)
              if (e.BINARY_EVENT === s.type || e.BINARY_ACK === s.type) {
                for (
                  var r = '';
                  '-' !== t.charAt(++n) && ((r += t.charAt(n)), n != t.length);

                );
                if (r != Number(r) || '-' !== t.charAt(n))
                  throw new Error('Illegal attachments')
                s.attachments = Number(r)
              }
              if ('/' === t.charAt(n + 1))
                for (
                  s.nsp = '';
                  ++n &&
                  ',' !== (l = t.charAt(n)) &&
                  ((s.nsp += l), n !== t.length);

                );
              else s.nsp = '/'
              var a = t.charAt(n + 1)
              if ('' !== a && Number(a) == a) {
                for (s.id = ''; ++n; ) {
                  var l
                  if (null == (l = t.charAt(n)) || Number(l) != l) {
                    --n
                    break
                  }
                  if (((s.id += t.charAt(n)), n === t.length)) break
                }
                s.id = Number(s.id)
              }
              if (t.charAt(++n)) {
                var c = (function (t) {
                  try {
                    return JSON.parse(t)
                  } catch (e) {
                    return !1
                  }
                })(t.substr(n))
                if (!1 === c || (s.type !== e.ERROR && !o(c)))
                  return p('invalid payload')
                s.data = c
              }
              return i('decoded %s as %j', t, s), s
            })(t)),
              e.BINARY_EVENT === n.type || e.BINARY_ACK === n.type
                ? ((this.reconstructor = new d(n)),
                  0 === this.reconstructor.reconPack.attachments &&
                    this.emit('decoded', n))
                : this.emit('decoded', n)
          else {
            if (!a(t) && !t.base64) throw new Error('Unknown type: ' + t)
            if (!this.reconstructor)
              throw new Error(
                'got binary data when not reconstructing a packet'
              )
            ;(n = this.reconstructor.takeBinaryData(t)) &&
              ((this.reconstructor = null), this.emit('decoded', n))
          }
        }),
        (u.prototype.destroy = function () {
          this.reconstructor && this.reconstructor.finishedReconstruction()
        }),
        (d.prototype.takeBinaryData = function (t) {
          if (
            (this.buffers.push(t),
            this.buffers.length === this.reconPack.attachments)
          ) {
            var e = r.reconstructPacket(this.reconPack, this.buffers)
            return this.finishedReconstruction(), e
          }
          return null
        }),
        (d.prototype.finishedReconstruction = function () {
          ;(this.reconPack = null), (this.buffers = [])
        })
    },
    Uxeu: function (t, e) {
      var n = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
        i = [
          'source',
          'protocol',
          'authority',
          'userInfo',
          'user',
          'password',
          'host',
          'port',
          'relative',
          'path',
          'directory',
          'file',
          'query',
          'anchor',
        ]
      t.exports = function (t) {
        var e,
          s,
          r = t,
          o = t.indexOf('['),
          a = t.indexOf(']')
        ;-1 != o &&
          -1 != a &&
          (t =
            t.substring(0, o) +
            t.substring(o, a).replace(/:/g, ';') +
            t.substring(a, t.length))
        for (var l, c = n.exec(t || ''), h = {}, u = 14; u--; )
          h[i[u]] = c[u] || ''
        return (
          -1 != o &&
            -1 != a &&
            ((h.source = r),
            (h.host = h.host
              .substring(1, h.host.length - 1)
              .replace(/;/g, ':')),
            (h.authority = h.authority
              .replace('[', '')
              .replace(']', '')
              .replace(/;/g, ':')),
            (h.ipv6uri = !0)),
          (h.pathNames =
            ((s = (e = h.path).replace(/\/{2,9}/g, '/').split('/')),
            ('/' != e.substr(0, 1) && 0 !== e.length) || s.splice(0, 1),
            '/' == e.substr(e.length - 1, 1) && s.splice(s.length - 1, 1),
            s)),
          (h.queryKey =
            ((l = {}),
            h.query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (t, e, n) {
              e && (l[e] = n)
            }),
            l)),
          h
        )
      }
    },
    WLGk: function (t, e, n) {
      var i = n('luTP'),
        s = Object.prototype.toString,
        r =
          'function' == typeof Blob ||
          ('undefined' != typeof Blob &&
            '[object BlobConstructor]' === s.call(Blob)),
        o =
          'function' == typeof File ||
          ('undefined' != typeof File &&
            '[object FileConstructor]' === s.call(File))
      t.exports = function t(e) {
        if (!e || 'object' != typeof e) return !1
        if (i(e)) {
          for (var n = 0, s = e.length; n < s; n++) if (t(e[n])) return !0
          return !1
        }
        if (
          ('function' == typeof Buffer &&
            Buffer.isBuffer &&
            Buffer.isBuffer(e)) ||
          ('function' == typeof ArrayBuffer && e instanceof ArrayBuffer) ||
          (r && e instanceof Blob) ||
          (o && e instanceof File)
        )
          return !0
        if (e.toJSON && 'function' == typeof e.toJSON && 1 === arguments.length)
          return t(e.toJSON(), !0)
        for (var a in e)
          if (Object.prototype.hasOwnProperty.call(e, a) && t(e[a])) return !0
        return !1
      }
    },
    Wm4p: function (t, e, n) {
      var i,
        s = n('dkv/'),
        r = n('WLGk'),
        o = n('ypnn'),
        a = n('zMFY'),
        l = n('oIG/')
      'undefined' != typeof ArrayBuffer && (i = n('g5Dd'))
      var c =
          'undefined' != typeof navigator &&
          /Android/i.test(navigator.userAgent),
        h =
          'undefined' != typeof navigator &&
          /PhantomJS/i.test(navigator.userAgent),
        u = c || h
      e.protocol = 3
      var d = (e.packets = {
          open: 0,
          close: 1,
          ping: 2,
          pong: 3,
          message: 4,
          upgrade: 5,
          noop: 6,
        }),
        p = s(d),
        f = { type: 'error', data: 'parser error' },
        m = n('14A5')
      function g(t, e, n) {
        for (
          var i = new Array(t.length),
            s = a(t.length, n),
            r = function (t, n, s) {
              e(n, function (e, n) {
                ;(i[t] = n), s(e, i)
              })
            },
            o = 0;
          o < t.length;
          o++
        )
          r(o, t[o], s)
      }
      ;(e.encodePacket = function (t, n, i, s) {
        'function' == typeof n && ((s = n), (n = !1)),
          'function' == typeof i && ((s = i), (i = null))
        var r = void 0 === t.data ? void 0 : t.data.buffer || t.data
        if ('undefined' != typeof ArrayBuffer && r instanceof ArrayBuffer)
          return (function (t, n, i) {
            if (!n) return e.encodeBase64Packet(t, i)
            var s = t.data,
              r = new Uint8Array(s),
              o = new Uint8Array(1 + s.byteLength)
            o[0] = d[t.type]
            for (var a = 0; a < r.length; a++) o[a + 1] = r[a]
            return i(o.buffer)
          })(t, n, s)
        if (void 0 !== m && r instanceof m)
          return (function (t, n, i) {
            if (!n) return e.encodeBase64Packet(t, i)
            if (u)
              return (function (t, n, i) {
                if (!n) return e.encodeBase64Packet(t, i)
                var s = new FileReader()
                return (
                  (s.onload = function () {
                    e.encodePacket({ type: t.type, data: s.result }, n, !0, i)
                  }),
                  s.readAsArrayBuffer(t.data)
                )
              })(t, n, i)
            var s = new Uint8Array(1)
            return (s[0] = d[t.type]), i(new m([s.buffer, t.data]))
          })(t, n, s)
        if (r && r.base64)
          return (function (t, n) {
            return n('b' + e.packets[t.type] + t.data.data)
          })(t, s)
        var o = d[t.type]
        return (
          void 0 !== t.data &&
            (o += i
              ? l.encode(String(t.data), { strict: !1 })
              : String(t.data)),
          s('' + o)
        )
      }),
        (e.encodeBase64Packet = function (t, n) {
          var i,
            s = 'b' + e.packets[t.type]
          if (void 0 !== m && t.data instanceof m) {
            var r = new FileReader()
            return (
              (r.onload = function () {
                var t = r.result.split(',')[1]
                n(s + t)
              }),
              r.readAsDataURL(t.data)
            )
          }
          try {
            i = String.fromCharCode.apply(null, new Uint8Array(t.data))
          } catch (c) {
            for (
              var o = new Uint8Array(t.data), a = new Array(o.length), l = 0;
              l < o.length;
              l++
            )
              a[l] = o[l]
            i = String.fromCharCode.apply(null, a)
          }
          return (s += btoa(i)), n(s)
        }),
        (e.decodePacket = function (t, n, i) {
          if (void 0 === t) return f
          if ('string' == typeof t) {
            if ('b' === t.charAt(0)) return e.decodeBase64Packet(t.substr(1), n)
            if (
              i &&
              !1 ===
                (t = (function (t) {
                  try {
                    t = l.decode(t, { strict: !1 })
                  } catch (e) {
                    return !1
                  }
                  return t
                })(t))
            )
              return f
            var s = t.charAt(0)
            return Number(s) == s && p[s]
              ? t.length > 1
                ? { type: p[s], data: t.substring(1) }
                : { type: p[s] }
              : f
          }
          s = new Uint8Array(t)[0]
          var r = o(t, 1)
          return m && 'blob' === n && (r = new m([r])), { type: p[s], data: r }
        }),
        (e.decodeBase64Packet = function (t, e) {
          var n = p[t.charAt(0)]
          if (!i) return { type: n, data: { base64: !0, data: t.substr(1) } }
          var s = i.decode(t.substr(1))
          return 'blob' === e && m && (s = new m([s])), { type: n, data: s }
        }),
        (e.encodePayload = function (t, n, i) {
          'function' == typeof n && ((i = n), (n = null))
          var s = r(t)
          return n && s
            ? m && !u
              ? e.encodePayloadAsBlob(t, i)
              : e.encodePayloadAsArrayBuffer(t, i)
            : t.length
            ? void g(
                t,
                function (t, i) {
                  e.encodePacket(t, !!s && n, !1, function (t) {
                    i(
                      null,
                      (function (t) {
                        return t.length + ':' + t
                      })(t)
                    )
                  })
                },
                function (t, e) {
                  return i(e.join(''))
                }
              )
            : i('0:')
        }),
        (e.decodePayload = function (t, n, i) {
          if ('string' != typeof t) return e.decodePayloadAsBinary(t, n, i)
          var s
          if (('function' == typeof n && ((i = n), (n = null)), '' === t))
            return i(f, 0, 1)
          for (var r, o, a = '', l = 0, c = t.length; l < c; l++) {
            var h = t.charAt(l)
            if (':' === h) {
              if ('' === a || a != (r = Number(a))) return i(f, 0, 1)
              if (a != (o = t.substr(l + 1, r)).length) return i(f, 0, 1)
              if (o.length) {
                if (
                  ((s = e.decodePacket(o, n, !1)),
                  f.type === s.type && f.data === s.data)
                )
                  return i(f, 0, 1)
                if (!1 === i(s, l + r, c)) return
              }
              ;(l += r), (a = '')
            } else a += h
          }
          return '' !== a ? i(f, 0, 1) : void 0
        }),
        (e.encodePayloadAsArrayBuffer = function (t, n) {
          if (!t.length) return n(new ArrayBuffer(0))
          g(
            t,
            function (t, n) {
              e.encodePacket(t, !0, !0, function (t) {
                return n(null, t)
              })
            },
            function (t, e) {
              var i = e.reduce(function (t, e) {
                  var n
                  return (
                    t +
                    (n =
                      'string' == typeof e ? e.length : e.byteLength).toString()
                      .length +
                    n +
                    2
                  )
                }, 0),
                s = new Uint8Array(i),
                r = 0
              return (
                e.forEach(function (t) {
                  var e = 'string' == typeof t,
                    n = t
                  if (e) {
                    for (
                      var i = new Uint8Array(t.length), o = 0;
                      o < t.length;
                      o++
                    )
                      i[o] = t.charCodeAt(o)
                    n = i.buffer
                  }
                  s[r++] = e ? 0 : 1
                  var a = n.byteLength.toString()
                  for (o = 0; o < a.length; o++) s[r++] = parseInt(a[o])
                  for (
                    s[r++] = 255, i = new Uint8Array(n), o = 0;
                    o < i.length;
                    o++
                  )
                    s[r++] = i[o]
                }),
                n(s.buffer)
              )
            }
          )
        }),
        (e.encodePayloadAsBlob = function (t, n) {
          g(
            t,
            function (t, n) {
              e.encodePacket(t, !0, !0, function (t) {
                var e = new Uint8Array(1)
                if (((e[0] = 1), 'string' == typeof t)) {
                  for (
                    var i = new Uint8Array(t.length), s = 0;
                    s < t.length;
                    s++
                  )
                    i[s] = t.charCodeAt(s)
                  ;(t = i.buffer), (e[0] = 0)
                }
                var r = (t instanceof ArrayBuffer
                    ? t.byteLength
                    : t.size
                  ).toString(),
                  o = new Uint8Array(r.length + 1)
                for (s = 0; s < r.length; s++) o[s] = parseInt(r[s])
                if (((o[r.length] = 255), m)) {
                  var a = new m([e.buffer, o.buffer, t])
                  n(null, a)
                }
              })
            },
            function (t, e) {
              return n(new m(e))
            }
          )
        }),
        (e.decodePayloadAsBinary = function (t, n, i) {
          'function' == typeof n && ((i = n), (n = null))
          for (var s = t, r = []; s.byteLength > 0; ) {
            for (
              var a = new Uint8Array(s), l = 0 === a[0], c = '', h = 1;
              255 !== a[h];
              h++
            ) {
              if (c.length > 310) return i(f, 0, 1)
              c += a[h]
            }
            ;(s = o(s, 2 + c.length)), (c = parseInt(c))
            var u = o(s, 0, c)
            if (l)
              try {
                u = String.fromCharCode.apply(null, new Uint8Array(u))
              } catch (m) {
                var d = new Uint8Array(u)
                for (u = '', h = 0; h < d.length; h++)
                  u += String.fromCharCode(d[h])
              }
            r.push(u), (s = o(s, c))
          }
          var p = r.length
          r.forEach(function (t, s) {
            i(e.decodePacket(t, n, !0), s, p)
          })
        })
    },
    Yvos: function (t, e) {
      t.exports = function (t, e) {
        var n = function () {}
        ;(n.prototype = e.prototype),
          (t.prototype = new n()),
          (t.prototype.constructor = t)
      }
    },
    Zr4m: function (t, e, n) {
      'use strict'
      function i(t) {
        return 'function' == typeof t
      }
      n.r(e)
      let s = !1
      const r = {
        Promise: void 0,
        set useDeprecatedSynchronousErrorHandling(t) {
          if (t) {
            const t = new Error()
            console.warn(
              'DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' +
                t.stack
            )
          } else
            s &&
              console.log(
                'RxJS: Back to a better error behavior. Thank you. <3'
              )
          s = t
        },
        get useDeprecatedSynchronousErrorHandling() {
          return s
        },
      }
      function o(t) {
        setTimeout(() => {
          throw t
        }, 0)
      }
      const a = {
          closed: !0,
          next(t) {},
          error(t) {
            if (r.useDeprecatedSynchronousErrorHandling) throw t
            o(t)
          },
          complete() {},
        },
        l = (() => Array.isArray || ((t) => t && 'number' == typeof t.length))()
      function c(t) {
        return null !== t && 'object' == typeof t
      }
      const h = (() => {
        function t(t) {
          return (
            Error.call(this),
            (this.message = t
              ? `${t.length} errors occurred during unsubscription:\n${t
                  .map((t, e) => `${e + 1}) ${t.toString()}`)
                  .join('\n  ')}`
              : ''),
            (this.name = 'UnsubscriptionError'),
            (this.errors = t),
            this
          )
        }
        return (t.prototype = Object.create(Error.prototype)), t
      })()
      let u = (() => {
        class t {
          constructor(t) {
            ;(this.closed = !1),
              (this._parentOrParents = null),
              (this._subscriptions = null),
              t && (this._unsubscribe = t)
          }
          unsubscribe() {
            let e
            if (this.closed) return
            let {
              _parentOrParents: n,
              _unsubscribe: s,
              _subscriptions: r,
            } = this
            if (
              ((this.closed = !0),
              (this._parentOrParents = null),
              (this._subscriptions = null),
              n instanceof t)
            )
              n.remove(this)
            else if (null !== n)
              for (let t = 0; t < n.length; ++t) n[t].remove(this)
            if (i(s))
              try {
                s.call(this)
              } catch (o) {
                e = o instanceof h ? d(o.errors) : [o]
              }
            if (l(r)) {
              let t = -1,
                n = r.length
              for (; ++t < n; ) {
                const n = r[t]
                if (c(n))
                  try {
                    n.unsubscribe()
                  } catch (o) {
                    ;(e = e || []),
                      o instanceof h ? (e = e.concat(d(o.errors))) : e.push(o)
                  }
              }
            }
            if (e) throw new h(e)
          }
          add(e) {
            let n = e
            if (!e) return t.EMPTY
            switch (typeof e) {
              case 'function':
                n = new t(e)
              case 'object':
                if (
                  n === this ||
                  n.closed ||
                  'function' != typeof n.unsubscribe
                )
                  return n
                if (this.closed) return n.unsubscribe(), n
                if (!(n instanceof t)) {
                  const e = n
                  ;(n = new t()), (n._subscriptions = [e])
                }
                break
              default:
                throw new Error(
                  'unrecognized teardown ' + e + ' added to Subscription.'
                )
            }
            let { _parentOrParents: i } = n
            if (null === i) n._parentOrParents = this
            else if (i instanceof t) {
              if (i === this) return n
              n._parentOrParents = [i, this]
            } else {
              if (-1 !== i.indexOf(this)) return n
              i.push(this)
            }
            const s = this._subscriptions
            return null === s ? (this._subscriptions = [n]) : s.push(n), n
          }
          remove(t) {
            const e = this._subscriptions
            if (e) {
              const n = e.indexOf(t)
              ;-1 !== n && e.splice(n, 1)
            }
          }
        }
        return (
          (t.EMPTY = (function (t) {
            return (t.closed = !0), t
          })(new t())),
          t
        )
      })()
      function d(t) {
        return t.reduce((t, e) => t.concat(e instanceof h ? e.errors : e), [])
      }
      const p = (() =>
        'function' == typeof Symbol
          ? Symbol('rxSubscriber')
          : '@@rxSubscriber_' + Math.random())()
      class f extends u {
        constructor(t, e, n) {
          switch (
            (super(),
            (this.syncErrorValue = null),
            (this.syncErrorThrown = !1),
            (this.syncErrorThrowable = !1),
            (this.isStopped = !1),
            arguments.length)
          ) {
            case 0:
              this.destination = a
              break
            case 1:
              if (!t) {
                this.destination = a
                break
              }
              if ('object' == typeof t) {
                t instanceof f
                  ? ((this.syncErrorThrowable = t.syncErrorThrowable),
                    (this.destination = t),
                    t.add(this))
                  : ((this.syncErrorThrowable = !0),
                    (this.destination = new m(this, t)))
                break
              }
            default:
              ;(this.syncErrorThrowable = !0),
                (this.destination = new m(this, t, e, n))
          }
        }
        [p]() {
          return this
        }
        static create(t, e, n) {
          const i = new f(t, e, n)
          return (i.syncErrorThrowable = !1), i
        }
        next(t) {
          this.isStopped || this._next(t)
        }
        error(t) {
          this.isStopped || ((this.isStopped = !0), this._error(t))
        }
        complete() {
          this.isStopped || ((this.isStopped = !0), this._complete())
        }
        unsubscribe() {
          this.closed || ((this.isStopped = !0), super.unsubscribe())
        }
        _next(t) {
          this.destination.next(t)
        }
        _error(t) {
          this.destination.error(t), this.unsubscribe()
        }
        _complete() {
          this.destination.complete(), this.unsubscribe()
        }
        _unsubscribeAndRecycle() {
          const { _parentOrParents: t } = this
          return (
            (this._parentOrParents = null),
            this.unsubscribe(),
            (this.closed = !1),
            (this.isStopped = !1),
            (this._parentOrParents = t),
            this
          )
        }
      }
      class m extends f {
        constructor(t, e, n, s) {
          let r
          super(), (this._parentSubscriber = t)
          let o = this
          i(e)
            ? (r = e)
            : e &&
              ((r = e.next),
              (n = e.error),
              (s = e.complete),
              e !== a &&
                ((o = Object.create(e)),
                i(o.unsubscribe) && this.add(o.unsubscribe.bind(o)),
                (o.unsubscribe = this.unsubscribe.bind(this)))),
            (this._context = o),
            (this._next = r),
            (this._error = n),
            (this._complete = s)
        }
        next(t) {
          if (!this.isStopped && this._next) {
            const { _parentSubscriber: e } = this
            r.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable
              ? this.__tryOrSetError(e, this._next, t) && this.unsubscribe()
              : this.__tryOrUnsub(this._next, t)
          }
        }
        error(t) {
          if (!this.isStopped) {
            const { _parentSubscriber: e } = this,
              { useDeprecatedSynchronousErrorHandling: n } = r
            if (this._error)
              n && e.syncErrorThrowable
                ? (this.__tryOrSetError(e, this._error, t), this.unsubscribe())
                : (this.__tryOrUnsub(this._error, t), this.unsubscribe())
            else if (e.syncErrorThrowable)
              n ? ((e.syncErrorValue = t), (e.syncErrorThrown = !0)) : o(t),
                this.unsubscribe()
            else {
              if ((this.unsubscribe(), n)) throw t
              o(t)
            }
          }
        }
        complete() {
          if (!this.isStopped) {
            const { _parentSubscriber: t } = this
            if (this._complete) {
              const e = () => this._complete.call(this._context)
              r.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable
                ? (this.__tryOrSetError(t, e), this.unsubscribe())
                : (this.__tryOrUnsub(e), this.unsubscribe())
            } else this.unsubscribe()
          }
        }
        __tryOrUnsub(t, e) {
          try {
            t.call(this._context, e)
          } catch (n) {
            if ((this.unsubscribe(), r.useDeprecatedSynchronousErrorHandling))
              throw n
            o(n)
          }
        }
        __tryOrSetError(t, e, n) {
          if (!r.useDeprecatedSynchronousErrorHandling)
            throw new Error('bad call')
          try {
            e.call(this._context, n)
          } catch (i) {
            return r.useDeprecatedSynchronousErrorHandling
              ? ((t.syncErrorValue = i), (t.syncErrorThrown = !0), !0)
              : (o(i), !0)
          }
          return !1
        }
        _unsubscribe() {
          const { _parentSubscriber: t } = this
          ;(this._context = null),
            (this._parentSubscriber = null),
            t.unsubscribe()
        }
      }
      const g = (() =>
        ('function' == typeof Symbol && Symbol.observable) || '@@observable')()
      function y(t) {
        return t
      }
      let _ = (() => {
        class t {
          constructor(t) {
            ;(this._isScalar = !1), t && (this._subscribe = t)
          }
          lift(e) {
            const n = new t()
            return (n.source = this), (n.operator = e), n
          }
          subscribe(t, e, n) {
            const { operator: i } = this,
              s = (function (t, e, n) {
                if (t) {
                  if (t instanceof f) return t
                  if (t[p]) return t[p]()
                }
                return t || e || n ? new f(t, e, n) : new f(a)
              })(t, e, n)
            if (
              (s.add(
                i
                  ? i.call(s, this.source)
                  : this.source ||
                    (r.useDeprecatedSynchronousErrorHandling &&
                      !s.syncErrorThrowable)
                  ? this._subscribe(s)
                  : this._trySubscribe(s)
              ),
              r.useDeprecatedSynchronousErrorHandling &&
                s.syncErrorThrowable &&
                ((s.syncErrorThrowable = !1), s.syncErrorThrown))
            )
              throw s.syncErrorValue
            return s
          }
          _trySubscribe(t) {
            try {
              return this._subscribe(t)
            } catch (e) {
              r.useDeprecatedSynchronousErrorHandling &&
                ((t.syncErrorThrown = !0), (t.syncErrorValue = e)),
                (function (t) {
                  for (; t; ) {
                    const { closed: e, destination: n, isStopped: i } = t
                    if (e || i) return !1
                    t = n && n instanceof f ? n : null
                  }
                  return !0
                })(t)
                  ? t.error(e)
                  : console.warn(e)
            }
          }
          forEach(t, e) {
            return new (e = v(e))((e, n) => {
              let i
              i = this.subscribe(
                (e) => {
                  try {
                    t(e)
                  } catch (s) {
                    n(s), i && i.unsubscribe()
                  }
                },
                n,
                e
              )
            })
          }
          _subscribe(t) {
            const { source: e } = this
            return e && e.subscribe(t)
          }
          [g]() {
            return this
          }
          pipe(...t) {
            return 0 === t.length
              ? this
              : (0 === (e = t).length
                  ? y
                  : 1 === e.length
                  ? e[0]
                  : function (t) {
                      return e.reduce((t, e) => e(t), t)
                    })(this)
            var e
          }
          toPromise(t) {
            return new (t = v(t))((t, e) => {
              let n
              this.subscribe(
                (t) => (n = t),
                (t) => e(t),
                () => t(n)
              )
            })
          }
        }
        return (t.create = (e) => new t(e)), t
      })()
      function v(t) {
        if ((t || (t = r.Promise || Promise), !t))
          throw new Error('no Promise impl found')
        return t
      }
      const b = (() => {
        function t() {
          return (
            Error.call(this),
            (this.message = 'object unsubscribed'),
            (this.name = 'ObjectUnsubscribedError'),
            this
          )
        }
        return (t.prototype = Object.create(Error.prototype)), t
      })()
      class w extends u {
        constructor(t, e) {
          super(), (this.subject = t), (this.subscriber = e), (this.closed = !1)
        }
        unsubscribe() {
          if (this.closed) return
          this.closed = !0
          const t = this.subject,
            e = t.observers
          if (
            ((this.subject = null),
            !e || 0 === e.length || t.isStopped || t.closed)
          )
            return
          const n = e.indexOf(this.subscriber)
          ;-1 !== n && e.splice(n, 1)
        }
      }
      class C extends f {
        constructor(t) {
          super(t), (this.destination = t)
        }
      }
      let x = (() => {
        class t extends _ {
          constructor() {
            super(),
              (this.observers = []),
              (this.closed = !1),
              (this.isStopped = !1),
              (this.hasError = !1),
              (this.thrownError = null)
          }
          [p]() {
            return new C(this)
          }
          lift(t) {
            const e = new S(this, this)
            return (e.operator = t), e
          }
          next(t) {
            if (this.closed) throw new b()
            if (!this.isStopped) {
              const { observers: e } = this,
                n = e.length,
                i = e.slice()
              for (let s = 0; s < n; s++) i[s].next(t)
            }
          }
          error(t) {
            if (this.closed) throw new b()
            ;(this.hasError = !0), (this.thrownError = t), (this.isStopped = !0)
            const { observers: e } = this,
              n = e.length,
              i = e.slice()
            for (let s = 0; s < n; s++) i[s].error(t)
            this.observers.length = 0
          }
          complete() {
            if (this.closed) throw new b()
            this.isStopped = !0
            const { observers: t } = this,
              e = t.length,
              n = t.slice()
            for (let i = 0; i < e; i++) n[i].complete()
            this.observers.length = 0
          }
          unsubscribe() {
            ;(this.isStopped = !0), (this.closed = !0), (this.observers = null)
          }
          _trySubscribe(t) {
            if (this.closed) throw new b()
            return super._trySubscribe(t)
          }
          _subscribe(t) {
            if (this.closed) throw new b()
            return this.hasError
              ? (t.error(this.thrownError), u.EMPTY)
              : this.isStopped
              ? (t.complete(), u.EMPTY)
              : (this.observers.push(t), new w(this, t))
          }
          asObservable() {
            const t = new _()
            return (t.source = this), t
          }
        }
        return (t.create = (t, e) => new S(t, e)), t
      })()
      class S extends x {
        constructor(t, e) {
          super(), (this.destination = t), (this.source = e)
        }
        next(t) {
          const { destination: e } = this
          e && e.next && e.next(t)
        }
        error(t) {
          const { destination: e } = this
          e && e.error && this.destination.error(t)
        }
        complete() {
          const { destination: t } = this
          t && t.complete && this.destination.complete()
        }
        _subscribe(t) {
          const { source: e } = this
          return e ? this.source.subscribe(t) : u.EMPTY
        }
      }
      function E(t) {
        return t && 'function' == typeof t.schedule
      }
      class k extends f {
        constructor(t, e, n) {
          super(),
            (this.parent = t),
            (this.outerValue = e),
            (this.outerIndex = n),
            (this.index = 0)
        }
        _next(t) {
          this.parent.notifyNext(
            this.outerValue,
            t,
            this.outerIndex,
            this.index++,
            this
          )
        }
        _error(t) {
          this.parent.notifyError(t, this), this.unsubscribe()
        }
        _complete() {
          this.parent.notifyComplete(this), this.unsubscribe()
        }
      }
      const T = (t) => (e) => {
        for (let n = 0, i = t.length; n < i && !e.closed; n++) e.next(t[n])
        e.complete()
      }
      function A() {
        return 'function' == typeof Symbol && Symbol.iterator
          ? Symbol.iterator
          : '@@iterator'
      }
      const O = A(),
        I = (t) => t && 'number' == typeof t.length && 'function' != typeof t
      function R(t) {
        return (
          !!t && 'function' != typeof t.subscribe && 'function' == typeof t.then
        )
      }
      const P = (t) => {
        if (t && 'function' == typeof t[g])
          return (
            (i = t),
            (t) => {
              const e = i[g]()
              if ('function' != typeof e.subscribe)
                throw new TypeError(
                  'Provided object does not correctly implement Symbol.observable'
                )
              return e.subscribe(t)
            }
          )
        if (I(t)) return T(t)
        if (R(t))
          return (
            (n = t),
            (t) => (
              n
                .then(
                  (e) => {
                    t.closed || (t.next(e), t.complete())
                  },
                  (e) => t.error(e)
                )
                .then(null, o),
              t
            )
          )
        if (t && 'function' == typeof t[O])
          return (
            (e = t),
            (t) => {
              const n = e[O]()
              for (;;) {
                const e = n.next()
                if (e.done) {
                  t.complete()
                  break
                }
                if ((t.next(e.value), t.closed)) break
              }
              return (
                'function' == typeof n.return &&
                  t.add(() => {
                    n.return && n.return()
                  }),
                t
              )
            }
          )
        {
          const e = c(t) ? 'an invalid object' : `'${t}'`
          throw new TypeError(
            `You provided ${e} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`
          )
        }
        var e, n, i
      }
      function D(t, e, n, i, s = new k(t, n, i)) {
        if (!s.closed) return e instanceof _ ? e.subscribe(s) : P(e)(s)
      }
      class N extends f {
        notifyNext(t, e, n, i, s) {
          this.destination.next(e)
        }
        notifyError(t, e) {
          this.destination.error(t)
        }
        notifyComplete(t) {
          this.destination.complete()
        }
      }
      function F(t, e) {
        return function (n) {
          if ('function' != typeof t)
            throw new TypeError(
              'argument is not a function. Are you looking for `mapTo()`?'
            )
          return n.lift(new M(t, e))
        }
      }
      class M {
        constructor(t, e) {
          ;(this.project = t), (this.thisArg = e)
        }
        call(t, e) {
          return e.subscribe(new L(t, this.project, this.thisArg))
        }
      }
      class L extends f {
        constructor(t, e, n) {
          super(t),
            (this.project = e),
            (this.count = 0),
            (this.thisArg = n || this)
        }
        _next(t) {
          let e
          try {
            e = this.project.call(this.thisArg, t, this.count++)
          } catch (n) {
            return void this.destination.error(n)
          }
          this.destination.next(e)
        }
      }
      function j(t, e) {
        return new _((n) => {
          const i = new u()
          let s = 0
          return (
            i.add(
              e.schedule(function () {
                s !== t.length
                  ? (n.next(t[s++]), n.closed || i.add(this.schedule()))
                  : n.complete()
              })
            ),
            i
          )
        })
      }
      function B(t, e) {
        return e
          ? (function (t, e) {
              if (null != t) {
                if (
                  (function (t) {
                    return t && 'function' == typeof t[g]
                  })(t)
                )
                  return (function (t, e) {
                    return new _((n) => {
                      const i = new u()
                      return (
                        i.add(
                          e.schedule(() => {
                            const s = t[g]()
                            i.add(
                              s.subscribe({
                                next(t) {
                                  i.add(e.schedule(() => n.next(t)))
                                },
                                error(t) {
                                  i.add(e.schedule(() => n.error(t)))
                                },
                                complete() {
                                  i.add(e.schedule(() => n.complete()))
                                },
                              })
                            )
                          })
                        ),
                        i
                      )
                    })
                  })(t, e)
                if (R(t))
                  return (function (t, e) {
                    return new _((n) => {
                      const i = new u()
                      return (
                        i.add(
                          e.schedule(() =>
                            t.then(
                              (t) => {
                                i.add(
                                  e.schedule(() => {
                                    n.next(t),
                                      i.add(e.schedule(() => n.complete()))
                                  })
                                )
                              },
                              (t) => {
                                i.add(e.schedule(() => n.error(t)))
                              }
                            )
                          )
                        ),
                        i
                      )
                    })
                  })(t, e)
                if (I(t)) return j(t, e)
                if (
                  (function (t) {
                    return t && 'function' == typeof t[O]
                  })(t) ||
                  'string' == typeof t
                )
                  return (function (t, e) {
                    if (!t) throw new Error('Iterable cannot be null')
                    return new _((n) => {
                      const i = new u()
                      let s
                      return (
                        i.add(() => {
                          s && 'function' == typeof s.return && s.return()
                        }),
                        i.add(
                          e.schedule(() => {
                            ;(s = t[O]()),
                              i.add(
                                e.schedule(function () {
                                  if (n.closed) return
                                  let t, e
                                  try {
                                    const n = s.next()
                                    ;(t = n.value), (e = n.done)
                                  } catch (i) {
                                    return void n.error(i)
                                  }
                                  e
                                    ? n.complete()
                                    : (n.next(t), this.schedule())
                                })
                              )
                          })
                        ),
                        i
                      )
                    })
                  })(t, e)
              }
              throw new TypeError(
                ((null !== t && typeof t) || t) + ' is not observable'
              )
            })(t, e)
          : t instanceof _
          ? t
          : new _(P(t))
      }
      function V(t, e, n = Number.POSITIVE_INFINITY) {
        return 'function' == typeof e
          ? (i) =>
              i.pipe(
                V((n, i) => B(t(n, i)).pipe(F((t, s) => e(n, t, i, s))), n)
              )
          : ('number' == typeof e && (n = e), (e) => e.lift(new U(t, n)))
      }
      class U {
        constructor(t, e = Number.POSITIVE_INFINITY) {
          ;(this.project = t), (this.concurrent = e)
        }
        call(t, e) {
          return e.subscribe(new z(t, this.project, this.concurrent))
        }
      }
      class z extends N {
        constructor(t, e, n = Number.POSITIVE_INFINITY) {
          super(t),
            (this.project = e),
            (this.concurrent = n),
            (this.hasCompleted = !1),
            (this.buffer = []),
            (this.active = 0),
            (this.index = 0)
        }
        _next(t) {
          this.active < this.concurrent ? this._tryNext(t) : this.buffer.push(t)
        }
        _tryNext(t) {
          let e
          const n = this.index++
          try {
            e = this.project(t, n)
          } catch (i) {
            return void this.destination.error(i)
          }
          this.active++, this._innerSub(e, t, n)
        }
        _innerSub(t, e, n) {
          const i = new k(this, e, n),
            s = this.destination
          s.add(i)
          const r = D(this, t, void 0, void 0, i)
          r !== i && s.add(r)
        }
        _complete() {
          ;(this.hasCompleted = !0),
            0 === this.active &&
              0 === this.buffer.length &&
              this.destination.complete(),
            this.unsubscribe()
        }
        notifyNext(t, e, n, i, s) {
          this.destination.next(e)
        }
        notifyComplete(t) {
          const e = this.buffer
          this.remove(t),
            this.active--,
            e.length > 0
              ? this._next(e.shift())
              : 0 === this.active &&
                this.hasCompleted &&
                this.destination.complete()
        }
      }
      function H(t = Number.POSITIVE_INFINITY) {
        return V(y, t)
      }
      function q(t, e) {
        return e ? j(t, e) : new _(T(t))
      }
      function $(...t) {
        let e = Number.POSITIVE_INFINITY,
          n = null,
          i = t[t.length - 1]
        return (
          E(i)
            ? ((n = t.pop()),
              t.length > 1 &&
                'number' == typeof t[t.length - 1] &&
                (e = t.pop()))
            : 'number' == typeof i && (e = t.pop()),
          null === n && 1 === t.length && t[0] instanceof _
            ? t[0]
            : H(e)(q(t, n))
        )
      }
      function W() {
        return function (t) {
          return t.lift(new K(t))
        }
      }
      class K {
        constructor(t) {
          this.connectable = t
        }
        call(t, e) {
          const { connectable: n } = this
          n._refCount++
          const i = new G(t, n),
            s = e.subscribe(i)
          return i.closed || (i.connection = n.connect()), s
        }
      }
      class G extends f {
        constructor(t, e) {
          super(t), (this.connectable = e)
        }
        _unsubscribe() {
          const { connectable: t } = this
          if (!t) return void (this.connection = null)
          this.connectable = null
          const e = t._refCount
          if (e <= 0) return void (this.connection = null)
          if (((t._refCount = e - 1), e > 1))
            return void (this.connection = null)
          const { connection: n } = this,
            i = t._connection
          ;(this.connection = null), !i || (n && i !== n) || i.unsubscribe()
        }
      }
      class Q extends _ {
        constructor(t, e) {
          super(),
            (this.source = t),
            (this.subjectFactory = e),
            (this._refCount = 0),
            (this._isComplete = !1)
        }
        _subscribe(t) {
          return this.getSubject().subscribe(t)
        }
        getSubject() {
          const t = this._subject
          return (
            (t && !t.isStopped) || (this._subject = this.subjectFactory()),
            this._subject
          )
        }
        connect() {
          let t = this._connection
          return (
            t ||
              ((this._isComplete = !1),
              (t = this._connection = new u()),
              t.add(this.source.subscribe(new Y(this.getSubject(), this))),
              t.closed && ((this._connection = null), (t = u.EMPTY))),
            t
          )
        }
        refCount() {
          return W()(this)
        }
      }
      const Z = (() => {
        const t = Q.prototype
        return {
          operator: { value: null },
          _refCount: { value: 0, writable: !0 },
          _subject: { value: null, writable: !0 },
          _connection: { value: null, writable: !0 },
          _subscribe: { value: t._subscribe },
          _isComplete: { value: t._isComplete, writable: !0 },
          getSubject: { value: t.getSubject },
          connect: { value: t.connect },
          refCount: { value: t.refCount },
        }
      })()
      class Y extends C {
        constructor(t, e) {
          super(t), (this.connectable = e)
        }
        _error(t) {
          this._unsubscribe(), super._error(t)
        }
        _complete() {
          ;(this.connectable._isComplete = !0),
            this._unsubscribe(),
            super._complete()
        }
        _unsubscribe() {
          const t = this.connectable
          if (t) {
            this.connectable = null
            const e = t._connection
            ;(t._refCount = 0),
              (t._subject = null),
              (t._connection = null),
              e && e.unsubscribe()
          }
        }
      }
      function X(t, e) {
        return function (n) {
          let i
          if (
            ((i =
              'function' == typeof t
                ? t
                : function () {
                    return t
                  }),
            'function' == typeof e)
          )
            return n.lift(new J(i, e))
          const s = Object.create(n, Z)
          return (s.source = n), (s.subjectFactory = i), s
        }
      }
      class J {
        constructor(t, e) {
          ;(this.subjectFactory = t), (this.selector = e)
        }
        call(t, e) {
          const { selector: n } = this,
            i = this.subjectFactory(),
            s = n(i).subscribe(t)
          return s.add(e.subscribe(i)), s
        }
      }
      function tt() {
        return new x()
      }
      function et() {
        return (t) => W()(X(tt)(t))
      }
      function nt(t) {
        for (let e in t) if (t[e] === nt) return e
        throw Error('Could not find renamed property on target object.')
      }
      function it(t, e) {
        for (const n in e)
          e.hasOwnProperty(n) && !t.hasOwnProperty(n) && (t[n] = e[n])
      }
      function st(t) {
        if ('string' == typeof t) return t
        if (Array.isArray(t)) return '[' + t.map(st).join(', ') + ']'
        if (null == t) return '' + t
        if (t.overriddenName) return '' + t.overriddenName
        if (t.name) return '' + t.name
        const e = t.toString()
        if (null == e) return '' + e
        const n = e.indexOf('\n')
        return -1 === n ? e : e.substring(0, n)
      }
      function rt(t, e) {
        return null == t || '' === t
          ? null === e
            ? ''
            : e
          : null == e || '' === e
          ? t
          : t + ' ' + e
      }
      const ot = nt({ __forward_ref__: nt })
      function at(t) {
        return (
          (t.__forward_ref__ = at),
          (t.toString = function () {
            return st(this())
          }),
          t
        )
      }
      function lt(t) {
        return ct(t) ? t() : t
      }
      function ct(t) {
        return (
          'function' == typeof t &&
          t.hasOwnProperty(ot) &&
          t.__forward_ref__ === at
        )
      }
      function ht(t) {
        return {
          token: t.token,
          providedIn: t.providedIn || null,
          factory: t.factory,
          value: void 0,
        }
      }
      function ut(t) {
        return {
          factory: t.factory,
          providers: t.providers || [],
          imports: t.imports || [],
        }
      }
      function dt(t) {
        return pt(t, mt) || pt(t, yt)
      }
      function pt(t, e) {
        return t.hasOwnProperty(e) ? t[e] : null
      }
      function ft(t) {
        return t && (t.hasOwnProperty(gt) || t.hasOwnProperty(_t))
          ? t[gt]
          : null
      }
      const mt = nt({ '\u0275prov': nt }),
        gt = nt({ '\u0275inj': nt }),
        yt = nt({ ngInjectableDef: nt }),
        _t = nt({ ngInjectorDef: nt })
      var vt = (function (t) {
        return (
          (t[(t.Default = 0)] = 'Default'),
          (t[(t.Host = 1)] = 'Host'),
          (t[(t.Self = 2)] = 'Self'),
          (t[(t.SkipSelf = 4)] = 'SkipSelf'),
          (t[(t.Optional = 8)] = 'Optional'),
          t
        )
      })({})
      let bt
      function wt(t) {
        const e = bt
        return (bt = t), e
      }
      function Ct(t, e, n) {
        const i = dt(t)
        if (i && 'root' == i.providedIn)
          return void 0 === i.value ? (i.value = i.factory()) : i.value
        if (n & vt.Optional) return null
        if (void 0 !== e) return e
        throw new Error(`Injector: NOT_FOUND [${st(t)}]`)
      }
      function xt(t) {
        return { toString: t }.toString()
      }
      var St = (function (t) {
          return (
            (t[(t.OnPush = 0)] = 'OnPush'), (t[(t.Default = 1)] = 'Default'), t
          )
        })({}),
        Et = (function (t) {
          return (
            (t[(t.Emulated = 0)] = 'Emulated'),
            (t[(t.None = 2)] = 'None'),
            (t[(t.ShadowDom = 3)] = 'ShadowDom'),
            t
          )
        })({})
      const kt = 'undefined' != typeof globalThis && globalThis,
        Tt = 'undefined' != typeof window && window,
        At =
          'undefined' != typeof self &&
          'undefined' != typeof WorkerGlobalScope &&
          self instanceof WorkerGlobalScope &&
          self,
        Ot = 'undefined' != typeof global && global,
        It = kt || Ot || Tt || At,
        Rt = {},
        Pt = [],
        Dt = nt({ '\u0275cmp': nt }),
        Nt = nt({ '\u0275dir': nt }),
        Ft = nt({ '\u0275pipe': nt }),
        Mt = nt({ '\u0275mod': nt }),
        Lt = nt({ '\u0275loc': nt }),
        jt = nt({ '\u0275fac': nt }),
        Bt = nt({ __NG_ELEMENT_ID__: nt })
      let Vt = 0
      function Ut(t) {
        return xt(() => {
          const e = {},
            n = {
              type: t.type,
              providersResolver: null,
              decls: t.decls,
              vars: t.vars,
              factory: null,
              template: t.template || null,
              consts: t.consts || null,
              ngContentSelectors: t.ngContentSelectors,
              hostBindings: t.hostBindings || null,
              hostVars: t.hostVars || 0,
              hostAttrs: t.hostAttrs || null,
              contentQueries: t.contentQueries || null,
              declaredInputs: e,
              inputs: null,
              outputs: null,
              exportAs: t.exportAs || null,
              onPush: t.changeDetection === St.OnPush,
              directiveDefs: null,
              pipeDefs: null,
              selectors: t.selectors || Pt,
              viewQuery: t.viewQuery || null,
              features: t.features || null,
              data: t.data || {},
              encapsulation: t.encapsulation || Et.Emulated,
              id: 'c',
              styles: t.styles || Pt,
              _: null,
              setInput: null,
              schemas: t.schemas || null,
              tView: null,
            },
            i = t.directives,
            s = t.features,
            r = t.pipes
          return (
            (n.id += Vt++),
            (n.inputs = Wt(t.inputs, e)),
            (n.outputs = Wt(t.outputs)),
            s && s.forEach((t) => t(n)),
            (n.directiveDefs = i
              ? () => ('function' == typeof i ? i() : i).map(zt)
              : null),
            (n.pipeDefs = r
              ? () => ('function' == typeof r ? r() : r).map(Ht)
              : null),
            n
          )
        })
      }
      function zt(t) {
        return (
          Qt(t) ||
          (function (t) {
            return t[Nt] || null
          })(t)
        )
      }
      function Ht(t) {
        return (function (t) {
          return t[Ft] || null
        })(t)
      }
      const qt = {}
      function $t(t) {
        const e = {
          type: t.type,
          bootstrap: t.bootstrap || Pt,
          declarations: t.declarations || Pt,
          imports: t.imports || Pt,
          exports: t.exports || Pt,
          transitiveCompileScopes: null,
          schemas: t.schemas || null,
          id: t.id || null,
        }
        return (
          null != t.id &&
            xt(() => {
              qt[t.id] = t.type
            }),
          e
        )
      }
      function Wt(t, e) {
        if (null == t) return Rt
        const n = {}
        for (const i in t)
          if (t.hasOwnProperty(i)) {
            let s = t[i],
              r = s
            Array.isArray(s) && ((r = s[1]), (s = s[0])),
              (n[s] = i),
              e && (e[s] = r)
          }
        return n
      }
      const Kt = Ut
      function Gt(t) {
        return {
          type: t.type,
          name: t.name,
          factory: null,
          pure: !1 !== t.pure,
          onDestroy: t.type.prototype.ngOnDestroy || null,
        }
      }
      function Qt(t) {
        return t[Dt] || null
      }
      function Zt(t, e) {
        const n = t[Mt] || null
        if (!n && !0 === e)
          throw new Error(`Type ${st(t)} does not have '\u0275mod' property.`)
        return n
      }
      const Yt = 20,
        Xt = 10
      function Jt(t) {
        return Array.isArray(t) && 'object' == typeof t[1]
      }
      function te(t) {
        return Array.isArray(t) && !0 === t[1]
      }
      function ee(t) {
        return 0 != (8 & t.flags)
      }
      function ne(t) {
        return 2 == (2 & t.flags)
      }
      function ie(t) {
        return 1 == (1 & t.flags)
      }
      function se(t) {
        return null !== t.template
      }
      function re(t, e) {
        return t.hasOwnProperty(jt) ? t[jt] : null
      }
      class oe extends Error {
        constructor(t, e) {
          super(
            (function (t, e) {
              return `${t ? `NG0${t}: ` : ''}${e}`
            })(t, e)
          ),
            (this.code = t)
        }
      }
      function ae(t) {
        return 'string' == typeof t ? t : null == t ? '' : String(t)
      }
      function le(t) {
        return 'function' == typeof t
          ? t.name || t.toString()
          : 'object' == typeof t && null != t && 'function' == typeof t.type
          ? t.type.name || t.type.toString()
          : ae(t)
      }
      function ce(t, e) {
        const n = e ? ' in ' + e : ''
        throw new oe('201', `No provider for ${le(t)} found${n}`)
      }
      class he {
        constructor(t, e, n) {
          ;(this.previousValue = t),
            (this.currentValue = e),
            (this.firstChange = n)
        }
        isFirstChange() {
          return this.firstChange
        }
      }
      function ue() {
        return de
      }
      function de(t) {
        return t.type.prototype.ngOnChanges && (t.setInput = fe), pe
      }
      function pe() {
        const t = me(this),
          e = null == t ? void 0 : t.current
        if (e) {
          const n = t.previous
          if (n === Rt) t.previous = e
          else for (let t in e) n[t] = e[t]
          ;(t.current = null), this.ngOnChanges(e)
        }
      }
      function fe(t, e, n, i) {
        const s =
            me(t) ||
            (function (t, e) {
              return (t.__ngSimpleChanges__ = e)
            })(t, { previous: Rt, current: null }),
          r = s.current || (s.current = {}),
          o = s.previous,
          a = this.declaredInputs[n],
          l = o[a]
        ;(r[a] = new he(l && l.currentValue, e, o === Rt)), (t[i] = e)
      }
      function me(t) {
        return t.__ngSimpleChanges__ || null
      }
      ue.ngInherit = !0
      const ge = 'http://www.w3.org/2000/svg'
      let ye = void 0
      function _e(t) {
        return !!t.listen
      }
      const ve = {
        createRenderer: (t, e) =>
          void 0 !== ye
            ? ye
            : 'undefined' != typeof document
            ? document
            : void 0,
      }
      function be(t) {
        for (; Array.isArray(t); ) t = t[0]
        return t
      }
      function we(t, e) {
        return be(e[t])
      }
      function Ce(t, e) {
        return be(e[t.index])
      }
      function xe(t, e) {
        return t.data[e]
      }
      function Se(t, e) {
        return t[e]
      }
      function Ee(t, e) {
        const n = e[t]
        return Jt(n) ? n : n[0]
      }
      function ke(t) {
        const e = (function (t) {
          return t.__ngContext__ || null
        })(t)
        return e ? (Array.isArray(e) ? e : e.lView) : null
      }
      function Te(t) {
        return 4 == (4 & t[2])
      }
      function Ae(t) {
        return 128 == (128 & t[2])
      }
      function Oe(t, e) {
        return null == e ? null : t[e]
      }
      function Ie(t) {
        t[18] = 0
      }
      function Re(t, e) {
        t[5] += e
        let n = t,
          i = t[3]
        for (
          ;
          null !== i && ((1 === e && 1 === n[5]) || (-1 === e && 0 === n[5]));

        )
          (i[5] += e), (n = i), (i = i[3])
      }
      const Pe = {
        lFrame: nn(null),
        bindingsEnabled: !0,
        isInCheckNoChangesMode: !1,
      }
      function De() {
        return Pe.bindingsEnabled
      }
      function Ne() {
        return Pe.lFrame.lView
      }
      function Fe() {
        return Pe.lFrame.tView
      }
      function Me(t) {
        Pe.lFrame.contextLView = t
      }
      function Le() {
        let t = je()
        for (; null !== t && 64 === t.type; ) t = t.parent
        return t
      }
      function je() {
        return Pe.lFrame.currentTNode
      }
      function Be(t, e) {
        const n = Pe.lFrame
        ;(n.currentTNode = t), (n.isParent = e)
      }
      function Ve() {
        return Pe.lFrame.isParent
      }
      function Ue() {
        Pe.lFrame.isParent = !1
      }
      function ze() {
        return Pe.isInCheckNoChangesMode
      }
      function He(t) {
        Pe.isInCheckNoChangesMode = t
      }
      function qe() {
        const t = Pe.lFrame
        let e = t.bindingRootIndex
        return (
          -1 === e && (e = t.bindingRootIndex = t.tView.bindingStartIndex), e
        )
      }
      function $e() {
        return Pe.lFrame.bindingIndex++
      }
      function We(t) {
        const e = Pe.lFrame,
          n = e.bindingIndex
        return (e.bindingIndex = e.bindingIndex + t), n
      }
      function Ke(t, e) {
        const n = Pe.lFrame
        ;(n.bindingIndex = n.bindingRootIndex = t), Ge(e)
      }
      function Ge(t) {
        Pe.lFrame.currentDirectiveIndex = t
      }
      function Qe(t) {
        const e = Pe.lFrame.currentDirectiveIndex
        return -1 === e ? null : t[e]
      }
      function Ze() {
        return Pe.lFrame.currentQueryIndex
      }
      function Ye(t) {
        Pe.lFrame.currentQueryIndex = t
      }
      function Xe(t) {
        const e = t[1]
        return 2 === e.type ? e.declTNode : 1 === e.type ? t[6] : null
      }
      function Je(t, e, n) {
        if (n & vt.SkipSelf) {
          let i = e,
            s = t
          for (
            ;
            (i = i.parent),
              !(
                null !== i ||
                n & vt.Host ||
                ((i = Xe(s)), null === i) ||
                ((s = s[15]), 10 & i.type)
              );

          );
          if (null === i) return !1
          ;(e = i), (t = s)
        }
        const i = (Pe.lFrame = en())
        return (i.currentTNode = e), (i.lView = t), !0
      }
      function tn(t) {
        const e = en(),
          n = t[1]
        ;(Pe.lFrame = e),
          (e.currentTNode = n.firstChild),
          (e.lView = t),
          (e.tView = n),
          (e.contextLView = t),
          (e.bindingIndex = n.bindingStartIndex),
          (e.inI18n = !1)
      }
      function en() {
        const t = Pe.lFrame,
          e = null === t ? null : t.child
        return null === e ? nn(t) : e
      }
      function nn(t) {
        const e = {
          currentTNode: null,
          isParent: !0,
          lView: null,
          tView: null,
          selectedIndex: -1,
          contextLView: null,
          elementDepthCount: 0,
          currentNamespace: null,
          currentDirectiveIndex: -1,
          bindingRootIndex: -1,
          bindingIndex: -1,
          currentQueryIndex: 0,
          parent: t,
          child: null,
          inI18n: !1,
        }
        return null !== t && (t.child = e), e
      }
      function sn() {
        const t = Pe.lFrame
        return (
          (Pe.lFrame = t.parent), (t.currentTNode = null), (t.lView = null), t
        )
      }
      const rn = sn
      function on() {
        const t = sn()
        ;(t.isParent = !0),
          (t.tView = null),
          (t.selectedIndex = -1),
          (t.contextLView = null),
          (t.elementDepthCount = 0),
          (t.currentDirectiveIndex = -1),
          (t.currentNamespace = null),
          (t.bindingRootIndex = -1),
          (t.bindingIndex = -1),
          (t.currentQueryIndex = 0)
      }
      function an() {
        return Pe.lFrame.selectedIndex
      }
      function ln(t) {
        Pe.lFrame.selectedIndex = t
      }
      function cn() {
        const t = Pe.lFrame
        return xe(t.tView, t.selectedIndex)
      }
      function hn() {
        Pe.lFrame.currentNamespace = ge
      }
      function un(t, e) {
        for (let n = e.directiveStart, i = e.directiveEnd; n < i; n++) {
          const e = t.data[n].type.prototype,
            {
              ngAfterContentInit: i,
              ngAfterContentChecked: s,
              ngAfterViewInit: r,
              ngAfterViewChecked: o,
              ngOnDestroy: a,
            } = e
          i && (t.contentHooks || (t.contentHooks = [])).push(-n, i),
            s &&
              ((t.contentHooks || (t.contentHooks = [])).push(n, s),
              (t.contentCheckHooks || (t.contentCheckHooks = [])).push(n, s)),
            r && (t.viewHooks || (t.viewHooks = [])).push(-n, r),
            o &&
              ((t.viewHooks || (t.viewHooks = [])).push(n, o),
              (t.viewCheckHooks || (t.viewCheckHooks = [])).push(n, o)),
            null != a && (t.destroyHooks || (t.destroyHooks = [])).push(n, a)
        }
      }
      function dn(t, e, n) {
        mn(t, e, 3, n)
      }
      function pn(t, e, n, i) {
        ;(3 & t[2]) === n && mn(t, e, n, i)
      }
      function fn(t, e) {
        let n = t[2]
        ;(3 & n) === e && ((n &= 2047), (n += 1), (t[2] = n))
      }
      function mn(t, e, n, i) {
        const s = null != i ? i : -1
        let r = 0
        for (let o = void 0 !== i ? 65535 & t[18] : 0; o < e.length; o++)
          if ('number' == typeof e[o + 1]) {
            if (((r = e[o]), null != i && r >= i)) break
          } else
            e[o] < 0 && (t[18] += 65536),
              (r < s || -1 == s) &&
                (gn(t, n, e, o), (t[18] = (4294901760 & t[18]) + o + 2)),
              o++
      }
      function gn(t, e, n, i) {
        const s = n[i] < 0,
          r = n[i + 1],
          o = t[s ? -n[i] : n[i]]
        s
          ? t[2] >> 11 < t[18] >> 16 &&
            (3 & t[2]) === e &&
            ((t[2] += 2048), r.call(o))
          : r.call(o)
      }
      const yn = -1
      class _n {
        constructor(t, e, n) {
          ;(this.factory = t),
            (this.resolving = !1),
            (this.canSeeViewProviders = e),
            (this.injectImpl = n)
        }
      }
      function vn(t, e, n) {
        const i = _e(t)
        let s = 0
        for (; s < n.length; ) {
          const r = n[s]
          if ('number' == typeof r) {
            if (0 !== r) break
            s++
            const o = n[s++],
              a = n[s++],
              l = n[s++]
            i ? t.setAttribute(e, a, l, o) : e.setAttributeNS(o, a, l)
          } else {
            const o = r,
              a = n[++s]
            wn(o)
              ? i && t.setProperty(e, o, a)
              : i
              ? t.setAttribute(e, o, a)
              : e.setAttribute(o, a),
              s++
          }
        }
        return s
      }
      function bn(t) {
        return 3 === t || 4 === t || 6 === t
      }
      function wn(t) {
        return 64 === t.charCodeAt(0)
      }
      function Cn(t, e) {
        if (null === e || 0 === e.length);
        else if (null === t || 0 === t.length) t = e.slice()
        else {
          let n = -1
          for (let i = 0; i < e.length; i++) {
            const s = e[i]
            'number' == typeof s
              ? (n = s)
              : 0 === n ||
                xn(t, n, s, null, -1 === n || 2 === n ? e[++i] : null)
          }
        }
        return t
      }
      function xn(t, e, n, i, s) {
        let r = 0,
          o = t.length
        if (-1 === e) o = -1
        else
          for (; r < t.length; ) {
            const n = t[r++]
            if ('number' == typeof n) {
              if (n === e) {
                o = -1
                break
              }
              if (n > e) {
                o = r - 1
                break
              }
            }
          }
        for (; r < t.length; ) {
          const e = t[r]
          if ('number' == typeof e) break
          if (e === n) {
            if (null === i) return void (null !== s && (t[r + 1] = s))
            if (i === t[r + 1]) return void (t[r + 2] = s)
          }
          r++, null !== i && r++, null !== s && r++
        }
        ;-1 !== o && (t.splice(o, 0, e), (r = o + 1)),
          t.splice(r++, 0, n),
          null !== i && t.splice(r++, 0, i),
          null !== s && t.splice(r++, 0, s)
      }
      function Sn(t) {
        return t !== yn
      }
      function En(t) {
        return 32767 & t
      }
      function kn(t, e) {
        let n = t >> 16,
          i = e
        for (; n > 0; ) (i = i[15]), n--
        return i
      }
      let Tn = !0
      function An(t) {
        const e = Tn
        return (Tn = t), e
      }
      let On = 0
      function In(t, e) {
        const n = Pn(t, e)
        if (-1 !== n) return n
        const i = e[1]
        i.firstCreatePass &&
          ((t.injectorIndex = e.length),
          Rn(i.data, t),
          Rn(e, null),
          Rn(i.blueprint, null))
        const s = Dn(t, e),
          r = t.injectorIndex
        if (Sn(s)) {
          const t = En(s),
            n = kn(s, e),
            i = n[1].data
          for (let s = 0; s < 8; s++) e[r + s] = n[t + s] | i[t + s]
        }
        return (e[r + 8] = s), r
      }
      function Rn(t, e) {
        t.push(0, 0, 0, 0, 0, 0, 0, 0, e)
      }
      function Pn(t, e) {
        return -1 === t.injectorIndex ||
          (t.parent && t.parent.injectorIndex === t.injectorIndex) ||
          null === e[t.injectorIndex + 8]
          ? -1
          : t.injectorIndex
      }
      function Dn(t, e) {
        if (t.parent && -1 !== t.parent.injectorIndex)
          return t.parent.injectorIndex
        let n = 0,
          i = null,
          s = e
        for (; null !== s; ) {
          const t = s[1],
            e = t.type
          if (((i = 2 === e ? t.declTNode : 1 === e ? s[6] : null), null === i))
            return yn
          if ((n++, (s = s[15]), -1 !== i.injectorIndex))
            return i.injectorIndex | (n << 16)
        }
        return yn
      }
      function Nn(t, e, n) {
        !(function (t, e, n) {
          let i
          'string' == typeof n
            ? (i = n.charCodeAt(0) || 0)
            : n.hasOwnProperty(Bt) && (i = n[Bt]),
            null == i && (i = n[Bt] = On++)
          const s = 255 & i,
            r = 1 << s,
            o = 64 & s,
            a = 32 & s,
            l = e.data
          128 & s
            ? o
              ? a
                ? (l[t + 7] |= r)
                : (l[t + 6] |= r)
              : a
              ? (l[t + 5] |= r)
              : (l[t + 4] |= r)
            : o
            ? a
              ? (l[t + 3] |= r)
              : (l[t + 2] |= r)
            : a
            ? (l[t + 1] |= r)
            : (l[t] |= r)
        })(t, e, n)
      }
      function Fn(t, e, n) {
        if (n & vt.Optional) return t
        ce(e, 'NodeInjector')
      }
      function Mn(t, e, n, i) {
        if (
          (n & vt.Optional && void 0 === i && (i = null),
          0 == (n & (vt.Self | vt.Host)))
        ) {
          const s = t[9],
            r = wt(void 0)
          try {
            return s ? s.get(e, i, n & vt.Optional) : Ct(e, i, n & vt.Optional)
          } finally {
            wt(r)
          }
        }
        return Fn(i, e, n)
      }
      function Ln(t, e, n, i = vt.Default, s) {
        if (null !== t) {
          const r = (function (t) {
            if ('string' == typeof t) return t.charCodeAt(0) || 0
            const e = t.hasOwnProperty(Bt) ? t[Bt] : void 0
            return 'number' == typeof e ? (e >= 0 ? 255 & e : Bn) : e
          })(n)
          if ('function' == typeof r) {
            if (!Je(e, t, i)) return i & vt.Host ? Fn(s, n, i) : Mn(e, n, i, s)
            try {
              const t = r()
              if (null != t || i & vt.Optional) return t
              ce(n)
            } finally {
              rn()
            }
          } else if ('number' == typeof r) {
            let s = null,
              o = Pn(t, e),
              a = yn,
              l = i & vt.Host ? e[16][6] : null
            for (
              (-1 === o || i & vt.SkipSelf) &&
              ((a = -1 === o ? Dn(t, e) : e[o + 8]),
              a !== yn && qn(i, !1)
                ? ((s = e[1]), (o = En(a)), (e = kn(a, e)))
                : (o = -1));
              -1 !== o;

            ) {
              const t = e[1]
              if (Hn(r, o, t.data)) {
                const t = Vn(o, e, n, s, i, l)
                if (t !== jn) return t
              }
              ;(a = e[o + 8]),
                a !== yn && qn(i, e[1].data[o + 8] === l) && Hn(r, o, e)
                  ? ((s = t), (o = En(a)), (e = kn(a, e)))
                  : (o = -1)
            }
          }
        }
        return Mn(e, n, i, s)
      }
      const jn = {}
      function Bn() {
        return new $n(Le(), Ne())
      }
      function Vn(t, e, n, i, s, r) {
        const o = e[1],
          a = o.data[t + 8],
          l = Un(
            a,
            o,
            n,
            null == i ? ne(a) && Tn : i != o && 0 != (3 & a.type),
            s & vt.Host && r === a
          )
        return null !== l ? zn(e, o, l, a) : jn
      }
      function Un(t, e, n, i, s) {
        const r = t.providerIndexes,
          o = e.data,
          a = 1048575 & r,
          l = t.directiveStart,
          c = r >> 20,
          h = s ? a + c : t.directiveEnd
        for (let u = i ? a : a + c; u < h; u++) {
          const t = o[u]
          if ((u < l && n === t) || (u >= l && t.type === n)) return u
        }
        if (s) {
          const t = o[l]
          if (t && se(t) && t.type === n) return l
        }
        return null
      }
      function zn(t, e, n, i) {
        let s = t[n]
        const r = e.data
        if (s instanceof _n) {
          const o = s
          o.resolving &&
            (function (t, e) {
              throw new oe('200', 'Circular dependency in DI detected for ' + t)
            })(le(r[n]))
          const a = An(o.canSeeViewProviders)
          o.resolving = !0
          const l = o.injectImpl ? wt(o.injectImpl) : null
          Je(t, i, vt.Default)
          try {
            ;(s = t[n] = o.factory(void 0, r, t, i)),
              e.firstCreatePass &&
                n >= i.directiveStart &&
                (function (t, e, n) {
                  const {
                    ngOnChanges: i,
                    ngOnInit: s,
                    ngDoCheck: r,
                  } = e.type.prototype
                  if (i) {
                    const i = de(e)
                    ;(n.preOrderHooks || (n.preOrderHooks = [])).push(t, i),
                      (
                        n.preOrderCheckHooks || (n.preOrderCheckHooks = [])
                      ).push(t, i)
                  }
                  s &&
                    (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - t, s),
                    r &&
                      ((n.preOrderHooks || (n.preOrderHooks = [])).push(t, r),
                      (
                        n.preOrderCheckHooks || (n.preOrderCheckHooks = [])
                      ).push(t, r))
                })(n, r[n], e)
          } finally {
            null !== l && wt(l), An(a), (o.resolving = !1), rn()
          }
        }
        return s
      }
      function Hn(t, e, n) {
        const i = 64 & t,
          s = 32 & t
        let r
        return (
          (r =
            128 & t
              ? i
                ? s
                  ? n[e + 7]
                  : n[e + 6]
                : s
                ? n[e + 5]
                : n[e + 4]
              : i
              ? s
                ? n[e + 3]
                : n[e + 2]
              : s
              ? n[e + 1]
              : n[e]),
          !!(r & (1 << t))
        )
      }
      function qn(t, e) {
        return !(t & vt.Self || (t & vt.Host && e))
      }
      class $n {
        constructor(t, e) {
          ;(this._tNode = t), (this._lView = e)
        }
        get(t, e) {
          return Ln(this._tNode, this._lView, t, void 0, e)
        }
      }
      function Wn(t) {
        const e = t
        if (ct(t))
          return () => {
            const t = Wn(lt(e))
            return t ? t() : null
          }
        let n = re(e)
        if (null === n) {
          const t = ft(e)
          n = t && t.factory
        }
        return n || null
      }
      function Kn(t) {
        return xt(() => {
          const e = t.prototype.constructor,
            n = e[jt] || Wn(e),
            i = Object.prototype
          let s = Object.getPrototypeOf(t.prototype).constructor
          for (; s && s !== i; ) {
            const t = s[jt] || Wn(s)
            if (t && t !== n) return t
            s = Object.getPrototypeOf(s)
          }
          return (t) => new t()
        })
      }
      function Gn(t) {
        return (function (t, e) {
          if ('class' === e) return t.classes
          if ('style' === e) return t.styles
          const n = t.attrs
          if (n) {
            const t = n.length
            let i = 0
            for (; i < t; ) {
              const s = n[i]
              if (bn(s)) break
              if (0 === s) i += 2
              else if ('number' == typeof s)
                for (i++; i < t && 'string' == typeof n[i]; ) i++
              else {
                if (s === e) return n[i + 1]
                i += 2
              }
            }
          }
          return null
        })(Le(), t)
      }
      const Qn = '__parameters__'
      function Zn(t, e, n) {
        return xt(() => {
          const i = (function (t) {
            return function (...e) {
              if (t) {
                const n = t(...e)
                for (const t in n) this[t] = n[t]
              }
            }
          })(e)
          function s(...t) {
            if (this instanceof s) return i.apply(this, t), this
            const e = new s(...t)
            return (n.annotation = e), n
            function n(t, n, i) {
              const s = t.hasOwnProperty(Qn)
                ? t[Qn]
                : Object.defineProperty(t, Qn, { value: [] })[Qn]
              for (; s.length <= i; ) s.push(null)
              return (s[i] = s[i] || []).push(e), t
            }
          }
          return (
            n && (s.prototype = Object.create(n.prototype)),
            (s.prototype.ngMetadataName = t),
            (s.annotationCls = s),
            s
          )
        })
      }
      class Yn {
        constructor(t, e) {
          ;(this._desc = t),
            (this.ngMetadataName = 'InjectionToken'),
            (this.ɵprov = void 0),
            'number' == typeof e
              ? (this.__NG_ELEMENT_ID__ = e)
              : void 0 !== e &&
                (this.ɵprov = ht({
                  token: this,
                  providedIn: e.providedIn || 'root',
                  factory: e.factory,
                }))
        }
        toString() {
          return 'InjectionToken ' + this._desc
        }
      }
      const Xn = new Yn('AnalyzeForEntryComponents'),
        Jn = Function
      function ti(t, e) {
        void 0 === e && (e = t)
        for (let n = 0; n < t.length; n++) {
          let i = t[n]
          Array.isArray(i)
            ? (e === t && (e = t.slice(0, n)), ti(i, e))
            : e !== t && e.push(i)
        }
        return e
      }
      function ei(t, e) {
        t.forEach((t) => (Array.isArray(t) ? ei(t, e) : e(t)))
      }
      function ni(t, e, n) {
        e >= t.length ? t.push(n) : t.splice(e, 0, n)
      }
      function ii(t, e) {
        return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0]
      }
      function si(t, e) {
        const n = []
        for (let i = 0; i < t; i++) n.push(e)
        return n
      }
      function ri(t, e, n) {
        let i = ai(t, e)
        return (
          i >= 0
            ? (t[1 | i] = n)
            : ((i = ~i),
              (function (t, e, n, i) {
                let s = t.length
                if (s == e) t.push(n, i)
                else if (1 === s) t.push(i, t[0]), (t[0] = n)
                else {
                  for (s--, t.push(t[s - 1], t[s]); s > e; )
                    (t[s] = t[s - 2]), s--
                  ;(t[e] = n), (t[e + 1] = i)
                }
              })(t, i, e, n)),
          i
        )
      }
      function oi(t, e) {
        const n = ai(t, e)
        if (n >= 0) return t[1 | n]
      }
      function ai(t, e) {
        return (function (t, e, n) {
          let i = 0,
            s = t.length >> 1
          for (; s !== i; ) {
            const n = i + ((s - i) >> 1),
              r = t[n << 1]
            if (e === r) return n << 1
            r > e ? (s = n) : (i = n + 1)
          }
          return ~(s << 1)
        })(t, e)
      }
      const li = Zn('Inject', (t) => ({ token: t })),
        ci = Zn('Optional'),
        hi = Zn('Self'),
        ui = Zn('SkipSelf'),
        di = {},
        pi = /\n/gm,
        fi = '__source',
        mi = nt({ provide: String, useValue: nt })
      let gi = void 0
      function yi(t) {
        const e = gi
        return (gi = t), e
      }
      function _i(t, e = vt.Default) {
        if (void 0 === gi)
          throw new Error('inject() must be called from an injection context')
        return null === gi
          ? Ct(t, void 0, e)
          : gi.get(t, e & vt.Optional ? null : void 0, e)
      }
      function vi(t, e = vt.Default) {
        return (bt || _i)(lt(t), e)
      }
      const bi = vi
      function wi(t) {
        const e = []
        for (let n = 0; n < t.length; n++) {
          const i = lt(t[n])
          if (Array.isArray(i)) {
            if (0 === i.length)
              throw new Error('Arguments array must have arguments.')
            let t = void 0,
              n = vt.Default
            for (let e = 0; e < i.length; e++) {
              const s = i[e]
              s instanceof ci || 'Optional' === s.ngMetadataName || s === ci
                ? (n |= vt.Optional)
                : s instanceof ui || 'SkipSelf' === s.ngMetadataName || s === ui
                ? (n |= vt.SkipSelf)
                : s instanceof hi || 'Self' === s.ngMetadataName || s === hi
                ? (n |= vt.Self)
                : (t = s instanceof li || s === li ? s.token : s)
            }
            e.push(vi(t, n))
          } else e.push(vi(i))
        }
        return e
      }
      let Ci
      function xi(t) {
        var e
        return (
          (null ===
            (e = (function () {
              if (void 0 === Ci && ((Ci = null), It.trustedTypes))
                try {
                  Ci = It.trustedTypes.createPolicy('angular', {
                    createHTML: (t) => t,
                    createScript: (t) => t,
                    createScriptURL: (t) => t,
                  })
                } catch (e) {}
              return Ci
            })()) || void 0 === e
            ? void 0
            : e.createHTML(t)) || t
        )
      }
      class Si {
        constructor(t) {
          this.changingThisBreaksApplicationSecurity = t
        }
        toString() {
          return (
            'SafeValue must use [property]=binding: ' +
            this.changingThisBreaksApplicationSecurity +
            ' (see https://g.co/ng/security#xss)'
          )
        }
      }
      class Ei extends Si {
        getTypeName() {
          return 'HTML'
        }
      }
      class ki extends Si {
        getTypeName() {
          return 'Style'
        }
      }
      class Ti extends Si {
        getTypeName() {
          return 'Script'
        }
      }
      class Ai extends Si {
        getTypeName() {
          return 'URL'
        }
      }
      class Oi extends Si {
        getTypeName() {
          return 'ResourceURL'
        }
      }
      function Ii(t) {
        return t instanceof Si ? t.changingThisBreaksApplicationSecurity : t
      }
      function Ri(t, e) {
        const n = Pi(t)
        if (null != n && n !== e) {
          if ('ResourceURL' === n && 'URL' === e) return !0
          throw new Error(
            `Required a safe ${e}, got a ${n} (see https://g.co/ng/security#xss)`
          )
        }
        return n === e
      }
      function Pi(t) {
        return (t instanceof Si && t.getTypeName()) || null
      }
      class Di {
        getInertBodyElement(t) {
          t = '<body><remove></remove>' + t
          try {
            const e = new window.DOMParser().parseFromString(xi(t), 'text/html')
              .body
            return e.removeChild(e.firstChild), e
          } catch (e) {
            return null
          }
        }
      }
      class Ni {
        constructor(t) {
          if (
            ((this.defaultDoc = t),
            (this.inertDocument = this.defaultDoc.implementation.createHTMLDocument(
              'sanitization-inert'
            )),
            null == this.inertDocument.body)
          ) {
            const t = this.inertDocument.createElement('html')
            this.inertDocument.appendChild(t)
            const e = this.inertDocument.createElement('body')
            t.appendChild(e)
          }
        }
        getInertBodyElement(t) {
          const e = this.inertDocument.createElement('template')
          if ('content' in e) return (e.innerHTML = xi(t)), e
          const n = this.inertDocument.createElement('body')
          return (
            (n.innerHTML = xi(t)),
            this.defaultDoc.documentMode && this.stripCustomNsAttrs(n),
            n
          )
        }
        stripCustomNsAttrs(t) {
          const e = t.attributes
          for (let i = e.length - 1; 0 < i; i--) {
            const n = e.item(i).name
            ;('xmlns:ns1' !== n && 0 !== n.indexOf('ns1:')) ||
              t.removeAttribute(n)
          }
          let n = t.firstChild
          for (; n; )
            n.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(n),
              (n = n.nextSibling)
        }
      }
      const Fi = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi,
        Mi = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i
      function Li(t) {
        return (t = String(t)).match(Fi) || t.match(Mi) ? t : 'unsafe:' + t
      }
      function ji(t) {
        const e = {}
        for (const n of t.split(',')) e[n] = !0
        return e
      }
      function Bi(...t) {
        const e = {}
        for (const n of t) for (const t in n) n.hasOwnProperty(t) && (e[t] = !0)
        return e
      }
      const Vi = ji('area,br,col,hr,img,wbr'),
        Ui = ji('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr'),
        zi = ji('rp,rt'),
        Hi = Bi(zi, Ui),
        qi = Bi(
          Vi,
          Bi(
            Ui,
            ji(
              'address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'
            )
          ),
          Bi(
            zi,
            ji(
              'a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'
            )
          ),
          Hi
        ),
        $i = ji('background,cite,href,itemtype,longdesc,poster,src,xlink:href'),
        Wi = ji('srcset'),
        Ki = Bi(
          $i,
          Wi,
          ji(
            'abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width'
          ),
          ji(
            'aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext'
          )
        ),
        Gi = ji('script,style,template')
      class Qi {
        constructor() {
          ;(this.sanitizedSomething = !1), (this.buf = [])
        }
        sanitizeChildren(t) {
          let e = t.firstChild,
            n = !0
          for (; e; )
            if (
              (e.nodeType === Node.ELEMENT_NODE
                ? (n = this.startElement(e))
                : e.nodeType === Node.TEXT_NODE
                ? this.chars(e.nodeValue)
                : (this.sanitizedSomething = !0),
              n && e.firstChild)
            )
              e = e.firstChild
            else
              for (; e; ) {
                e.nodeType === Node.ELEMENT_NODE && this.endElement(e)
                let t = this.checkClobberedElement(e, e.nextSibling)
                if (t) {
                  e = t
                  break
                }
                e = this.checkClobberedElement(e, e.parentNode)
              }
          return this.buf.join('')
        }
        startElement(t) {
          const e = t.nodeName.toLowerCase()
          if (!qi.hasOwnProperty(e))
            return (this.sanitizedSomething = !0), !Gi.hasOwnProperty(e)
          this.buf.push('<'), this.buf.push(e)
          const n = t.attributes
          for (let s = 0; s < n.length; s++) {
            const t = n.item(s),
              e = t.name,
              r = e.toLowerCase()
            if (!Ki.hasOwnProperty(r)) {
              this.sanitizedSomething = !0
              continue
            }
            let o = t.value
            $i[r] && (o = Li(o)),
              Wi[r] &&
                ((i = o),
                (o = (i = String(i))
                  .split(',')
                  .map((t) => Li(t.trim()))
                  .join(', '))),
              this.buf.push(' ', e, '="', Xi(o), '"')
          }
          var i
          return this.buf.push('>'), !0
        }
        endElement(t) {
          const e = t.nodeName.toLowerCase()
          qi.hasOwnProperty(e) &&
            !Vi.hasOwnProperty(e) &&
            (this.buf.push('</'), this.buf.push(e), this.buf.push('>'))
        }
        chars(t) {
          this.buf.push(Xi(t))
        }
        checkClobberedElement(t, e) {
          if (
            e &&
            (t.compareDocumentPosition(e) &
              Node.DOCUMENT_POSITION_CONTAINED_BY) ===
              Node.DOCUMENT_POSITION_CONTAINED_BY
          )
            throw new Error(
              'Failed to sanitize html because the element is clobbered: ' +
                t.outerHTML
            )
          return e
        }
      }
      const Zi = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
        Yi = /([^\#-~ |!])/g
      function Xi(t) {
        return t
          .replace(/&/g, '&amp;')
          .replace(Zi, function (t) {
            return (
              '&#' +
              (1024 * (t.charCodeAt(0) - 55296) +
                (t.charCodeAt(1) - 56320) +
                65536) +
              ';'
            )
          })
          .replace(Yi, function (t) {
            return '&#' + t.charCodeAt(0) + ';'
          })
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
      }
      let Ji
      function ts(t) {
        return 'content' in t &&
          (function (t) {
            return t.nodeType === Node.ELEMENT_NODE && 'TEMPLATE' === t.nodeName
          })(t)
          ? t.content
          : null
      }
      var es = (function (t) {
        return (
          (t[(t.NONE = 0)] = 'NONE'),
          (t[(t.HTML = 1)] = 'HTML'),
          (t[(t.STYLE = 2)] = 'STYLE'),
          (t[(t.SCRIPT = 3)] = 'SCRIPT'),
          (t[(t.URL = 4)] = 'URL'),
          (t[(t.RESOURCE_URL = 5)] = 'RESOURCE_URL'),
          t
        )
      })({})
      function ns(t) {
        const e = (function () {
          const t = Ne()
          return t && t[12]
        })()
        return e
          ? e.sanitize(es.URL, t) || ''
          : Ri(t, 'URL')
          ? Ii(t)
          : Li(ae(t))
      }
      function is(t) {
        return t.ngDebugContext
      }
      function ss(t) {
        return t.ngOriginalError
      }
      function rs(t, ...e) {
        t.error(...e)
      }
      class os {
        constructor() {
          this._console = console
        }
        handleError(t) {
          const e = this._findOriginalError(t),
            n = this._findContext(t),
            i = (function (t) {
              return t.ngErrorLogger || rs
            })(t)
          i(this._console, 'ERROR', t),
            e && i(this._console, 'ORIGINAL ERROR', e),
            n && i(this._console, 'ERROR CONTEXT', n)
        }
        _findContext(t) {
          return t ? (is(t) ? is(t) : this._findContext(ss(t))) : null
        }
        _findOriginalError(t) {
          let e = ss(t)
          for (; e && ss(e); ) e = ss(e)
          return e
        }
      }
      function as(t, e) {
        t.__ngContext__ = e
      }
      const ls = (() =>
        (
          ('undefined' != typeof requestAnimationFrame &&
            requestAnimationFrame) ||
          setTimeout
        ).bind(It))()
      function cs(t) {
        return { name: 'window', target: t.ownerDocument.defaultView }
      }
      function hs(t) {
        return { name: 'body', target: t.ownerDocument.body }
      }
      function us(t) {
        return t instanceof Function ? t() : t
      }
      var ds = (function (t) {
        return (
          (t[(t.Important = 1)] = 'Important'),
          (t[(t.DashCase = 2)] = 'DashCase'),
          t
        )
      })({})
      function ps(t, e) {
        return (void 0)(t, e)
      }
      function fs(t) {
        const e = t[3]
        return te(e) ? e[3] : e
      }
      function ms(t) {
        return ys(t[13])
      }
      function gs(t) {
        return ys(t[4])
      }
      function ys(t) {
        for (; null !== t && !te(t); ) t = t[4]
        return t
      }
      function _s(t, e, n, i, s) {
        if (null != i) {
          let r,
            o = !1
          te(i) ? (r = i) : Jt(i) && ((o = !0), (i = i[0]))
          const a = be(i)
          0 === t && null !== n
            ? null == s
              ? ks(e, n, a)
              : Es(e, n, a, s || null, !0)
            : 1 === t && null !== n
            ? Es(e, n, a, s || null, !0)
            : 2 === t
            ? (function (t, e, n) {
                const i = As(t, e)
                i &&
                  (function (t, e, n, i) {
                    _e(t) ? t.removeChild(e, n, i) : e.removeChild(n)
                  })(t, i, e, n)
              })(e, a, o)
            : 3 === t && e.destroyNode(a),
            null != r &&
              (function (t, e, n, i, s) {
                const r = n[7]
                r !== be(n) && _s(e, t, i, r, s)
                for (let o = Xt; o < n.length; o++) {
                  const s = n[o]
                  Fs(s[1], s, t, e, i, r)
                }
              })(e, t, r, n, s)
        }
      }
      function vs(t, e, n) {
        return _e(t)
          ? t.createElement(e, n)
          : null === n
          ? t.createElement(e)
          : t.createElementNS(n, e)
      }
      function bs(t, e) {
        const n = t[9],
          i = n.indexOf(e),
          s = e[3]
        1024 & e[2] && ((e[2] &= -1025), Re(s, -1)), n.splice(i, 1)
      }
      function ws(t, e) {
        if (t.length <= Xt) return
        const n = Xt + e,
          i = t[n]
        if (i) {
          const r = i[17]
          null !== r && r !== t && bs(r, i), e > 0 && (t[n - 1][4] = i[4])
          const o = ii(t, Xt + e)
          Fs(i[1], (s = i), s[11], 2, null, null), (s[0] = null), (s[6] = null)
          const a = o[19]
          null !== a && a.detachView(o[1]),
            (i[3] = null),
            (i[4] = null),
            (i[2] &= -129)
        }
        var s
        return i
      }
      function Cs(t, e) {
        if (!(256 & e[2])) {
          const n = e[11]
          _e(n) && n.destroyNode && Fs(t, e, n, 3, null, null),
            (function (t) {
              let e = t[13]
              if (!e) return xs(t[1], t)
              for (; e; ) {
                let n = null
                if (Jt(e)) n = e[13]
                else {
                  const t = e[10]
                  t && (n = t)
                }
                if (!n) {
                  for (; e && !e[4] && e !== t; )
                    Jt(e) && xs(e[1], e), (e = e[3])
                  null === e && (e = t), Jt(e) && xs(e[1], e), (n = e && e[4])
                }
                e = n
              }
            })(e)
        }
      }
      function xs(t, e) {
        if (!(256 & e[2])) {
          ;(e[2] &= -129),
            (e[2] |= 256),
            (function (t, e) {
              let n
              if (null != t && null != (n = t.destroyHooks))
                for (let i = 0; i < n.length; i += 2) {
                  const t = e[n[i]]
                  if (!(t instanceof _n)) {
                    const e = n[i + 1]
                    if (Array.isArray(e))
                      for (let n = 0; n < e.length; n += 2)
                        e[n + 1].call(t[e[n]])
                    else e.call(t)
                  }
                }
            })(t, e),
            (function (t, e) {
              const n = t.cleanup,
                i = e[7]
              let s = -1
              if (null !== n) {
                for (let t = 0; t < n.length - 1; t += 2)
                  if ('string' == typeof n[t]) {
                    const r = n[t + 1],
                      o = 'function' == typeof r ? r(e) : be(e[r]),
                      a = i[(s = n[t + 2])],
                      l = n[t + 3]
                    'boolean' == typeof l
                      ? o.removeEventListener(n[t], a, l)
                      : l >= 0
                      ? i[(s = l)]()
                      : i[(s = -l)].unsubscribe(),
                      (t += 2)
                  } else {
                    const e = i[(s = n[t + 1])]
                    n[t].call(e)
                  }
                if (null !== i)
                  for (let t = s + 1; t < i.length; t++) (0, i[t])()
                e[7] = null
              }
            })(t, e),
            1 === e[1].type && _e(e[11]) && e[11].destroy()
          const n = e[17]
          if (null !== n && te(e[3])) {
            n !== e[3] && bs(n, e)
            const i = e[19]
            null !== i && i.detachView(t)
          }
        }
      }
      function Ss(t, e, n) {
        return (function (t, e, n) {
          let i = e
          for (; null !== i && 40 & i.type; ) i = (e = i).parent
          if (null === i) return n[0]
          if (2 & i.flags) {
            const e = t.data[i.directiveStart].encapsulation
            if (e === Et.None || e === Et.Emulated) return null
          }
          return Ce(i, n)
        })(t, e.parent, n)
      }
      function Es(t, e, n, i, s) {
        _e(t) ? t.insertBefore(e, n, i, s) : e.insertBefore(n, i, s)
      }
      function ks(t, e, n) {
        _e(t) ? t.appendChild(e, n) : e.appendChild(n)
      }
      function Ts(t, e, n, i, s) {
        null !== i ? Es(t, e, n, i, s) : ks(t, e, n)
      }
      function As(t, e) {
        return _e(t) ? t.parentNode(e) : e.parentNode
      }
      function Os(t, e, n) {
        return Is(t, e, n)
      }
      let Is = function (t, e, n) {
        return 40 & t.type ? Ce(t, n) : null
      }
      function Rs(t, e, n, i) {
        const s = Ss(t, i, e),
          r = e[11],
          o = Os(i.parent || e[6], i, e)
        if (null != s)
          if (Array.isArray(n))
            for (let a = 0; a < n.length; a++) Ts(r, s, n[a], o, !1)
          else Ts(r, s, n, o, !1)
      }
      function Ps(t, e) {
        if (null !== e) {
          const n = e.type
          if (3 & n) return Ce(e, t)
          if (4 & n) return Ds(-1, t[e.index])
          if (8 & n) {
            const n = e.child
            if (null !== n) return Ps(t, n)
            {
              const n = t[e.index]
              return te(n) ? Ds(-1, n) : be(n)
            }
          }
          if (32 & n) return ps(e, t)() || be(t[e.index])
          {
            const n = t[16],
              i = n[6],
              s = fs(n),
              r = i.projection[e.projection]
            return null != r ? Ps(s, r) : Ps(t, e.next)
          }
        }
        return null
      }
      function Ds(t, e) {
        const n = Xt + t + 1
        if (n < e.length) {
          const t = e[n],
            i = t[1].firstChild
          if (null !== i) return Ps(t, i)
        }
        return e[7]
      }
      function Ns(t, e, n, i, s, r, o) {
        for (; null != n; ) {
          const a = i[n.index],
            l = n.type
          if (
            (o && 0 === e && (a && as(be(a), i), (n.flags |= 4)),
            64 != (64 & n.flags))
          )
            if (8 & l) Ns(t, e, n.child, i, s, r, !1), _s(e, t, s, a, r)
            else if (32 & l) {
              const o = ps(n, i)
              let l
              for (; (l = o()); ) _s(e, t, s, l, r)
              _s(e, t, s, a, r)
            } else 16 & l ? Ms(t, e, i, n, s, r) : _s(e, t, s, a, r)
          n = o ? n.projectionNext : n.next
        }
      }
      function Fs(t, e, n, i, s, r) {
        Ns(n, i, t.firstChild, e, s, r, !1)
      }
      function Ms(t, e, n, i, s, r) {
        const o = n[16],
          a = o[6].projection[i.projection]
        if (Array.isArray(a))
          for (let l = 0; l < a.length; l++) _s(e, t, s, a[l], r)
        else Ns(t, e, a, o[3], s, r, !0)
      }
      function Ls(t, e, n) {
        _e(t) ? t.setAttribute(e, 'style', n) : (e.style.cssText = n)
      }
      function js(t, e, n) {
        _e(t)
          ? '' === n
            ? t.removeAttribute(e, 'class')
            : t.setAttribute(e, 'class', n)
          : (e.className = n)
      }
      function Bs(t, e, n) {
        let i = t.length
        for (;;) {
          const s = t.indexOf(e, n)
          if (-1 === s) return s
          if (0 === s || t.charCodeAt(s - 1) <= 32) {
            const n = e.length
            if (s + n === i || t.charCodeAt(s + n) <= 32) return s
          }
          n = s + 1
        }
      }
      const Vs = 'ng-template'
      function Us(t, e, n) {
        let i = 0
        for (; i < t.length; ) {
          let s = t[i++]
          if (n && 'class' === s) {
            if (((s = t[i]), -1 !== Bs(s.toLowerCase(), e, 0))) return !0
          } else if (1 === s) {
            for (; i < t.length && 'string' == typeof (s = t[i++]); )
              if (s.toLowerCase() === e) return !0
            return !1
          }
        }
        return !1
      }
      function zs(t) {
        return 4 === t.type && t.value !== Vs
      }
      function Hs(t, e, n) {
        return e === (4 !== t.type || n ? t.value : Vs)
      }
      function qs(t, e, n) {
        let i = 4
        const s = t.attrs || [],
          r = (function (t) {
            for (let e = 0; e < t.length; e++) if (bn(t[e])) return e
            return t.length
          })(s)
        let o = !1
        for (let a = 0; a < e.length; a++) {
          const l = e[a]
          if ('number' != typeof l) {
            if (!o)
              if (4 & i) {
                if (
                  ((i = 2 | (1 & i)),
                  ('' !== l && !Hs(t, l, n)) || ('' === l && 1 === e.length))
                ) {
                  if ($s(i)) return !1
                  o = !0
                }
              } else {
                const c = 8 & i ? l : e[++a]
                if (8 & i && null !== t.attrs) {
                  if (!Us(t.attrs, c, n)) {
                    if ($s(i)) return !1
                    o = !0
                  }
                  continue
                }
                const h = Ws(8 & i ? 'class' : l, s, zs(t), n)
                if (-1 === h) {
                  if ($s(i)) return !1
                  o = !0
                  continue
                }
                if ('' !== c) {
                  let t
                  t = h > r ? '' : s[h + 1].toLowerCase()
                  const e = 8 & i ? t : null
                  if ((e && -1 !== Bs(e, c, 0)) || (2 & i && c !== t)) {
                    if ($s(i)) return !1
                    o = !0
                  }
                }
              }
          } else {
            if (!o && !$s(i) && !$s(l)) return !1
            if (o && $s(l)) continue
            ;(o = !1), (i = l | (1 & i))
          }
        }
        return $s(i) || o
      }
      function $s(t) {
        return 0 == (1 & t)
      }
      function Ws(t, e, n, i) {
        if (null === e) return -1
        let s = 0
        if (i || !n) {
          let n = !1
          for (; s < e.length; ) {
            const i = e[s]
            if (i === t) return s
            if (3 === i || 6 === i) n = !0
            else {
              if (1 === i || 2 === i) {
                let t = e[++s]
                for (; 'string' == typeof t; ) t = e[++s]
                continue
              }
              if (4 === i) break
              if (0 === i) {
                s += 4
                continue
              }
            }
            s += n ? 1 : 2
          }
          return -1
        }
        return (function (t, e) {
          let n = t.indexOf(4)
          if (n > -1)
            for (n++; n < t.length; ) {
              const i = t[n]
              if ('number' == typeof i) return -1
              if (i === e) return n
              n++
            }
          return -1
        })(e, t)
      }
      function Ks(t, e, n = !1) {
        for (let i = 0; i < e.length; i++) if (qs(t, e[i], n)) return !0
        return !1
      }
      function Gs(t, e) {
        t: for (let n = 0; n < e.length; n++) {
          const i = e[n]
          if (t.length === i.length) {
            for (let e = 0; e < t.length; e++) if (t[e] !== i[e]) continue t
            return !0
          }
        }
        return !1
      }
      function Qs(t, e) {
        return t ? ':not(' + e.trim() + ')' : e
      }
      function Zs(t) {
        let e = t[0],
          n = 1,
          i = 2,
          s = '',
          r = !1
        for (; n < t.length; ) {
          let o = t[n]
          if ('string' == typeof o)
            if (2 & i) {
              const e = t[++n]
              s += '[' + o + (e.length > 0 ? '="' + e + '"' : '') + ']'
            } else 8 & i ? (s += '.' + o) : 4 & i && (s += ' ' + o)
          else
            '' === s || $s(o) || ((e += Qs(r, s)), (s = '')),
              (i = o),
              (r = r || !$s(i))
          n++
        }
        return '' !== s && (e += Qs(r, s)), e
      }
      const Ys = {}
      function Xs(t) {
        Js(Fe(), Ne(), an() + t, ze())
      }
      function Js(t, e, n, i) {
        if (!i)
          if (3 == (3 & e[2])) {
            const i = t.preOrderCheckHooks
            null !== i && dn(e, i, n)
          } else {
            const i = t.preOrderHooks
            null !== i && pn(e, i, 0, n)
          }
        ln(n)
      }
      function tr(t, e) {
        return (t << 17) | (e << 2)
      }
      function er(t) {
        return (t >> 17) & 32767
      }
      function nr(t) {
        return 2 | t
      }
      function ir(t) {
        return (131068 & t) >> 2
      }
      function sr(t, e) {
        return (-131069 & t) | (e << 2)
      }
      function rr(t) {
        return 1 | t
      }
      function or(t, e) {
        const n = t.contentQueries
        if (null !== n)
          for (let i = 0; i < n.length; i += 2) {
            const s = n[i],
              r = n[i + 1]
            if (-1 !== r) {
              const n = t.data[r]
              Ye(s), n.contentQueries(2, e[r], r)
            }
          }
      }
      function ar(t, e, n, i, s, r, o, a, l, c) {
        const h = e.blueprint.slice()
        return (
          (h[0] = s),
          (h[2] = 140 | i),
          Ie(h),
          (h[3] = h[15] = t),
          (h[8] = n),
          (h[10] = o || (t && t[10])),
          (h[11] = a || (t && t[11])),
          (h[12] = l || (t && t[12]) || null),
          (h[9] = c || (t && t[9]) || null),
          (h[6] = r),
          (h[16] = 2 == e.type ? t[16] : h),
          h
        )
      }
      function lr(t, e, n, i, s) {
        let r = t.data[e]
        if (null === r)
          (r = (function (t, e, n, i, s) {
            const r = je(),
              o = Ve(),
              a = (t.data[e] = (function (t, e, n, i, s, r) {
                return {
                  type: n,
                  index: i,
                  insertBeforeIndex: null,
                  injectorIndex: e ? e.injectorIndex : -1,
                  directiveStart: -1,
                  directiveEnd: -1,
                  directiveStylingLast: -1,
                  propertyBindings: null,
                  flags: 0,
                  providerIndexes: 0,
                  value: s,
                  attrs: r,
                  mergedAttrs: null,
                  localNames: null,
                  initialInputs: void 0,
                  inputs: null,
                  outputs: null,
                  tViews: null,
                  next: null,
                  projectionNext: null,
                  child: null,
                  parent: e,
                  projection: null,
                  styles: null,
                  stylesWithoutHost: null,
                  residualStyles: void 0,
                  classes: null,
                  classesWithoutHost: null,
                  residualClasses: void 0,
                  classBindings: 0,
                  styleBindings: 0,
                }
              })(0, o ? r : r && r.parent, n, e, i, s))
            return (
              null === t.firstChild && (t.firstChild = a),
              null !== r &&
                (o
                  ? null == r.child && null !== a.parent && (r.child = a)
                  : null === r.next && (r.next = a)),
              a
            )
          })(t, e, n, i, s)),
            Pe.lFrame.inI18n && (r.flags |= 64)
        else if (64 & r.type) {
          ;(r.type = n), (r.value = i), (r.attrs = s)
          const t = (function () {
            const t = Pe.lFrame,
              e = t.currentTNode
            return t.isParent ? e : e.parent
          })()
          r.injectorIndex = null === t ? -1 : t.injectorIndex
        }
        return Be(r, !0), r
      }
      function cr(t, e, n, i) {
        if (0 === n) return -1
        const s = e.length
        for (let r = 0; r < n; r++)
          e.push(i), t.blueprint.push(i), t.data.push(null)
        return s
      }
      function hr(t, e, n) {
        tn(e)
        try {
          const i = t.viewQuery
          null !== i && Vr(1, i, n)
          const s = t.template
          null !== s && pr(t, e, s, 1, n),
            t.firstCreatePass && (t.firstCreatePass = !1),
            t.staticContentQueries && or(t, e),
            t.staticViewQueries && Vr(2, t.viewQuery, n)
          const r = t.components
          null !== r &&
            (function (t, e) {
              for (let n = 0; n < e.length; n++) Fr(t, e[n])
            })(e, r)
        } catch (i) {
          throw (t.firstCreatePass && (t.incompleteFirstPass = !0), i)
        } finally {
          ;(e[2] &= -5), on()
        }
      }
      function ur(t, e, n, i) {
        const s = e[2]
        if (256 == (256 & s)) return
        tn(e)
        const r = ze()
        try {
          Ie(e),
            (Pe.lFrame.bindingIndex = t.bindingStartIndex),
            null !== n && pr(t, e, n, 2, i)
          const o = 3 == (3 & s)
          if (!r)
            if (o) {
              const n = t.preOrderCheckHooks
              null !== n && dn(e, n, null)
            } else {
              const n = t.preOrderHooks
              null !== n && pn(e, n, 0, null), fn(e, 0)
            }
          if (
            ((function (t) {
              for (let e = ms(t); null !== e; e = gs(e)) {
                if (!e[2]) continue
                const t = e[9]
                for (let e = 0; e < t.length; e++) {
                  const n = t[e],
                    i = n[3]
                  0 == (1024 & n[2]) && Re(i, 1), (n[2] |= 1024)
                }
              }
            })(e),
            (function (t) {
              for (let e = ms(t); null !== e; e = gs(e))
                for (let t = Xt; t < e.length; t++) {
                  const n = e[t],
                    i = n[1]
                  Ae(n) && ur(i, n, i.template, n[8])
                }
            })(e),
            null !== t.contentQueries && or(t, e),
            !r)
          )
            if (o) {
              const n = t.contentCheckHooks
              null !== n && dn(e, n)
            } else {
              const n = t.contentHooks
              null !== n && pn(e, n, 1), fn(e, 1)
            }
          !(function (t, e) {
            const n = t.hostBindingOpCodes
            if (null !== n)
              try {
                for (let t = 0; t < n.length; t++) {
                  const i = n[t]
                  if (i < 0) ln(~i)
                  else {
                    const s = i,
                      r = n[++t],
                      o = n[++t]
                    Ke(r, s), o(2, e[s])
                  }
                }
              } finally {
                ln(-1)
              }
          })(t, e)
          const a = t.components
          null !== a &&
            (function (t, e) {
              for (let n = 0; n < e.length; n++) Dr(t, e[n])
            })(e, a)
          const l = t.viewQuery
          if ((null !== l && Vr(2, l, i), !r))
            if (o) {
              const n = t.viewCheckHooks
              null !== n && dn(e, n)
            } else {
              const n = t.viewHooks
              null !== n && pn(e, n, 2), fn(e, 2)
            }
          !0 === t.firstUpdatePass && (t.firstUpdatePass = !1),
            r || (e[2] &= -73),
            1024 & e[2] && ((e[2] &= -1025), Re(e[3], -1))
        } finally {
          on()
        }
      }
      function dr(t, e, n, i) {
        const s = e[10],
          r = !ze(),
          o = Te(e)
        try {
          r && !o && s.begin && s.begin(), o && hr(t, e, i), ur(t, e, n, i)
        } finally {
          r && !o && s.end && s.end()
        }
      }
      function pr(t, e, n, i, s) {
        const r = an()
        try {
          ln(-1), 2 & i && e.length > Yt && Js(t, e, Yt, ze()), n(i, s)
        } finally {
          ln(r)
        }
      }
      function fr(t, e, n) {
        if (ee(e)) {
          const i = e.directiveEnd
          for (let s = e.directiveStart; s < i; s++) {
            const e = t.data[s]
            e.contentQueries && e.contentQueries(1, n[s], s)
          }
        }
      }
      function mr(t, e, n) {
        De() &&
          ((function (t, e, n, i) {
            const s = n.directiveStart,
              r = n.directiveEnd
            t.firstCreatePass || In(n, e), as(i, e)
            const o = n.initialInputs
            for (let a = s; a < r; a++) {
              const i = t.data[a],
                r = se(i)
              r && Or(e, n, i)
              const l = zn(e, t, a, n)
              as(l, e),
                null !== o && Ir(0, a - s, l, i, 0, o),
                r && (Ee(n.index, e)[8] = l)
            }
          })(t, e, n, Ce(n, e)),
          128 == (128 & n.flags) &&
            (function (t, e, n) {
              const i = n.directiveStart,
                s = n.directiveEnd,
                r = n.index,
                o = Pe.lFrame.currentDirectiveIndex
              try {
                ln(r)
                for (let n = i; n < s; n++) {
                  const i = t.data[n],
                    s = e[n]
                  Ge(n),
                    (null === i.hostBindings &&
                      0 === i.hostVars &&
                      null === i.hostAttrs) ||
                      Sr(i, s)
                }
              } finally {
                ln(-1), Ge(o)
              }
            })(t, e, n))
      }
      function gr(t, e, n = Ce) {
        const i = e.localNames
        if (null !== i) {
          let s = e.index + 1
          for (let r = 0; r < i.length; r += 2) {
            const o = i[r + 1],
              a = -1 === o ? n(e, t) : t[o]
            t[s++] = a
          }
        }
      }
      function yr(t) {
        const e = t.tView
        return null === e || e.incompleteFirstPass
          ? (t.tView = _r(
              1,
              null,
              t.template,
              t.decls,
              t.vars,
              t.directiveDefs,
              t.pipeDefs,
              t.viewQuery,
              t.schemas,
              t.consts
            ))
          : e
      }
      function _r(t, e, n, i, s, r, o, a, l, c) {
        const h = Yt + i,
          u = h + s,
          d = (function (t, e) {
            const n = []
            for (let i = 0; i < e; i++) n.push(i < t ? null : Ys)
            return n
          })(h, u),
          p = 'function' == typeof c ? c() : c
        return (d[1] = {
          type: t,
          blueprint: d,
          template: n,
          queries: null,
          viewQuery: a,
          declTNode: e,
          data: d.slice().fill(null, h),
          bindingStartIndex: h,
          expandoStartIndex: u,
          hostBindingOpCodes: null,
          firstCreatePass: !0,
          firstUpdatePass: !0,
          staticViewQueries: !1,
          staticContentQueries: !1,
          preOrderHooks: null,
          preOrderCheckHooks: null,
          contentHooks: null,
          contentCheckHooks: null,
          viewHooks: null,
          viewCheckHooks: null,
          destroyHooks: null,
          cleanup: null,
          contentQueries: null,
          components: null,
          directiveRegistry: 'function' == typeof r ? r() : r,
          pipeRegistry: 'function' == typeof o ? o() : o,
          firstChild: null,
          schemas: l,
          consts: p,
          incompleteFirstPass: !1,
        })
      }
      function vr(t, e, n, i) {
        const s = zr(e)
        null === n
          ? s.push(i)
          : (s.push(n), t.firstCreatePass && Hr(t).push(i, s.length - 1))
      }
      function br(t, e, n) {
        for (let i in t)
          if (t.hasOwnProperty(i)) {
            const s = t[i]
            ;(n = null === n ? {} : n).hasOwnProperty(i)
              ? n[i].push(e, s)
              : (n[i] = [e, s])
          }
        return n
      }
      function wr(t, e, n, i, s, r, o, a) {
        const l = Ce(e, n)
        let c,
          h = e.inputs
        var u
        !a && null != h && (c = h[i])
          ? (Wr(t, n, c, i, s),
            ne(e) &&
              (function (t, e) {
                const n = Ee(e, t)
                16 & n[2] || (n[2] |= 64)
              })(n, e.index))
          : 3 & e.type &&
            ((i =
              'class' === (u = i)
                ? 'className'
                : 'for' === u
                ? 'htmlFor'
                : 'formaction' === u
                ? 'formAction'
                : 'innerHtml' === u
                ? 'innerHTML'
                : 'readonly' === u
                ? 'readOnly'
                : 'tabindex' === u
                ? 'tabIndex'
                : u),
            (s = null != o ? o(s, e.value || '', i) : s),
            _e(r)
              ? r.setProperty(l, i, s)
              : wn(i) || (l.setProperty ? l.setProperty(i, s) : (l[i] = s)))
      }
      function Cr(t, e, n, i) {
        let s = !1
        if (De()) {
          const r = (function (t, e, n) {
              const i = t.directiveRegistry
              let s = null
              if (i)
                for (let r = 0; r < i.length; r++) {
                  const o = i[r]
                  Ks(n, o.selectors, !1) &&
                    (s || (s = []),
                    Nn(In(n, e), t, o.type),
                    se(o) ? (Er(t, n), s.unshift(o)) : s.push(o))
                }
              return s
            })(t, e, n),
            o = null === i ? null : { '': -1 }
          if (null !== r) {
            ;(s = !0), Tr(n, t.data.length, r.length)
            for (let t = 0; t < r.length; t++) {
              const e = r[t]
              e.providersResolver && e.providersResolver(e)
            }
            let i = !1,
              a = !1,
              l = cr(t, e, r.length, null)
            for (let s = 0; s < r.length; s++) {
              const c = r[s]
              ;(n.mergedAttrs = Cn(n.mergedAttrs, c.hostAttrs)),
                Ar(t, n, e, l, c),
                kr(l, c, o),
                null !== c.contentQueries && (n.flags |= 8),
                (null === c.hostBindings &&
                  null === c.hostAttrs &&
                  0 === c.hostVars) ||
                  (n.flags |= 128)
              const h = c.type.prototype
              !i &&
                (h.ngOnChanges || h.ngOnInit || h.ngDoCheck) &&
                ((t.preOrderHooks || (t.preOrderHooks = [])).push(n.index),
                (i = !0)),
                a ||
                  (!h.ngOnChanges && !h.ngDoCheck) ||
                  ((t.preOrderCheckHooks || (t.preOrderCheckHooks = [])).push(
                    n.index
                  ),
                  (a = !0)),
                l++
            }
            !(function (t, e) {
              const n = e.directiveEnd,
                i = t.data,
                s = e.attrs,
                r = []
              let o = null,
                a = null
              for (let l = e.directiveStart; l < n; l++) {
                const t = i[l],
                  n = t.inputs,
                  c = null === s || zs(e) ? null : Rr(n, s)
                r.push(c), (o = br(n, l, o)), (a = br(t.outputs, l, a))
              }
              null !== o &&
                (o.hasOwnProperty('class') && (e.flags |= 16),
                o.hasOwnProperty('style') && (e.flags |= 32)),
                (e.initialInputs = r),
                (e.inputs = o),
                (e.outputs = a)
            })(t, n)
          }
          o &&
            (function (t, e, n) {
              if (e) {
                const i = (t.localNames = [])
                for (let t = 0; t < e.length; t += 2) {
                  const s = n[e[t + 1]]
                  if (null == s)
                    throw new oe(
                      '301',
                      `Export of name '${e[t + 1]}' not found!`
                    )
                  i.push(e[t], s)
                }
              }
            })(n, i, o)
        }
        return (n.mergedAttrs = Cn(n.mergedAttrs, n.attrs)), s
      }
      function xr(t, e, n, i, s, r) {
        const o = r.hostBindings
        if (o) {
          let n = t.hostBindingOpCodes
          null === n && (n = t.hostBindingOpCodes = [])
          const r = ~e.index
          ;(function (t) {
            let e = t.length
            for (; e > 0; ) {
              const n = t[--e]
              if ('number' == typeof n && n < 0) return n
            }
            return 0
          })(n) != r && n.push(r),
            n.push(i, s, o)
        }
      }
      function Sr(t, e) {
        null !== t.hostBindings && t.hostBindings(1, e)
      }
      function Er(t, e) {
        ;(e.flags |= 2), (t.components || (t.components = [])).push(e.index)
      }
      function kr(t, e, n) {
        if (n) {
          if (e.exportAs)
            for (let i = 0; i < e.exportAs.length; i++) n[e.exportAs[i]] = t
          se(e) && (n[''] = t)
        }
      }
      function Tr(t, e, n) {
        ;(t.flags |= 1),
          (t.directiveStart = e),
          (t.directiveEnd = e + n),
          (t.providerIndexes = e)
      }
      function Ar(t, e, n, i, s) {
        t.data[i] = s
        const r = s.factory || (s.factory = re(s.type)),
          o = new _n(r, se(s), null)
        ;(t.blueprint[i] = o),
          (n[i] = o),
          xr(t, e, 0, i, cr(t, n, s.hostVars, Ys), s)
      }
      function Or(t, e, n) {
        const i = Ce(e, t),
          s = yr(n),
          r = t[10],
          o = Mr(
            t,
            ar(
              t,
              s,
              null,
              n.onPush ? 64 : 16,
              i,
              e,
              r,
              r.createRenderer(i, n),
              null,
              null
            )
          )
        t[e.index] = o
      }
      function Ir(t, e, n, i, s, r) {
        const o = r[e]
        if (null !== o) {
          const t = i.setInput
          for (let e = 0; e < o.length; ) {
            const s = o[e++],
              r = o[e++],
              a = o[e++]
            null !== t ? i.setInput(n, a, s, r) : (n[r] = a)
          }
        }
      }
      function Rr(t, e) {
        let n = null,
          i = 0
        for (; i < e.length; ) {
          const s = e[i]
          if (0 !== s)
            if (5 !== s) {
              if ('number' == typeof s) break
              t.hasOwnProperty(s) &&
                (null === n && (n = []), n.push(s, t[s], e[i + 1])),
                (i += 2)
            } else i += 2
          else i += 4
        }
        return n
      }
      function Pr(t, e, n, i) {
        return new Array(t, !0, !1, e, null, 0, i, n, null, null)
      }
      function Dr(t, e) {
        const n = Ee(e, t)
        if (Ae(n)) {
          const t = n[1]
          80 & n[2] ? ur(t, n, t.template, n[8]) : n[5] > 0 && Nr(n)
        }
      }
      function Nr(t) {
        for (let n = ms(t); null !== n; n = gs(n))
          for (let t = Xt; t < n.length; t++) {
            const e = n[t]
            if (1024 & e[2]) {
              const t = e[1]
              ur(t, e, t.template, e[8])
            } else e[5] > 0 && Nr(e)
          }
        const e = t[1].components
        if (null !== e)
          for (let n = 0; n < e.length; n++) {
            const i = Ee(e[n], t)
            Ae(i) && i[5] > 0 && Nr(i)
          }
      }
      function Fr(t, e) {
        const n = Ee(e, t),
          i = n[1]
        !(function (t, e) {
          for (let n = e.length; n < t.blueprint.length; n++)
            e.push(t.blueprint[n])
        })(i, n),
          hr(i, n, n[8])
      }
      function Mr(t, e) {
        return t[13] ? (t[14][4] = e) : (t[13] = e), (t[14] = e), e
      }
      function Lr(t) {
        for (; t; ) {
          t[2] |= 64
          const e = fs(t)
          if (0 != (512 & t[2]) && !e) return t
          t = e
        }
        return null
      }
      function jr(t, e, n) {
        const i = e[10]
        i.begin && i.begin()
        try {
          ur(t, e, t.template, n)
        } catch (s) {
          throw ($r(e, s), s)
        } finally {
          i.end && i.end()
        }
      }
      function Br(t) {
        !(function (t) {
          for (let e = 0; e < t.components.length; e++) {
            const n = t.components[e],
              i = ke(n),
              s = i[1]
            dr(s, i, s.template, n)
          }
        })(t[8])
      }
      function Vr(t, e, n) {
        Ye(0), e(t, n)
      }
      const Ur = (() => Promise.resolve(null))()
      function zr(t) {
        return t[7] || (t[7] = [])
      }
      function Hr(t) {
        return t.cleanup || (t.cleanup = [])
      }
      function qr(t, e, n) {
        return (
          (null === t || se(t)) &&
            (n = (function (t) {
              for (; Array.isArray(t); ) {
                if ('object' == typeof t[1]) return t
                t = t[0]
              }
              return null
            })(n[e.index])),
          n[11]
        )
      }
      function $r(t, e) {
        const n = t[9],
          i = n ? n.get(os, null) : null
        i && i.handleError(e)
      }
      function Wr(t, e, n, i, s) {
        for (let r = 0; r < n.length; ) {
          const o = n[r++],
            a = n[r++],
            l = e[o],
            c = t.data[o]
          null !== c.setInput ? c.setInput(l, s, i, a) : (l[a] = s)
        }
      }
      function Kr(t, e, n) {
        let i = n ? t.styles : null,
          s = n ? t.classes : null,
          r = 0
        if (null !== e)
          for (let o = 0; o < e.length; o++) {
            const t = e[o]
            'number' == typeof t
              ? (r = t)
              : 1 == r
              ? (s = rt(s, t))
              : 2 == r && (i = rt(i, t + ': ' + e[++o] + ';'))
          }
        n ? (t.styles = i) : (t.stylesWithoutHost = i),
          n ? (t.classes = s) : (t.classesWithoutHost = s)
      }
      const Gr = new Yn('INJECTOR', -1)
      class Qr {
        get(t, e = di) {
          if (e === di) {
            const e = new Error(`NullInjectorError: No provider for ${st(t)}!`)
            throw ((e.name = 'NullInjectorError'), e)
          }
          return e
        }
      }
      const Zr = new Yn('Set Injector scope.'),
        Yr = {},
        Xr = {},
        Jr = []
      let to = void 0
      function eo() {
        return void 0 === to && (to = new Qr()), to
      }
      function no(t, e = null, n = null, i) {
        return new io(t, n, e || eo(), i)
      }
      class io {
        constructor(t, e, n, i = null) {
          ;(this.parent = n),
            (this.records = new Map()),
            (this.injectorDefTypes = new Set()),
            (this.onDestroy = new Set()),
            (this._destroyed = !1)
          const s = []
          e && ei(e, (n) => this.processProvider(n, t, e)),
            ei([t], (t) => this.processInjectorType(t, [], s)),
            this.records.set(Gr, oo(void 0, this))
          const r = this.records.get(Zr)
          ;(this.scope = null != r ? r.value : null),
            (this.source = i || ('object' == typeof t ? null : st(t)))
        }
        get destroyed() {
          return this._destroyed
        }
        destroy() {
          this.assertNotDestroyed(), (this._destroyed = !0)
          try {
            this.onDestroy.forEach((t) => t.ngOnDestroy())
          } finally {
            this.records.clear(),
              this.onDestroy.clear(),
              this.injectorDefTypes.clear()
          }
        }
        get(t, e = di, n = vt.Default) {
          this.assertNotDestroyed()
          const i = yi(this)
          try {
            if (!(n & vt.SkipSelf)) {
              let e = this.records.get(t)
              if (void 0 === e) {
                const n =
                  ('function' == typeof (s = t) ||
                    ('object' == typeof s && s instanceof Yn)) &&
                  dt(t)
                ;(e = n && this.injectableDefInScope(n) ? oo(so(t), Yr) : null),
                  this.records.set(t, e)
              }
              if (null != e) return this.hydrate(t, e)
            }
            return (n & vt.Self ? eo() : this.parent).get(
              t,
              (e = n & vt.Optional && e === di ? null : e)
            )
          } catch (r) {
            if ('NullInjectorError' === r.name) {
              if (
                ((r.ngTempTokenPath = r.ngTempTokenPath || []).unshift(st(t)),
                i)
              )
                throw r
              return (function (t, e, n, i) {
                const s = t.ngTempTokenPath
                throw (
                  (e[fi] && s.unshift(e[fi]),
                  (t.message = (function (t, e, n, i = null) {
                    t =
                      t && '\n' === t.charAt(0) && '\u0275' == t.charAt(1)
                        ? t.substr(2)
                        : t
                    let s = st(e)
                    if (Array.isArray(e)) s = e.map(st).join(' -> ')
                    else if ('object' == typeof e) {
                      let t = []
                      for (let n in e)
                        if (e.hasOwnProperty(n)) {
                          let i = e[n]
                          t.push(
                            n +
                              ':' +
                              ('string' == typeof i ? JSON.stringify(i) : st(i))
                          )
                        }
                      s = `{${t.join(', ')}}`
                    }
                    return `${n}${i ? '(' + i + ')' : ''}[${s}]: ${t.replace(
                      pi,
                      '\n  '
                    )}`
                  })('\n' + t.message, s, n, i)),
                  (t.ngTokenPath = s),
                  (t.ngTempTokenPath = null),
                  t)
                )
              })(r, t, 'R3InjectorError', this.source)
            }
            throw r
          } finally {
            yi(i)
          }
          var s
        }
        _resolveInjectorDefTypes() {
          this.injectorDefTypes.forEach((t) => this.get(t))
        }
        toString() {
          const t = []
          return (
            this.records.forEach((e, n) => t.push(st(n))),
            `R3Injector[${t.join(', ')}]`
          )
        }
        assertNotDestroyed() {
          if (this._destroyed)
            throw new Error('Injector has already been destroyed.')
        }
        processInjectorType(t, e, n) {
          if (!(t = lt(t))) return !1
          let i = ft(t)
          const s = (null == i && t.ngModule) || void 0,
            r = void 0 === s ? t : s,
            o = -1 !== n.indexOf(r)
          if ((void 0 !== s && (i = ft(s)), null == i)) return !1
          if (null != i.imports && !o) {
            let t
            n.push(r)
            try {
              ei(i.imports, (i) => {
                this.processInjectorType(i, e, n) &&
                  (void 0 === t && (t = []), t.push(i))
              })
            } finally {
            }
            if (void 0 !== t)
              for (let e = 0; e < t.length; e++) {
                const { ngModule: n, providers: i } = t[e]
                ei(i, (t) => this.processProvider(t, n, i || Jr))
              }
          }
          this.injectorDefTypes.add(r), this.records.set(r, oo(i.factory, Yr))
          const a = i.providers
          if (null != a && !o) {
            const e = t
            ei(a, (t) => this.processProvider(t, e, a))
          }
          return void 0 !== s && void 0 !== t.providers
        }
        processProvider(t, e, n) {
          let i = lo((t = lt(t))) ? t : lt(t && t.provide)
          const s = (function (t, e, n) {
            return ao(t) ? oo(void 0, t.useValue) : oo(ro(t), Yr)
          })(t)
          if (lo(t) || !0 !== t.multi) this.records.get(i)
          else {
            let e = this.records.get(i)
            e ||
              ((e = oo(void 0, Yr, !0)),
              (e.factory = () => wi(e.multi)),
              this.records.set(i, e)),
              (i = t),
              e.multi.push(t)
          }
          this.records.set(i, s)
        }
        hydrate(t, e) {
          var n
          return (
            e.value === Yr && ((e.value = Xr), (e.value = e.factory())),
            'object' == typeof e.value &&
              e.value &&
              null !== (n = e.value) &&
              'object' == typeof n &&
              'function' == typeof n.ngOnDestroy &&
              this.onDestroy.add(e.value),
            e.value
          )
        }
        injectableDefInScope(t) {
          return (
            !!t.providedIn &&
            ('string' == typeof t.providedIn
              ? 'any' === t.providedIn || t.providedIn === this.scope
              : this.injectorDefTypes.has(t.providedIn))
          )
        }
      }
      function so(t) {
        const e = dt(t),
          n = null !== e ? e.factory : re(t)
        if (null !== n) return n
        const i = ft(t)
        if (null !== i) return i.factory
        if (t instanceof Yn)
          throw new Error(`Token ${st(t)} is missing a \u0275prov definition.`)
        if (t instanceof Function)
          return (function (t) {
            const e = t.length
            if (e > 0) {
              const n = si(e, '?')
              throw new Error(
                `Can't resolve all parameters for ${st(t)}: (${n.join(', ')}).`
              )
            }
            const n = (function (t) {
              const e = t && (t[mt] || t[yt])
              if (e) {
                const n = (function (t) {
                  if (t.hasOwnProperty('name')) return t.name
                  const e = ('' + t).match(/^function\s*([^\s(]+)/)
                  return null === e ? '' : e[1]
                })(t)
                return (
                  console.warn(
                    `DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`
                  ),
                  e
                )
              }
              return null
            })(t)
            return null !== n ? () => n.factory(t) : () => new t()
          })(t)
        throw new Error('unreachable')
      }
      function ro(t, e, n) {
        let i = void 0
        if (lo(t)) {
          const e = lt(t)
          return re(e) || so(e)
        }
        if (ao(t)) i = () => lt(t.useValue)
        else if ((s = t) && s.useFactory)
          i = () => t.useFactory(...wi(t.deps || []))
        else if (
          (function (t) {
            return !(!t || !t.useExisting)
          })(t)
        )
          i = () => vi(lt(t.useExisting))
        else {
          const e = lt(t && (t.useClass || t.provide))
          if (
            !(function (t) {
              return !!t.deps
            })(t)
          )
            return re(e) || so(e)
          i = () => new e(...wi(t.deps))
        }
        var s
        return i
      }
      function oo(t, e, n = !1) {
        return { factory: t, value: e, multi: n ? [] : void 0 }
      }
      function ao(t) {
        return null !== t && 'object' == typeof t && mi in t
      }
      function lo(t) {
        return 'function' == typeof t
      }
      const co = function (t, e, n) {
        return (function (t, e = null, n = null, i) {
          const s = no(t, e, n, i)
          return s._resolveInjectorDefTypes(), s
        })({ name: n }, e, t, n)
      }
      let ho = (() => {
        class t {
          static create(t, e) {
            return Array.isArray(t)
              ? co(t, e, '')
              : co(t.providers, t.parent, t.name || '')
          }
        }
        return (
          (t.THROW_IF_NOT_FOUND = di),
          (t.NULL = new Qr()),
          (t.ɵprov = ht({
            token: t,
            providedIn: 'any',
            factory: () => vi(Gr),
          })),
          (t.__NG_ELEMENT_ID__ = -1),
          t
        )
      })()
      function uo(t, e) {
        un(ke(t)[1], Le())
      }
      function po(t) {
        let e = Object.getPrototypeOf(t.type.prototype).constructor,
          n = !0
        const i = [t]
        for (; e; ) {
          let s = void 0
          if (se(t)) s = e.ɵcmp || e.ɵdir
          else {
            if (e.ɵcmp) throw new Error('Directives cannot inherit Components')
            s = e.ɵdir
          }
          if (s) {
            if (n) {
              i.push(s)
              const e = t
              ;(e.inputs = fo(t.inputs)),
                (e.declaredInputs = fo(t.declaredInputs)),
                (e.outputs = fo(t.outputs))
              const n = s.hostBindings
              n && yo(t, n)
              const r = s.viewQuery,
                o = s.contentQueries
              if (
                (r && mo(t, r),
                o && go(t, o),
                it(t.inputs, s.inputs),
                it(t.declaredInputs, s.declaredInputs),
                it(t.outputs, s.outputs),
                se(s) && s.data.animation)
              ) {
                const e = t.data
                e.animation = (e.animation || []).concat(s.data.animation)
              }
            }
            const e = s.features
            if (e)
              for (let i = 0; i < e.length; i++) {
                const s = e[i]
                s && s.ngInherit && s(t), s === po && (n = !1)
              }
          }
          e = Object.getPrototypeOf(e)
        }
        !(function (t) {
          let e = 0,
            n = null
          for (let i = t.length - 1; i >= 0; i--) {
            const s = t[i]
            ;(s.hostVars = e += s.hostVars),
              (s.hostAttrs = Cn(s.hostAttrs, (n = Cn(n, s.hostAttrs))))
          }
        })(i)
      }
      function fo(t) {
        return t === Rt ? {} : t === Pt ? [] : t
      }
      function mo(t, e) {
        const n = t.viewQuery
        t.viewQuery = n
          ? (t, i) => {
              e(t, i), n(t, i)
            }
          : e
      }
      function go(t, e) {
        const n = t.contentQueries
        t.contentQueries = n
          ? (t, i, s) => {
              e(t, i, s), n(t, i, s)
            }
          : e
      }
      function yo(t, e) {
        const n = t.hostBindings
        t.hostBindings = n
          ? (t, i) => {
              e(t, i), n(t, i)
            }
          : e
      }
      let _o = null
      function vo() {
        if (!_o) {
          const t = It.Symbol
          if (t && t.iterator) _o = t.iterator
          else {
            const t = Object.getOwnPropertyNames(Map.prototype)
            for (let e = 0; e < t.length; ++e) {
              const n = t[e]
              'entries' !== n &&
                'size' !== n &&
                Map.prototype[n] === Map.prototype.entries &&
                (_o = n)
            }
          }
        }
        return _o
      }
      class bo {
        constructor(t) {
          this.wrapped = t
        }
        static wrap(t) {
          return new bo(t)
        }
        static unwrap(t) {
          return bo.isWrapped(t) ? t.wrapped : t
        }
        static isWrapped(t) {
          return t instanceof bo
        }
      }
      function wo(t) {
        return (
          !!Co(t) && (Array.isArray(t) || (!(t instanceof Map) && vo() in t))
        )
      }
      function Co(t) {
        return null !== t && ('function' == typeof t || 'object' == typeof t)
      }
      function xo(t, e, n) {
        return (t[e] = n)
      }
      function So(t, e, n) {
        return !Object.is(t[e], n) && ((t[e] = n), !0)
      }
      function Eo(t, e, n, i) {
        const s = Ne()
        return (
          So(s, $e(), e) &&
            (Fe(),
            (function (t, e, n, i, s, r) {
              const o = Ce(t, e)
              !(function (t, e, n, i, s, r, o) {
                if (null == r)
                  _e(t) ? t.removeAttribute(e, s, n) : e.removeAttribute(s)
                else {
                  const a = null == o ? ae(r) : o(r, i || '', s)
                  _e(t)
                    ? t.setAttribute(e, s, a, n)
                    : n
                    ? e.setAttributeNS(n, s, a)
                    : e.setAttribute(s, a)
                }
              })(e[11], o, r, t.value, n, i, s)
            })(cn(), s, t, e, n, i)),
          Eo
        )
      }
      function ko(t, e, n, i, s, r, o, a) {
        const l = Ne(),
          c = Fe(),
          h = t + Yt,
          u = c.firstCreatePass
            ? (function (t, e, n, i, s, r, o, a, l) {
                const c = e.consts,
                  h = lr(e, t, 4, o || null, Oe(c, a))
                Cr(e, n, h, Oe(c, l)), un(e, h)
                const u = (h.tViews = _r(
                  2,
                  h,
                  i,
                  s,
                  r,
                  e.directiveRegistry,
                  e.pipeRegistry,
                  null,
                  e.schemas,
                  c
                ))
                return (
                  null !== e.queries &&
                    (e.queries.template(e, h),
                    (u.queries = e.queries.embeddedTView(h))),
                  h
                )
              })(h, c, l, e, n, i, s, r, o)
            : c.data[h]
        Be(u, !1)
        const d = l[11].createComment('')
        Rs(c, l, d, u),
          as(d, l),
          Mr(l, (l[h] = Pr(d, l, d, u))),
          ie(u) && mr(c, l, u),
          null != o && gr(l, u, a)
      }
      function To(t) {
        return Se(Pe.lFrame.contextLView, Yt + t)
      }
      function Ao(t, e = vt.Default) {
        const n = Ne()
        return null === n ? vi(t, e) : Ln(Le(), n, lt(t), e)
      }
      function Oo(t, e, n) {
        const i = Ne()
        return So(i, $e(), e) && wr(Fe(), cn(), i, t, e, i[11], n, !1), Oo
      }
      function Io(t, e, n, i, s) {
        const r = s ? 'class' : 'style'
        Wr(t, n, e.inputs[r], r, i)
      }
      function Ro(t, e, n, i) {
        const s = Ne(),
          r = Fe(),
          o = Yt + t,
          a = s[11],
          l = (s[o] = vs(a, e, Pe.lFrame.currentNamespace)),
          c = r.firstCreatePass
            ? (function (t, e, n, i, s, r, o) {
                const a = e.consts,
                  l = lr(e, t, 2, s, Oe(a, r))
                return (
                  Cr(e, n, l, Oe(a, o)),
                  null !== l.attrs && Kr(l, l.attrs, !1),
                  null !== l.mergedAttrs && Kr(l, l.mergedAttrs, !0),
                  null !== e.queries && e.queries.elementStart(e, l),
                  l
                )
              })(o, r, s, 0, e, n, i)
            : r.data[o]
        Be(c, !0)
        const h = c.mergedAttrs
        null !== h && vn(a, l, h)
        const u = c.classes
        null !== u && js(a, l, u)
        const d = c.styles
        null !== d && Ls(a, l, d),
          64 != (64 & c.flags) && Rs(r, s, l, c),
          0 === Pe.lFrame.elementDepthCount && as(l, s),
          Pe.lFrame.elementDepthCount++,
          ie(c) && (mr(r, s, c), fr(r, c, s)),
          null !== i && gr(s, c)
      }
      function Po() {
        let t = Le()
        Ve() ? Ue() : ((t = t.parent), Be(t, !1))
        const e = t
        Pe.lFrame.elementDepthCount--
        const n = Fe()
        n.firstCreatePass && (un(n, t), ee(t) && n.queries.elementEnd(t)),
          null != e.classesWithoutHost &&
            (function (t) {
              return 0 != (16 & t.flags)
            })(e) &&
            Io(n, e, Ne(), e.classesWithoutHost, !0),
          null != e.stylesWithoutHost &&
            (function (t) {
              return 0 != (32 & t.flags)
            })(e) &&
            Io(n, e, Ne(), e.stylesWithoutHost, !1)
      }
      function Do(t, e, n, i) {
        Ro(t, e, n, i), Po()
      }
      function No(t, e, n) {
        const i = Ne(),
          s = Fe(),
          r = t + Yt,
          o = s.firstCreatePass
            ? (function (t, e, n, i, s) {
                const r = e.consts,
                  o = Oe(r, i),
                  a = lr(e, t, 8, 'ng-container', o)
                return (
                  null !== o && Kr(a, o, !0),
                  Cr(e, n, a, Oe(r, s)),
                  null !== e.queries && e.queries.elementStart(e, a),
                  a
                )
              })(r, s, i, e, n)
            : s.data[r]
        Be(o, !0)
        const a = (i[r] = i[11].createComment(''))
        Rs(s, i, a, o),
          as(a, i),
          ie(o) && (mr(s, i, o), fr(s, o, i)),
          null != n && gr(i, o)
      }
      function Fo() {
        let t = Le()
        const e = Fe()
        Ve() ? Ue() : ((t = t.parent), Be(t, !1)),
          e.firstCreatePass && (un(e, t), ee(t) && e.queries.elementEnd(t))
      }
      function Mo() {
        return Ne()
      }
      function Lo(t) {
        return !!t && 'function' == typeof t.then
      }
      function jo(t) {
        return !!t && 'function' == typeof t.subscribe
      }
      function Bo(t, e, n = !1, i) {
        const s = Ne(),
          r = Fe(),
          o = Le()
        return Uo(r, s, s[11], o, t, e, n, i), Bo
      }
      function Vo(t, e, n = !1, i) {
        const s = Le(),
          r = Ne(),
          o = Fe()
        return Uo(o, r, qr(Qe(o.data), s, r), s, t, e, n, i), Vo
      }
      function Uo(t, e, n, i, s, r, o = !1, a) {
        const l = ie(i),
          c = t.firstCreatePass && Hr(t),
          h = zr(e)
        let u = !0
        if (3 & i.type) {
          const d = Ce(i, e),
            p = a ? a(d) : Rt,
            f = p.target || d,
            m = h.length,
            g = a ? (t) => a(be(t[i.index])).target : i.index
          if (_e(n)) {
            let o = null
            if (
              (!a &&
                l &&
                (o = (function (t, e, n, i) {
                  const s = t.cleanup
                  if (null != s)
                    for (let r = 0; r < s.length - 1; r += 2) {
                      const t = s[r]
                      if (t === n && s[r + 1] === i) {
                        const t = e[7],
                          n = s[r + 2]
                        return t.length > n ? t[n] : null
                      }
                      'string' == typeof t && (r += 2)
                    }
                  return null
                })(t, e, s, i.index)),
              null !== o)
            )
              ((o.__ngLastListenerFn__ || o).__ngNextListenerFn__ = r),
                (o.__ngLastListenerFn__ = r),
                (u = !1)
            else {
              r = Ho(i, e, r, !1)
              const t = n.listen(p.name || f, s, r)
              h.push(r, t), c && c.push(s, g, m, m + 1)
            }
          } else
            (r = Ho(i, e, r, !0)),
              f.addEventListener(s, r, o),
              h.push(r),
              c && c.push(s, g, m, o)
        } else r = Ho(i, e, r, !1)
        const d = i.outputs
        let p
        if (u && null !== d && (p = d[s])) {
          const t = p.length
          if (t)
            for (let n = 0; n < t; n += 2) {
              const t = e[p[n]][p[n + 1]].subscribe(r),
                o = h.length
              h.push(r, t), c && c.push(s, i.index, o, -(o + 1))
            }
        }
      }
      function zo(t, e, n) {
        try {
          return !1 !== e(n)
        } catch (i) {
          return $r(t, i), !1
        }
      }
      function Ho(t, e, n, i) {
        return function s(r) {
          if (r === Function) return n
          const o = 2 & t.flags ? Ee(t.index, e) : e
          0 == (32 & e[2]) && Lr(o)
          let a = zo(e, n, r),
            l = s.__ngNextListenerFn__
          for (; l; ) (a = zo(e, l, r) && a), (l = l.__ngNextListenerFn__)
          return i && !1 === a && (r.preventDefault(), (r.returnValue = !1)), a
        }
      }
      function qo(t = 1) {
        return (function (t) {
          return (Pe.lFrame.contextLView = (function (t, e) {
            for (; t > 0; ) (e = e[15]), t--
            return e
          })(t, Pe.lFrame.contextLView))[8]
        })(t)
      }
      function $o(t, e) {
        let n = null
        const i = (function (t) {
          const e = t.attrs
          if (null != e) {
            const t = e.indexOf(5)
            if (0 == (1 & t)) return e[t + 1]
          }
          return null
        })(t)
        for (let s = 0; s < e.length; s++) {
          const r = e[s]
          if ('*' !== r) {
            if (null === i ? Ks(t, r, !0) : Gs(i, r)) return s
          } else n = s
        }
        return n
      }
      function Wo(t) {
        const e = Ne()[16][6]
        if (!e.projection) {
          const n = (e.projection = si(t ? t.length : 1, null)),
            i = n.slice()
          let s = e.child
          for (; null !== s; ) {
            const e = t ? $o(s, t) : 0
            null !== e &&
              (i[e] ? (i[e].projectionNext = s) : (n[e] = s), (i[e] = s)),
              (s = s.next)
          }
        }
      }
      function Ko(t, e = 0, n) {
        const i = Ne(),
          s = Fe(),
          r = lr(s, Yt + t, 16, null, n || null)
        null === r.projection && (r.projection = e),
          Ue(),
          64 != (64 & r.flags) &&
            (function (t, e, n) {
              Ms(e[11], 0, e, n, Ss(t, n, e), Os(n.parent || e[6], n, e))
            })(s, i, r)
      }
      const Go = []
      function Qo(t, e, n, i, s) {
        const r = t[n + 1],
          o = null === e
        let a = i ? er(r) : ir(r),
          l = !1
        for (; 0 !== a && (!1 === l || o); ) {
          const n = t[a + 1]
          Zo(t[a], e) && ((l = !0), (t[a + 1] = i ? rr(n) : nr(n))),
            (a = i ? er(n) : ir(n))
        }
        l && (t[n + 1] = i ? nr(r) : rr(r))
      }
      function Zo(t, e) {
        return (
          null === t ||
          null == e ||
          (Array.isArray(t) ? t[1] : t) === e ||
          (!(!Array.isArray(t) || 'string' != typeof e) && ai(t, e) >= 0)
        )
      }
      const Yo = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 }
      function Xo(t) {
        return t.substring(Yo.key, Yo.keyEnd)
      }
      function Jo(t, e) {
        const n = Yo.textEnd
        return n === e
          ? -1
          : ((e = Yo.keyEnd = (function (t, e, n) {
              for (; e < n && t.charCodeAt(e) > 32; ) e++
              return e
            })(t, (Yo.key = e), n)),
            ta(t, e, n))
      }
      function ta(t, e, n) {
        for (; e < n && t.charCodeAt(e) <= 32; ) e++
        return e
      }
      function ea(t, e, n) {
        return sa(t, e, n, !1), ea
      }
      function na(t, e) {
        return sa(t, e, null, !0), na
      }
      function ia(t, e) {
        for (
          let n = (function (t) {
            return (
              (function (t) {
                ;(Yo.key = 0),
                  (Yo.keyEnd = 0),
                  (Yo.value = 0),
                  (Yo.valueEnd = 0),
                  (Yo.textEnd = t.length)
              })(t),
              Jo(t, ta(t, 0, Yo.textEnd))
            )
          })(e);
          n >= 0;
          n = Jo(e, n)
        )
          ri(t, Xo(e), !0)
      }
      function sa(t, e, n, i) {
        const s = Ne(),
          r = Fe(),
          o = We(2)
        r.firstUpdatePass && oa(r, t, o, i),
          e !== Ys &&
            So(s, o, e) &&
            ca(
              r,
              r.data[an()],
              s,
              s[11],
              t,
              (s[o + 1] = (function (t, e) {
                return (
                  null == t ||
                    ('string' == typeof e
                      ? (t += e)
                      : 'object' == typeof t && (t = st(Ii(t)))),
                  t
                )
              })(e, n)),
              i,
              o
            )
      }
      function ra(t, e) {
        return e >= t.expandoStartIndex
      }
      function oa(t, e, n, i) {
        const s = t.data
        if (null === s[n + 1]) {
          const r = s[an()],
            o = ra(t, n)
          da(r, i) && null === e && !o && (e = !1),
            (e = (function (t, e, n, i) {
              const s = Qe(t)
              let r = i ? e.residualClasses : e.residualStyles
              if (null === s)
                0 === (i ? e.classBindings : e.styleBindings) &&
                  ((n = la((n = aa(null, t, e, n, i)), e.attrs, i)), (r = null))
              else {
                const o = e.directiveStylingLast
                if (-1 === o || t[o] !== s)
                  if (((n = aa(s, t, e, n, i)), null === r)) {
                    let n = (function (t, e, n) {
                      const i = n ? e.classBindings : e.styleBindings
                      if (0 !== ir(i)) return t[er(i)]
                    })(t, e, i)
                    void 0 !== n &&
                      Array.isArray(n) &&
                      ((n = aa(null, t, e, n[1], i)),
                      (n = la(n, e.attrs, i)),
                      (function (t, e, n, i) {
                        t[er(n ? e.classBindings : e.styleBindings)] = i
                      })(t, e, i, n))
                  } else
                    r = (function (t, e, n) {
                      let i = void 0
                      const s = e.directiveEnd
                      for (let r = 1 + e.directiveStylingLast; r < s; r++)
                        i = la(i, t[r].hostAttrs, n)
                      return la(i, e.attrs, n)
                    })(t, e, i)
              }
              return (
                void 0 !== r &&
                  (i ? (e.residualClasses = r) : (e.residualStyles = r)),
                n
              )
            })(s, r, e, i)),
            (function (t, e, n, i, s, r) {
              let o = r ? e.classBindings : e.styleBindings,
                a = er(o),
                l = ir(o)
              t[i] = n
              let c,
                h = !1
              if (Array.isArray(n)) {
                const t = n
                ;(c = t[1]), (null === c || ai(t, c) > 0) && (h = !0)
              } else c = n
              if (s)
                if (0 !== l) {
                  const e = er(t[a + 1])
                  ;(t[i + 1] = tr(e, a)),
                    0 !== e && (t[e + 1] = sr(t[e + 1], i)),
                    (t[a + 1] = (131071 & t[a + 1]) | (i << 17))
                } else
                  (t[i + 1] = tr(a, 0)),
                    0 !== a && (t[a + 1] = sr(t[a + 1], i)),
                    (a = i)
              else
                (t[i + 1] = tr(l, 0)),
                  0 === a ? (a = i) : (t[l + 1] = sr(t[l + 1], i)),
                  (l = i)
              h && (t[i + 1] = nr(t[i + 1])),
                Qo(t, c, i, !0),
                Qo(t, c, i, !1),
                (function (t, e, n, i, s) {
                  const r = s ? t.residualClasses : t.residualStyles
                  null != r &&
                    'string' == typeof e &&
                    ai(r, e) >= 0 &&
                    (n[i + 1] = rr(n[i + 1]))
                })(e, c, t, i, r),
                (o = tr(a, l)),
                r ? (e.classBindings = o) : (e.styleBindings = o)
            })(s, r, e, n, o, i)
        }
      }
      function aa(t, e, n, i, s) {
        let r = null
        const o = n.directiveEnd
        let a = n.directiveStylingLast
        for (
          -1 === a ? (a = n.directiveStart) : a++;
          a < o && ((r = e[a]), (i = la(i, r.hostAttrs, s)), r !== t);

        )
          a++
        return null !== t && (n.directiveStylingLast = a), i
      }
      function la(t, e, n) {
        const i = n ? 1 : 2
        let s = -1
        if (null !== e)
          for (let r = 0; r < e.length; r++) {
            const o = e[r]
            'number' == typeof o
              ? (s = o)
              : s === i &&
                (Array.isArray(t) || (t = void 0 === t ? [] : ['', t]),
                ri(t, o, !!n || e[++r]))
          }
        return void 0 === t ? null : t
      }
      function ca(t, e, n, i, s, r, o, a) {
        if (!(3 & e.type)) return
        const l = t.data,
          c = l[a + 1]
        ua(1 == (1 & c) ? ha(l, e, n, s, ir(c), o) : void 0) ||
          (ua(r) || (2 == (2 & c) && (r = ha(l, null, n, s, a, o))),
          (function (t, e, n, i, s) {
            const r = _e(t)
            if (e)
              s
                ? r
                  ? t.addClass(n, i)
                  : n.classList.add(i)
                : r
                ? t.removeClass(n, i)
                : n.classList.remove(i)
            else {
              let e = -1 === i.indexOf('-') ? void 0 : ds.DashCase
              if (null == s)
                r ? t.removeStyle(n, i, e) : n.style.removeProperty(i)
              else {
                const o = 'string' == typeof s && s.endsWith('!important')
                o && ((s = s.slice(0, -10)), (e |= ds.Important)),
                  r
                    ? t.setStyle(n, i, s, e)
                    : n.style.setProperty(i, s, o ? 'important' : '')
              }
            }
          })(i, o, we(an(), n), s, r))
      }
      function ha(t, e, n, i, s, r) {
        const o = null === e
        let a = void 0
        for (; s > 0; ) {
          const e = t[s],
            r = Array.isArray(e),
            l = r ? e[1] : e,
            c = null === l
          let h = n[s + 1]
          h === Ys && (h = c ? Go : void 0)
          let u = c ? oi(h, i) : l === i ? h : void 0
          if ((r && !ua(u) && (u = oi(e, i)), ua(u) && ((a = u), o))) return a
          const d = t[s + 1]
          s = o ? er(d) : ir(d)
        }
        if (null !== e) {
          let t = r ? e.residualClasses : e.residualStyles
          null != t && (a = oi(t, i))
        }
        return a
      }
      function ua(t) {
        return void 0 !== t
      }
      function da(t, e) {
        return 0 != (t.flags & (e ? 16 : 32))
      }
      function pa(t, e = '') {
        const n = Ne(),
          i = Fe(),
          s = t + Yt,
          r = i.firstCreatePass ? lr(i, s, 1, e, null) : i.data[s],
          o = (n[s] = (function (t, e) {
            return _e(t) ? t.createText(e) : t.createTextNode(e)
          })(n[11], e))
        Rs(i, n, o, r), Be(r, !1)
      }
      function fa(t) {
        return ma('', t, ''), fa
      }
      function ma(t, e, n) {
        const i = Ne(),
          s = (function (t, e, n, i) {
            return So(t, $e(), n) ? e + ae(n) + i : Ys
          })(i, t, e, n)
        return (
          s !== Ys &&
            (function (t, e, n) {
              const i = we(e, t)
              !(function (t, e, n) {
                _e(t) ? t.setValue(e, n) : (e.textContent = n)
              })(t[11], i, n)
            })(i, an(), s),
          ma
        )
      }
      function ga(t, e, n) {
        const i = Ne()
        return So(i, $e(), e) && wr(Fe(), cn(), i, t, e, i[11], n, !0), ga
      }
      function ya(t, e, n) {
        const i = Ne()
        if (So(i, $e(), e)) {
          const s = Fe(),
            r = cn()
          wr(s, r, i, t, e, qr(Qe(s.data), r, i), n, !0)
        }
        return ya
      }
      const _a = void 0
      var va = [
        'en',
        [['a', 'p'], ['AM', 'PM'], _a],
        [['AM', 'PM'], _a, _a],
        [
          ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
          ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
          [
            'Sunday',
            'Monday',
            'Tuesday',
            'Wednesday',
            'Thursday',
            'Friday',
            'Saturday',
          ],
          ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
        ],
        _a,
        [
          ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
          [
            'Jan',
            'Feb',
            'Mar',
            'Apr',
            'May',
            'Jun',
            'Jul',
            'Aug',
            'Sep',
            'Oct',
            'Nov',
            'Dec',
          ],
          [
            'January',
            'February',
            'March',
            'April',
            'May',
            'June',
            'July',
            'August',
            'September',
            'October',
            'November',
            'December',
          ],
        ],
        _a,
        [
          ['B', 'A'],
          ['BC', 'AD'],
          ['Before Christ', 'Anno Domini'],
        ],
        0,
        [6, 0],
        ['M/d/yy', 'MMM d, y', 'MMMM d, y', 'EEEE, MMMM d, y'],
        ['h:mm a', 'h:mm:ss a', 'h:mm:ss a z', 'h:mm:ss a zzzz'],
        ['{1}, {0}', _a, "{1} 'at' {0}", _a],
        [
          '.',
          ',',
          ';',
          '%',
          '+',
          '-',
          'E',
          '\xd7',
          '\u2030',
          '\u221e',
          'NaN',
          ':',
        ],
        ['#,##0.###', '#,##0%', '\xa4#,##0.00', '#E0'],
        'USD',
        '$',
        'US Dollar',
        {},
        'ltr',
        function (t) {
          let e = Math.floor(Math.abs(t)),
            n = t.toString().replace(/^[^.]*\.?/, '').length
          return 1 === e && 0 === n ? 1 : 5
        },
      ]
      let ba = {}
      function wa(t) {
        return (
          t in ba ||
            (ba[t] =
              It.ng &&
              It.ng.common &&
              It.ng.common.locales &&
              It.ng.common.locales[t]),
          ba[t]
        )
      }
      var Ca = (function (t) {
        return (
          (t[(t.LocaleId = 0)] = 'LocaleId'),
          (t[(t.DayPeriodsFormat = 1)] = 'DayPeriodsFormat'),
          (t[(t.DayPeriodsStandalone = 2)] = 'DayPeriodsStandalone'),
          (t[(t.DaysFormat = 3)] = 'DaysFormat'),
          (t[(t.DaysStandalone = 4)] = 'DaysStandalone'),
          (t[(t.MonthsFormat = 5)] = 'MonthsFormat'),
          (t[(t.MonthsStandalone = 6)] = 'MonthsStandalone'),
          (t[(t.Eras = 7)] = 'Eras'),
          (t[(t.FirstDayOfWeek = 8)] = 'FirstDayOfWeek'),
          (t[(t.WeekendRange = 9)] = 'WeekendRange'),
          (t[(t.DateFormat = 10)] = 'DateFormat'),
          (t[(t.TimeFormat = 11)] = 'TimeFormat'),
          (t[(t.DateTimeFormat = 12)] = 'DateTimeFormat'),
          (t[(t.NumberSymbols = 13)] = 'NumberSymbols'),
          (t[(t.NumberFormats = 14)] = 'NumberFormats'),
          (t[(t.CurrencyCode = 15)] = 'CurrencyCode'),
          (t[(t.CurrencySymbol = 16)] = 'CurrencySymbol'),
          (t[(t.CurrencyName = 17)] = 'CurrencyName'),
          (t[(t.Currencies = 18)] = 'Currencies'),
          (t[(t.Directionality = 19)] = 'Directionality'),
          (t[(t.PluralCase = 20)] = 'PluralCase'),
          (t[(t.ExtraData = 21)] = 'ExtraData'),
          t
        )
      })({})
      const xa = 'en-US'
      let Sa = xa
      function Ea(t) {
        var e, n
        ;(n = 'Expected localeId to be defined'),
          null == (e = t) &&
            (function (t, e, n, i) {
              throw new Error(
                'ASSERTION ERROR: ' + t + ` [Expected=> null != ${e} <=Actual]`
              )
            })(n, e),
          'string' == typeof t && (Sa = t.toLowerCase().replace(/_/g, '-'))
      }
      function ka(t, e, n, i, s) {
        if (((t = lt(t)), Array.isArray(t)))
          for (let r = 0; r < t.length; r++) ka(t[r], e, n, i, s)
        else {
          const r = Fe(),
            o = Ne()
          let a = lo(t) ? t : lt(t.provide),
            l = ro(t)
          const c = Le(),
            h = 1048575 & c.providerIndexes,
            u = c.directiveStart,
            d = c.providerIndexes >> 20
          if (lo(t) || !t.multi) {
            const i = new _n(l, s, Ao),
              p = Oa(a, e, s ? h : h + d, u)
            ;-1 === p
              ? (Nn(In(c, o), r, a),
                Ta(r, t, e.length),
                e.push(a),
                c.directiveStart++,
                c.directiveEnd++,
                s && (c.providerIndexes += 1048576),
                n.push(i),
                o.push(i))
              : ((n[p] = i), (o[p] = i))
          } else {
            const p = Oa(a, e, h + d, u),
              f = Oa(a, e, h, h + d),
              m = p >= 0 && n[p],
              g = f >= 0 && n[f]
            if ((s && !g) || (!s && !m)) {
              Nn(In(c, o), r, a)
              const h = (function (t, e, n, i, s) {
                const r = new _n(t, n, Ao)
                return (
                  (r.multi = []),
                  (r.index = e),
                  (r.componentProviders = 0),
                  Aa(r, s, i && !n),
                  r
                )
              })(s ? Ra : Ia, n.length, s, i, l)
              !s && g && (n[f].providerFactory = h),
                Ta(r, t, e.length, 0),
                e.push(a),
                c.directiveStart++,
                c.directiveEnd++,
                s && (c.providerIndexes += 1048576),
                n.push(h),
                o.push(h)
            } else Ta(r, t, p > -1 ? p : f, Aa(n[s ? f : p], l, !s && i))
            !s && i && g && n[f].componentProviders++
          }
        }
      }
      function Ta(t, e, n, i) {
        const s = lo(e)
        if (s || e.useClass) {
          const r = (e.useClass || e).prototype.ngOnDestroy
          if (r) {
            const o = t.destroyHooks || (t.destroyHooks = [])
            if (!s && e.multi) {
              const t = o.indexOf(n)
              ;-1 === t ? o.push(n, [i, r]) : o[t + 1].push(i, r)
            } else o.push(n, r)
          }
        }
      }
      function Aa(t, e, n) {
        return n && t.componentProviders++, t.multi.push(e) - 1
      }
      function Oa(t, e, n, i) {
        for (let s = n; s < i; s++) if (e[s] === t) return s
        return -1
      }
      function Ia(t, e, n, i) {
        return Pa(this.multi, [])
      }
      function Ra(t, e, n, i) {
        const s = this.multi
        let r
        if (this.providerFactory) {
          const t = this.providerFactory.componentProviders,
            e = zn(n, n[1], this.providerFactory.index, i)
          ;(r = e.slice(0, t)), Pa(s, r)
          for (let n = t; n < e.length; n++) r.push(e[n])
        } else (r = []), Pa(s, r)
        return r
      }
      function Pa(t, e) {
        for (let n = 0; n < t.length; n++) e.push((0, t[n])())
        return e
      }
      function Da(t, e = []) {
        return (n) => {
          n.providersResolver = (n, i) =>
            (function (t, e, n) {
              const i = Fe()
              if (i.firstCreatePass) {
                const s = se(t)
                ka(n, i.data, i.blueprint, s, !0),
                  ka(e, i.data, i.blueprint, s, !1)
              }
            })(n, i ? i(t) : t, e)
        }
      }
      class Na {}
      class Fa {
        resolveComponentFactory(t) {
          throw (function (t) {
            const e = Error(
              `No component factory found for ${st(
                t
              )}. Did you add it to @NgModule.entryComponents?`
            )
            return (e.ngComponent = t), e
          })(t)
        }
      }
      let Ma = (() => {
        class t {}
        return (t.NULL = new Fa()), t
      })()
      function La(...t) {}
      function ja(t, e) {
        return new Va(Ce(t, e))
      }
      const Ba = function () {
        return ja(Le(), Ne())
      }
      let Va = (() => {
        class t {
          constructor(t) {
            this.nativeElement = t
          }
        }
        return (t.__NG_ELEMENT_ID__ = Ba), t
      })()
      class Ua {}
      let za = (() => {
        class t {}
        return (t.__NG_ELEMENT_ID__ = () => Ha()), t
      })()
      const Ha = function () {
        const t = Ne(),
          e = Ee(Le().index, t)
        return (function (t) {
          return t[11]
        })(Jt(e) ? e : t)
      }
      let qa = (() => {
        class t {}
        return (
          (t.ɵprov = ht({ token: t, providedIn: 'root', factory: () => null })),
          t
        )
      })()
      class $a {
        constructor(t) {
          ;(this.full = t),
            (this.major = t.split('.')[0]),
            (this.minor = t.split('.')[1]),
            (this.patch = t.split('.').slice(2).join('.'))
        }
      }
      const Wa = new $a('11.0.5')
      class Ka {
        constructor() {}
        supports(t) {
          return wo(t)
        }
        create(t) {
          return new Qa(t)
        }
      }
      const Ga = (t, e) => e
      class Qa {
        constructor(t) {
          ;(this.length = 0),
            (this._linkedRecords = null),
            (this._unlinkedRecords = null),
            (this._previousItHead = null),
            (this._itHead = null),
            (this._itTail = null),
            (this._additionsHead = null),
            (this._additionsTail = null),
            (this._movesHead = null),
            (this._movesTail = null),
            (this._removalsHead = null),
            (this._removalsTail = null),
            (this._identityChangesHead = null),
            (this._identityChangesTail = null),
            (this._trackByFn = t || Ga)
        }
        forEachItem(t) {
          let e
          for (e = this._itHead; null !== e; e = e._next) t(e)
        }
        forEachOperation(t) {
          let e = this._itHead,
            n = this._removalsHead,
            i = 0,
            s = null
          for (; e || n; ) {
            const r = !n || (e && e.currentIndex < Ja(n, i, s)) ? e : n,
              o = Ja(r, i, s),
              a = r.currentIndex
            if (r === n) i--, (n = n._nextRemoved)
            else if (((e = e._next), null == r.previousIndex)) i++
            else {
              s || (s = [])
              const t = o - i,
                e = a - i
              if (t != e) {
                for (let n = 0; n < t; n++) {
                  const i = n < s.length ? s[n] : (s[n] = 0),
                    r = i + n
                  e <= r && r < t && (s[n] = i + 1)
                }
                s[r.previousIndex] = e - t
              }
            }
            o !== a && t(r, o, a)
          }
        }
        forEachPreviousItem(t) {
          let e
          for (e = this._previousItHead; null !== e; e = e._nextPrevious) t(e)
        }
        forEachAddedItem(t) {
          let e
          for (e = this._additionsHead; null !== e; e = e._nextAdded) t(e)
        }
        forEachMovedItem(t) {
          let e
          for (e = this._movesHead; null !== e; e = e._nextMoved) t(e)
        }
        forEachRemovedItem(t) {
          let e
          for (e = this._removalsHead; null !== e; e = e._nextRemoved) t(e)
        }
        forEachIdentityChange(t) {
          let e
          for (
            e = this._identityChangesHead;
            null !== e;
            e = e._nextIdentityChange
          )
            t(e)
        }
        diff(t) {
          if ((null == t && (t = []), !wo(t)))
            throw new Error(
              `Error trying to diff '${st(
                t
              )}'. Only arrays and iterables are allowed`
            )
          return this.check(t) ? this : null
        }
        onDestroy() {}
        check(t) {
          this._reset()
          let e,
            n,
            i,
            s = this._itHead,
            r = !1
          if (Array.isArray(t)) {
            this.length = t.length
            for (let e = 0; e < this.length; e++)
              (n = t[e]),
                (i = this._trackByFn(e, n)),
                null !== s && Object.is(s.trackById, i)
                  ? (r && (s = this._verifyReinsertion(s, n, i, e)),
                    Object.is(s.item, n) || this._addIdentityChange(s, n))
                  : ((s = this._mismatch(s, n, i, e)), (r = !0)),
                (s = s._next)
          } else
            (e = 0),
              (function (t, e) {
                if (Array.isArray(t)) for (let n = 0; n < t.length; n++) e(t[n])
                else {
                  const n = t[vo()]()
                  let i
                  for (; !(i = n.next()).done; ) e(i.value)
                }
              })(t, (t) => {
                ;(i = this._trackByFn(e, t)),
                  null !== s && Object.is(s.trackById, i)
                    ? (r && (s = this._verifyReinsertion(s, t, i, e)),
                      Object.is(s.item, t) || this._addIdentityChange(s, t))
                    : ((s = this._mismatch(s, t, i, e)), (r = !0)),
                  (s = s._next),
                  e++
              }),
              (this.length = e)
          return this._truncate(s), (this.collection = t), this.isDirty
        }
        get isDirty() {
          return (
            null !== this._additionsHead ||
            null !== this._movesHead ||
            null !== this._removalsHead ||
            null !== this._identityChangesHead
          )
        }
        _reset() {
          if (this.isDirty) {
            let t
            for (
              t = this._previousItHead = this._itHead;
              null !== t;
              t = t._next
            )
              t._nextPrevious = t._next
            for (t = this._additionsHead; null !== t; t = t._nextAdded)
              t.previousIndex = t.currentIndex
            for (
              this._additionsHead = this._additionsTail = null,
                t = this._movesHead;
              null !== t;
              t = t._nextMoved
            )
              t.previousIndex = t.currentIndex
            ;(this._movesHead = this._movesTail = null),
              (this._removalsHead = this._removalsTail = null),
              (this._identityChangesHead = this._identityChangesTail = null)
          }
        }
        _mismatch(t, e, n, i) {
          let s
          return (
            null === t ? (s = this._itTail) : ((s = t._prev), this._remove(t)),
            null !==
            (t =
              null === this._linkedRecords
                ? null
                : this._linkedRecords.get(n, i))
              ? (Object.is(t.item, e) || this._addIdentityChange(t, e),
                this._moveAfter(t, s, i))
              : null !==
                (t =
                  null === this._unlinkedRecords
                    ? null
                    : this._unlinkedRecords.get(n, null))
              ? (Object.is(t.item, e) || this._addIdentityChange(t, e),
                this._reinsertAfter(t, s, i))
              : (t = this._addAfter(new Za(e, n), s, i)),
            t
          )
        }
        _verifyReinsertion(t, e, n, i) {
          let s =
            null === this._unlinkedRecords
              ? null
              : this._unlinkedRecords.get(n, null)
          return (
            null !== s
              ? (t = this._reinsertAfter(s, t._prev, i))
              : t.currentIndex != i &&
                ((t.currentIndex = i), this._addToMoves(t, i)),
            t
          )
        }
        _truncate(t) {
          for (; null !== t; ) {
            const e = t._next
            this._addToRemovals(this._unlink(t)), (t = e)
          }
          null !== this._unlinkedRecords && this._unlinkedRecords.clear(),
            null !== this._additionsTail &&
              (this._additionsTail._nextAdded = null),
            null !== this._movesTail && (this._movesTail._nextMoved = null),
            null !== this._itTail && (this._itTail._next = null),
            null !== this._removalsTail &&
              (this._removalsTail._nextRemoved = null),
            null !== this._identityChangesTail &&
              (this._identityChangesTail._nextIdentityChange = null)
        }
        _reinsertAfter(t, e, n) {
          null !== this._unlinkedRecords && this._unlinkedRecords.remove(t)
          const i = t._prevRemoved,
            s = t._nextRemoved
          return (
            null === i ? (this._removalsHead = s) : (i._nextRemoved = s),
            null === s ? (this._removalsTail = i) : (s._prevRemoved = i),
            this._insertAfter(t, e, n),
            this._addToMoves(t, n),
            t
          )
        }
        _moveAfter(t, e, n) {
          return (
            this._unlink(t),
            this._insertAfter(t, e, n),
            this._addToMoves(t, n),
            t
          )
        }
        _addAfter(t, e, n) {
          return (
            this._insertAfter(t, e, n),
            (this._additionsTail =
              null === this._additionsTail
                ? (this._additionsHead = t)
                : (this._additionsTail._nextAdded = t)),
            t
          )
        }
        _insertAfter(t, e, n) {
          const i = null === e ? this._itHead : e._next
          return (
            (t._next = i),
            (t._prev = e),
            null === i ? (this._itTail = t) : (i._prev = t),
            null === e ? (this._itHead = t) : (e._next = t),
            null === this._linkedRecords && (this._linkedRecords = new Xa()),
            this._linkedRecords.put(t),
            (t.currentIndex = n),
            t
          )
        }
        _remove(t) {
          return this._addToRemovals(this._unlink(t))
        }
        _unlink(t) {
          null !== this._linkedRecords && this._linkedRecords.remove(t)
          const e = t._prev,
            n = t._next
          return (
            null === e ? (this._itHead = n) : (e._next = n),
            null === n ? (this._itTail = e) : (n._prev = e),
            t
          )
        }
        _addToMoves(t, e) {
          return (
            t.previousIndex === e ||
              (this._movesTail =
                null === this._movesTail
                  ? (this._movesHead = t)
                  : (this._movesTail._nextMoved = t)),
            t
          )
        }
        _addToRemovals(t) {
          return (
            null === this._unlinkedRecords &&
              (this._unlinkedRecords = new Xa()),
            this._unlinkedRecords.put(t),
            (t.currentIndex = null),
            (t._nextRemoved = null),
            null === this._removalsTail
              ? ((this._removalsTail = this._removalsHead = t),
                (t._prevRemoved = null))
              : ((t._prevRemoved = this._removalsTail),
                (this._removalsTail = this._removalsTail._nextRemoved = t)),
            t
          )
        }
        _addIdentityChange(t, e) {
          return (
            (t.item = e),
            (this._identityChangesTail =
              null === this._identityChangesTail
                ? (this._identityChangesHead = t)
                : (this._identityChangesTail._nextIdentityChange = t)),
            t
          )
        }
      }
      class Za {
        constructor(t, e) {
          ;(this.item = t),
            (this.trackById = e),
            (this.currentIndex = null),
            (this.previousIndex = null),
            (this._nextPrevious = null),
            (this._prev = null),
            (this._next = null),
            (this._prevDup = null),
            (this._nextDup = null),
            (this._prevRemoved = null),
            (this._nextRemoved = null),
            (this._nextAdded = null),
            (this._nextMoved = null),
            (this._nextIdentityChange = null)
        }
      }
      class Ya {
        constructor() {
          ;(this._head = null), (this._tail = null)
        }
        add(t) {
          null === this._head
            ? ((this._head = this._tail = t),
              (t._nextDup = null),
              (t._prevDup = null))
            : ((this._tail._nextDup = t),
              (t._prevDup = this._tail),
              (t._nextDup = null),
              (this._tail = t))
        }
        get(t, e) {
          let n
          for (n = this._head; null !== n; n = n._nextDup)
            if (
              (null === e || e <= n.currentIndex) &&
              Object.is(n.trackById, t)
            )
              return n
          return null
        }
        remove(t) {
          const e = t._prevDup,
            n = t._nextDup
          return (
            null === e ? (this._head = n) : (e._nextDup = n),
            null === n ? (this._tail = e) : (n._prevDup = e),
            null === this._head
          )
        }
      }
      class Xa {
        constructor() {
          this.map = new Map()
        }
        put(t) {
          const e = t.trackById
          let n = this.map.get(e)
          n || ((n = new Ya()), this.map.set(e, n)), n.add(t)
        }
        get(t, e) {
          const n = this.map.get(t)
          return n ? n.get(t, e) : null
        }
        remove(t) {
          const e = t.trackById
          return this.map.get(e).remove(t) && this.map.delete(e), t
        }
        get isEmpty() {
          return 0 === this.map.size
        }
        clear() {
          this.map.clear()
        }
      }
      function Ja(t, e, n) {
        const i = t.previousIndex
        if (null === i) return i
        let s = 0
        return n && i < n.length && (s = n[i]), i + e + s
      }
      class tl {
        constructor() {}
        supports(t) {
          return t instanceof Map || Co(t)
        }
        create() {
          return new el()
        }
      }
      class el {
        constructor() {
          ;(this._records = new Map()),
            (this._mapHead = null),
            (this._appendAfter = null),
            (this._previousMapHead = null),
            (this._changesHead = null),
            (this._changesTail = null),
            (this._additionsHead = null),
            (this._additionsTail = null),
            (this._removalsHead = null),
            (this._removalsTail = null)
        }
        get isDirty() {
          return (
            null !== this._additionsHead ||
            null !== this._changesHead ||
            null !== this._removalsHead
          )
        }
        forEachItem(t) {
          let e
          for (e = this._mapHead; null !== e; e = e._next) t(e)
        }
        forEachPreviousItem(t) {
          let e
          for (e = this._previousMapHead; null !== e; e = e._nextPrevious) t(e)
        }
        forEachChangedItem(t) {
          let e
          for (e = this._changesHead; null !== e; e = e._nextChanged) t(e)
        }
        forEachAddedItem(t) {
          let e
          for (e = this._additionsHead; null !== e; e = e._nextAdded) t(e)
        }
        forEachRemovedItem(t) {
          let e
          for (e = this._removalsHead; null !== e; e = e._nextRemoved) t(e)
        }
        diff(t) {
          if (t) {
            if (!(t instanceof Map || Co(t)))
              throw new Error(
                `Error trying to diff '${st(
                  t
                )}'. Only maps and objects are allowed`
              )
          } else t = new Map()
          return this.check(t) ? this : null
        }
        onDestroy() {}
        check(t) {
          this._reset()
          let e = this._mapHead
          if (
            ((this._appendAfter = null),
            this._forEach(t, (t, n) => {
              if (e && e.key === n)
                this._maybeAddToChanges(e, t),
                  (this._appendAfter = e),
                  (e = e._next)
              else {
                const i = this._getOrCreateRecordForKey(n, t)
                e = this._insertBeforeOrAppend(e, i)
              }
            }),
            e)
          ) {
            e._prev && (e._prev._next = null), (this._removalsHead = e)
            for (let t = e; null !== t; t = t._nextRemoved)
              t === this._mapHead && (this._mapHead = null),
                this._records.delete(t.key),
                (t._nextRemoved = t._next),
                (t.previousValue = t.currentValue),
                (t.currentValue = null),
                (t._prev = null),
                (t._next = null)
          }
          return (
            this._changesTail && (this._changesTail._nextChanged = null),
            this._additionsTail && (this._additionsTail._nextAdded = null),
            this.isDirty
          )
        }
        _insertBeforeOrAppend(t, e) {
          if (t) {
            const n = t._prev
            return (
              (e._next = t),
              (e._prev = n),
              (t._prev = e),
              n && (n._next = e),
              t === this._mapHead && (this._mapHead = e),
              (this._appendAfter = t),
              t
            )
          }
          return (
            this._appendAfter
              ? ((this._appendAfter._next = e), (e._prev = this._appendAfter))
              : (this._mapHead = e),
            (this._appendAfter = e),
            null
          )
        }
        _getOrCreateRecordForKey(t, e) {
          if (this._records.has(t)) {
            const n = this._records.get(t)
            this._maybeAddToChanges(n, e)
            const i = n._prev,
              s = n._next
            return (
              i && (i._next = s),
              s && (s._prev = i),
              (n._next = null),
              (n._prev = null),
              n
            )
          }
          const n = new nl(t)
          return (
            this._records.set(t, n),
            (n.currentValue = e),
            this._addToAdditions(n),
            n
          )
        }
        _reset() {
          if (this.isDirty) {
            let t
            for (
              this._previousMapHead = this._mapHead, t = this._previousMapHead;
              null !== t;
              t = t._next
            )
              t._nextPrevious = t._next
            for (t = this._changesHead; null !== t; t = t._nextChanged)
              t.previousValue = t.currentValue
            for (t = this._additionsHead; null != t; t = t._nextAdded)
              t.previousValue = t.currentValue
            ;(this._changesHead = this._changesTail = null),
              (this._additionsHead = this._additionsTail = null),
              (this._removalsHead = null)
          }
        }
        _maybeAddToChanges(t, e) {
          Object.is(e, t.currentValue) ||
            ((t.previousValue = t.currentValue),
            (t.currentValue = e),
            this._addToChanges(t))
        }
        _addToAdditions(t) {
          null === this._additionsHead
            ? (this._additionsHead = this._additionsTail = t)
            : ((this._additionsTail._nextAdded = t), (this._additionsTail = t))
        }
        _addToChanges(t) {
          null === this._changesHead
            ? (this._changesHead = this._changesTail = t)
            : ((this._changesTail._nextChanged = t), (this._changesTail = t))
        }
        _forEach(t, e) {
          t instanceof Map
            ? t.forEach(e)
            : Object.keys(t).forEach((n) => e(t[n], n))
        }
      }
      class nl {
        constructor(t) {
          ;(this.key = t),
            (this.previousValue = null),
            (this.currentValue = null),
            (this._nextPrevious = null),
            (this._next = null),
            (this._prev = null),
            (this._nextAdded = null),
            (this._nextRemoved = null),
            (this._nextChanged = null)
        }
      }
      let il = (() => {
          class t {
            constructor(t) {
              this.factories = t
            }
            static create(e, n) {
              if (null != n) {
                const t = n.factories.slice()
                e = e.concat(t)
              }
              return new t(e)
            }
            static extend(e) {
              return {
                provide: t,
                useFactory: (n) => {
                  if (!n)
                    throw new Error(
                      'Cannot extend IterableDiffers without a parent injector'
                    )
                  return t.create(e, n)
                },
                deps: [[t, new ui(), new ci()]],
              }
            }
            find(t) {
              const e = this.factories.find((e) => e.supports(t))
              if (null != e) return e
              throw new Error(
                `Cannot find a differ supporting object '${t}' of type '${
                  ((n = t), n.name || typeof n)
                }'`
              )
              var n
            }
          }
          return (
            (t.ɵprov = ht({
              token: t,
              providedIn: 'root',
              factory: () => new t([new Ka()]),
            })),
            t
          )
        })(),
        sl = (() => {
          class t {
            constructor(t) {
              this.factories = t
            }
            static create(e, n) {
              if (n) {
                const t = n.factories.slice()
                e = e.concat(t)
              }
              return new t(e)
            }
            static extend(e) {
              return {
                provide: t,
                useFactory: (n) => {
                  if (!n)
                    throw new Error(
                      'Cannot extend KeyValueDiffers without a parent injector'
                    )
                  return t.create(e, n)
                },
                deps: [[t, new ui(), new ci()]],
              }
            }
            find(t) {
              const e = this.factories.find((e) => e.supports(t))
              if (e) return e
              throw new Error(`Cannot find a differ supporting object '${t}'`)
            }
          }
          return (
            (t.ɵprov = ht({
              token: t,
              providedIn: 'root',
              factory: () => new t([new tl()]),
            })),
            t
          )
        })()
      function rl(t, e, n, i, s = !1) {
        for (; null !== n; ) {
          const r = e[n.index]
          if ((null !== r && i.push(be(r)), te(r)))
            for (let t = Xt; t < r.length; t++) {
              const e = r[t],
                n = e[1].firstChild
              null !== n && rl(e[1], e, n, i)
            }
          const o = n.type
          if (8 & o) rl(t, e, n.child, i)
          else if (32 & o) {
            const t = ps(n, e)
            let s
            for (; (s = t()); ) i.push(s)
          } else if (16 & o) {
            const t = e[16],
              s = t[6].projection[n.projection]
            if (Array.isArray(s)) i.push(...s)
            else {
              const e = fs(t)
              rl(e[1], e, s, i, !0)
            }
          }
          n = s ? n.projectionNext : n.next
        }
        return i
      }
      class ol {
        constructor(t, e) {
          ;(this._lView = t),
            (this._cdRefInjectingView = e),
            (this._appRef = null),
            (this._viewContainerRef = null)
        }
        get rootNodes() {
          const t = this._lView,
            e = t[1]
          return rl(e, t, e.firstChild, [])
        }
        get context() {
          return this._lView[8]
        }
        get destroyed() {
          return 256 == (256 & this._lView[2])
        }
        destroy() {
          if (this._appRef) this._appRef.detachView(this)
          else if (this._viewContainerRef) {
            const t = this._viewContainerRef.indexOf(this)
            t > -1 && this._viewContainerRef.detach(t),
              (this._viewContainerRef = null)
          }
          Cs(this._lView[1], this._lView)
        }
        onDestroy(t) {
          vr(this._lView[1], this._lView, null, t)
        }
        markForCheck() {
          Lr(this._cdRefInjectingView || this._lView)
        }
        detach() {
          this._lView[2] &= -129
        }
        reattach() {
          this._lView[2] |= 128
        }
        detectChanges() {
          jr(this._lView[1], this._lView, this.context)
        }
        checkNoChanges() {
          !(function (t, e, n) {
            He(!0)
            try {
              jr(t, e, n)
            } finally {
              He(!1)
            }
          })(this._lView[1], this._lView, this.context)
        }
        attachToViewContainerRef(t) {
          if (this._appRef)
            throw new Error(
              'This view is already attached directly to the ApplicationRef!'
            )
          this._viewContainerRef = t
        }
        detachFromAppRef() {
          var t
          ;(this._appRef = null),
            Fs(this._lView[1], (t = this._lView), t[11], 2, null, null)
        }
        attachToAppRef(t) {
          if (this._viewContainerRef)
            throw new Error('This view is already attached to a ViewContainer!')
          this._appRef = t
        }
      }
      class al extends ol {
        constructor(t) {
          super(t), (this._view = t)
        }
        detectChanges() {
          Br(this._view)
        }
        checkNoChanges() {
          !(function (t) {
            He(!0)
            try {
              Br(t)
            } finally {
              He(!1)
            }
          })(this._view)
        }
        get context() {
          return null
        }
      }
      const ll = hl
      let cl = (() => {
        class t {}
        return (t.__NG_ELEMENT_ID__ = ll), (t.__ChangeDetectorRef__ = !0), t
      })()
      function hl(t = !1) {
        return (function (t, e, n) {
          if (!n && ne(t)) {
            const n = Ee(t.index, e)
            return new ol(n, n)
          }
          return 47 & t.type ? new ol(e[16], e) : null
        })(Le(), Ne(), t)
      }
      const ul = [new tl()],
        dl = new il([new Ka()]),
        pl = new sl(ul),
        fl = function () {
          return _l(Le(), Ne())
        }
      let ml = (() => {
        class t {}
        return (t.__NG_ELEMENT_ID__ = fl), t
      })()
      const gl = ml,
        yl = class extends gl {
          constructor(t, e, n) {
            super(),
              (this._declarationLView = t),
              (this._declarationTContainer = e),
              (this.elementRef = n)
          }
          createEmbeddedView(t) {
            const e = this._declarationTContainer.tViews,
              n = ar(
                this._declarationLView,
                e,
                t,
                16,
                null,
                e.declTNode,
                null,
                null,
                null,
                null
              )
            n[17] = this._declarationLView[this._declarationTContainer.index]
            const i = this._declarationLView[19]
            return (
              null !== i && (n[19] = i.createEmbeddedView(e)),
              hr(e, n, t),
              new ol(n)
            )
          }
        }
      function _l(t, e) {
        return 4 & t.type ? new yl(e, t, ja(t, e)) : null
      }
      class vl {}
      class bl {}
      const wl = function () {
        return Tl(Le(), Ne())
      }
      let Cl = (() => {
        class t {}
        return (t.__NG_ELEMENT_ID__ = wl), t
      })()
      const xl = Cl,
        Sl = class extends xl {
          constructor(t, e, n) {
            super(),
              (this._lContainer = t),
              (this._hostTNode = e),
              (this._hostLView = n)
          }
          get element() {
            return ja(this._hostTNode, this._hostLView)
          }
          get injector() {
            return new $n(this._hostTNode, this._hostLView)
          }
          get parentInjector() {
            const t = Dn(this._hostTNode, this._hostLView)
            if (Sn(t)) {
              const e = kn(t, this._hostLView),
                n = En(t)
              return new $n(e[1].data[n + 8], e)
            }
            return new $n(null, this._hostLView)
          }
          clear() {
            for (; this.length > 0; ) this.remove(this.length - 1)
          }
          get(t) {
            const e = El(this._lContainer)
            return (null !== e && e[t]) || null
          }
          get length() {
            return this._lContainer.length - Xt
          }
          createEmbeddedView(t, e, n) {
            const i = t.createEmbeddedView(e || {})
            return this.insert(i, n), i
          }
          createComponent(t, e, n, i, s) {
            const r = n || this.parentInjector
            if (!s && null == t.ngModule && r) {
              const t = r.get(vl, null)
              t && (s = t)
            }
            const o = t.create(r, i, void 0, s)
            return this.insert(o.hostView, e), o
          }
          insert(t, e) {
            const n = t._lView,
              i = n[1]
            if (te(n[3])) {
              const e = this.indexOf(t)
              if (-1 !== e) this.detach(e)
              else {
                const e = n[3],
                  i = new Sl(e, e[6], e[3])
                i.detach(i.indexOf(t))
              }
            }
            const s = this._adjustIndex(e),
              r = this._lContainer
            !(function (t, e, n, i) {
              const s = Xt + i,
                r = n.length
              i > 0 && (n[s - 1][4] = e),
                i < r - Xt
                  ? ((e[4] = n[s]), ni(n, Xt + i, e))
                  : (n.push(e), (e[4] = null)),
                (e[3] = n)
              const o = e[17]
              null !== o &&
                n !== o &&
                (function (t, e) {
                  const n = t[9]
                  e[16] !== e[3][3][16] && (t[2] = !0),
                    null === n ? (t[9] = [e]) : n.push(e)
                })(o, e)
              const a = e[19]
              null !== a && a.insertView(t), (e[2] |= 128)
            })(i, n, r, s)
            const o = Ds(s, r),
              a = n[11],
              l = As(a, r[7])
            return (
              null !== l &&
                (function (t, e, n, i, s, r) {
                  ;(i[0] = s), (i[6] = e), Fs(t, i, n, 1, s, r)
                })(i, r[6], a, n, l, o),
              t.attachToViewContainerRef(this),
              ni(kl(r), s, t),
              t
            )
          }
          move(t, e) {
            return this.insert(t, e)
          }
          indexOf(t) {
            const e = El(this._lContainer)
            return null !== e ? e.indexOf(t) : -1
          }
          remove(t) {
            const e = this._adjustIndex(t, -1),
              n = ws(this._lContainer, e)
            n && (ii(kl(this._lContainer), e), Cs(n[1], n))
          }
          detach(t) {
            const e = this._adjustIndex(t, -1),
              n = ws(this._lContainer, e)
            return n && null != ii(kl(this._lContainer), e) ? new ol(n) : null
          }
          _adjustIndex(t, e = 0) {
            return null == t ? this.length + e : t
          }
        }
      function El(t) {
        return t[8]
      }
      function kl(t) {
        return t[8] || (t[8] = [])
      }
      function Tl(t, e) {
        let n
        const i = e[t.index]
        if (te(i)) n = i
        else {
          let s
          if (8 & t.type) s = be(i)
          else {
            const n = e[11]
            s = n.createComment('')
            const i = Ce(t, e)
            Es(
              n,
              As(n, i),
              s,
              (function (t, e) {
                return _e(t) ? t.nextSibling(e) : e.nextSibling
              })(n, i),
              !1
            )
          }
          ;(e[t.index] = n = Pr(i, e, s, t)), Mr(e, n)
        }
        return new Sl(n, t, e)
      }
      const Al = {}
      class Ol extends Ma {
        constructor(t) {
          super(), (this.ngModule = t)
        }
        resolveComponentFactory(t) {
          const e = Qt(t)
          return new Pl(e, this.ngModule)
        }
      }
      function Il(t) {
        const e = []
        for (let n in t)
          t.hasOwnProperty(n) && e.push({ propName: t[n], templateName: n })
        return e
      }
      const Rl = new Yn('SCHEDULER_TOKEN', {
        providedIn: 'root',
        factory: () => ls,
      })
      class Pl extends Na {
        constructor(t, e) {
          super(),
            (this.componentDef = t),
            (this.ngModule = e),
            (this.componentType = t.type),
            (this.selector = t.selectors.map(Zs).join(',')),
            (this.ngContentSelectors = t.ngContentSelectors
              ? t.ngContentSelectors
              : []),
            (this.isBoundToModule = !!e)
        }
        get inputs() {
          return Il(this.componentDef.inputs)
        }
        get outputs() {
          return Il(this.componentDef.outputs)
        }
        create(t, e, n, i) {
          const s = (i = i || this.ngModule)
              ? (function (t, e) {
                  return {
                    get: (n, i, s) => {
                      const r = t.get(n, Al, s)
                      return r !== Al || i === Al ? r : e.get(n, i, s)
                    },
                  }
                })(t, i.injector)
              : t,
            r = s.get(Ua, ve),
            o = s.get(qa, null),
            a = r.createRenderer(null, this.componentDef),
            l = this.componentDef.selectors[0][0] || 'div',
            c = n
              ? (function (t, e, n) {
                  if (_e(t)) return t.selectRootElement(e, n === Et.ShadowDom)
                  let i = 'string' == typeof e ? t.querySelector(e) : e
                  return (i.textContent = ''), i
                })(a, n, this.componentDef.encapsulation)
              : vs(
                  r.createRenderer(null, this.componentDef),
                  l,
                  (function (t) {
                    const e = t.toLowerCase()
                    return 'svg' === e
                      ? ge
                      : 'math' === e
                      ? 'http://www.w3.org/1998/MathML/'
                      : null
                  })(l)
                ),
            h = this.componentDef.onPush ? 576 : 528,
            u = {
              components: [],
              scheduler: ls,
              clean: Ur,
              playerHandler: null,
              flags: 0,
            },
            d = _r(0, null, null, 1, 0, null, null, null, null, null),
            p = ar(null, d, u, h, null, null, r, a, o, s)
          let f, m
          tn(p)
          try {
            const t = (function (t, e, n, i, s, r) {
              const o = n[1]
              n[20] = t
              const a = lr(o, 20, 2, '#host', null),
                l = (a.mergedAttrs = e.hostAttrs)
              null !== l &&
                (Kr(a, l, !0),
                null !== t &&
                  (vn(s, t, l),
                  null !== a.classes && js(s, t, a.classes),
                  null !== a.styles && Ls(s, t, a.styles)))
              const c = i.createRenderer(t, e),
                h = ar(
                  n,
                  yr(e),
                  null,
                  e.onPush ? 64 : 16,
                  n[20],
                  a,
                  i,
                  c,
                  null,
                  null
                )
              return (
                o.firstCreatePass &&
                  (Nn(In(a, n), o, e.type), Er(o, a), Tr(a, n.length, 1)),
                Mr(n, h),
                (n[20] = h)
              )
            })(c, this.componentDef, p, r, a)
            if (c)
              if (n) vn(a, c, ['ng-version', Wa.full])
              else {
                const { attrs: t, classes: e } = (function (t) {
                  const e = [],
                    n = []
                  let i = 1,
                    s = 2
                  for (; i < t.length; ) {
                    let r = t[i]
                    if ('string' == typeof r)
                      2 === s
                        ? '' !== r && e.push(r, t[++i])
                        : 8 === s && n.push(r)
                    else {
                      if (!$s(s)) break
                      s = r
                    }
                    i++
                  }
                  return { attrs: e, classes: n }
                })(this.componentDef.selectors[0])
                t && vn(a, c, t), e && e.length > 0 && js(a, c, e.join(' '))
              }
            if (((m = xe(d, Yt)), void 0 !== e)) {
              const t = (m.projection = [])
              for (let n = 0; n < this.ngContentSelectors.length; n++) {
                const i = e[n]
                t.push(null != i ? Array.from(i) : null)
              }
            }
            ;(f = (function (t, e, n, i, s) {
              const r = n[1],
                o = (function (t, e, n) {
                  const i = Le()
                  t.firstCreatePass &&
                    (n.providersResolver && n.providersResolver(n),
                    Ar(t, i, e, cr(t, e, 1, null), n))
                  const s = zn(e, t, i.directiveStart, i)
                  as(s, e)
                  const r = Ce(i, e)
                  return r && as(r, e), s
                })(r, n, e)
              if (
                (i.components.push(o),
                (t[8] = o),
                s && s.forEach((t) => t(o, e)),
                e.contentQueries)
              ) {
                const t = Le()
                e.contentQueries(1, o, t.directiveStart)
              }
              const a = Le()
              return (
                !r.firstCreatePass ||
                  (null === e.hostBindings && null === e.hostAttrs) ||
                  (ln(a.index),
                  xr(n[1], a, 0, a.directiveStart, a.directiveEnd, e),
                  Sr(e, o)),
                o
              )
            })(t, this.componentDef, p, u, [uo])),
              hr(d, p, null)
          } finally {
            on()
          }
          return new Dl(this.componentType, f, ja(m, p), p, m)
        }
      }
      class Dl extends class {} {
        constructor(t, e, n, i, s) {
          super(),
            (this.location = n),
            (this._rootLView = i),
            (this._tNode = s),
            (this.instance = e),
            (this.hostView = this.changeDetectorRef = new al(i)),
            (this.componentType = t)
        }
        get injector() {
          return new $n(this._tNode, this._rootLView)
        }
        destroy() {
          this.hostView.destroy()
        }
        onDestroy(t) {
          this.hostView.onDestroy(t)
        }
      }
      const Nl = new Map()
      class Fl extends vl {
        constructor(t, e) {
          super(),
            (this._parent = e),
            (this._bootstrapComponents = []),
            (this.injector = this),
            (this.destroyCbs = []),
            (this.componentFactoryResolver = new Ol(this))
          const n = Zt(t),
            i = t[Lt] || null
          i && Ea(i),
            (this._bootstrapComponents = us(n.bootstrap)),
            (this._r3Injector = no(
              t,
              e,
              [
                { provide: vl, useValue: this },
                { provide: Ma, useValue: this.componentFactoryResolver },
              ],
              st(t)
            )),
            this._r3Injector._resolveInjectorDefTypes(),
            (this.instance = this.get(t))
        }
        get(t, e = ho.THROW_IF_NOT_FOUND, n = vt.Default) {
          return t === ho || t === vl || t === Gr
            ? this
            : this._r3Injector.get(t, e, n)
        }
        destroy() {
          const t = this._r3Injector
          !t.destroyed && t.destroy(),
            this.destroyCbs.forEach((t) => t()),
            (this.destroyCbs = null)
        }
        onDestroy(t) {
          this.destroyCbs.push(t)
        }
      }
      class Ml extends bl {
        constructor(t) {
          super(),
            (this.moduleType = t),
            null !== Zt(t) &&
              (function (t) {
                const e = new Set()
                !(function t(n) {
                  const i = Zt(n, !0),
                    s = i.id
                  null !== s &&
                    ((function (t, e, n) {
                      if (e && e !== n)
                        throw new Error(
                          `Duplicate module registered for ${t} - ${st(
                            e
                          )} vs ${st(e.name)}`
                        )
                    })(s, Nl.get(s), n),
                    Nl.set(s, n))
                  const r = us(i.imports)
                  for (const o of r) e.has(o) || (e.add(o), t(o))
                })(t)
              })(t)
        }
        create(t) {
          return new Fl(this.moduleType, t)
        }
      }
      function Ll(t, e, n, i, s) {
        return (function (t, e, n, i, s, r, o) {
          const a = e + n
          return (function (t, e, n, i) {
            const s = So(t, e, n)
            return So(t, e + 1, i) || s
          })(t, a, s, r)
            ? xo(t, a + 2, o ? i.call(o, s, r) : i(s, r))
            : jl(t, a + 2)
        })(Ne(), qe(), t, e, n, i, s)
      }
      function jl(t, e) {
        const n = t[e]
        return n === Ys ? void 0 : n
      }
      function Bl(t, e, n, i, s, r) {
        const o = e + n
        return So(t, o, s)
          ? xo(t, o + 1, r ? i.call(r, s) : i(s))
          : jl(t, o + 1)
      }
      function Vl(t, e) {
        const n = Fe()
        let i
        const s = t + Yt
        n.firstCreatePass
          ? ((i = (function (t, e) {
              if (e)
                for (let n = e.length - 1; n >= 0; n--) {
                  const i = e[n]
                  if (t === i.name) return i
                }
              throw new oe('302', `The pipe '${t}' could not be found!`)
            })(e, n.pipeRegistry)),
            (n.data[s] = i),
            i.onDestroy &&
              (n.destroyHooks || (n.destroyHooks = [])).push(s, i.onDestroy))
          : (i = n.data[s])
        const r = i.factory || (i.factory = re(i.type)),
          o = wt(Ao)
        try {
          const t = An(!1),
            e = r()
          return (
            An(t),
            (function (t, e, n, i) {
              n >= t.data.length &&
                ((t.data[n] = null), (t.blueprint[n] = null)),
                (e[n] = i)
            })(n, Ne(), s, e),
            e
          )
        } finally {
          wt(o)
        }
      }
      function Ul(t, e, n) {
        const i = t + Yt,
          s = Ne(),
          r = Se(s, i)
        return (function (t, e) {
          return (
            bo.isWrapped(e) &&
              ((e = bo.unwrap(e)), (t[Pe.lFrame.bindingIndex] = Ys)),
            e
          )
        })(
          s,
          (function (t, e) {
            return t[1].data[e].pure
          })(s, i)
            ? Bl(s, qe(), e, r.transform, n, r)
            : r.transform(n)
        )
      }
      const zl = class extends x {
        constructor(t = !1) {
          super(), (this.__isAsync = t)
        }
        emit(t) {
          super.next(t)
        }
        subscribe(t, e, n) {
          let i,
            s = (t) => null,
            r = () => null
          t && 'object' == typeof t
            ? ((i = this.__isAsync
                ? (e) => {
                    setTimeout(() => t.next(e))
                  }
                : (e) => {
                    t.next(e)
                  }),
              t.error &&
                (s = this.__isAsync
                  ? (e) => {
                      setTimeout(() => t.error(e))
                    }
                  : (e) => {
                      t.error(e)
                    }),
              t.complete &&
                (r = this.__isAsync
                  ? () => {
                      setTimeout(() => t.complete())
                    }
                  : () => {
                      t.complete()
                    }))
            : ((i = this.__isAsync
                ? (e) => {
                    setTimeout(() => t(e))
                  }
                : (e) => {
                    t(e)
                  }),
              e &&
                (s = this.__isAsync
                  ? (t) => {
                      setTimeout(() => e(t))
                    }
                  : (t) => {
                      e(t)
                    }),
              n &&
                (r = this.__isAsync
                  ? () => {
                      setTimeout(() => n())
                    }
                  : () => {
                      n()
                    }))
          const o = super.subscribe(i, s, r)
          return t instanceof u && t.add(o), o
        }
      }
      function Hl() {
        return this._results[vo()]()
      }
      class ql {
        constructor() {
          ;(this.dirty = !0),
            (this._results = []),
            (this.changes = new zl()),
            (this.length = 0)
          const t = vo(),
            e = ql.prototype
          e[t] || (e[t] = Hl)
        }
        map(t) {
          return this._results.map(t)
        }
        filter(t) {
          return this._results.filter(t)
        }
        find(t) {
          return this._results.find(t)
        }
        reduce(t, e) {
          return this._results.reduce(t, e)
        }
        forEach(t) {
          this._results.forEach(t)
        }
        some(t) {
          return this._results.some(t)
        }
        toArray() {
          return this._results.slice()
        }
        toString() {
          return this._results.toString()
        }
        reset(t) {
          ;(this._results = ti(t)),
            (this.dirty = !1),
            (this.length = this._results.length),
            (this.last = this._results[this.length - 1]),
            (this.first = this._results[0])
        }
        notifyOnChanges() {
          this.changes.emit(this)
        }
        setDirty() {
          this.dirty = !0
        }
        destroy() {
          this.changes.complete(), this.changes.unsubscribe()
        }
      }
      class $l {
        constructor(t) {
          ;(this.queryList = t), (this.matches = null)
        }
        clone() {
          return new $l(this.queryList)
        }
        setDirty() {
          this.queryList.setDirty()
        }
      }
      class Wl {
        constructor(t = []) {
          this.queries = t
        }
        createEmbeddedView(t) {
          const e = t.queries
          if (null !== e) {
            const n =
                null !== t.contentQueries ? t.contentQueries[0] : e.length,
              i = []
            for (let t = 0; t < n; t++) {
              const n = e.getByIndex(t)
              i.push(this.queries[n.indexInDeclarationView].clone())
            }
            return new Wl(i)
          }
          return null
        }
        insertView(t) {
          this.dirtyQueriesWithMatches(t)
        }
        detachView(t) {
          this.dirtyQueriesWithMatches(t)
        }
        dirtyQueriesWithMatches(t) {
          for (let e = 0; e < this.queries.length; e++)
            null !== oc(t, e).matches && this.queries[e].setDirty()
        }
      }
      class Kl {
        constructor(t, e, n, i = null) {
          ;(this.predicate = t),
            (this.descendants = e),
            (this.isStatic = n),
            (this.read = i)
        }
      }
      class Gl {
        constructor(t = []) {
          this.queries = t
        }
        elementStart(t, e) {
          for (let n = 0; n < this.queries.length; n++)
            this.queries[n].elementStart(t, e)
        }
        elementEnd(t) {
          for (let e = 0; e < this.queries.length; e++)
            this.queries[e].elementEnd(t)
        }
        embeddedTView(t) {
          let e = null
          for (let n = 0; n < this.length; n++) {
            const i = null !== e ? e.length : 0,
              s = this.getByIndex(n).embeddedTView(t, i)
            s &&
              ((s.indexInDeclarationView = n),
              null !== e ? e.push(s) : (e = [s]))
          }
          return null !== e ? new Gl(e) : null
        }
        template(t, e) {
          for (let n = 0; n < this.queries.length; n++)
            this.queries[n].template(t, e)
        }
        getByIndex(t) {
          return this.queries[t]
        }
        get length() {
          return this.queries.length
        }
        track(t) {
          this.queries.push(t)
        }
      }
      class Ql {
        constructor(t, e = -1) {
          ;(this.metadata = t),
            (this.matches = null),
            (this.indexInDeclarationView = -1),
            (this.crossesNgTemplate = !1),
            (this._appliesToNextNode = !0),
            (this._declarationNodeIndex = e)
        }
        elementStart(t, e) {
          this.isApplyingToNode(e) && this.matchTNode(t, e)
        }
        elementEnd(t) {
          this._declarationNodeIndex === t.index &&
            (this._appliesToNextNode = !1)
        }
        template(t, e) {
          this.elementStart(t, e)
        }
        embeddedTView(t, e) {
          return this.isApplyingToNode(t)
            ? ((this.crossesNgTemplate = !0),
              this.addMatch(-t.index, e),
              new Ql(this.metadata))
            : null
        }
        isApplyingToNode(t) {
          if (this._appliesToNextNode && !1 === this.metadata.descendants) {
            const e = this._declarationNodeIndex
            let n = t.parent
            for (; null !== n && 8 & n.type && n.index !== e; ) n = n.parent
            return e === (null !== n ? n.index : -1)
          }
          return this._appliesToNextNode
        }
        matchTNode(t, e) {
          const n = this.metadata.predicate
          if (Array.isArray(n))
            for (let i = 0; i < n.length; i++) {
              const s = n[i]
              this.matchTNodeWithReadOption(t, e, Zl(e, s)),
                this.matchTNodeWithReadOption(t, e, Un(e, t, s, !1, !1))
            }
          else
            n === ml
              ? 4 & e.type && this.matchTNodeWithReadOption(t, e, -1)
              : this.matchTNodeWithReadOption(t, e, Un(e, t, n, !1, !1))
        }
        matchTNodeWithReadOption(t, e, n) {
          if (null !== n) {
            const i = this.metadata.read
            if (null !== i)
              if (i === Va || i === Cl || (i === ml && 4 & e.type))
                this.addMatch(e.index, -2)
              else {
                const n = Un(e, t, i, !1, !1)
                null !== n && this.addMatch(e.index, n)
              }
            else this.addMatch(e.index, n)
          }
        }
        addMatch(t, e) {
          null === this.matches
            ? (this.matches = [t, e])
            : this.matches.push(t, e)
        }
      }
      function Zl(t, e) {
        const n = t.localNames
        if (null !== n)
          for (let i = 0; i < n.length; i += 2) if (n[i] === e) return n[i + 1]
        return null
      }
      function Yl(t, e, n, i) {
        return -1 === n
          ? (function (t, e) {
              return 11 & t.type ? ja(t, e) : 4 & t.type ? _l(t, e) : null
            })(e, t)
          : -2 === n
          ? (function (t, e, n) {
              return n === Va
                ? ja(e, t)
                : n === ml
                ? _l(e, t)
                : n === Cl
                ? Tl(e, t)
                : void 0
            })(t, e, i)
          : zn(t, t[1], n, e)
      }
      function Xl(t, e, n, i) {
        const s = e[19].queries[i]
        if (null === s.matches) {
          const i = t.data,
            r = n.matches,
            o = []
          for (let t = 0; t < r.length; t += 2) {
            const s = r[t]
            o.push(s < 0 ? null : Yl(e, i[s], r[t + 1], n.metadata.read))
          }
          s.matches = o
        }
        return s.matches
      }
      function Jl(t, e, n, i) {
        const s = t.queries.getByIndex(n),
          r = s.matches
        if (null !== r) {
          const o = Xl(t, e, s, n)
          for (let t = 0; t < r.length; t += 2) {
            const n = r[t]
            if (n > 0) i.push(o[t / 2])
            else {
              const s = r[t + 1],
                o = e[-n]
              for (let t = Xt; t < o.length; t++) {
                const e = o[t]
                e[17] === e[3] && Jl(e[1], e, s, i)
              }
              if (null !== o[9]) {
                const t = o[9]
                for (let e = 0; e < t.length; e++) {
                  const n = t[e]
                  Jl(n[1], n, s, i)
                }
              }
            }
          }
        }
        return i
      }
      function tc(t) {
        const e = Ne(),
          n = Fe(),
          i = Ze()
        Ye(i + 1)
        const s = oc(n, i)
        if (t.dirty && Te(e) === s.metadata.isStatic) {
          if (null === s.matches) t.reset([])
          else {
            const r = s.crossesNgTemplate ? Jl(n, e, i, []) : Xl(n, e, s, i)
            t.reset(r), t.notifyOnChanges()
          }
          return !0
        }
        return !1
      }
      function ec(t, e, n) {
        !(function (t, e, n, i, s, r) {
          t.firstCreatePass && rc(t, new Kl(n, i, false, s), -1), sc(t, e)
        })(Fe(), Ne(), t, e, n)
      }
      function nc(t, e, n, i) {
        !(function (t, e, n, i, s, r, o, a) {
          t.firstCreatePass &&
            (rc(t, new Kl(n, i, false, s), o.index),
            (function (t, e) {
              const n = t.contentQueries || (t.contentQueries = [])
              e !== (n.length ? n[n.length - 1] : -1) &&
                n.push(t.queries.length - 1, e)
            })(t, a)),
            sc(t, e)
        })(Fe(), Ne(), e, n, i, 0, Le(), t)
      }
      function ic() {
        return (t = Ne()), (e = Ze()), t[19].queries[e].queryList
        var t, e
      }
      function sc(t, e) {
        const n = new ql()
        vr(t, e, n, n.destroy),
          null === e[19] && (e[19] = new Wl()),
          e[19].queries.push(new $l(n))
      }
      function rc(t, e, n) {
        null === t.queries && (t.queries = new Gl()),
          t.queries.track(new Ql(e, n))
      }
      function oc(t, e) {
        return t.queries.getByIndex(e)
      }
      function ac(t, e) {
        return _l(t, e)
      }
      const lc = new Yn('Application Initializer')
      let cc = (() => {
        class t {
          constructor(t) {
            ;(this.appInits = t),
              (this.resolve = La),
              (this.reject = La),
              (this.initialized = !1),
              (this.done = !1),
              (this.donePromise = new Promise((t, e) => {
                ;(this.resolve = t), (this.reject = e)
              }))
          }
          runInitializers() {
            if (this.initialized) return
            const t = [],
              e = () => {
                ;(this.done = !0), this.resolve()
              }
            if (this.appInits)
              for (let n = 0; n < this.appInits.length; n++) {
                const e = this.appInits[n]()
                Lo(e) && t.push(e)
              }
            Promise.all(t)
              .then(() => {
                e()
              })
              .catch((t) => {
                this.reject(t)
              }),
              0 === t.length && e(),
              (this.initialized = !0)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(lc, 8))
          }),
          (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      const hc = new Yn('AppId'),
        uc = {
          provide: hc,
          useFactory: function () {
            return `${dc()}${dc()}${dc()}`
          },
          deps: [],
        }
      function dc() {
        return String.fromCharCode(97 + Math.floor(25 * Math.random()))
      }
      const pc = new Yn('Platform Initializer'),
        fc = new Yn('Platform ID'),
        mc = new Yn('appBootstrapListener')
      let gc = (() => {
        class t {
          log(t) {
            console.log(t)
          }
          warn(t) {
            console.warn(t)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      const yc = new Yn('LocaleId'),
        _c = new Yn('DefaultCurrencyCode')
      class vc {
        constructor(t, e) {
          ;(this.ngModuleFactory = t), (this.componentFactories = e)
        }
      }
      const bc = function (t) {
          return new Ml(t)
        },
        wc = bc,
        Cc = function (t) {
          return Promise.resolve(bc(t))
        },
        xc = function (t) {
          const e = bc(t),
            n = us(Zt(t).declarations).reduce((t, e) => {
              const n = Qt(e)
              return n && t.push(new Pl(n)), t
            }, [])
          return new vc(e, n)
        },
        Sc = xc,
        Ec = function (t) {
          return Promise.resolve(xc(t))
        }
      let kc = (() => {
        class t {
          constructor() {
            ;(this.compileModuleSync = wc),
              (this.compileModuleAsync = Cc),
              (this.compileModuleAndAllComponentsSync = Sc),
              (this.compileModuleAndAllComponentsAsync = Ec)
          }
          clearCache() {}
          clearCacheFor(t) {}
          getModuleId(t) {}
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      const Tc = (() => Promise.resolve(0))()
      function Ac(t) {
        'undefined' == typeof Zone
          ? Tc.then(() => {
              t && t.apply(null, null)
            })
          : Zone.current.scheduleMicroTask('scheduleMicrotask', t)
      }
      class Oc {
        constructor({
          enableLongStackTrace: t = !1,
          shouldCoalesceEventChangeDetection: e = !1,
        }) {
          if (
            ((this.hasPendingMacrotasks = !1),
            (this.hasPendingMicrotasks = !1),
            (this.isStable = !0),
            (this.onUnstable = new zl(!1)),
            (this.onMicrotaskEmpty = new zl(!1)),
            (this.onStable = new zl(!1)),
            (this.onError = new zl(!1)),
            'undefined' == typeof Zone)
          )
            throw new Error('In this configuration Angular requires Zone.js')
          Zone.assertZonePatched()
          const n = this
          ;(n._nesting = 0),
            (n._outer = n._inner = Zone.current),
            Zone.TaskTrackingZoneSpec &&
              (n._inner = n._inner.fork(new Zone.TaskTrackingZoneSpec())),
            t &&
              Zone.longStackTraceZoneSpec &&
              (n._inner = n._inner.fork(Zone.longStackTraceZoneSpec)),
            (n.shouldCoalesceEventChangeDetection = e),
            (n.lastRequestAnimationFrameId = -1),
            (n.nativeRequestAnimationFrame = (function () {
              let t = It.requestAnimationFrame,
                e = It.cancelAnimationFrame
              if ('undefined' != typeof Zone && t && e) {
                const n = t[Zone.__symbol__('OriginalDelegate')]
                n && (t = n)
                const i = e[Zone.__symbol__('OriginalDelegate')]
                i && (e = i)
              }
              return {
                nativeRequestAnimationFrame: t,
                nativeCancelAnimationFrame: e,
              }
            })().nativeRequestAnimationFrame),
            (function (t) {
              const e =
                !!t.shouldCoalesceEventChangeDetection &&
                t.nativeRequestAnimationFrame &&
                (() => {
                  !(function (t) {
                    ;-1 === t.lastRequestAnimationFrameId &&
                      ((t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(
                        It,
                        () => {
                          t.fakeTopEventTask ||
                            (t.fakeTopEventTask = Zone.root.scheduleEventTask(
                              'fakeTopEventTask',
                              () => {
                                ;(t.lastRequestAnimationFrameId = -1),
                                  Pc(t),
                                  Rc(t)
                              },
                              void 0,
                              () => {},
                              () => {}
                            )),
                            t.fakeTopEventTask.invoke()
                        }
                      )),
                      Pc(t))
                  })(t)
                })
              t._inner = t._inner.fork({
                name: 'angular',
                properties: { isAngularZone: !0, maybeDelayChangeDetection: e },
                onInvokeTask: (n, i, s, r, o, a) => {
                  try {
                    return Dc(t), n.invokeTask(s, r, o, a)
                  } finally {
                    e && 'eventTask' === r.type && e(), Nc(t)
                  }
                },
                onInvoke: (e, n, i, s, r, o, a) => {
                  try {
                    return Dc(t), e.invoke(i, s, r, o, a)
                  } finally {
                    Nc(t)
                  }
                },
                onHasTask: (e, n, i, s) => {
                  e.hasTask(i, s),
                    n === i &&
                      ('microTask' == s.change
                        ? ((t._hasPendingMicrotasks = s.microTask),
                          Pc(t),
                          Rc(t))
                        : 'macroTask' == s.change &&
                          (t.hasPendingMacrotasks = s.macroTask))
                },
                onHandleError: (e, n, i, s) => (
                  e.handleError(i, s),
                  t.runOutsideAngular(() => t.onError.emit(s)),
                  !1
                ),
              })
            })(n)
        }
        static isInAngularZone() {
          return !0 === Zone.current.get('isAngularZone')
        }
        static assertInAngularZone() {
          if (!Oc.isInAngularZone())
            throw new Error('Expected to be in Angular Zone, but it is not!')
        }
        static assertNotInAngularZone() {
          if (Oc.isInAngularZone())
            throw new Error('Expected to not be in Angular Zone, but it is!')
        }
        run(t, e, n) {
          return this._inner.run(t, e, n)
        }
        runTask(t, e, n, i) {
          const s = this._inner,
            r = s.scheduleEventTask('NgZoneEvent: ' + i, t, Ic, La, La)
          try {
            return s.runTask(r, e, n)
          } finally {
            s.cancelTask(r)
          }
        }
        runGuarded(t, e, n) {
          return this._inner.runGuarded(t, e, n)
        }
        runOutsideAngular(t) {
          return this._outer.run(t)
        }
      }
      const Ic = {}
      function Rc(t) {
        if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable)
          try {
            t._nesting++, t.onMicrotaskEmpty.emit(null)
          } finally {
            if ((t._nesting--, !t.hasPendingMicrotasks))
              try {
                t.runOutsideAngular(() => t.onStable.emit(null))
              } finally {
                t.isStable = !0
              }
          }
      }
      function Pc(t) {
        t.hasPendingMicrotasks = !!(
          t._hasPendingMicrotasks ||
          (t.shouldCoalesceEventChangeDetection &&
            -1 !== t.lastRequestAnimationFrameId)
        )
      }
      function Dc(t) {
        t._nesting++, t.isStable && ((t.isStable = !1), t.onUnstable.emit(null))
      }
      function Nc(t) {
        t._nesting--, Rc(t)
      }
      class Fc {
        constructor() {
          ;(this.hasPendingMicrotasks = !1),
            (this.hasPendingMacrotasks = !1),
            (this.isStable = !0),
            (this.onUnstable = new zl()),
            (this.onMicrotaskEmpty = new zl()),
            (this.onStable = new zl()),
            (this.onError = new zl())
        }
        run(t, e, n) {
          return t.apply(e, n)
        }
        runGuarded(t, e, n) {
          return t.apply(e, n)
        }
        runOutsideAngular(t) {
          return t()
        }
        runTask(t, e, n, i) {
          return t.apply(e, n)
        }
      }
      let Mc = (() => {
          class t {
            constructor(t) {
              ;(this._ngZone = t),
                (this._pendingCount = 0),
                (this._isZoneStable = !0),
                (this._didWork = !1),
                (this._callbacks = []),
                (this.taskTrackingZone = null),
                this._watchAngularEvents(),
                t.run(() => {
                  this.taskTrackingZone =
                    'undefined' == typeof Zone
                      ? null
                      : Zone.current.get('TaskTrackingZone')
                })
            }
            _watchAngularEvents() {
              this._ngZone.onUnstable.subscribe({
                next: () => {
                  ;(this._didWork = !0), (this._isZoneStable = !1)
                },
              }),
                this._ngZone.runOutsideAngular(() => {
                  this._ngZone.onStable.subscribe({
                    next: () => {
                      Oc.assertNotInAngularZone(),
                        Ac(() => {
                          ;(this._isZoneStable = !0),
                            this._runCallbacksIfReady()
                        })
                    },
                  })
                })
            }
            increasePendingRequestCount() {
              return (
                (this._pendingCount += 1),
                (this._didWork = !0),
                this._pendingCount
              )
            }
            decreasePendingRequestCount() {
              if (((this._pendingCount -= 1), this._pendingCount < 0))
                throw new Error('pending async requests below zero')
              return this._runCallbacksIfReady(), this._pendingCount
            }
            isStable() {
              return (
                this._isZoneStable &&
                0 === this._pendingCount &&
                !this._ngZone.hasPendingMacrotasks
              )
            }
            _runCallbacksIfReady() {
              if (this.isStable())
                Ac(() => {
                  for (; 0 !== this._callbacks.length; ) {
                    let t = this._callbacks.pop()
                    clearTimeout(t.timeoutId), t.doneCb(this._didWork)
                  }
                  this._didWork = !1
                })
              else {
                let t = this.getPendingTasks()
                ;(this._callbacks = this._callbacks.filter(
                  (e) =>
                    !e.updateCb ||
                    !e.updateCb(t) ||
                    (clearTimeout(e.timeoutId), !1)
                )),
                  (this._didWork = !0)
              }
            }
            getPendingTasks() {
              return this.taskTrackingZone
                ? this.taskTrackingZone.macroTasks.map((t) => ({
                    source: t.source,
                    creationLocation: t.creationLocation,
                    data: t.data,
                  }))
                : []
            }
            addCallback(t, e, n) {
              let i = -1
              e &&
                e > 0 &&
                (i = setTimeout(() => {
                  ;(this._callbacks = this._callbacks.filter(
                    (t) => t.timeoutId !== i
                  )),
                    t(this._didWork, this.getPendingTasks())
                }, e)),
                this._callbacks.push({ doneCb: t, timeoutId: i, updateCb: n })
            }
            whenStable(t, e, n) {
              if (n && !this.taskTrackingZone)
                throw new Error(
                  'Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?'
                )
              this.addCallback(t, e, n), this._runCallbacksIfReady()
            }
            getPendingRequestCount() {
              return this._pendingCount
            }
            findProviders(t, e, n) {
              return []
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(Oc))
            }),
            (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        Lc = (() => {
          class t {
            constructor() {
              ;(this._applications = new Map()), Vc.addToWindow(this)
            }
            registerApplication(t, e) {
              this._applications.set(t, e)
            }
            unregisterApplication(t) {
              this._applications.delete(t)
            }
            unregisterAllApplications() {
              this._applications.clear()
            }
            getTestability(t) {
              return this._applications.get(t) || null
            }
            getAllTestabilities() {
              return Array.from(this._applications.values())
            }
            getAllRootElements() {
              return Array.from(this._applications.keys())
            }
            findTestabilityInTree(t, e = !0) {
              return Vc.findTestabilityInTree(this, t, e)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
            t
          )
        })()
      class jc {
        addToWindow(t) {}
        findTestabilityInTree(t, e, n) {
          return null
        }
      }
      let Bc,
        Vc = new jc(),
        Uc = !0,
        zc = !1
      function Hc() {
        return (zc = !0), Uc
      }
      const qc = new Yn('AllowMultipleToken')
      class $c {
        constructor(t, e) {
          ;(this.name = t), (this.token = e)
        }
      }
      function Wc(t, e, n = []) {
        const i = 'Platform: ' + e,
          s = new Yn(i)
        return (e = []) => {
          let r = Kc()
          if (!r || r.injector.get(qc, !1))
            if (t) t(n.concat(e).concat({ provide: s, useValue: !0 }))
            else {
              const t = n
                .concat(e)
                .concat(
                  { provide: s, useValue: !0 },
                  { provide: Zr, useValue: 'platform' }
                )
              !(function (t) {
                if (Bc && !Bc.destroyed && !Bc.injector.get(qc, !1))
                  throw new Error(
                    'There can be only one platform. Destroy the previous one to create a new one.'
                  )
                Bc = t.get(Gc)
                const e = t.get(pc, null)
                e && e.forEach((t) => t())
              })(ho.create({ providers: t, name: i }))
            }
          return (function (t) {
            const e = Kc()
            if (!e) throw new Error('No platform exists!')
            if (!e.injector.get(t, null))
              throw new Error(
                'A platform with a different configuration has been created. Please destroy it first.'
              )
            return e
          })(s)
        }
      }
      function Kc() {
        return Bc && !Bc.destroyed ? Bc : null
      }
      let Gc = (() => {
        class t {
          constructor(t) {
            ;(this._injector = t),
              (this._modules = []),
              (this._destroyListeners = []),
              (this._destroyed = !1)
          }
          bootstrapModuleFactory(t, e) {
            const n = (function (t, e) {
                let n
                return (
                  (n =
                    'noop' === t
                      ? new Fc()
                      : ('zone.js' === t ? void 0 : t) ||
                        new Oc({
                          enableLongStackTrace: Hc(),
                          shouldCoalesceEventChangeDetection: e,
                        })),
                  n
                )
              })(e ? e.ngZone : void 0, (e && e.ngZoneEventCoalescing) || !1),
              i = [{ provide: Oc, useValue: n }]
            return n.run(() => {
              const e = ho.create({
                  providers: i,
                  parent: this.injector,
                  name: t.moduleType.name,
                }),
                s = t.create(e),
                r = s.injector.get(os, null)
              if (!r)
                throw new Error(
                  'No ErrorHandler. Is platform module (BrowserModule) included?'
                )
              return (
                n.runOutsideAngular(() => {
                  const t = n.onError.subscribe({
                    next: (t) => {
                      r.handleError(t)
                    },
                  })
                  s.onDestroy(() => {
                    Yc(this._modules, s), t.unsubscribe()
                  })
                }),
                (function (t, e, n) {
                  try {
                    const i = n()
                    return Lo(i)
                      ? i.catch((n) => {
                          throw (e.runOutsideAngular(() => t.handleError(n)), n)
                        })
                      : i
                  } catch (i) {
                    throw (e.runOutsideAngular(() => t.handleError(i)), i)
                  }
                })(r, n, () => {
                  const t = s.injector.get(cc)
                  return (
                    t.runInitializers(),
                    t.donePromise.then(
                      () => (
                        Ea(s.injector.get(yc, xa) || xa),
                        this._moduleDoBootstrap(s),
                        s
                      )
                    )
                  )
                })
              )
            })
          }
          bootstrapModule(t, e = []) {
            const n = Qc({}, e)
            return (function (t, e, n) {
              const i = new Ml(n)
              return Promise.resolve(i)
            })(0, 0, t).then((t) => this.bootstrapModuleFactory(t, n))
          }
          _moduleDoBootstrap(t) {
            const e = t.injector.get(Zc)
            if (t._bootstrapComponents.length > 0)
              t._bootstrapComponents.forEach((t) => e.bootstrap(t))
            else {
              if (!t.instance.ngDoBootstrap)
                throw new Error(
                  `The module ${st(
                    t.instance.constructor
                  )} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`
                )
              t.instance.ngDoBootstrap(e)
            }
            this._modules.push(t)
          }
          onDestroy(t) {
            this._destroyListeners.push(t)
          }
          get injector() {
            return this._injector
          }
          destroy() {
            if (this._destroyed)
              throw new Error('The platform has already been destroyed!')
            this._modules.slice().forEach((t) => t.destroy()),
              this._destroyListeners.forEach((t) => t()),
              (this._destroyed = !0)
          }
          get destroyed() {
            return this._destroyed
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(ho))
          }),
          (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      function Qc(t, e) {
        return Array.isArray(e)
          ? e.reduce(Qc, t)
          : Object.assign(Object.assign({}, t), e)
      }
      let Zc = (() => {
        class t {
          constructor(t, e, n, i, s, r) {
            ;(this._zone = t),
              (this._console = e),
              (this._injector = n),
              (this._exceptionHandler = i),
              (this._componentFactoryResolver = s),
              (this._initStatus = r),
              (this._bootstrapListeners = []),
              (this._views = []),
              (this._runningTick = !1),
              (this._stable = !0),
              (this.componentTypes = []),
              (this.components = []),
              (this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe(
                {
                  next: () => {
                    this._zone.run(() => {
                      this.tick()
                    })
                  },
                }
              ))
            const o = new _((t) => {
                ;(this._stable =
                  this._zone.isStable &&
                  !this._zone.hasPendingMacrotasks &&
                  !this._zone.hasPendingMicrotasks),
                  this._zone.runOutsideAngular(() => {
                    t.next(this._stable), t.complete()
                  })
              }),
              a = new _((t) => {
                let e
                this._zone.runOutsideAngular(() => {
                  e = this._zone.onStable.subscribe(() => {
                    Oc.assertNotInAngularZone(),
                      Ac(() => {
                        this._stable ||
                          this._zone.hasPendingMacrotasks ||
                          this._zone.hasPendingMicrotasks ||
                          ((this._stable = !0), t.next(!0))
                      })
                  })
                })
                const n = this._zone.onUnstable.subscribe(() => {
                  Oc.assertInAngularZone(),
                    this._stable &&
                      ((this._stable = !1),
                      this._zone.runOutsideAngular(() => {
                        t.next(!1)
                      }))
                })
                return () => {
                  e.unsubscribe(), n.unsubscribe()
                }
              })
            this.isStable = $(o, a.pipe(et()))
          }
          bootstrap(t, e) {
            if (!this._initStatus.done)
              throw new Error(
                'Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.'
              )
            let n
            ;(n =
              t instanceof Na
                ? t
                : this._componentFactoryResolver.resolveComponentFactory(t)),
              this.componentTypes.push(n.componentType)
            const i = n.isBoundToModule ? void 0 : this._injector.get(vl),
              s = n.create(ho.NULL, [], e || n.selector, i),
              r = s.location.nativeElement,
              o = s.injector.get(Mc, null),
              a = o && s.injector.get(Lc)
            return (
              o && a && a.registerApplication(r, o),
              s.onDestroy(() => {
                this.detachView(s.hostView),
                  Yc(this.components, s),
                  a && a.unregisterApplication(r)
              }),
              this._loadComponent(s),
              Hc() &&
                this._console.log(
                  'Angular is running in development mode. Call enableProdMode() to enable production mode.'
                ),
              s
            )
          }
          tick() {
            if (this._runningTick)
              throw new Error('ApplicationRef.tick is called recursively')
            try {
              this._runningTick = !0
              for (let t of this._views) t.detectChanges()
            } catch (t) {
              this._zone.runOutsideAngular(() =>
                this._exceptionHandler.handleError(t)
              )
            } finally {
              this._runningTick = !1
            }
          }
          attachView(t) {
            const e = t
            this._views.push(e), e.attachToAppRef(this)
          }
          detachView(t) {
            const e = t
            Yc(this._views, e), e.detachFromAppRef()
          }
          _loadComponent(t) {
            this.attachView(t.hostView),
              this.tick(),
              this.components.push(t),
              this._injector
                .get(mc, [])
                .concat(this._bootstrapListeners)
                .forEach((e) => e(t))
          }
          ngOnDestroy() {
            this._views.slice().forEach((t) => t.destroy()),
              this._onMicrotaskEmptySubscription.unsubscribe()
          }
          get viewCount() {
            return this._views.length
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(Oc), vi(gc), vi(ho), vi(os), vi(Ma), vi(cc))
          }),
          (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      function Yc(t, e) {
        const n = t.indexOf(e)
        n > -1 && t.splice(n, 1)
      }
      class Xc {}
      class Jc {}
      const th = { factoryPathPrefix: '', factoryPathSuffix: '.ngfactory' }
      let eh = (() => {
        class t {
          constructor(t, e) {
            ;(this._compiler = t), (this._config = e || th)
          }
          load(t) {
            return this.loadAndCompile(t)
          }
          loadAndCompile(t) {
            let [e, i] = t.split('#')
            return (
              void 0 === i && (i = 'default'),
              n('F1In')(e)
                .then((t) => t[i])
                .then((t) => nh(t, e, i))
                .then((t) => this._compiler.compileModuleAsync(t))
            )
          }
          loadFactory(t) {
            let [e, i] = t.split('#'),
              s = 'NgFactory'
            return (
              void 0 === i && ((i = 'default'), (s = '')),
              n('F1In')(
                this._config.factoryPathPrefix +
                  e +
                  this._config.factoryPathSuffix
              )
                .then((t) => t[i + s])
                .then((t) => nh(t, e, i))
            )
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(kc), vi(Jc, 8))
          }),
          (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      function nh(t, e, n) {
        if (!t) throw new Error(`Cannot find '${n}' in '${e}'`)
        return t
      }
      const ih = Wc(null, 'core', [
          { provide: fc, useValue: 'unknown' },
          { provide: Gc, deps: [ho] },
          { provide: Lc, deps: [] },
          { provide: gc, deps: [] },
        ]),
        sh = [
          { provide: Zc, useClass: Zc, deps: [Oc, gc, ho, os, Ma, cc] },
          {
            provide: Rl,
            deps: [Oc],
            useFactory: function (t) {
              let e = []
              return (
                t.onStable.subscribe(() => {
                  for (; e.length; ) e.pop()()
                }),
                function (t) {
                  e.push(t)
                }
              )
            },
          },
          { provide: cc, useClass: cc, deps: [[new ci(), lc]] },
          { provide: kc, useClass: kc, deps: [] },
          uc,
          {
            provide: il,
            useFactory: function () {
              return dl
            },
            deps: [],
          },
          {
            provide: sl,
            useFactory: function () {
              return pl
            },
            deps: [],
          },
          {
            provide: yc,
            useFactory: function (t) {
              return (
                Ea(
                  (t =
                    t ||
                    ('undefined' != typeof $localize && $localize.locale) ||
                    xa)
                ),
                t
              )
            },
            deps: [[new li(yc), new ci(), new ui()]],
          },
          { provide: _c, useValue: 'USD' },
        ]
      let rh = (() => {
        class t {
          constructor(t) {}
        }
        return (
          (t.ɵmod = $t({ type: t })),
          (t.ɵinj = ut({
            factory: function (e) {
              return new (e || t)(vi(Zc))
            },
            providers: sh,
          })),
          t
        )
      })()
      function oh(t, e, n, i) {
        return new (n || (n = Promise))(function (s, r) {
          function o(t) {
            try {
              l(i.next(t))
            } catch (e) {
              r(e)
            }
          }
          function a(t) {
            try {
              l(i.throw(t))
            } catch (e) {
              r(e)
            }
          }
          function l(t) {
            var e
            t.done
              ? s(t.value)
              : ((e = t.value),
                e instanceof n
                  ? e
                  : new n(function (t) {
                      t(e)
                    })).then(o, a)
          }
          l((i = i.apply(t, e || [])).next())
        })
      }
      var ah = n('gFX4')
      class lh {
        constructor(t) {
          ;(this.message = new x()),
            (this.message$ = this.message.asObservable()),
            console.log({ uri: t }),
            t &&
              ((this.io = ah.connect(t)),
              this.io.on('message', (t) => this.message.next(t)))
        }
        send(t) {
          this.io.send(t)
        }
      }
      let ch = (() => {
        class t {
          static log(e, n = t.logColor) {
            console.log('%c' + e, 'color:' + n)
          }
          static info(e, n = t.infoColor) {
            console.info('%c' + e, 'color:' + n)
          }
          static warn(e, n = t.warnColor) {
            console.warn('%c' + e, 'color:' + n)
          }
          static error(e, n = t.errorColor) {
            console.error('%c' + e, 'color:' + n)
          }
        }
        return (
          (t.logColor = '#2196F3'),
          (t.infoColor = 'purple'),
          (t.warnColor = 'orange'),
          (t.errorColor = 'red'),
          t
        )
      })()
      var hh = (function (t) {
          return (
            (t.Connect = 'connect'),
            (t.Disconnect = 'disconnect'),
            (t.Connected = 'connected'),
            (t.Completed = 'completed'),
            (t.Offer = 'offer'),
            (t.Answer = 'answer'),
            t
          )
        })({}),
        uh = (function (t) {
          return (t.Connected = 'connected'), (t.Completed = 'completed'), t
        })({})
      let dh = (() => {
          class t {
            constructor() {
              this.constraints = {
                audio: { echoCancellation: !0 },
                video: {
                  facingMode: 'user',
                  frameRate: 30,
                  width: { max: 1280, ideal: 800 },
                },
              }
            }
            getUserMedia(t) {
              return navigator.mediaDevices.getUserMedia(t || this.constraints)
            }
            getDevices(t) {
              return oh(this, void 0, void 0, function* () {
                const e = yield navigator.mediaDevices.enumerateDevices()
                return t ? e.filter(({ kind: e }) => e === t) : e
              })
            }
            getDisplayMedia() {
              const t = { video: !0 },
                e = navigator.mediaDevices
              return 'getDisplayMedia' in navigator
                ? navigator.getDisplayMedia(t)
                : 'getDisplayMedia' in e
                ? e.getDisplayMedia(t)
                : e.getUserMedia({ video: { mediaSourcee: 'screen' } })
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        ph = null
      function fh() {
        return ph
      }
      const mh = new Yn('DocumentToken')
      let gh = (() => {
        class t {}
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵprov = ht({ factory: yh, token: t, providedIn: 'platform' })),
          t
        )
      })()
      function yh() {
        return vi(vh)
      }
      const _h = new Yn('Location Initialized')
      let vh = (() => {
        class t extends gh {
          constructor(t) {
            super(), (this._doc = t), this._init()
          }
          _init() {
            ;(this.location = fh().getLocation()),
              (this._history = fh().getHistory())
          }
          getBaseHrefFromDOM() {
            return fh().getBaseHref(this._doc)
          }
          onPopState(t) {
            fh()
              .getGlobalEventTarget(this._doc, 'window')
              .addEventListener('popstate', t, !1)
          }
          onHashChange(t) {
            fh()
              .getGlobalEventTarget(this._doc, 'window')
              .addEventListener('hashchange', t, !1)
          }
          get href() {
            return this.location.href
          }
          get protocol() {
            return this.location.protocol
          }
          get hostname() {
            return this.location.hostname
          }
          get port() {
            return this.location.port
          }
          get pathname() {
            return this.location.pathname
          }
          get search() {
            return this.location.search
          }
          get hash() {
            return this.location.hash
          }
          set pathname(t) {
            this.location.pathname = t
          }
          pushState(t, e, n) {
            bh() ? this._history.pushState(t, e, n) : (this.location.hash = n)
          }
          replaceState(t, e, n) {
            bh()
              ? this._history.replaceState(t, e, n)
              : (this.location.hash = n)
          }
          forward() {
            this._history.forward()
          }
          back() {
            this._history.back()
          }
          getState() {
            return this._history.state
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(mh))
          }),
          (t.ɵprov = ht({ factory: wh, token: t, providedIn: 'platform' })),
          t
        )
      })()
      function bh() {
        return !!window.history.pushState
      }
      function wh() {
        return new vh(vi(mh))
      }
      function Ch(t, e) {
        if (0 == t.length) return e
        if (0 == e.length) return t
        let n = 0
        return (
          t.endsWith('/') && n++,
          e.startsWith('/') && n++,
          2 == n ? t + e.substring(1) : 1 == n ? t + e : t + '/' + e
        )
      }
      function xh(t) {
        const e = t.match(/#|\?|$/),
          n = (e && e.index) || t.length
        return t.slice(0, n - ('/' === t[n - 1] ? 1 : 0)) + t.slice(n)
      }
      function Sh(t) {
        return t && '?' !== t[0] ? '?' + t : t
      }
      let Eh = (() => {
        class t {}
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵprov = ht({ factory: kh, token: t, providedIn: 'root' })),
          t
        )
      })()
      function kh(t) {
        const e = vi(mh).location
        return new Ah(vi(gh), (e && e.origin) || '')
      }
      const Th = new Yn('appBaseHref')
      let Ah = (() => {
          class t extends Eh {
            constructor(t, e) {
              if (
                (super(),
                (this._platformLocation = t),
                null == e && (e = this._platformLocation.getBaseHrefFromDOM()),
                null == e)
              )
                throw new Error(
                  'No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.'
                )
              this._baseHref = e
            }
            onPopState(t) {
              this._platformLocation.onPopState(t),
                this._platformLocation.onHashChange(t)
            }
            getBaseHref() {
              return this._baseHref
            }
            prepareExternalUrl(t) {
              return Ch(this._baseHref, t)
            }
            path(t = !1) {
              const e =
                  this._platformLocation.pathname +
                  Sh(this._platformLocation.search),
                n = this._platformLocation.hash
              return n && t ? `${e}${n}` : e
            }
            pushState(t, e, n, i) {
              const s = this.prepareExternalUrl(n + Sh(i))
              this._platformLocation.pushState(t, e, s)
            }
            replaceState(t, e, n, i) {
              const s = this.prepareExternalUrl(n + Sh(i))
              this._platformLocation.replaceState(t, e, s)
            }
            forward() {
              this._platformLocation.forward()
            }
            back() {
              this._platformLocation.back()
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(gh), vi(Th, 8))
            }),
            (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        Oh = (() => {
          class t extends Eh {
            constructor(t, e) {
              super(),
                (this._platformLocation = t),
                (this._baseHref = ''),
                null != e && (this._baseHref = e)
            }
            onPopState(t) {
              this._platformLocation.onPopState(t),
                this._platformLocation.onHashChange(t)
            }
            getBaseHref() {
              return this._baseHref
            }
            path(t = !1) {
              let e = this._platformLocation.hash
              return null == e && (e = '#'), e.length > 0 ? e.substring(1) : e
            }
            prepareExternalUrl(t) {
              const e = Ch(this._baseHref, t)
              return e.length > 0 ? '#' + e : e
            }
            pushState(t, e, n, i) {
              let s = this.prepareExternalUrl(n + Sh(i))
              0 == s.length && (s = this._platformLocation.pathname),
                this._platformLocation.pushState(t, e, s)
            }
            replaceState(t, e, n, i) {
              let s = this.prepareExternalUrl(n + Sh(i))
              0 == s.length && (s = this._platformLocation.pathname),
                this._platformLocation.replaceState(t, e, s)
            }
            forward() {
              this._platformLocation.forward()
            }
            back() {
              this._platformLocation.back()
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(gh), vi(Th, 8))
            }),
            (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        Ih = (() => {
          class t {
            constructor(t, e) {
              ;(this._subject = new zl()),
                (this._urlChangeListeners = []),
                (this._platformStrategy = t)
              const n = this._platformStrategy.getBaseHref()
              ;(this._platformLocation = e),
                (this._baseHref = xh(Ph(n))),
                this._platformStrategy.onPopState((t) => {
                  this._subject.emit({
                    url: this.path(!0),
                    pop: !0,
                    state: t.state,
                    type: t.type,
                  })
                })
            }
            path(t = !1) {
              return this.normalize(this._platformStrategy.path(t))
            }
            getState() {
              return this._platformLocation.getState()
            }
            isCurrentPathEqualTo(t, e = '') {
              return this.path() == this.normalize(t + Sh(e))
            }
            normalize(e) {
              return t.stripTrailingSlash(
                (function (t, e) {
                  return t && e.startsWith(t) ? e.substring(t.length) : e
                })(this._baseHref, Ph(e))
              )
            }
            prepareExternalUrl(t) {
              return (
                t && '/' !== t[0] && (t = '/' + t),
                this._platformStrategy.prepareExternalUrl(t)
              )
            }
            go(t, e = '', n = null) {
              this._platformStrategy.pushState(n, '', t, e),
                this._notifyUrlChangeListeners(
                  this.prepareExternalUrl(t + Sh(e)),
                  n
                )
            }
            replaceState(t, e = '', n = null) {
              this._platformStrategy.replaceState(n, '', t, e),
                this._notifyUrlChangeListeners(
                  this.prepareExternalUrl(t + Sh(e)),
                  n
                )
            }
            forward() {
              this._platformStrategy.forward()
            }
            back() {
              this._platformStrategy.back()
            }
            onUrlChange(t) {
              this._urlChangeListeners.push(t),
                this._urlChangeSubscription ||
                  (this._urlChangeSubscription = this.subscribe((t) => {
                    this._notifyUrlChangeListeners(t.url, t.state)
                  }))
            }
            _notifyUrlChangeListeners(t = '', e) {
              this._urlChangeListeners.forEach((n) => n(t, e))
            }
            subscribe(t, e, n) {
              return this._subject.subscribe({ next: t, error: e, complete: n })
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(Eh), vi(gh))
            }),
            (t.normalizeQueryParams = Sh),
            (t.joinWithSlash = Ch),
            (t.stripTrailingSlash = xh),
            (t.ɵprov = ht({ factory: Rh, token: t, providedIn: 'root' })),
            t
          )
        })()
      function Rh() {
        return new Ih(vi(Eh), vi(gh))
      }
      function Ph(t) {
        return t.replace(/\/index.html$/, '')
      }
      var Dh = (function (t) {
        return (
          (t[(t.Zero = 0)] = 'Zero'),
          (t[(t.One = 1)] = 'One'),
          (t[(t.Two = 2)] = 'Two'),
          (t[(t.Few = 3)] = 'Few'),
          (t[(t.Many = 4)] = 'Many'),
          (t[(t.Other = 5)] = 'Other'),
          t
        )
      })({})
      class Nh {}
      let Fh = (() => {
          class t extends Nh {
            constructor(t) {
              super(), (this.locale = t)
            }
            getPluralCategory(t, e) {
              switch (
                (function (t) {
                  return (function (t) {
                    const e = (function (t) {
                      return t.toLowerCase().replace(/_/g, '-')
                    })(t)
                    let n = wa(e)
                    if (n) return n
                    const i = e.split('-')[0]
                    if (((n = wa(i)), n)) return n
                    if ('en' === i) return va
                    throw new Error(
                      `Missing locale data for the locale "${t}".`
                    )
                  })(t)[Ca.PluralCase]
                })(e || this.locale)(t)
              ) {
                case Dh.Zero:
                  return 'zero'
                case Dh.One:
                  return 'one'
                case Dh.Two:
                  return 'two'
                case Dh.Few:
                  return 'few'
                case Dh.Many:
                  return 'many'
                default:
                  return 'other'
              }
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(yc))
            }),
            (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        Mh = (() => {
          class t {
            constructor(t, e, n, i) {
              ;(this._iterableDiffers = t),
                (this._keyValueDiffers = e),
                (this._ngEl = n),
                (this._renderer = i),
                (this._iterableDiffer = null),
                (this._keyValueDiffer = null),
                (this._initialClasses = []),
                (this._rawClass = null)
            }
            set klass(t) {
              this._removeClasses(this._initialClasses),
                (this._initialClasses =
                  'string' == typeof t ? t.split(/\s+/) : []),
                this._applyClasses(this._initialClasses),
                this._applyClasses(this._rawClass)
            }
            set ngClass(t) {
              this._removeClasses(this._rawClass),
                this._applyClasses(this._initialClasses),
                (this._iterableDiffer = null),
                (this._keyValueDiffer = null),
                (this._rawClass = 'string' == typeof t ? t.split(/\s+/) : t),
                this._rawClass &&
                  (wo(this._rawClass)
                    ? (this._iterableDiffer = this._iterableDiffers
                        .find(this._rawClass)
                        .create())
                    : (this._keyValueDiffer = this._keyValueDiffers
                        .find(this._rawClass)
                        .create()))
            }
            ngDoCheck() {
              if (this._iterableDiffer) {
                const t = this._iterableDiffer.diff(this._rawClass)
                t && this._applyIterableChanges(t)
              } else if (this._keyValueDiffer) {
                const t = this._keyValueDiffer.diff(this._rawClass)
                t && this._applyKeyValueChanges(t)
              }
            }
            _applyKeyValueChanges(t) {
              t.forEachAddedItem((t) =>
                this._toggleClass(t.key, t.currentValue)
              ),
                t.forEachChangedItem((t) =>
                  this._toggleClass(t.key, t.currentValue)
                ),
                t.forEachRemovedItem((t) => {
                  t.previousValue && this._toggleClass(t.key, !1)
                })
            }
            _applyIterableChanges(t) {
              t.forEachAddedItem((t) => {
                if ('string' != typeof t.item)
                  throw new Error(
                    'NgClass can only toggle CSS classes expressed as strings, got ' +
                      st(t.item)
                  )
                this._toggleClass(t.item, !0)
              }),
                t.forEachRemovedItem((t) => this._toggleClass(t.item, !1))
            }
            _applyClasses(t) {
              t &&
                (Array.isArray(t) || t instanceof Set
                  ? t.forEach((t) => this._toggleClass(t, !0))
                  : Object.keys(t).forEach((e) => this._toggleClass(e, !!t[e])))
            }
            _removeClasses(t) {
              t &&
                (Array.isArray(t) || t instanceof Set
                  ? t.forEach((t) => this._toggleClass(t, !1))
                  : Object.keys(t).forEach((t) => this._toggleClass(t, !1)))
            }
            _toggleClass(t, e) {
              ;(t = t.trim()) &&
                t.split(/\s+/g).forEach((t) => {
                  e
                    ? this._renderer.addClass(this._ngEl.nativeElement, t)
                    : this._renderer.removeClass(this._ngEl.nativeElement, t)
                })
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(Ao(il), Ao(sl), Ao(Va), Ao(za))
            }),
            (t.ɵdir = Kt({
              type: t,
              selectors: [['', 'ngClass', '']],
              inputs: { klass: ['class', 'klass'], ngClass: 'ngClass' },
            })),
            t
          )
        })()
      class Lh {
        constructor(t, e, n, i) {
          ;(this.$implicit = t),
            (this.ngForOf = e),
            (this.index = n),
            (this.count = i)
        }
        get first() {
          return 0 === this.index
        }
        get last() {
          return this.index === this.count - 1
        }
        get even() {
          return this.index % 2 == 0
        }
        get odd() {
          return !this.even
        }
      }
      let jh = (() => {
        class t {
          constructor(t, e, n) {
            ;(this._viewContainer = t),
              (this._template = e),
              (this._differs = n),
              (this._ngForOf = null),
              (this._ngForOfDirty = !0),
              (this._differ = null)
          }
          set ngForOf(t) {
            ;(this._ngForOf = t), (this._ngForOfDirty = !0)
          }
          set ngForTrackBy(t) {
            this._trackByFn = t
          }
          get ngForTrackBy() {
            return this._trackByFn
          }
          set ngForTemplate(t) {
            t && (this._template = t)
          }
          ngDoCheck() {
            if (this._ngForOfDirty) {
              this._ngForOfDirty = !1
              const n = this._ngForOf
              if (!this._differ && n)
                try {
                  this._differ = this._differs.find(n).create(this.ngForTrackBy)
                } catch (e) {
                  throw new Error(
                    `Cannot find a differ supporting object '${n}' of type '${
                      ((t = n), t.name || typeof t)
                    }'. NgFor only supports binding to Iterables such as Arrays.`
                  )
                }
            }
            var t
            if (this._differ) {
              const t = this._differ.diff(this._ngForOf)
              t && this._applyChanges(t)
            }
          }
          _applyChanges(t) {
            const e = []
            t.forEachOperation((t, n, i) => {
              if (null == t.previousIndex) {
                const n = this._viewContainer.createEmbeddedView(
                    this._template,
                    new Lh(null, this._ngForOf, -1, -1),
                    null === i ? void 0 : i
                  ),
                  s = new Bh(t, n)
                e.push(s)
              } else if (null == i)
                this._viewContainer.remove(null === n ? void 0 : n)
              else if (null !== n) {
                const s = this._viewContainer.get(n)
                this._viewContainer.move(s, i)
                const r = new Bh(t, s)
                e.push(r)
              }
            })
            for (let n = 0; n < e.length; n++)
              this._perViewChange(e[n].view, e[n].record)
            for (let n = 0, i = this._viewContainer.length; n < i; n++) {
              const t = this._viewContainer.get(n)
              ;(t.context.index = n),
                (t.context.count = i),
                (t.context.ngForOf = this._ngForOf)
            }
            t.forEachIdentityChange((t) => {
              this._viewContainer.get(t.currentIndex).context.$implicit = t.item
            })
          }
          _perViewChange(t, e) {
            t.context.$implicit = e.item
          }
          static ngTemplateContextGuard(t, e) {
            return !0
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(Ao(Cl), Ao(ml), Ao(il))
          }),
          (t.ɵdir = Kt({
            type: t,
            selectors: [['', 'ngFor', '', 'ngForOf', '']],
            inputs: {
              ngForOf: 'ngForOf',
              ngForTrackBy: 'ngForTrackBy',
              ngForTemplate: 'ngForTemplate',
            },
          })),
          t
        )
      })()
      class Bh {
        constructor(t, e) {
          ;(this.record = t), (this.view = e)
        }
      }
      let Vh = (() => {
        class t {
          constructor(t, e) {
            ;(this._viewContainer = t),
              (this._context = new Uh()),
              (this._thenTemplateRef = null),
              (this._elseTemplateRef = null),
              (this._thenViewRef = null),
              (this._elseViewRef = null),
              (this._thenTemplateRef = e)
          }
          set ngIf(t) {
            ;(this._context.$implicit = this._context.ngIf = t),
              this._updateView()
          }
          set ngIfThen(t) {
            zh('ngIfThen', t),
              (this._thenTemplateRef = t),
              (this._thenViewRef = null),
              this._updateView()
          }
          set ngIfElse(t) {
            zh('ngIfElse', t),
              (this._elseTemplateRef = t),
              (this._elseViewRef = null),
              this._updateView()
          }
          _updateView() {
            this._context.$implicit
              ? this._thenViewRef ||
                (this._viewContainer.clear(),
                (this._elseViewRef = null),
                this._thenTemplateRef &&
                  (this._thenViewRef = this._viewContainer.createEmbeddedView(
                    this._thenTemplateRef,
                    this._context
                  )))
              : this._elseViewRef ||
                (this._viewContainer.clear(),
                (this._thenViewRef = null),
                this._elseTemplateRef &&
                  (this._elseViewRef = this._viewContainer.createEmbeddedView(
                    this._elseTemplateRef,
                    this._context
                  )))
          }
          static ngTemplateContextGuard(t, e) {
            return !0
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(Ao(Cl), Ao(ml))
          }),
          (t.ɵdir = Kt({
            type: t,
            selectors: [['', 'ngIf', '']],
            inputs: {
              ngIf: 'ngIf',
              ngIfThen: 'ngIfThen',
              ngIfElse: 'ngIfElse',
            },
          })),
          t
        )
      })()
      class Uh {
        constructor() {
          ;(this.$implicit = null), (this.ngIf = null)
        }
      }
      function zh(t, e) {
        if (e && !e.createEmbeddedView)
          throw new Error(
            `${t} must be a TemplateRef, but received '${st(e)}'.`
          )
      }
      class Hh {
        createSubscription(t, e) {
          return t.subscribe({
            next: e,
            error: (t) => {
              throw t
            },
          })
        }
        dispose(t) {
          t.unsubscribe()
        }
        onDestroy(t) {
          t.unsubscribe()
        }
      }
      class qh {
        createSubscription(t, e) {
          return t.then(e, (t) => {
            throw t
          })
        }
        dispose(t) {}
        onDestroy(t) {}
      }
      const $h = new qh(),
        Wh = new Hh()
      let Kh = (() => {
          class t {
            constructor(t) {
              ;(this._ref = t),
                (this._latestValue = null),
                (this._subscription = null),
                (this._obj = null),
                (this._strategy = null)
            }
            ngOnDestroy() {
              this._subscription && this._dispose()
            }
            transform(t) {
              return this._obj
                ? t !== this._obj
                  ? (this._dispose(), this.transform(t))
                  : this._latestValue
                : (t && this._subscribe(t), this._latestValue)
            }
            _subscribe(t) {
              ;(this._obj = t),
                (this._strategy = this._selectStrategy(t)),
                (this._subscription = this._strategy.createSubscription(
                  t,
                  (e) => this._updateLatestValue(t, e)
                ))
            }
            _selectStrategy(e) {
              if (Lo(e)) return $h
              if (jo(e)) return Wh
              throw Error(`InvalidPipeArgument: '${e}' for pipe '${st(t)}'`)
            }
            _dispose() {
              this._strategy.dispose(this._subscription),
                (this._latestValue = null),
                (this._subscription = null),
                (this._obj = null)
            }
            _updateLatestValue(t, e) {
              t === this._obj &&
                ((this._latestValue = e), this._ref.markForCheck())
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                (function (t = vt.Default) {
                  const e = hl(!0)
                  if (null != e || t & vt.Optional) return e
                  ce('ChangeDetectorRef')
                })()
              )
            }),
            (t.ɵpipe = Gt({ name: 'async', type: t, pure: !1 })),
            t
          )
        })(),
        Gh = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
              providers: [{ provide: Nh, useClass: Fh }],
            })),
            t
          )
        })()
      function Qh(t) {
        return 'browser' === t
      }
      let Zh = (() => {
        class t {}
        return (
          (t.ɵprov = ht({
            token: t,
            providedIn: 'root',
            factory: () => new Yh(vi(mh), window, vi(os)),
          })),
          t
        )
      })()
      class Yh {
        constructor(t, e, n) {
          ;(this.document = t),
            (this.window = e),
            (this.errorHandler = n),
            (this.offset = () => [0, 0])
        }
        setOffset(t) {
          this.offset = Array.isArray(t) ? () => t : t
        }
        getScrollPosition() {
          return this.supportsScrolling()
            ? [this.window.pageXOffset, this.window.pageYOffset]
            : [0, 0]
        }
        scrollToPosition(t) {
          this.supportsScrolling() && this.window.scrollTo(t[0], t[1])
        }
        scrollToAnchor(t) {
          if (this.supportsScrolling()) {
            const e =
              this.document.getElementById(t) ||
              this.document.getElementsByName(t)[0]
            e && this.scrollToElement(e)
          }
        }
        setHistoryScrollRestoration(t) {
          if (this.supportScrollRestoration()) {
            const e = this.window.history
            e && e.scrollRestoration && (e.scrollRestoration = t)
          }
        }
        scrollToElement(t) {
          const e = t.getBoundingClientRect(),
            n = e.left + this.window.pageXOffset,
            i = e.top + this.window.pageYOffset,
            s = this.offset()
          this.window.scrollTo(n - s[0], i - s[1])
        }
        supportScrollRestoration() {
          try {
            if (!this.supportsScrolling()) return !1
            const t =
              Xh(this.window.history) ||
              Xh(Object.getPrototypeOf(this.window.history))
            return !(!t || (!t.writable && !t.set))
          } catch (t) {
            return !1
          }
        }
        supportsScrolling() {
          try {
            return (
              !!this.window &&
              !!this.window.scrollTo &&
              'pageXOffset' in this.window
            )
          } catch (t) {
            return !1
          }
        }
      }
      function Xh(t) {
        return Object.getOwnPropertyDescriptor(t, 'scrollRestoration')
      }
      function Jh(t, e) {
        if ((1 & t && (No(0), Do(1, 'img', 3), Fo()), 2 & t)) {
          const t = qo()
          Xs(1), Oo('src', t.src, ns)('alt', t.alt)
        }
      }
      function tu(t, e) {
        1 & t &&
          (hn(), Ro(0, 'svg', 4), Do(1, 'path', 5), Do(2, 'path', 6), Po())
      }
      const eu = function (t) {
        return { 'call-avatar-animation': t }
      }
      let nu = (() => {
        class t {
          constructor() {
            this.alt = 'avatar'
          }
          get animation() {
            return this._animation
          }
          set animation(t) {
            this._animation = t
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵcmp = Ut({
            type: t,
            selectors: [['app-call-avatar']],
            inputs: { src: 'src', alt: 'alt', animation: 'animation' },
            decls: 4,
            vars: 5,
            consts: [
              [1, 'call-avatar', 3, 'ngClass'],
              [4, 'ngIf', 'ngIfElse'],
              ['noSrc', ''],
              ['width', '135', 3, 'src', 'alt'],
              [
                'xmlns',
                'http://www.w3.org/2000/svg',
                'viewBox',
                '0 0 496.158 496.158',
              ],
              [
                'd',
                'M496.158,248.085c0-137.022-111.069-248.082-248.075-248.082C111.07,0.003,0,111.063,0,248.085\n\tc0,137.001,111.07,248.07,248.083,248.07C385.089,496.155,496.158,385.086,496.158,248.085z',
                2,
                'fill',
                '#333',
              ],
              [
                'd',
                'M138.216,173.592c0-13.915,4.467-28.015,13.403-42.297c8.933-14.282,21.973-26.11,39.111-35.486\n\tc17.139-9.373,37.134-14.062,59.985-14.062c21.238,0,39.99,3.921,56.25,11.755c16.26,7.838,28.818,18.495,37.683,31.97\n\tc8.861,13.479,13.293,28.125,13.293,43.945c0,12.452-2.527,23.367-7.581,32.739c-5.054,9.376-11.062,17.469-18.018,24.279\n\tc-6.959,6.812-19.446,18.275-37.463,34.388c-4.981,4.542-8.975,8.535-11.975,11.976c-3.004,3.443-5.239,6.592-6.702,9.447\n\tc-1.466,2.857-2.603,5.713-3.406,8.57c-0.807,2.855-2.015,7.875-3.625,15.051c-2.784,15.236-11.501,22.852-26.147,22.852\n\tc-7.618,0-14.028-2.489-19.226-7.471c-5.201-4.979-7.8-12.377-7.8-22.192c0-12.305,1.902-22.962,5.713-31.97\n\tc3.808-9.01,8.861-16.92,15.161-23.73c6.296-6.812,14.794-14.904,25.488-24.28c9.373-8.202,16.15-14.392,20.325-18.567\n\tc4.175-4.175,7.69-8.823,10.547-13.953c2.856-5.126,4.285-10.691,4.285-16.699c0-11.718-4.36-21.605-13.074-29.663\n\tc-8.717-8.054-19.961-12.085-33.728-12.085c-16.116,0-27.981,4.065-35.596,12.195c-7.618,8.13-14.062,20.105-19.336,35.925\n\tc-4.981,16.555-14.43,24.829-28.345,24.829c-8.206,0-15.127-2.891-20.764-8.679C141.035,186.593,138.216,180.331,138.216,173.592z\n\t M245.442,414.412c-8.937,0-16.737-2.895-23.401-8.68c-6.667-5.784-9.998-13.877-9.998-24.279c0-9.229,3.22-16.991,9.668-23.291\n\tc6.444-6.297,14.354-9.448,23.73-9.448c9.229,0,16.991,3.151,23.291,9.448c6.296,6.3,9.448,14.062,9.448,23.291\n\tc0,10.255-3.296,18.312-9.888,24.17C261.7,411.481,254.084,414.412,245.442,414.412z',
                2,
                'fill',
                '#18ffff',
              ],
            ],
            template: function (t, e) {
              if (
                (1 & t &&
                  (Ro(0, 'div', 0),
                  ko(1, Jh, 2, 2, 'ng-container', 1),
                  Po(),
                  ko(2, tu, 3, 0, 'ng-template', null, 2, ac)),
                2 & t)
              ) {
                const t = To(3)
                Oo(
                  'ngClass',
                  (3,
                  (n = eu),
                  (i = e.animation),
                  Bl(Ne(), qe(), 3, n, i, undefined))
                ),
                  Xs(1),
                  Oo('ngIf', e.src)('ngIfElse', t)
              }
              var n, i
            },
            directives: [Mh, Vh],
            styles: [
              '[_nghost-%COMP%]{display:block}[_nghost-%COMP%]   .call-avatar[_ngcontent-%COMP%]{background:#fff;width:135px;height:135px;position:relative;margin:0 auto;border-radius:100%;border:5px solid #fff}[_nghost-%COMP%]   .call-avatar-animation[_ngcontent-%COMP%]{animation:play 2s ease infinite;-webkit-backface-visibility:hidden;backface-visibility:hidden}[_nghost-%COMP%]     video, [_nghost-%COMP%]   img[_ngcontent-%COMP%], [_nghost-%COMP%]   video[_ngcontent-%COMP%]{width:135px;height:135px;border-radius:100%;position:absolute;left:0;top:0}@keyframes play{0%{transform:scale(1)}15%{box-shadow:0 0 0 5px hsla(0,0%,100%,.4)}25%{box-shadow:0 0 0 10px hsla(0,0%,100%,.4),0 0 0 20px hsla(0,0%,100%,.2)}25%{box-shadow:0 0 0 15px hsla(0,0%,100%,.4),0 0 0 30px hsla(0,0%,100%,.2)}}',
            ],
            changeDetection: 0,
          })),
          t
        )
      })()
      const iu = ['selfView'],
        su = ['remoteView']
      function ru(t, e) {
        if (
          (1 & t &&
            (No(0),
            Ro(1, 'div', 6),
            Do(2, 'app-call-avatar', 7),
            Ro(3, 'h3', 8),
            pa(4, 'Convite algu\xe9m ou abra em outra janela'),
            Po(),
            Po(),
            Fo()),
          2 & t)
        ) {
          const t = e.ngIf
          Xs(2), Oo('animation', t)
        }
      }
      let ou = (() => {
        class t {
          constructor(t, e) {
            ;(this.signaling = t),
              (this.media = e),
              (this.title = 'client-app'),
              (this.active = new x()),
              (this.active$ = this.active.asObservable()),
              (this.sender = (function () {
                function t() {
                  return Math.floor(65536 * (1 + Math.random()))
                    .toString(16)
                    .substring(1)
                }
                return `${t()}${t()}-${t()}-${t()}-${t()}-${t()}${t()}${t()}`
              })()),
              (this.makingOffer = !1),
              (this.ignoreOffer = !1),
              (this.isSettingRemoteAnswerPending = !1),
              (this.offerOptions = {
                offerToReceiveAudio: !0,
                offerToReceiveVideo: !0,
              }),
              (this.start = () =>
                oh(this, void 0, void 0, function* () {
                  try {
                    this.media.currentStream = yield this.media.getUserMedia()
                    for (const t of this.media.currentStream.getTracks())
                      this.pc.addTrack(t, this.media.currentStream)
                    ;(this.selfView.srcObject = this.media.currentStream),
                      (this.selfView.muted = !0)
                  } catch (t) {
                    console.error(t)
                  }
                })),
              (this.restart = () =>
                oh(this, void 0, void 0, function* () {
                  ;(this.offerOptions.iceRestart = !0),
                    this.makeOffer(this.offerOptions)
                }))
          }
          makeOffer(t) {
            return oh(this, void 0, void 0, function* () {
              try {
                ;(this.makingOffer = !0),
                  yield this.pc.setLocalDescription(
                    yield this.pc.createOffer(t)
                  ),
                  this.signaling.send({
                    sender: this.sender,
                    description: this.pc.localDescription,
                  })
              } catch (e) {
                console.error(e)
              } finally {
                this.makingOffer = !1
              }
            })
          }
          ngAfterViewInit() {
            ;(this.selfView = this.selfViewRef.nativeElement),
              (this.remoteView = this.remoteViewRef.nativeElement),
              (this.pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.stunprotocol.org:3478' }],
              })),
              this.pc.addEventListener('track', ({ track: t, streams: e }) => {
                t.addEventListener('unmute', () => {
                  this.remoteView.srcObject ||
                    ((this.remoteView.srcObject = e[0]), this.active.next(!0))
                })
              }),
              this.pc.addEventListener('icecandidate', ({ candidate: t }) => {
                t && this.signaling.send({ sender: this.sender, candidate: t })
              }),
              this.pc.addEventListener('negotiationneeded', () =>
                oh(this, void 0, void 0, function* () {
                  this.makeOffer(this.offerOptions)
                })
              ),
              (this.subs = this.signaling.message$.subscribe(
                ({ sender: t, description: e, candidate: n }) =>
                  oh(this, void 0, void 0, function* () {
                    console.log('sender: ', t)
                    try {
                      if (e) {
                        const n =
                            !this.makingOffer &&
                            ('stable' == this.pc.signalingState ||
                              this.isSettingRemoteAnswerPending),
                          i = e.type == hh.Offer && !n
                        if (
                          ((this.ignoreOffer = t === this.sender && i),
                          this.ignoreOffer)
                        )
                          return
                        ;(this.isSettingRemoteAnswerPending =
                          e.type == hh.Answer),
                          yield this.pc.setRemoteDescription(e),
                          (this.isSettingRemoteAnswerPending = !1),
                          e.type == hh.Offer &&
                            (yield this.pc.setLocalDescription(
                              yield this.pc.createAnswer()
                            ),
                            this.signaling.send({
                              description: this.pc.localDescription,
                            }))
                      } else if (n)
                        try {
                          yield this.pc.addIceCandidate(n)
                        } catch (i) {
                          if (!this.ignoreOffer) throw i
                        }
                    } catch (i) {
                      console.error(i)
                    }
                  })
              )),
              this.start()
          }
          hangup() {
            console.log('Ending call'),
              this.media.currentStream.getTracks().forEach((t) => t.stop()),
              this.pc && (this.pc.close(), (this.pc = null))
          }
          ngOnDestroy() {
            this.hangup(), this.subs && this.subs.unsubscribe()
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(Ao(lh), Ao(dh))
          }),
          (t.ɵcmp = Ut({
            type: t,
            selectors: [['app-perfect-negotiation']],
            viewQuery: function (t, e) {
              if ((1 & t && (ec(iu, !0), ec(su, !0)), 2 & t)) {
                let t
                tc((t = ic())) && (e.selfViewRef = t.first),
                  tc((t = ic())) && (e.remoteViewRef = t.first)
              }
            },
            decls: 8,
            vars: 3,
            consts: [
              [4, 'ngIf'],
              ['id', 'remote'],
              ['autoplay', ''],
              ['remoteView', ''],
              ['id', 'self'],
              ['selfView', ''],
              [1, 'center'],
              [3, 'animation'],
              [1, 'mat-h3', 'mat-hint'],
            ],
            template: function (t, e) {
              1 & t &&
                (ko(0, ru, 5, 1, 'ng-container', 0),
                Vl(1, 'async'),
                Ro(2, 'div', 1),
                Do(3, 'video', 2, 3),
                Po(),
                Ro(5, 'div', 4),
                Do(6, 'video', 2, 5),
                Po()),
                2 & t && Oo('ngIf', !Ul(1, 1, e.active$))
            },
            directives: [Vh, nu],
            pipes: [Kh],
            styles: [
              '[_nghost-%COMP%]{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative}[_nghost-%COMP%]   .center[_ngcontent-%COMP%]{position:absolute;text-align:center;max-width:150px}[_nghost-%COMP%]   .center[_ngcontent-%COMP%]   h3[_ngcontent-%COMP%]{margin-top:16px;line-height:1.2}#remote[_ngcontent-%COMP%]{width:100%;height:100%;display:flex;align-items:center;justify-content:center}#remote[_ngcontent-%COMP%]   video[_ngcontent-%COMP%]{max-width:100vw;height:100%;object-fit:cover}#self[_ngcontent-%COMP%]{position:fixed;bottom:32px;right:32px;border-radius:50%;overflow:hidden;width:160px;height:160px;display:flex;align-items:center;justify-content:center;border:3px solid #fff;border-radius:100%}#self[_ngcontent-%COMP%]   video[_ngcontent-%COMP%]{width:auto;height:154px;object-fit:contain}',
            ],
            changeDetection: 0,
          })),
          t
        )
      })()
      const au = ['selfView'],
        lu = ['remoteView']
      let cu = (() => {
        class t {
          constructor(t, e) {
            ;(this.signaling = t),
              (this.media = e),
              (this.constraints = { audio: !0, video: !0 }),
              (this.active = new x()),
              (this.active$ = this.active.asObservable()),
              (this.offerOptions = {
                offerToReceiveAudio: !0,
                offerToReceiveVideo: !0,
              }),
              (this.start = () => {
                this.addCameraMic()
              }),
              (this.addCameraMic = () =>
                oh(this, void 0, void 0, function* () {
                  try {
                    this.media.currentStream = yield this.media.getUserMedia(
                      this.constraints
                    )
                    for (const t of this.media.currentStream.getTracks())
                      this.pc.addTrack(t, this.media.currentStream)
                    this.selfView.srcObject = this.media.currentStream
                  } catch (t) {
                    console.error(t)
                  }
                }))
          }
          ngOnInit() {}
          ngAfterViewInit() {
            ;(this.selfView = this.selfViewRef.nativeElement),
              (this.remoteView = this.remoteViewRef.nativeElement),
              (this.pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.stunprotocol.org:3478' }],
              })),
              this.pc.addEventListener('icecandidate', ({ candidate: t }) =>
                this.signaling.send({ candidate: t })
              ),
              (this.pc.onnegotiationneeded = () =>
                oh(this, void 0, void 0, function* () {
                  try {
                    yield this.pc.setLocalDescription(
                      yield this.pc.createOffer(this.offerOptions)
                    ),
                      this.signaling.send({
                        description: this.pc.localDescription,
                      })
                  } catch (t) {
                    console.error(t)
                  }
                })),
              (this.pc.ontrack = ({ track: t, streams: e }) => {
                t.onunmute = () => {
                  this.remoteView.srcObject ||
                    ((this.remoteView.srcObject = e[0]), this.active.next(!0))
                }
              }),
              this.signaling.message$.subscribe(
                ({ description: t, candidate: e }) =>
                  oh(this, void 0, void 0, function* () {
                    try {
                      t
                        ? (yield this.pc.setRemoteDescription(t),
                          'offer' == t.type &&
                            (this.selfView.srcObject ||
                              (yield this.addCameraMic()),
                            yield this.pc.setLocalDescription(
                              yield this.pc.createAnswer()
                            ),
                            this.signaling.send({
                              description: this.pc.localDescription,
                            })))
                        : e && (yield this.pc.addIceCandidate(e))
                    } catch (n) {
                      console.error(n)
                    }
                  })
              ),
              this.start()
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(Ao(lh), Ao(dh))
          }),
          (t.ɵcmp = Ut({
            type: t,
            selectors: [['app-peer-to-peer']],
            viewQuery: function (t, e) {
              if ((1 & t && (ec(au, !0), ec(lu, !0)), 2 & t)) {
                let t
                tc((t = ic())) && (e.selfViewRef = t.first),
                  tc((t = ic())) && (e.remoteViewRef = t.first)
              }
            },
            decls: 8,
            vars: 3,
            consts: [
              [3, 'animation'],
              ['id', 'remote'],
              ['autoplay', ''],
              ['remoteView', ''],
              ['id', 'self'],
              ['selfView', ''],
            ],
            template: function (t, e) {
              1 & t &&
                (Do(0, 'app-call-avatar', 0),
                Vl(1, 'async'),
                Ro(2, 'div', 1),
                Do(3, 'video', 2, 3),
                Po(),
                Ro(5, 'div', 4),
                Do(6, 'video', 2, 5),
                Po()),
                2 & t && Oo('animation', null === Ul(1, 1, e.active$))
            },
            directives: [nu],
            pipes: [Kh],
            styles: [
              '[_nghost-%COMP%]{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative}[_nghost-%COMP%]   app-call-avatar[_ngcontent-%COMP%]{position:absolute}#remote[_ngcontent-%COMP%]{width:100%;height:100%;display:flex;align-items:center;justify-content:center}#remote[_ngcontent-%COMP%]   video[_ngcontent-%COMP%]{max-width:100vw;height:100%;object-fit:contain}#self[_ngcontent-%COMP%]{position:fixed;bottom:0;right:0;border-radius:50%;overflow:hidden;width:120px;height:120px;display:flex;align-items:center;justify-content:center}#self[_ngcontent-%COMP%]   video[_ngcontent-%COMP%]{height:120px;width:auto;object-fit:contain}',
            ],
          })),
          t
        )
      })()
      function hu(t) {
        return null != t && '' + t != 'false'
      }
      function uu(t, e = 0) {
        return (function (t) {
          return !isNaN(parseFloat(t)) && !isNaN(Number(t))
        })(t)
          ? Number(t)
          : e
      }
      function du(t) {
        return Array.isArray(t) ? t : [t]
      }
      function pu(t) {
        return null == t ? '' : 'string' == typeof t ? t : t + 'px'
      }
      function fu(t) {
        return t instanceof Va ? t.nativeElement : t
      }
      function mu(...t) {
        let e = t[t.length - 1]
        return E(e) ? (t.pop(), j(t, e)) : q(t)
      }
      function gu(t, e, n, s) {
        return (
          i(n) && ((s = n), (n = void 0)),
          s
            ? gu(t, e, n).pipe(F((t) => (l(t) ? s(...t) : s(t))))
            : new _((i) => {
                yu(
                  t,
                  e,
                  function (t) {
                    i.next(
                      arguments.length > 1
                        ? Array.prototype.slice.call(arguments)
                        : t
                    )
                  },
                  i,
                  n
                )
              })
        )
      }
      function yu(t, e, n, i, s) {
        let r
        if (
          (function (t) {
            return (
              t &&
              'function' == typeof t.addEventListener &&
              'function' == typeof t.removeEventListener
            )
          })(t)
        ) {
          const i = t
          t.addEventListener(e, n, s),
            (r = () => i.removeEventListener(e, n, s))
        } else if (
          (function (t) {
            return t && 'function' == typeof t.on && 'function' == typeof t.off
          })(t)
        ) {
          const i = t
          t.on(e, n), (r = () => i.off(e, n))
        } else if (
          (function (t) {
            return (
              t &&
              'function' == typeof t.addListener &&
              'function' == typeof t.removeListener
            )
          })(t)
        ) {
          const i = t
          t.addListener(e, n), (r = () => i.removeListener(e, n))
        } else {
          if (!t || !t.length) throw new TypeError('Invalid event target')
          for (let r = 0, o = t.length; r < o; r++) yu(t[r], e, n, i, s)
        }
        i.add(r)
      }
      class _u extends u {
        constructor(t, e) {
          super()
        }
        schedule(t, e = 0) {
          return this
        }
      }
      class vu extends _u {
        constructor(t, e) {
          super(t, e),
            (this.scheduler = t),
            (this.work = e),
            (this.pending = !1)
        }
        schedule(t, e = 0) {
          if (this.closed) return this
          this.state = t
          const n = this.id,
            i = this.scheduler
          return (
            null != n && (this.id = this.recycleAsyncId(i, n, e)),
            (this.pending = !0),
            (this.delay = e),
            (this.id = this.id || this.requestAsyncId(i, this.id, e)),
            this
          )
        }
        requestAsyncId(t, e, n = 0) {
          return setInterval(t.flush.bind(t, this), n)
        }
        recycleAsyncId(t, e, n = 0) {
          if (null !== n && this.delay === n && !1 === this.pending) return e
          clearInterval(e)
        }
        execute(t, e) {
          if (this.closed) return new Error('executing a cancelled action')
          this.pending = !1
          const n = this._execute(t, e)
          if (n) return n
          !1 === this.pending &&
            null != this.id &&
            (this.id = this.recycleAsyncId(this.scheduler, this.id, null))
        }
        _execute(t, e) {
          let n = !1,
            i = void 0
          try {
            this.work(t)
          } catch (s) {
            ;(n = !0), (i = (!!s && s) || new Error(s))
          }
          if (n) return this.unsubscribe(), i
        }
        _unsubscribe() {
          const t = this.id,
            e = this.scheduler,
            n = e.actions,
            i = n.indexOf(this)
          ;(this.work = null),
            (this.state = null),
            (this.pending = !1),
            (this.scheduler = null),
            -1 !== i && n.splice(i, 1),
            null != t && (this.id = this.recycleAsyncId(e, t, null)),
            (this.delay = null)
        }
      }
      let bu = (() => {
        class t {
          constructor(e, n = t.now) {
            ;(this.SchedulerAction = e), (this.now = n)
          }
          schedule(t, e = 0, n) {
            return new this.SchedulerAction(this, t).schedule(n, e)
          }
        }
        return (t.now = () => Date.now()), t
      })()
      class wu extends bu {
        constructor(t, e = bu.now) {
          super(t, () =>
            wu.delegate && wu.delegate !== this ? wu.delegate.now() : e()
          ),
            (this.actions = []),
            (this.active = !1),
            (this.scheduled = void 0)
        }
        schedule(t, e = 0, n) {
          return wu.delegate && wu.delegate !== this
            ? wu.delegate.schedule(t, e, n)
            : super.schedule(t, e, n)
        }
        flush(t) {
          const { actions: e } = this
          if (this.active) return void e.push(t)
          let n
          this.active = !0
          do {
            if ((n = t.execute(t.state, t.delay))) break
          } while ((t = e.shift()))
          if (((this.active = !1), n)) {
            for (; (t = e.shift()); ) t.unsubscribe()
            throw n
          }
        }
      }
      class Cu {
        constructor(t, e) {
          ;(this.compare = t), (this.keySelector = e)
        }
        call(t, e) {
          return e.subscribe(new xu(t, this.compare, this.keySelector))
        }
      }
      class xu extends f {
        constructor(t, e, n) {
          super(t),
            (this.keySelector = n),
            (this.hasKey = !1),
            'function' == typeof e && (this.compare = e)
        }
        compare(t, e) {
          return t === e
        }
        _next(t) {
          let e
          try {
            const { keySelector: n } = this
            e = n ? n(t) : t
          } catch (i) {
            return this.destination.error(i)
          }
          let n = !1
          if (this.hasKey)
            try {
              const { compare: t } = this
              n = t(this.key, e)
            } catch (i) {
              return this.destination.error(i)
            }
          else this.hasKey = !0
          n || ((this.key = e), this.destination.next(t))
        }
      }
      const Su = new wu(vu)
      class Eu {
        constructor(t) {
          this.durationSelector = t
        }
        call(t, e) {
          return e.subscribe(new ku(t, this.durationSelector))
        }
      }
      class ku extends N {
        constructor(t, e) {
          super(t), (this.durationSelector = e), (this.hasValue = !1)
        }
        _next(t) {
          if (((this.value = t), (this.hasValue = !0), !this.throttled)) {
            let n
            try {
              const { durationSelector: e } = this
              n = e(t)
            } catch (e) {
              return this.destination.error(e)
            }
            const i = D(this, n)
            !i || i.closed
              ? this.clearThrottle()
              : this.add((this.throttled = i))
          }
        }
        clearThrottle() {
          const { value: t, hasValue: e, throttled: n } = this
          n && (this.remove(n), (this.throttled = null), n.unsubscribe()),
            e &&
              ((this.value = null),
              (this.hasValue = !1),
              this.destination.next(t))
        }
        notifyNext(t, e, n, i) {
          this.clearThrottle()
        }
        notifyComplete() {
          this.clearThrottle()
        }
      }
      function Tu(t) {
        return !l(t) && t - parseFloat(t) + 1 >= 0
      }
      function Au(t) {
        const { index: e, period: n, subscriber: i } = t
        if ((i.next(e), !i.closed)) {
          if (-1 === n) return i.complete()
          ;(t.index = e + 1), this.schedule(t, n)
        }
      }
      function Ou(t, e = Su) {
        return (
          (n = () =>
            (function (t = 0, e, n) {
              let i = -1
              return (
                Tu(e) ? (i = Number(e) < 1 ? 1 : Number(e)) : E(e) && (n = e),
                E(n) || (n = Su),
                new _((e) => {
                  const s = Tu(t) ? t : +t - n.now()
                  return n.schedule(Au, s, {
                    index: 0,
                    period: i,
                    subscriber: e,
                  })
                })
              )
            })(t, e)),
          function (t) {
            return t.lift(new Eu(n))
          }
        )
        var n
      }
      function Iu(t, e) {
        return function (n) {
          return n.lift(new Ru(t, e))
        }
      }
      class Ru {
        constructor(t, e) {
          ;(this.predicate = t), (this.thisArg = e)
        }
        call(t, e) {
          return e.subscribe(new Pu(t, this.predicate, this.thisArg))
        }
      }
      class Pu extends f {
        constructor(t, e, n) {
          super(t), (this.predicate = e), (this.thisArg = n), (this.count = 0)
        }
        _next(t) {
          let e
          try {
            e = this.predicate.call(this.thisArg, t, this.count++)
          } catch (n) {
            return void this.destination.error(n)
          }
          e && this.destination.next(t)
        }
      }
      function Du(t) {
        return (e) => e.lift(new Nu(t))
      }
      class Nu {
        constructor(t) {
          this.notifier = t
        }
        call(t, e) {
          const n = new Fu(t),
            i = D(n, this.notifier)
          return i && !n.seenValue ? (n.add(i), e.subscribe(n)) : n
        }
      }
      class Fu extends N {
        constructor(t) {
          super(t), (this.seenValue = !1)
        }
        notifyNext(t, e, n, i, s) {
          ;(this.seenValue = !0), this.complete()
        }
        notifyComplete() {}
      }
      function Mu() {
        return H(1)
      }
      function Lu(...t) {
        return Mu()(mu(...t))
      }
      function ju(...t) {
        const e = t[t.length - 1]
        return E(e) ? (t.pop(), (n) => Lu(t, n, e)) : (e) => Lu(t, e)
      }
      function Bu(t, e) {
        return 'function' == typeof e
          ? (n) =>
              n.pipe(Bu((n, i) => B(t(n, i)).pipe(F((t, s) => e(n, t, i, s)))))
          : (e) => e.lift(new Vu(t))
      }
      class Vu {
        constructor(t) {
          this.project = t
        }
        call(t, e) {
          return e.subscribe(new Uu(t, this.project))
        }
      }
      class Uu extends N {
        constructor(t, e) {
          super(t), (this.project = e), (this.index = 0)
        }
        _next(t) {
          let e
          const n = this.index++
          try {
            e = this.project(t, n)
          } catch (i) {
            return void this.destination.error(i)
          }
          this._innerSub(e, t, n)
        }
        _innerSub(t, e, n) {
          const i = this.innerSubscription
          i && i.unsubscribe()
          const s = new k(this, e, n),
            r = this.destination
          r.add(s),
            (this.innerSubscription = D(this, t, void 0, void 0, s)),
            this.innerSubscription !== s && r.add(this.innerSubscription)
        }
        _complete() {
          const { innerSubscription: t } = this
          ;(t && !t.closed) || super._complete(), this.unsubscribe()
        }
        _unsubscribe() {
          this.innerSubscription = null
        }
        notifyComplete(t) {
          this.destination.remove(t),
            (this.innerSubscription = null),
            this.isStopped && super._complete()
        }
        notifyNext(t, e, n, i, s) {
          this.destination.next(e)
        }
      }
      const zu = new _((t) => t.complete())
      function Hu(t) {
        return t
          ? (function (t) {
              return new _((e) => t.schedule(() => e.complete()))
            })(t)
          : zu
      }
      function qu(t, e) {
        return new _(
          e
            ? (n) => e.schedule($u, 0, { error: t, subscriber: n })
            : (e) => e.error(t)
        )
      }
      function $u({ error: t, subscriber: e }) {
        e.error(t)
      }
      let Wu,
        Ku = (() => {
          class t {
            constructor(t, e, n) {
              ;(this.kind = t),
                (this.value = e),
                (this.error = n),
                (this.hasValue = 'N' === t)
            }
            observe(t) {
              switch (this.kind) {
                case 'N':
                  return t.next && t.next(this.value)
                case 'E':
                  return t.error && t.error(this.error)
                case 'C':
                  return t.complete && t.complete()
              }
            }
            do(t, e, n) {
              switch (this.kind) {
                case 'N':
                  return t && t(this.value)
                case 'E':
                  return e && e(this.error)
                case 'C':
                  return n && n()
              }
            }
            accept(t, e, n) {
              return t && 'function' == typeof t.next
                ? this.observe(t)
                : this.do(t, e, n)
            }
            toObservable() {
              switch (this.kind) {
                case 'N':
                  return mu(this.value)
                case 'E':
                  return qu(this.error)
                case 'C':
                  return Hu()
              }
              throw new Error('unexpected notification kind value')
            }
            static createNext(e) {
              return void 0 !== e ? new t('N', e) : t.undefinedValueNotification
            }
            static createError(e) {
              return new t('E', void 0, e)
            }
            static createComplete() {
              return t.completeNotification
            }
          }
          return (
            (t.completeNotification = new t('C')),
            (t.undefinedValueNotification = new t('N', void 0)),
            t
          )
        })()
      try {
        Wu = 'undefined' != typeof Intl && Intl.v8BreakIterator
      } catch (mS) {
        Wu = !1
      }
      let Gu,
        Qu,
        Zu,
        Yu,
        Xu = (() => {
          class t {
            constructor(t) {
              ;(this._platformId = t),
                (this.isBrowser = this._platformId
                  ? Qh(this._platformId)
                  : 'object' == typeof document && !!document),
                (this.EDGE =
                  this.isBrowser && /(edge)/i.test(navigator.userAgent)),
                (this.TRIDENT =
                  this.isBrowser &&
                  /(msie|trident)/i.test(navigator.userAgent)),
                (this.BLINK =
                  this.isBrowser &&
                  !(!window.chrome && !Wu) &&
                  'undefined' != typeof CSS &&
                  !this.EDGE &&
                  !this.TRIDENT),
                (this.WEBKIT =
                  this.isBrowser &&
                  /AppleWebKit/i.test(navigator.userAgent) &&
                  !this.BLINK &&
                  !this.EDGE &&
                  !this.TRIDENT),
                (this.IOS =
                  this.isBrowser &&
                  /iPad|iPhone|iPod/.test(navigator.userAgent) &&
                  !('MSStream' in window)),
                (this.FIREFOX =
                  this.isBrowser &&
                  /(firefox|minefield)/i.test(navigator.userAgent)),
                (this.ANDROID =
                  this.isBrowser &&
                  /android/i.test(navigator.userAgent) &&
                  !this.TRIDENT),
                (this.SAFARI =
                  this.isBrowser &&
                  /safari/i.test(navigator.userAgent) &&
                  this.WEBKIT)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(fc))
            }),
            (t.ɵprov = ht({
              factory: function () {
                return new t(vi(fc))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        Ju = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
            })),
            t
          )
        })()
      function td(t) {
        return (function () {
          if (null == Gu && 'undefined' != typeof window)
            try {
              window.addEventListener(
                'test',
                null,
                Object.defineProperty({}, 'passive', { get: () => (Gu = !0) })
              )
            } finally {
              Gu = Gu || !1
            }
          return Gu
        })()
          ? t
          : !!t.capture
      }
      function ed() {
        if ('object' != typeof document || !document) return 0
        if (null == Qu) {
          const t = document.createElement('div'),
            e = t.style
          ;(t.dir = 'rtl'),
            (e.width = '1px'),
            (e.overflow = 'auto'),
            (e.visibility = 'hidden'),
            (e.pointerEvents = 'none'),
            (e.position = 'absolute')
          const n = document.createElement('div'),
            i = n.style
          ;(i.width = '2px'),
            (i.height = '1px'),
            t.appendChild(n),
            document.body.appendChild(t),
            (Qu = 0),
            0 === t.scrollLeft &&
              ((t.scrollLeft = 1), (Qu = 0 === t.scrollLeft ? 1 : 2)),
            t.parentNode.removeChild(t)
        }
        return Qu
      }
      const nd = new Yn('cdk-dir-doc', {
        providedIn: 'root',
        factory: function () {
          return bi(mh)
        },
      })
      let id = (() => {
          class t {
            constructor(t) {
              if (((this.value = 'ltr'), (this.change = new zl()), t)) {
                const e = t.documentElement ? t.documentElement.dir : null,
                  n = (t.body ? t.body.dir : null) || e
                this.value = 'ltr' === n || 'rtl' === n ? n : 'ltr'
              }
            }
            ngOnDestroy() {
              this.change.complete()
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(nd, 8))
            }),
            (t.ɵprov = ht({
              factory: function () {
                return new t(vi(nd, 8))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        sd = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
            })),
            t
          )
        })(),
        rd = (() => {
          class t {
            constructor(t, e, n) {
              ;(this._ngZone = t),
                (this._platform = e),
                (this._scrolled = new x()),
                (this._globalSubscription = null),
                (this._scrolledCount = 0),
                (this.scrollContainers = new Map()),
                (this._document = n)
            }
            register(t) {
              this.scrollContainers.has(t) ||
                this.scrollContainers.set(
                  t,
                  t.elementScrolled().subscribe(() => this._scrolled.next(t))
                )
            }
            deregister(t) {
              const e = this.scrollContainers.get(t)
              e && (e.unsubscribe(), this.scrollContainers.delete(t))
            }
            scrolled(t = 20) {
              return this._platform.isBrowser
                ? new _((e) => {
                    this._globalSubscription || this._addGlobalListener()
                    const n =
                      t > 0
                        ? this._scrolled.pipe(Ou(t)).subscribe(e)
                        : this._scrolled.subscribe(e)
                    return (
                      this._scrolledCount++,
                      () => {
                        n.unsubscribe(),
                          this._scrolledCount--,
                          this._scrolledCount || this._removeGlobalListener()
                      }
                    )
                  })
                : mu()
            }
            ngOnDestroy() {
              this._removeGlobalListener(),
                this.scrollContainers.forEach((t, e) => this.deregister(e)),
                this._scrolled.complete()
            }
            ancestorScrolled(t, e) {
              const n = this.getAncestorScrollContainers(t)
              return this.scrolled(e).pipe(Iu((t) => !t || n.indexOf(t) > -1))
            }
            getAncestorScrollContainers(t) {
              const e = []
              return (
                this.scrollContainers.forEach((n, i) => {
                  this._scrollableContainsElement(i, t) && e.push(i)
                }),
                e
              )
            }
            _getWindow() {
              return this._document.defaultView || window
            }
            _scrollableContainsElement(t, e) {
              let n = e.nativeElement,
                i = t.getElementRef().nativeElement
              do {
                if (n == i) return !0
              } while ((n = n.parentElement))
              return !1
            }
            _addGlobalListener() {
              this._globalSubscription = this._ngZone.runOutsideAngular(() =>
                gu(this._getWindow().document, 'scroll').subscribe(() =>
                  this._scrolled.next()
                )
              )
            }
            _removeGlobalListener() {
              this._globalSubscription &&
                (this._globalSubscription.unsubscribe(),
                (this._globalSubscription = null))
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(Oc), vi(Xu), vi(mh, 8))
            }),
            (t.ɵprov = ht({
              factory: function () {
                return new t(vi(Oc), vi(Xu), vi(mh, 8))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        od = (() => {
          class t {
            constructor(t, e, n, i) {
              ;(this.elementRef = t),
                (this.scrollDispatcher = e),
                (this.ngZone = n),
                (this.dir = i),
                (this._destroyed = new x()),
                (this._elementScrolled = new _((t) =>
                  this.ngZone.runOutsideAngular(() =>
                    gu(this.elementRef.nativeElement, 'scroll')
                      .pipe(Du(this._destroyed))
                      .subscribe(t)
                  )
                ))
            }
            ngOnInit() {
              this.scrollDispatcher.register(this)
            }
            ngOnDestroy() {
              this.scrollDispatcher.deregister(this),
                this._destroyed.next(),
                this._destroyed.complete()
            }
            elementScrolled() {
              return this._elementScrolled
            }
            getElementRef() {
              return this.elementRef
            }
            scrollTo(t) {
              const e = this.elementRef.nativeElement,
                n = this.dir && 'rtl' == this.dir.value
              null == t.left && (t.left = n ? t.end : t.start),
                null == t.right && (t.right = n ? t.start : t.end),
                null != t.bottom &&
                  (t.top = e.scrollHeight - e.clientHeight - t.bottom),
                n && 0 != ed()
                  ? (null != t.left &&
                      (t.right = e.scrollWidth - e.clientWidth - t.left),
                    2 == ed()
                      ? (t.left = t.right)
                      : 1 == ed() && (t.left = t.right ? -t.right : t.right))
                  : null != t.right &&
                    (t.left = e.scrollWidth - e.clientWidth - t.right),
                this._applyScrollToOptions(t)
            }
            _applyScrollToOptions(t) {
              const e = this.elementRef.nativeElement
              !(function () {
                if (null == Zu)
                  if (
                    (('object' == typeof document && document) || (Zu = !1),
                    'scrollBehavior' in document.documentElement.style)
                  )
                    Zu = !0
                  else {
                    const t = Element.prototype.scrollTo
                    Zu = !!t && !/\{\s*\[native code\]\s*\}/.test(t.toString())
                  }
                return Zu
              })()
                ? (null != t.top && (e.scrollTop = t.top),
                  null != t.left && (e.scrollLeft = t.left))
                : e.scrollTo(t)
            }
            measureScrollOffset(t) {
              const e = 'left',
                n = 'right',
                i = this.elementRef.nativeElement
              if ('top' == t) return i.scrollTop
              if ('bottom' == t)
                return i.scrollHeight - i.clientHeight - i.scrollTop
              const s = this.dir && 'rtl' == this.dir.value
              return (
                'start' == t ? (t = s ? n : e) : 'end' == t && (t = s ? e : n),
                s && 2 == ed()
                  ? t == e
                    ? i.scrollWidth - i.clientWidth - i.scrollLeft
                    : i.scrollLeft
                  : s && 1 == ed()
                  ? t == e
                    ? i.scrollLeft + i.scrollWidth - i.clientWidth
                    : -i.scrollLeft
                  : t == e
                  ? i.scrollLeft
                  : i.scrollWidth - i.clientWidth - i.scrollLeft
              )
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(Ao(Va), Ao(rd), Ao(Oc), Ao(id, 8))
            }),
            (t.ɵdir = Kt({
              type: t,
              selectors: [
                ['', 'cdk-scrollable', ''],
                ['', 'cdkScrollable', ''],
              ],
            })),
            t
          )
        })(),
        ad = (() => {
          class t {
            constructor(t, e, n) {
              ;(this._platform = t),
                (this._change = new x()),
                (this._changeListener = (t) => {
                  this._change.next(t)
                }),
                (this._document = n),
                e.runOutsideAngular(() => {
                  if (t.isBrowser) {
                    const t = this._getWindow()
                    t.addEventListener('resize', this._changeListener),
                      t.addEventListener(
                        'orientationchange',
                        this._changeListener
                      )
                  }
                  this.change().subscribe(() => this._updateViewportSize())
                })
            }
            ngOnDestroy() {
              if (this._platform.isBrowser) {
                const t = this._getWindow()
                t.removeEventListener('resize', this._changeListener),
                  t.removeEventListener(
                    'orientationchange',
                    this._changeListener
                  )
              }
              this._change.complete()
            }
            getViewportSize() {
              this._viewportSize || this._updateViewportSize()
              const t = {
                width: this._viewportSize.width,
                height: this._viewportSize.height,
              }
              return this._platform.isBrowser || (this._viewportSize = null), t
            }
            getViewportRect() {
              const t = this.getViewportScrollPosition(),
                { width: e, height: n } = this.getViewportSize()
              return {
                top: t.top,
                left: t.left,
                bottom: t.top + n,
                right: t.left + e,
                height: n,
                width: e,
              }
            }
            getViewportScrollPosition() {
              if (!this._platform.isBrowser) return { top: 0, left: 0 }
              const t = this._document,
                e = this._getWindow(),
                n = t.documentElement,
                i = n.getBoundingClientRect()
              return {
                top:
                  -i.top || t.body.scrollTop || e.scrollY || n.scrollTop || 0,
                left:
                  -i.left ||
                  t.body.scrollLeft ||
                  e.scrollX ||
                  n.scrollLeft ||
                  0,
              }
            }
            change(t = 20) {
              return t > 0 ? this._change.pipe(Ou(t)) : this._change
            }
            _getWindow() {
              return this._document.defaultView || window
            }
            _updateViewportSize() {
              const t = this._getWindow()
              this._viewportSize = this._platform.isBrowser
                ? { width: t.innerWidth, height: t.innerHeight }
                : { width: 0, height: 0 }
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(Xu), vi(Oc), vi(mh, 8))
            }),
            (t.ɵprov = ht({
              factory: function () {
                return new t(vi(Xu), vi(Oc), vi(mh, 8))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        ld = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
            })),
            t
          )
        })(),
        cd = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[sd, Ju, ld], sd, ld],
            })),
            t
          )
        })()
      class hd {
        attach(t) {
          return (this._attachedHost = t), t.attach(this)
        }
        detach() {
          let t = this._attachedHost
          null != t && ((this._attachedHost = null), t.detach())
        }
        get isAttached() {
          return null != this._attachedHost
        }
        setAttachedHost(t) {
          this._attachedHost = t
        }
      }
      class ud extends hd {
        constructor(t, e, n, i) {
          super(),
            (this.component = t),
            (this.viewContainerRef = e),
            (this.injector = n),
            (this.componentFactoryResolver = i)
        }
      }
      class dd extends hd {
        constructor(t, e, n) {
          super(),
            (this.templateRef = t),
            (this.viewContainerRef = e),
            (this.context = n)
        }
        get origin() {
          return this.templateRef.elementRef
        }
        attach(t, e = this.context) {
          return (this.context = e), super.attach(t)
        }
        detach() {
          return (this.context = void 0), super.detach()
        }
      }
      class pd extends hd {
        constructor(t) {
          super(), (this.element = t instanceof Va ? t.nativeElement : t)
        }
      }
      class fd extends class {
        constructor() {
          ;(this._isDisposed = !1), (this.attachDomPortal = null)
        }
        hasAttached() {
          return !!this._attachedPortal
        }
        attach(t) {
          return t instanceof ud
            ? ((this._attachedPortal = t), this.attachComponentPortal(t))
            : t instanceof dd
            ? ((this._attachedPortal = t), this.attachTemplatePortal(t))
            : this.attachDomPortal && t instanceof pd
            ? ((this._attachedPortal = t), this.attachDomPortal(t))
            : void 0
        }
        detach() {
          this._attachedPortal &&
            (this._attachedPortal.setAttachedHost(null),
            (this._attachedPortal = null)),
            this._invokeDisposeFn()
        }
        dispose() {
          this.hasAttached() && this.detach(),
            this._invokeDisposeFn(),
            (this._isDisposed = !0)
        }
        setDisposeFn(t) {
          this._disposeFn = t
        }
        _invokeDisposeFn() {
          this._disposeFn && (this._disposeFn(), (this._disposeFn = null))
        }
      } {
        constructor(t, e, n, i, s) {
          super(),
            (this.outletElement = t),
            (this._componentFactoryResolver = e),
            (this._appRef = n),
            (this._defaultInjector = i),
            (this.attachDomPortal = (t) => {
              const e = t.element,
                n = this._document.createComment('dom-portal')
              e.parentNode.insertBefore(n, e),
                this.outletElement.appendChild(e),
                super.setDisposeFn(() => {
                  n.parentNode && n.parentNode.replaceChild(e, n)
                })
            }),
            (this._document = s)
        }
        attachComponentPortal(t) {
          const e = (
            t.componentFactoryResolver || this._componentFactoryResolver
          ).resolveComponentFactory(t.component)
          let n
          return (
            t.viewContainerRef
              ? ((n = t.viewContainerRef.createComponent(
                  e,
                  t.viewContainerRef.length,
                  t.injector || t.viewContainerRef.injector
                )),
                this.setDisposeFn(() => n.destroy()))
              : ((n = e.create(t.injector || this._defaultInjector)),
                this._appRef.attachView(n.hostView),
                this.setDisposeFn(() => {
                  this._appRef.detachView(n.hostView), n.destroy()
                })),
            this.outletElement.appendChild(this._getComponentRootNode(n)),
            n
          )
        }
        attachTemplatePortal(t) {
          let e = t.viewContainerRef,
            n = e.createEmbeddedView(t.templateRef, t.context)
          return (
            n.rootNodes.forEach((t) => this.outletElement.appendChild(t)),
            n.detectChanges(),
            this.setDisposeFn(() => {
              let t = e.indexOf(n)
              ;-1 !== t && e.remove(t)
            }),
            n
          )
        }
        dispose() {
          super.dispose(),
            null != this.outletElement.parentNode &&
              this.outletElement.parentNode.removeChild(this.outletElement)
        }
        _getComponentRootNode(t) {
          return t.hostView.rootNodes[0]
        }
      }
      let md = (() => {
        class t {}
        return (
          (t.ɵmod = $t({ type: t })),
          (t.ɵinj = ut({
            factory: function (e) {
              return new (e || t)()
            },
          })),
          t
        )
      })()
      class gd {
        constructor(t, e) {
          ;(this._parentInjector = t), (this._customTokens = e)
        }
        get(t, e) {
          const n = this._customTokens.get(t)
          return void 0 !== n ? n : this._parentInjector.get(t, e)
        }
      }
      const yd = (() => {
        function t() {
          return (
            Error.call(this),
            (this.message = 'argument out of range'),
            (this.name = 'ArgumentOutOfRangeError'),
            this
          )
        }
        return (t.prototype = Object.create(Error.prototype)), t
      })()
      function _d(t) {
        return (e) => (0 === t ? Hu() : e.lift(new vd(t)))
      }
      class vd {
        constructor(t) {
          if (((this.total = t), this.total < 0)) throw new yd()
        }
        call(t, e) {
          return e.subscribe(new bd(t, this.total))
        }
      }
      class bd extends f {
        constructor(t, e) {
          super(t), (this.total = e), (this.count = 0)
        }
        _next(t) {
          const e = this.total,
            n = ++this.count
          n <= e &&
            (this.destination.next(t),
            n === e && (this.destination.complete(), this.unsubscribe()))
        }
      }
      function wd(t, ...e) {
        return e.length
          ? e.some((e) => t[e])
          : t.altKey || t.shiftKey || t.ctrlKey || t.metaKey
      }
      class Cd {
        constructor(t, e) {
          ;(this._viewportRuler = t),
            (this._previousHTMLStyles = { top: '', left: '' }),
            (this._isEnabled = !1),
            (this._document = e)
        }
        attach() {}
        enable() {
          if (this._canBeEnabled()) {
            const t = this._document.documentElement
            ;(this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition()),
              (this._previousHTMLStyles.left = t.style.left || ''),
              (this._previousHTMLStyles.top = t.style.top || ''),
              (t.style.left = pu(-this._previousScrollPosition.left)),
              (t.style.top = pu(-this._previousScrollPosition.top)),
              t.classList.add('cdk-global-scrollblock'),
              (this._isEnabled = !0)
          }
        }
        disable() {
          if (this._isEnabled) {
            const t = this._document.documentElement,
              e = t.style,
              n = this._document.body.style,
              i = e.scrollBehavior || '',
              s = n.scrollBehavior || ''
            ;(this._isEnabled = !1),
              (e.left = this._previousHTMLStyles.left),
              (e.top = this._previousHTMLStyles.top),
              t.classList.remove('cdk-global-scrollblock'),
              (e.scrollBehavior = n.scrollBehavior = 'auto'),
              window.scroll(
                this._previousScrollPosition.left,
                this._previousScrollPosition.top
              ),
              (e.scrollBehavior = i),
              (n.scrollBehavior = s)
          }
        }
        _canBeEnabled() {
          if (
            this._document.documentElement.classList.contains(
              'cdk-global-scrollblock'
            ) ||
            this._isEnabled
          )
            return !1
          const t = this._document.body,
            e = this._viewportRuler.getViewportSize()
          return t.scrollHeight > e.height || t.scrollWidth > e.width
        }
      }
      class xd {
        constructor(t, e, n, i) {
          ;(this._scrollDispatcher = t),
            (this._ngZone = e),
            (this._viewportRuler = n),
            (this._config = i),
            (this._scrollSubscription = null),
            (this._detach = () => {
              this.disable(),
                this._overlayRef.hasAttached() &&
                  this._ngZone.run(() => this._overlayRef.detach())
            })
        }
        attach(t) {
          this._overlayRef = t
        }
        enable() {
          if (this._scrollSubscription) return
          const t = this._scrollDispatcher.scrolled(0)
          this._config && this._config.threshold && this._config.threshold > 1
            ? ((this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top),
              (this._scrollSubscription = t.subscribe(() => {
                const t = this._viewportRuler.getViewportScrollPosition().top
                Math.abs(t - this._initialScrollPosition) >
                this._config.threshold
                  ? this._detach()
                  : this._overlayRef.updatePosition()
              })))
            : (this._scrollSubscription = t.subscribe(this._detach))
        }
        disable() {
          this._scrollSubscription &&
            (this._scrollSubscription.unsubscribe(),
            (this._scrollSubscription = null))
        }
        detach() {
          this.disable(), (this._overlayRef = null)
        }
      }
      class Sd {
        enable() {}
        disable() {}
        attach() {}
      }
      function Ed(t, e) {
        return e.some(
          (e) =>
            t.bottom < e.top ||
            t.top > e.bottom ||
            t.right < e.left ||
            t.left > e.right
        )
      }
      function kd(t, e) {
        return e.some(
          (e) =>
            t.top < e.top ||
            t.bottom > e.bottom ||
            t.left < e.left ||
            t.right > e.right
        )
      }
      class Td {
        constructor(t, e, n, i) {
          ;(this._scrollDispatcher = t),
            (this._viewportRuler = e),
            (this._ngZone = n),
            (this._config = i),
            (this._scrollSubscription = null)
        }
        attach(t) {
          this._overlayRef = t
        }
        enable() {
          this._scrollSubscription ||
            (this._scrollSubscription = this._scrollDispatcher
              .scrolled(this._config ? this._config.scrollThrottle : 0)
              .subscribe(() => {
                if (
                  (this._overlayRef.updatePosition(),
                  this._config && this._config.autoClose)
                ) {
                  const t = this._overlayRef.overlayElement.getBoundingClientRect(),
                    {
                      width: e,
                      height: n,
                    } = this._viewportRuler.getViewportSize()
                  Ed(t, [
                    {
                      width: e,
                      height: n,
                      bottom: n,
                      right: e,
                      top: 0,
                      left: 0,
                    },
                  ]) &&
                    (this.disable(),
                    this._ngZone.run(() => this._overlayRef.detach()))
                }
              }))
        }
        disable() {
          this._scrollSubscription &&
            (this._scrollSubscription.unsubscribe(),
            (this._scrollSubscription = null))
        }
        detach() {
          this.disable(), (this._overlayRef = null)
        }
      }
      let Ad = (() => {
        class t {
          constructor(t, e, n, i) {
            ;(this._scrollDispatcher = t),
              (this._viewportRuler = e),
              (this._ngZone = n),
              (this.noop = () => new Sd()),
              (this.close = (t) =>
                new xd(
                  this._scrollDispatcher,
                  this._ngZone,
                  this._viewportRuler,
                  t
                )),
              (this.block = () => new Cd(this._viewportRuler, this._document)),
              (this.reposition = (t) =>
                new Td(
                  this._scrollDispatcher,
                  this._viewportRuler,
                  this._ngZone,
                  t
                )),
              (this._document = i)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(rd), vi(ad), vi(Oc), vi(mh))
          }),
          (t.ɵprov = ht({
            factory: function () {
              return new t(vi(rd), vi(ad), vi(Oc), vi(mh))
            },
            token: t,
            providedIn: 'root',
          })),
          t
        )
      })()
      class Od {
        constructor(t) {
          if (
            ((this.scrollStrategy = new Sd()),
            (this.panelClass = ''),
            (this.hasBackdrop = !1),
            (this.backdropClass = 'cdk-overlay-dark-backdrop'),
            (this.disposeOnNavigation = !1),
            t)
          ) {
            const e = Object.keys(t)
            for (const n of e) void 0 !== t[n] && (this[n] = t[n])
          }
        }
      }
      class Id {
        constructor(t, e, n, i, s) {
          ;(this.offsetX = n),
            (this.offsetY = i),
            (this.panelClass = s),
            (this.originX = t.originX),
            (this.originY = t.originY),
            (this.overlayX = e.overlayX),
            (this.overlayY = e.overlayY)
        }
      }
      class Rd {
        constructor(t, e) {
          ;(this.connectionPair = t), (this.scrollableViewProperties = e)
        }
      }
      let Pd = (() => {
          class t {
            constructor(t) {
              ;(this._attachedOverlays = []), (this._document = t)
            }
            ngOnDestroy() {
              this.detach()
            }
            add(t) {
              this.remove(t), this._attachedOverlays.push(t)
            }
            remove(t) {
              const e = this._attachedOverlays.indexOf(t)
              e > -1 && this._attachedOverlays.splice(e, 1),
                0 === this._attachedOverlays.length && this.detach()
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(mh))
            }),
            (t.ɵprov = ht({
              factory: function () {
                return new t(vi(mh))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        Dd = (() => {
          class t extends Pd {
            constructor(t) {
              super(t),
                (this._keydownListener = (t) => {
                  const e = this._attachedOverlays
                  for (let n = e.length - 1; n > -1; n--)
                    if (e[n]._keydownEvents.observers.length > 0) {
                      e[n]._keydownEvents.next(t)
                      break
                    }
                })
            }
            add(t) {
              super.add(t),
                this._isAttached ||
                  (this._document.body.addEventListener(
                    'keydown',
                    this._keydownListener
                  ),
                  (this._isAttached = !0))
            }
            detach() {
              this._isAttached &&
                (this._document.body.removeEventListener(
                  'keydown',
                  this._keydownListener
                ),
                (this._isAttached = !1))
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(mh))
            }),
            (t.ɵprov = ht({
              factory: function () {
                return new t(vi(mh))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        Nd = (() => {
          class t extends Pd {
            constructor(t, e) {
              super(t),
                (this._platform = e),
                (this._cursorStyleIsSet = !1),
                (this._clickListener = (t) => {
                  const e = t.composedPath ? t.composedPath()[0] : t.target,
                    n = this._attachedOverlays.slice()
                  for (let i = n.length - 1; i > -1; i--) {
                    const s = n[i]
                    if (
                      !(s._outsidePointerEvents.observers.length < 1) &&
                      s.hasAttached()
                    ) {
                      if (s.overlayElement.contains(e)) break
                      s._outsidePointerEvents.next(t)
                    }
                  }
                })
            }
            add(t) {
              super.add(t),
                this._isAttached ||
                  (this._document.body.addEventListener(
                    'click',
                    this._clickListener,
                    !0
                  ),
                  this._document.body.addEventListener(
                    'contextmenu',
                    this._clickListener,
                    !0
                  ),
                  this._platform.IOS &&
                    !this._cursorStyleIsSet &&
                    ((this._cursorOriginalValue = this._document.body.style.cursor),
                    (this._document.body.style.cursor = 'pointer'),
                    (this._cursorStyleIsSet = !0)),
                  (this._isAttached = !0))
            }
            detach() {
              this._isAttached &&
                (this._document.body.removeEventListener(
                  'click',
                  this._clickListener,
                  !0
                ),
                this._document.body.removeEventListener(
                  'contextmenu',
                  this._clickListener,
                  !0
                ),
                this._platform.IOS &&
                  this._cursorStyleIsSet &&
                  ((this._document.body.style.cursor = this._cursorOriginalValue),
                  (this._cursorStyleIsSet = !1)),
                (this._isAttached = !1))
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(mh), vi(Xu))
            }),
            (t.ɵprov = ht({
              factory: function () {
                return new t(vi(mh), vi(Xu))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })()
      const Fd = !(
        'undefined' == typeof window ||
        !window ||
        (!window.__karma__ && !window.jasmine)
      )
      let Md = (() => {
        class t {
          constructor(t, e) {
            ;(this._platform = e), (this._document = t)
          }
          ngOnDestroy() {
            const t = this._containerElement
            t && t.parentNode && t.parentNode.removeChild(t)
          }
          getContainerElement() {
            return (
              this._containerElement || this._createContainer(),
              this._containerElement
            )
          }
          _createContainer() {
            const t = 'cdk-overlay-container'
            if (this._platform.isBrowser || Fd) {
              const e = this._document.querySelectorAll(
                `.${t}[platform="server"], .${t}[platform="test"]`
              )
              for (let t = 0; t < e.length; t++)
                e[t].parentNode.removeChild(e[t])
            }
            const e = this._document.createElement('div')
            e.classList.add(t),
              Fd
                ? e.setAttribute('platform', 'test')
                : this._platform.isBrowser ||
                  e.setAttribute('platform', 'server'),
              this._document.body.appendChild(e),
              (this._containerElement = e)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(mh), vi(Xu))
          }),
          (t.ɵprov = ht({
            factory: function () {
              return new t(vi(mh), vi(Xu))
            },
            token: t,
            providedIn: 'root',
          })),
          t
        )
      })()
      class Ld {
        constructor(t, e, n, i, s, r, o, a, l) {
          ;(this._portalOutlet = t),
            (this._host = e),
            (this._pane = n),
            (this._config = i),
            (this._ngZone = s),
            (this._keyboardDispatcher = r),
            (this._document = o),
            (this._location = a),
            (this._outsideClickDispatcher = l),
            (this._backdropElement = null),
            (this._backdropClick = new x()),
            (this._attachments = new x()),
            (this._detachments = new x()),
            (this._locationChanges = u.EMPTY),
            (this._backdropClickHandler = (t) => this._backdropClick.next(t)),
            (this._keydownEvents = new x()),
            (this._outsidePointerEvents = new x()),
            i.scrollStrategy &&
              ((this._scrollStrategy = i.scrollStrategy),
              this._scrollStrategy.attach(this)),
            (this._positionStrategy = i.positionStrategy)
        }
        get overlayElement() {
          return this._pane
        }
        get backdropElement() {
          return this._backdropElement
        }
        get hostElement() {
          return this._host
        }
        attach(t) {
          let e = this._portalOutlet.attach(t)
          return (
            !this._host.parentElement &&
              this._previousHostParent &&
              this._previousHostParent.appendChild(this._host),
            this._positionStrategy && this._positionStrategy.attach(this),
            this._updateStackingOrder(),
            this._updateElementSize(),
            this._updateElementDirection(),
            this._scrollStrategy && this._scrollStrategy.enable(),
            this._ngZone.onStable.pipe(_d(1)).subscribe(() => {
              this.hasAttached() && this.updatePosition()
            }),
            this._togglePointerEvents(!0),
            this._config.hasBackdrop && this._attachBackdrop(),
            this._config.panelClass &&
              this._toggleClasses(this._pane, this._config.panelClass, !0),
            this._attachments.next(),
            this._keyboardDispatcher.add(this),
            this._config.disposeOnNavigation &&
              (this._locationChanges = this._location.subscribe(() =>
                this.dispose()
              )),
            this._outsideClickDispatcher.add(this),
            e
          )
        }
        detach() {
          if (!this.hasAttached()) return
          this.detachBackdrop(),
            this._togglePointerEvents(!1),
            this._positionStrategy &&
              this._positionStrategy.detach &&
              this._positionStrategy.detach(),
            this._scrollStrategy && this._scrollStrategy.disable()
          const t = this._portalOutlet.detach()
          return (
            this._detachments.next(),
            this._keyboardDispatcher.remove(this),
            this._detachContentWhenStable(),
            this._locationChanges.unsubscribe(),
            this._outsideClickDispatcher.remove(this),
            t
          )
        }
        dispose() {
          const t = this.hasAttached()
          this._positionStrategy && this._positionStrategy.dispose(),
            this._disposeScrollStrategy(),
            this.detachBackdrop(),
            this._locationChanges.unsubscribe(),
            this._keyboardDispatcher.remove(this),
            this._portalOutlet.dispose(),
            this._attachments.complete(),
            this._backdropClick.complete(),
            this._keydownEvents.complete(),
            this._outsidePointerEvents.complete(),
            this._outsideClickDispatcher.remove(this),
            this._host &&
              this._host.parentNode &&
              (this._host.parentNode.removeChild(this._host),
              (this._host = null)),
            (this._previousHostParent = this._pane = null),
            t && this._detachments.next(),
            this._detachments.complete()
        }
        hasAttached() {
          return this._portalOutlet.hasAttached()
        }
        backdropClick() {
          return this._backdropClick
        }
        attachments() {
          return this._attachments
        }
        detachments() {
          return this._detachments
        }
        keydownEvents() {
          return this._keydownEvents
        }
        outsidePointerEvents() {
          return this._outsidePointerEvents
        }
        getConfig() {
          return this._config
        }
        updatePosition() {
          this._positionStrategy && this._positionStrategy.apply()
        }
        updatePositionStrategy(t) {
          t !== this._positionStrategy &&
            (this._positionStrategy && this._positionStrategy.dispose(),
            (this._positionStrategy = t),
            this.hasAttached() && (t.attach(this), this.updatePosition()))
        }
        updateSize(t) {
          ;(this._config = Object.assign(Object.assign({}, this._config), t)),
            this._updateElementSize()
        }
        setDirection(t) {
          ;(this._config = Object.assign(Object.assign({}, this._config), {
            direction: t,
          })),
            this._updateElementDirection()
        }
        addPanelClass(t) {
          this._pane && this._toggleClasses(this._pane, t, !0)
        }
        removePanelClass(t) {
          this._pane && this._toggleClasses(this._pane, t, !1)
        }
        getDirection() {
          const t = this._config.direction
          return t ? ('string' == typeof t ? t : t.value) : 'ltr'
        }
        updateScrollStrategy(t) {
          t !== this._scrollStrategy &&
            (this._disposeScrollStrategy(),
            (this._scrollStrategy = t),
            this.hasAttached() && (t.attach(this), t.enable()))
        }
        _updateElementDirection() {
          this._host.setAttribute('dir', this.getDirection())
        }
        _updateElementSize() {
          if (!this._pane) return
          const t = this._pane.style
          ;(t.width = pu(this._config.width)),
            (t.height = pu(this._config.height)),
            (t.minWidth = pu(this._config.minWidth)),
            (t.minHeight = pu(this._config.minHeight)),
            (t.maxWidth = pu(this._config.maxWidth)),
            (t.maxHeight = pu(this._config.maxHeight))
        }
        _togglePointerEvents(t) {
          this._pane.style.pointerEvents = t ? 'auto' : 'none'
        }
        _attachBackdrop() {
          const t = 'cdk-overlay-backdrop-showing'
          ;(this._backdropElement = this._document.createElement('div')),
            this._backdropElement.classList.add('cdk-overlay-backdrop'),
            this._config.backdropClass &&
              this._toggleClasses(
                this._backdropElement,
                this._config.backdropClass,
                !0
              ),
            this._host.parentElement.insertBefore(
              this._backdropElement,
              this._host
            ),
            this._backdropElement.addEventListener(
              'click',
              this._backdropClickHandler
            ),
            'undefined' != typeof requestAnimationFrame
              ? this._ngZone.runOutsideAngular(() => {
                  requestAnimationFrame(() => {
                    this._backdropElement &&
                      this._backdropElement.classList.add(t)
                  })
                })
              : this._backdropElement.classList.add(t)
        }
        _updateStackingOrder() {
          this._host.nextSibling &&
            this._host.parentNode.appendChild(this._host)
        }
        detachBackdrop() {
          let t,
            e = this._backdropElement
          if (!e) return
          let n = () => {
            e &&
              (e.removeEventListener('click', this._backdropClickHandler),
              e.removeEventListener('transitionend', n),
              e.parentNode && e.parentNode.removeChild(e)),
              this._backdropElement == e && (this._backdropElement = null),
              this._config.backdropClass &&
                this._toggleClasses(e, this._config.backdropClass, !1),
              clearTimeout(t)
          }
          e.classList.remove('cdk-overlay-backdrop-showing'),
            this._ngZone.runOutsideAngular(() => {
              e.addEventListener('transitionend', n)
            }),
            (e.style.pointerEvents = 'none'),
            (t = this._ngZone.runOutsideAngular(() => setTimeout(n, 500)))
        }
        _toggleClasses(t, e, n) {
          const i = t.classList
          du(e).forEach((t) => {
            t && (n ? i.add(t) : i.remove(t))
          })
        }
        _detachContentWhenStable() {
          this._ngZone.runOutsideAngular(() => {
            const t = this._ngZone.onStable
              .pipe(Du($(this._attachments, this._detachments)))
              .subscribe(() => {
                ;(this._pane &&
                  this._host &&
                  0 !== this._pane.children.length) ||
                  (this._pane &&
                    this._config.panelClass &&
                    this._toggleClasses(
                      this._pane,
                      this._config.panelClass,
                      !1
                    ),
                  this._host &&
                    this._host.parentElement &&
                    ((this._previousHostParent = this._host.parentElement),
                    this._previousHostParent.removeChild(this._host)),
                  t.unsubscribe())
              })
          })
        }
        _disposeScrollStrategy() {
          const t = this._scrollStrategy
          t && (t.disable(), t.detach && t.detach())
        }
      }
      const jd = 'cdk-overlay-connected-position-bounding-box',
        Bd = /([A-Za-z%]+)$/
      class Vd {
        constructor(t, e, n, i, s) {
          ;(this._viewportRuler = e),
            (this._document = n),
            (this._platform = i),
            (this._overlayContainer = s),
            (this._lastBoundingBoxSize = { width: 0, height: 0 }),
            (this._isPushed = !1),
            (this._canPush = !0),
            (this._growAfterOpen = !1),
            (this._hasFlexibleDimensions = !0),
            (this._positionLocked = !1),
            (this._viewportMargin = 0),
            (this._scrollables = []),
            (this._preferredPositions = []),
            (this._positionChanges = new x()),
            (this._resizeSubscription = u.EMPTY),
            (this._offsetX = 0),
            (this._offsetY = 0),
            (this._appliedPanelClasses = []),
            (this.positionChanges = this._positionChanges),
            this.setOrigin(t)
        }
        get positions() {
          return this._preferredPositions
        }
        attach(t) {
          this._validatePositions(),
            t.hostElement.classList.add(jd),
            (this._overlayRef = t),
            (this._boundingBox = t.hostElement),
            (this._pane = t.overlayElement),
            (this._isDisposed = !1),
            (this._isInitialRender = !0),
            (this._lastPosition = null),
            this._resizeSubscription.unsubscribe(),
            (this._resizeSubscription = this._viewportRuler
              .change()
              .subscribe(() => {
                ;(this._isInitialRender = !0), this.apply()
              }))
        }
        apply() {
          if (this._isDisposed || !this._platform.isBrowser) return
          if (
            !this._isInitialRender &&
            this._positionLocked &&
            this._lastPosition
          )
            return void this.reapplyLastPosition()
          this._clearPanelClasses(),
            this._resetOverlayElementStyles(),
            this._resetBoundingBoxStyles(),
            (this._viewportRect = this._getNarrowedViewportRect()),
            (this._originRect = this._getOriginRect()),
            (this._overlayRect = this._pane.getBoundingClientRect())
          const t = this._originRect,
            e = this._overlayRect,
            n = this._viewportRect,
            i = []
          let s
          for (let r of this._preferredPositions) {
            let o = this._getOriginPoint(t, r),
              a = this._getOverlayPoint(o, e, r),
              l = this._getOverlayFit(a, e, n, r)
            if (l.isCompletelyWithinViewport)
              return (this._isPushed = !1), void this._applyPosition(r, o)
            this._canFitWithFlexibleDimensions(l, a, n)
              ? i.push({
                  position: r,
                  origin: o,
                  overlayRect: e,
                  boundingBoxRect: this._calculateBoundingBoxRect(o, r),
                })
              : (!s || s.overlayFit.visibleArea < l.visibleArea) &&
                (s = {
                  overlayFit: l,
                  overlayPoint: a,
                  originPoint: o,
                  position: r,
                  overlayRect: e,
                })
          }
          if (i.length) {
            let t = null,
              e = -1
            for (const n of i) {
              const i =
                n.boundingBoxRect.width *
                n.boundingBoxRect.height *
                (n.position.weight || 1)
              i > e && ((e = i), (t = n))
            }
            return (
              (this._isPushed = !1),
              void this._applyPosition(t.position, t.origin)
            )
          }
          if (this._canPush)
            return (
              (this._isPushed = !0),
              void this._applyPosition(s.position, s.originPoint)
            )
          this._applyPosition(s.position, s.originPoint)
        }
        detach() {
          this._clearPanelClasses(),
            (this._lastPosition = null),
            (this._previousPushAmount = null),
            this._resizeSubscription.unsubscribe()
        }
        dispose() {
          this._isDisposed ||
            (this._boundingBox &&
              Ud(this._boundingBox.style, {
                top: '',
                left: '',
                right: '',
                bottom: '',
                height: '',
                width: '',
                alignItems: '',
                justifyContent: '',
              }),
            this._pane && this._resetOverlayElementStyles(),
            this._overlayRef &&
              this._overlayRef.hostElement.classList.remove(jd),
            this.detach(),
            this._positionChanges.complete(),
            (this._overlayRef = this._boundingBox = null),
            (this._isDisposed = !0))
        }
        reapplyLastPosition() {
          if (
            !this._isDisposed &&
            (!this._platform || this._platform.isBrowser)
          ) {
            ;(this._originRect = this._getOriginRect()),
              (this._overlayRect = this._pane.getBoundingClientRect()),
              (this._viewportRect = this._getNarrowedViewportRect())
            const t = this._lastPosition || this._preferredPositions[0],
              e = this._getOriginPoint(this._originRect, t)
            this._applyPosition(t, e)
          }
        }
        withScrollableContainers(t) {
          return (this._scrollables = t), this
        }
        withPositions(t) {
          return (
            (this._preferredPositions = t),
            -1 === t.indexOf(this._lastPosition) && (this._lastPosition = null),
            this._validatePositions(),
            this
          )
        }
        withViewportMargin(t) {
          return (this._viewportMargin = t), this
        }
        withFlexibleDimensions(t = !0) {
          return (this._hasFlexibleDimensions = t), this
        }
        withGrowAfterOpen(t = !0) {
          return (this._growAfterOpen = t), this
        }
        withPush(t = !0) {
          return (this._canPush = t), this
        }
        withLockedPosition(t = !0) {
          return (this._positionLocked = t), this
        }
        setOrigin(t) {
          return (this._origin = t), this
        }
        withDefaultOffsetX(t) {
          return (this._offsetX = t), this
        }
        withDefaultOffsetY(t) {
          return (this._offsetY = t), this
        }
        withTransformOriginOn(t) {
          return (this._transformOriginSelector = t), this
        }
        _getOriginPoint(t, e) {
          let n, i
          if ('center' == e.originX) n = t.left + t.width / 2
          else {
            const i = this._isRtl() ? t.right : t.left,
              s = this._isRtl() ? t.left : t.right
            n = 'start' == e.originX ? i : s
          }
          return (
            (i =
              'center' == e.originY
                ? t.top + t.height / 2
                : 'top' == e.originY
                ? t.top
                : t.bottom),
            { x: n, y: i }
          )
        }
        _getOverlayPoint(t, e, n) {
          let i, s
          return (
            (i =
              'center' == n.overlayX
                ? -e.width / 2
                : 'start' === n.overlayX
                ? this._isRtl()
                  ? -e.width
                  : 0
                : this._isRtl()
                ? 0
                : -e.width),
            (s =
              'center' == n.overlayY
                ? -e.height / 2
                : 'top' == n.overlayY
                ? 0
                : -e.height),
            { x: t.x + i, y: t.y + s }
          )
        }
        _getOverlayFit(t, e, n, i) {
          let { x: s, y: r } = t,
            o = this._getOffset(i, 'x'),
            a = this._getOffset(i, 'y')
          o && (s += o), a && (r += a)
          let l = 0 - r,
            c = r + e.height - n.height,
            h = this._subtractOverflows(e.width, 0 - s, s + e.width - n.width),
            u = this._subtractOverflows(e.height, l, c),
            d = h * u
          return {
            visibleArea: d,
            isCompletelyWithinViewport: e.width * e.height === d,
            fitsInViewportVertically: u === e.height,
            fitsInViewportHorizontally: h == e.width,
          }
        }
        _canFitWithFlexibleDimensions(t, e, n) {
          if (this._hasFlexibleDimensions) {
            const i = n.bottom - e.y,
              s = n.right - e.x,
              r = zd(this._overlayRef.getConfig().minHeight),
              o = zd(this._overlayRef.getConfig().minWidth),
              a = t.fitsInViewportHorizontally || (null != o && o <= s)
            return (t.fitsInViewportVertically || (null != r && r <= i)) && a
          }
          return !1
        }
        _pushOverlayOnScreen(t, e, n) {
          if (this._previousPushAmount && this._positionLocked)
            return {
              x: t.x + this._previousPushAmount.x,
              y: t.y + this._previousPushAmount.y,
            }
          const i = this._viewportRect,
            s = Math.max(t.x + e.width - i.width, 0),
            r = Math.max(t.y + e.height - i.height, 0),
            o = Math.max(i.top - n.top - t.y, 0),
            a = Math.max(i.left - n.left - t.x, 0)
          let l = 0,
            c = 0
          return (
            (l =
              e.width <= i.width
                ? a || -s
                : t.x < this._viewportMargin
                ? i.left - n.left - t.x
                : 0),
            (c =
              e.height <= i.height
                ? o || -r
                : t.y < this._viewportMargin
                ? i.top - n.top - t.y
                : 0),
            (this._previousPushAmount = { x: l, y: c }),
            { x: t.x + l, y: t.y + c }
          )
        }
        _applyPosition(t, e) {
          if (
            (this._setTransformOrigin(t),
            this._setOverlayElementStyles(e, t),
            this._setBoundingBoxStyles(e, t),
            t.panelClass && this._addPanelClasses(t.panelClass),
            (this._lastPosition = t),
            this._positionChanges.observers.length)
          ) {
            const e = this._getScrollVisibility(),
              n = new Rd(t, e)
            this._positionChanges.next(n)
          }
          this._isInitialRender = !1
        }
        _setTransformOrigin(t) {
          if (!this._transformOriginSelector) return
          const e = this._boundingBox.querySelectorAll(
            this._transformOriginSelector
          )
          let n,
            i = t.overlayY
          n =
            'center' === t.overlayX
              ? 'center'
              : this._isRtl()
              ? 'start' === t.overlayX
                ? 'right'
                : 'left'
              : 'start' === t.overlayX
              ? 'left'
              : 'right'
          for (let s = 0; s < e.length; s++)
            e[s].style.transformOrigin = `${n} ${i}`
        }
        _calculateBoundingBoxRect(t, e) {
          const n = this._viewportRect,
            i = this._isRtl()
          let s, r, o, a, l, c
          if ('top' === e.overlayY)
            (r = t.y), (s = n.height - r + this._viewportMargin)
          else if ('bottom' === e.overlayY)
            (o = n.height - t.y + 2 * this._viewportMargin),
              (s = n.height - o + this._viewportMargin)
          else {
            const e = Math.min(n.bottom - t.y + n.top, t.y),
              i = this._lastBoundingBoxSize.height
            ;(s = 2 * e),
              (r = t.y - e),
              s > i &&
                !this._isInitialRender &&
                !this._growAfterOpen &&
                (r = t.y - i / 2)
          }
          if (('end' === e.overlayX && !i) || ('start' === e.overlayX && i))
            (c = n.width - t.x + this._viewportMargin),
              (a = t.x - this._viewportMargin)
          else if (
            ('start' === e.overlayX && !i) ||
            ('end' === e.overlayX && i)
          )
            (l = t.x), (a = n.right - t.x)
          else {
            const e = Math.min(n.right - t.x + n.left, t.x),
              i = this._lastBoundingBoxSize.width
            ;(a = 2 * e),
              (l = t.x - e),
              a > i &&
                !this._isInitialRender &&
                !this._growAfterOpen &&
                (l = t.x - i / 2)
          }
          return { top: r, left: l, bottom: o, right: c, width: a, height: s }
        }
        _setBoundingBoxStyles(t, e) {
          const n = this._calculateBoundingBoxRect(t, e)
          this._isInitialRender ||
            this._growAfterOpen ||
            ((n.height = Math.min(n.height, this._lastBoundingBoxSize.height)),
            (n.width = Math.min(n.width, this._lastBoundingBoxSize.width)))
          const i = {}
          if (this._hasExactPosition())
            (i.top = i.left = '0'),
              (i.bottom = i.right = i.maxHeight = i.maxWidth = ''),
              (i.width = i.height = '100%')
          else {
            const t = this._overlayRef.getConfig().maxHeight,
              s = this._overlayRef.getConfig().maxWidth
            ;(i.height = pu(n.height)),
              (i.top = pu(n.top)),
              (i.bottom = pu(n.bottom)),
              (i.width = pu(n.width)),
              (i.left = pu(n.left)),
              (i.right = pu(n.right)),
              (i.alignItems =
                'center' === e.overlayX
                  ? 'center'
                  : 'end' === e.overlayX
                  ? 'flex-end'
                  : 'flex-start'),
              (i.justifyContent =
                'center' === e.overlayY
                  ? 'center'
                  : 'bottom' === e.overlayY
                  ? 'flex-end'
                  : 'flex-start'),
              t && (i.maxHeight = pu(t)),
              s && (i.maxWidth = pu(s))
          }
          ;(this._lastBoundingBoxSize = n), Ud(this._boundingBox.style, i)
        }
        _resetBoundingBoxStyles() {
          Ud(this._boundingBox.style, {
            top: '0',
            left: '0',
            right: '0',
            bottom: '0',
            height: '',
            width: '',
            alignItems: '',
            justifyContent: '',
          })
        }
        _resetOverlayElementStyles() {
          Ud(this._pane.style, {
            top: '',
            left: '',
            bottom: '',
            right: '',
            position: '',
            transform: '',
          })
        }
        _setOverlayElementStyles(t, e) {
          const n = {},
            i = this._hasExactPosition(),
            s = this._hasFlexibleDimensions,
            r = this._overlayRef.getConfig()
          if (i) {
            const i = this._viewportRuler.getViewportScrollPosition()
            Ud(n, this._getExactOverlayY(e, t, i)),
              Ud(n, this._getExactOverlayX(e, t, i))
          } else n.position = 'static'
          let o = '',
            a = this._getOffset(e, 'x'),
            l = this._getOffset(e, 'y')
          a && (o += `translateX(${a}px) `),
            l && (o += `translateY(${l}px)`),
            (n.transform = o.trim()),
            r.maxHeight &&
              (i ? (n.maxHeight = pu(r.maxHeight)) : s && (n.maxHeight = '')),
            r.maxWidth &&
              (i ? (n.maxWidth = pu(r.maxWidth)) : s && (n.maxWidth = '')),
            Ud(this._pane.style, n)
        }
        _getExactOverlayY(t, e, n) {
          let i = { top: '', bottom: '' },
            s = this._getOverlayPoint(e, this._overlayRect, t)
          this._isPushed &&
            (s = this._pushOverlayOnScreen(s, this._overlayRect, n))
          let r = this._overlayContainer
            .getContainerElement()
            .getBoundingClientRect().top
          return (
            (s.y -= r),
            'bottom' === t.overlayY
              ? (i.bottom =
                  this._document.documentElement.clientHeight -
                  (s.y + this._overlayRect.height) +
                  'px')
              : (i.top = pu(s.y)),
            i
          )
        }
        _getExactOverlayX(t, e, n) {
          let i,
            s = { left: '', right: '' },
            r = this._getOverlayPoint(e, this._overlayRect, t)
          return (
            this._isPushed &&
              (r = this._pushOverlayOnScreen(r, this._overlayRect, n)),
            (i = this._isRtl()
              ? 'end' === t.overlayX
                ? 'left'
                : 'right'
              : 'end' === t.overlayX
              ? 'right'
              : 'left'),
            'right' === i
              ? (s.right =
                  this._document.documentElement.clientWidth -
                  (r.x + this._overlayRect.width) +
                  'px')
              : (s.left = pu(r.x)),
            s
          )
        }
        _getScrollVisibility() {
          const t = this._getOriginRect(),
            e = this._pane.getBoundingClientRect(),
            n = this._scrollables.map((t) =>
              t.getElementRef().nativeElement.getBoundingClientRect()
            )
          return {
            isOriginClipped: kd(t, n),
            isOriginOutsideView: Ed(t, n),
            isOverlayClipped: kd(e, n),
            isOverlayOutsideView: Ed(e, n),
          }
        }
        _subtractOverflows(t, ...e) {
          return e.reduce((t, e) => t - Math.max(e, 0), t)
        }
        _getNarrowedViewportRect() {
          const t = this._document.documentElement.clientWidth,
            e = this._document.documentElement.clientHeight,
            n = this._viewportRuler.getViewportScrollPosition()
          return {
            top: n.top + this._viewportMargin,
            left: n.left + this._viewportMargin,
            right: n.left + t - this._viewportMargin,
            bottom: n.top + e - this._viewportMargin,
            width: t - 2 * this._viewportMargin,
            height: e - 2 * this._viewportMargin,
          }
        }
        _isRtl() {
          return 'rtl' === this._overlayRef.getDirection()
        }
        _hasExactPosition() {
          return !this._hasFlexibleDimensions || this._isPushed
        }
        _getOffset(t, e) {
          return 'x' === e
            ? null == t.offsetX
              ? this._offsetX
              : t.offsetX
            : null == t.offsetY
            ? this._offsetY
            : t.offsetY
        }
        _validatePositions() {}
        _addPanelClasses(t) {
          this._pane &&
            du(t).forEach((t) => {
              '' !== t &&
                -1 === this._appliedPanelClasses.indexOf(t) &&
                (this._appliedPanelClasses.push(t), this._pane.classList.add(t))
            })
        }
        _clearPanelClasses() {
          this._pane &&
            (this._appliedPanelClasses.forEach((t) => {
              this._pane.classList.remove(t)
            }),
            (this._appliedPanelClasses = []))
        }
        _getOriginRect() {
          const t = this._origin
          if (t instanceof Va) return t.nativeElement.getBoundingClientRect()
          if (t instanceof Element) return t.getBoundingClientRect()
          const e = t.width || 0,
            n = t.height || 0
          return {
            top: t.y,
            bottom: t.y + n,
            left: t.x,
            right: t.x + e,
            height: n,
            width: e,
          }
        }
      }
      function Ud(t, e) {
        for (let n in e) e.hasOwnProperty(n) && (t[n] = e[n])
        return t
      }
      function zd(t) {
        if ('number' != typeof t && null != t) {
          const [e, n] = t.split(Bd)
          return n && 'px' !== n ? null : parseFloat(e)
        }
        return t || null
      }
      class Hd {
        constructor(t, e, n, i, s, r, o) {
          ;(this._preferredPositions = []),
            (this._positionStrategy = new Vd(n, i, s, r, o)
              .withFlexibleDimensions(!1)
              .withPush(!1)
              .withViewportMargin(0)),
            this.withFallbackPosition(t, e),
            (this.onPositionChange = this._positionStrategy.positionChanges)
        }
        get positions() {
          return this._preferredPositions
        }
        attach(t) {
          ;(this._overlayRef = t),
            this._positionStrategy.attach(t),
            this._direction &&
              (t.setDirection(this._direction), (this._direction = null))
        }
        dispose() {
          this._positionStrategy.dispose()
        }
        detach() {
          this._positionStrategy.detach()
        }
        apply() {
          this._positionStrategy.apply()
        }
        recalculateLastPosition() {
          this._positionStrategy.reapplyLastPosition()
        }
        withScrollableContainers(t) {
          this._positionStrategy.withScrollableContainers(t)
        }
        withFallbackPosition(t, e, n, i) {
          const s = new Id(t, e, n, i)
          return (
            this._preferredPositions.push(s),
            this._positionStrategy.withPositions(this._preferredPositions),
            this
          )
        }
        withDirection(t) {
          return (
            this._overlayRef
              ? this._overlayRef.setDirection(t)
              : (this._direction = t),
            this
          )
        }
        withOffsetX(t) {
          return this._positionStrategy.withDefaultOffsetX(t), this
        }
        withOffsetY(t) {
          return this._positionStrategy.withDefaultOffsetY(t), this
        }
        withLockedPosition(t) {
          return this._positionStrategy.withLockedPosition(t), this
        }
        withPositions(t) {
          return (
            (this._preferredPositions = t.slice()),
            this._positionStrategy.withPositions(this._preferredPositions),
            this
          )
        }
        setOrigin(t) {
          return this._positionStrategy.setOrigin(t), this
        }
      }
      const qd = 'cdk-global-overlay-wrapper'
      class $d {
        constructor() {
          ;(this._cssPosition = 'static'),
            (this._topOffset = ''),
            (this._bottomOffset = ''),
            (this._leftOffset = ''),
            (this._rightOffset = ''),
            (this._alignItems = ''),
            (this._justifyContent = ''),
            (this._width = ''),
            (this._height = '')
        }
        attach(t) {
          const e = t.getConfig()
          ;(this._overlayRef = t),
            this._width && !e.width && t.updateSize({ width: this._width }),
            this._height && !e.height && t.updateSize({ height: this._height }),
            t.hostElement.classList.add(qd),
            (this._isDisposed = !1)
        }
        top(t = '') {
          return (
            (this._bottomOffset = ''),
            (this._topOffset = t),
            (this._alignItems = 'flex-start'),
            this
          )
        }
        left(t = '') {
          return (
            (this._rightOffset = ''),
            (this._leftOffset = t),
            (this._justifyContent = 'flex-start'),
            this
          )
        }
        bottom(t = '') {
          return (
            (this._topOffset = ''),
            (this._bottomOffset = t),
            (this._alignItems = 'flex-end'),
            this
          )
        }
        right(t = '') {
          return (
            (this._leftOffset = ''),
            (this._rightOffset = t),
            (this._justifyContent = 'flex-end'),
            this
          )
        }
        width(t = '') {
          return (
            this._overlayRef
              ? this._overlayRef.updateSize({ width: t })
              : (this._width = t),
            this
          )
        }
        height(t = '') {
          return (
            this._overlayRef
              ? this._overlayRef.updateSize({ height: t })
              : (this._height = t),
            this
          )
        }
        centerHorizontally(t = '') {
          return this.left(t), (this._justifyContent = 'center'), this
        }
        centerVertically(t = '') {
          return this.top(t), (this._alignItems = 'center'), this
        }
        apply() {
          if (!this._overlayRef || !this._overlayRef.hasAttached()) return
          const t = this._overlayRef.overlayElement.style,
            e = this._overlayRef.hostElement.style,
            n = this._overlayRef.getConfig(),
            { width: i, height: s, maxWidth: r, maxHeight: o } = n,
            a = !(
              ('100%' !== i && '100vw' !== i) ||
              (r && '100%' !== r && '100vw' !== r)
            ),
            l = !(
              ('100%' !== s && '100vh' !== s) ||
              (o && '100%' !== o && '100vh' !== o)
            )
          ;(t.position = this._cssPosition),
            (t.marginLeft = a ? '0' : this._leftOffset),
            (t.marginTop = l ? '0' : this._topOffset),
            (t.marginBottom = this._bottomOffset),
            (t.marginRight = this._rightOffset),
            a
              ? (e.justifyContent = 'flex-start')
              : 'center' === this._justifyContent
              ? (e.justifyContent = 'center')
              : 'rtl' === this._overlayRef.getConfig().direction
              ? 'flex-start' === this._justifyContent
                ? (e.justifyContent = 'flex-end')
                : 'flex-end' === this._justifyContent &&
                  (e.justifyContent = 'flex-start')
              : (e.justifyContent = this._justifyContent),
            (e.alignItems = l ? 'flex-start' : this._alignItems)
        }
        dispose() {
          if (this._isDisposed || !this._overlayRef) return
          const t = this._overlayRef.overlayElement.style,
            e = this._overlayRef.hostElement,
            n = e.style
          e.classList.remove(qd),
            (n.justifyContent = n.alignItems = t.marginTop = t.marginBottom = t.marginLeft = t.marginRight = t.position =
              ''),
            (this._overlayRef = null),
            (this._isDisposed = !0)
        }
      }
      let Wd = (() => {
          class t {
            constructor(t, e, n, i) {
              ;(this._viewportRuler = t),
                (this._document = e),
                (this._platform = n),
                (this._overlayContainer = i)
            }
            global() {
              return new $d()
            }
            connectedTo(t, e, n) {
              return new Hd(
                e,
                n,
                t,
                this._viewportRuler,
                this._document,
                this._platform,
                this._overlayContainer
              )
            }
            flexibleConnectedTo(t) {
              return new Vd(
                t,
                this._viewportRuler,
                this._document,
                this._platform,
                this._overlayContainer
              )
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(ad), vi(mh), vi(Xu), vi(Md))
            }),
            (t.ɵprov = ht({
              factory: function () {
                return new t(vi(ad), vi(mh), vi(Xu), vi(Md))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        Kd = 0,
        Gd = (() => {
          class t {
            constructor(t, e, n, i, s, r, o, a, l, c, h) {
              ;(this.scrollStrategies = t),
                (this._overlayContainer = e),
                (this._componentFactoryResolver = n),
                (this._positionBuilder = i),
                (this._keyboardDispatcher = s),
                (this._injector = r),
                (this._ngZone = o),
                (this._document = a),
                (this._directionality = l),
                (this._location = c),
                (this._outsideClickDispatcher = h)
            }
            create(t) {
              const e = this._createHostElement(),
                n = this._createPaneElement(e),
                i = this._createPortalOutlet(n),
                s = new Od(t)
              return (
                (s.direction = s.direction || this._directionality.value),
                new Ld(
                  i,
                  e,
                  n,
                  s,
                  this._ngZone,
                  this._keyboardDispatcher,
                  this._document,
                  this._location,
                  this._outsideClickDispatcher
                )
              )
            }
            position() {
              return this._positionBuilder
            }
            _createPaneElement(t) {
              const e = this._document.createElement('div')
              return (
                (e.id = 'cdk-overlay-' + Kd++),
                e.classList.add('cdk-overlay-pane'),
                t.appendChild(e),
                e
              )
            }
            _createHostElement() {
              const t = this._document.createElement('div')
              return (
                this._overlayContainer.getContainerElement().appendChild(t), t
              )
            }
            _createPortalOutlet(t) {
              return (
                this._appRef || (this._appRef = this._injector.get(Zc)),
                new fd(
                  t,
                  this._componentFactoryResolver,
                  this._appRef,
                  this._injector,
                  this._document
                )
              )
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                vi(Ad),
                vi(Md),
                vi(Ma),
                vi(Wd),
                vi(Dd),
                vi(ho),
                vi(Oc),
                vi(mh),
                vi(id),
                vi(Ih),
                vi(Nd)
              )
            }),
            (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
            t
          )
        })()
      const Qd = {
        provide: new Yn('cdk-connected-overlay-scroll-strategy'),
        deps: [Gd],
        useFactory: function (t) {
          return () => t.scrollStrategies.reposition()
        },
      }
      let Zd = (() => {
        class t {}
        return (
          (t.ɵmod = $t({ type: t })),
          (t.ɵinj = ut({
            factory: function (e) {
              return new (e || t)()
            },
            providers: [Gd, Qd],
            imports: [[sd, md, cd], cd],
          })),
          t
        )
      })()
      class Yd {}
      const Xd = '*'
      function Jd(t, e) {
        return { type: 7, name: t, definitions: e, options: {} }
      }
      function tp(t, e = null) {
        return { type: 4, styles: e, timings: t }
      }
      function ep(t, e = null) {
        return { type: 2, steps: t, options: e }
      }
      function np(t) {
        return { type: 6, styles: t, offset: null }
      }
      function ip(t, e, n) {
        return { type: 0, name: t, styles: e, options: n }
      }
      function sp(t) {
        return { type: 5, steps: t }
      }
      function rp(t, e, n = null) {
        return { type: 1, expr: t, animation: e, options: n }
      }
      function op(t, e = null) {
        return { type: 8, animation: t, options: e }
      }
      function ap(t) {
        Promise.resolve(null).then(t)
      }
      class lp {
        constructor(t = 0, e = 0) {
          ;(this._onDoneFns = []),
            (this._onStartFns = []),
            (this._onDestroyFns = []),
            (this._started = !1),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._position = 0),
            (this.parentPlayer = null),
            (this.totalTime = t + e)
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((t) => t()),
            (this._onDoneFns = []))
        }
        onStart(t) {
          this._onStartFns.push(t)
        }
        onDone(t) {
          this._onDoneFns.push(t)
        }
        onDestroy(t) {
          this._onDestroyFns.push(t)
        }
        hasStarted() {
          return this._started
        }
        init() {}
        play() {
          this.hasStarted() || (this._onStart(), this.triggerMicrotask()),
            (this._started = !0)
        }
        triggerMicrotask() {
          ap(() => this._onFinish())
        }
        _onStart() {
          this._onStartFns.forEach((t) => t()), (this._onStartFns = [])
        }
        pause() {}
        restart() {}
        finish() {
          this._onFinish()
        }
        destroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this.hasStarted() || this._onStart(),
            this.finish(),
            this._onDestroyFns.forEach((t) => t()),
            (this._onDestroyFns = []))
        }
        reset() {}
        setPosition(t) {
          this._position = this.totalTime ? t * this.totalTime : 1
        }
        getPosition() {
          return this.totalTime ? this._position / this.totalTime : 1
        }
        triggerCallback(t) {
          const e = 'start' == t ? this._onStartFns : this._onDoneFns
          e.forEach((t) => t()), (e.length = 0)
        }
      }
      class cp {
        constructor(t) {
          ;(this._onDoneFns = []),
            (this._onStartFns = []),
            (this._finished = !1),
            (this._started = !1),
            (this._destroyed = !1),
            (this._onDestroyFns = []),
            (this.parentPlayer = null),
            (this.totalTime = 0),
            (this.players = t)
          let e = 0,
            n = 0,
            i = 0
          const s = this.players.length
          0 == s
            ? ap(() => this._onFinish())
            : this.players.forEach((t) => {
                t.onDone(() => {
                  ++e == s && this._onFinish()
                }),
                  t.onDestroy(() => {
                    ++n == s && this._onDestroy()
                  }),
                  t.onStart(() => {
                    ++i == s && this._onStart()
                  })
              }),
            (this.totalTime = this.players.reduce(
              (t, e) => Math.max(t, e.totalTime),
              0
            ))
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((t) => t()),
            (this._onDoneFns = []))
        }
        init() {
          this.players.forEach((t) => t.init())
        }
        onStart(t) {
          this._onStartFns.push(t)
        }
        _onStart() {
          this.hasStarted() ||
            ((this._started = !0),
            this._onStartFns.forEach((t) => t()),
            (this._onStartFns = []))
        }
        onDone(t) {
          this._onDoneFns.push(t)
        }
        onDestroy(t) {
          this._onDestroyFns.push(t)
        }
        hasStarted() {
          return this._started
        }
        play() {
          this.parentPlayer || this.init(),
            this._onStart(),
            this.players.forEach((t) => t.play())
        }
        pause() {
          this.players.forEach((t) => t.pause())
        }
        restart() {
          this.players.forEach((t) => t.restart())
        }
        finish() {
          this._onFinish(), this.players.forEach((t) => t.finish())
        }
        destroy() {
          this._onDestroy()
        }
        _onDestroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this._onFinish(),
            this.players.forEach((t) => t.destroy()),
            this._onDestroyFns.forEach((t) => t()),
            (this._onDestroyFns = []))
        }
        reset() {
          this.players.forEach((t) => t.reset()),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._started = !1)
        }
        setPosition(t) {
          const e = t * this.totalTime
          this.players.forEach((t) => {
            const n = t.totalTime ? Math.min(1, e / t.totalTime) : 1
            t.setPosition(n)
          })
        }
        getPosition() {
          const t = this.players.reduce(
            (t, e) => (null === t || e.totalTime > t.totalTime ? e : t),
            null
          )
          return null != t ? t.getPosition() : 0
        }
        beforeDestroy() {
          this.players.forEach((t) => {
            t.beforeDestroy && t.beforeDestroy()
          })
        }
        triggerCallback(t) {
          const e = 'start' == t ? this._onStartFns : this._onDoneFns
          e.forEach((t) => t()), (e.length = 0)
        }
      }
      const hp = {
        fadeOverlog: Jd('fadeAnimation', [
          ip('default', np({ opacity: 1 })),
          rp('void => *', [np({ opacity: 0 }), tp('{{ fadeIn }}ms')]),
          rp('default => closing', tp('{{ fadeOut }}ms', np({ opacity: 0 }))),
        ]),
      }
      op([
        np({ transform: 'scale(1)' }),
        tp(
          '{{ timings }}',
          sp([
            np({ transform: 'scale(1)', offset: 0 }),
            np({ transform: 'scale(2)', offset: 0.5 }),
            np({ transform: 'scale(1)', offset: 1 }),
          ])
        ),
      ]),
        op([
          np({ transform: 'translateY({{ from }})', opacity: 0 }),
          tp('{{ timings }}', np('*')),
        ]),
        op([
          tp(
            '{{ timings }}',
            np({ transform: 'translateY({{ to }})', opacity: 0 })
          ),
        ])
      class up {
        constructor() {
          this.type = 'info'
        }
      }
      const dp = {
          position: { top: 20, right: 20, bottom: 20 },
          animation: { fadeOut: 500, fadeIn: 0 },
        },
        pp = [
          {
            overlayX: 'center',
            overlayY: 'bottom',
            originX: 'center',
            originY: 'top',
            panelClass: ['bottom', 'center'],
          },
          {
            overlayX: 'start',
            overlayY: 'bottom',
            originX: 'center',
            originY: 'top',
          },
          {
            overlayX: 'end',
            overlayY: 'bottom',
            originX: 'center',
            originY: 'top',
            panelClass: ['bottom', 'right'],
          },
          {
            overlayX: 'center',
            overlayY: 'top',
            originX: 'center',
            originY: 'bottom',
            panelClass: ['top', 'center'],
          },
          {
            overlayX: 'start',
            overlayY: 'top',
            originX: 'center',
            originY: 'bottom',
            panelClass: ['top', 'left'],
          },
          {
            overlayX: 'end',
            overlayY: 'top',
            originX: 'center',
            originY: 'bottom',
            panelClass: ['top', 'right'],
          },
        ],
        fp = new Yn('OverlogConfig')
      class mp {
        constructor(t) {
          this.overlay = t
        }
        close() {
          this.overlay.dispose()
        }
        isVisible() {
          return this.overlay && this.overlay.overlayElement
        }
        getPosition() {
          return this.overlay.overlayElement.getBoundingClientRect()
        }
      }
      const gp = function (t, e) {
          return { fadeIn: t, fadeOut: e }
        },
        yp = function (t, e) {
          return { value: t, params: e }
        }
      let _p = (() => {
          class t {
            constructor(t, e, n) {
              ;(this.data = t),
                (this.ref = e),
                (this.overlogConfig = n),
                (this.animationState = 'default'),
                (this.iconType = 'success' === t.type ? 'done' : t.type)
            }
            ngOnInit() {
              const { duration: t } = this.data
              this.intervalId = window.setTimeout(() => {
                this.animationState = 'closing'
              }, t || 5e3)
            }
            ngOnDestroy() {
              window.clearTimeout(this.intervalId)
            }
            close() {
              this.ref.close()
            }
            onFadeFinished(t) {
              const { toState: e } = t
              'closing' === e &&
                'closing' === this.animationState &&
                this.close()
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(Ao(up), Ao(mp), Ao(fp))
            }),
            (t.ɵcmp = Ut({
              type: t,
              selectors: [['quertc-overlog']],
              decls: 4,
              vars: 10,
              consts: [[1, 'material-icons', 3, 'click']],
              template: function (t, e) {
                1 & t &&
                  (Ro(0, 'i', 0),
                  Bo('click', function () {
                    return e.close()
                  }),
                  pa(1, 'close'),
                  Po(),
                  Ro(2, 'div'),
                  Bo('@fadeAnimation.done', function (t) {
                    return e.onFadeFinished(t)
                  }),
                  pa(3),
                  Po()),
                  2 & t &&
                    (Xs(2),
                    (function (t, e, n, i) {
                      const s = Fe(),
                        r = We(2)
                      s.firstUpdatePass && oa(s, null, r, i)
                      const o = Ne()
                      if (n !== Ys && So(o, r, n)) {
                        const a = s.data[an()]
                        if (da(a, i) && !ra(s, r)) {
                          let t = a.classesWithoutHost
                          null !== t && (n = rt(t, n || '')), Io(s, a, o, n, i)
                        } else
                          !(function (t, e, n, i, s, r, o, a) {
                            s === Ys && (s = Go)
                            let l = 0,
                              c = 0,
                              h = 0 < s.length ? s[0] : null,
                              u = 0 < r.length ? r[0] : null
                            for (; null !== h || null !== u; ) {
                              const o = l < s.length ? s[l + 1] : void 0,
                                d = c < r.length ? r[c + 1] : void 0
                              let p = null,
                                f = void 0
                              h === u
                                ? ((l += 2),
                                  (c += 2),
                                  o !== d && ((p = u), (f = d)))
                                : null === u || (null !== h && h < u)
                                ? ((l += 2), (p = h))
                                : ((c += 2), (p = u), (f = d)),
                                null !== p && ca(t, e, n, i, p, f, !0, a),
                                (h = l < s.length ? s[l] : null),
                                (u = c < r.length ? r[c] : null)
                            }
                          })(
                            s,
                            a,
                            o,
                            o[11],
                            o[r + 1],
                            (o[r + 1] = (function (t, e, n) {
                              if (null == n || '' === n) return Go
                              const i = [],
                                s = Ii(n)
                              if (Array.isArray(s))
                                for (let r = 0; r < s.length; r++)
                                  t(i, s[r], !0)
                              else if ('object' == typeof s)
                                for (const r in s)
                                  s.hasOwnProperty(r) && t(i, r, s[r])
                              else 'string' == typeof s && e(i, s)
                              return i
                            })(t, e, n)),
                            0,
                            r
                          )
                      }
                    })(ri, ia, 'overlog ' + e.data.type, !0),
                    Oo(
                      '@fadeAnimation',
                      Ll(
                        7,
                        yp,
                        e.animationState,
                        Ll(
                          4,
                          gp,
                          e.overlogConfig.animation.fadeIn,
                          e.overlogConfig.animation.fadeOut
                        )
                      )
                    ),
                    Xs(1),
                    ma(' ', e.data.text, ' '))
              },
              styles: [
                '[_nghost-%COMP%]{display:block;position:relative;padding:8px 16px;border-radius:6px;margin-bottom:8px;background-color:hsla(0,0%,100%,.4392156862745098);transition:background-color .2s ease-in-out}[_nghost-%COMP%]:hover{background-color:#fff}[_nghost-%COMP%]   .material-icons[_ngcontent-%COMP%]{cursor:pointer;position:absolute;color:#111;font-size:16px;height:16px;width:16px;right:0;top:0}',
              ],
              data: { animation: [hp.fadeOverlog] },
            })),
            t
          )
        })(),
        vp = (() => {
          class t {
            constructor(t, e, n) {
              ;(this.overlay = t),
                (this.parentInjector = e),
                (this.overlogConfig = n)
            }
            show(t, e) {
              this.overlogConfig = Object.assign({}, this.overlogConfig, e)
              const n = this.getPositionStrategy(),
                i = this.overlay.create({ positionStrategy: n }),
                s = new mp(i)
              this.lastOverlog = s
              const r = this.getInjector(t, s, this.parentInjector),
                o = new ud(_p, null, r)
              return i.attach(o), s
            }
            showFrom(t, e) {
              const n = this.getConnectedPosition(e),
                i = this.overlay.create({ positionStrategy: n }),
                s = new mp(i)
              this.lastOverlog = s
              const r = this.getInjector(t, s, this.parentInjector),
                o = new ud(_p, null, r)
              return i.attach(o), s
            }
            getConnectedPosition(t) {
              return this.overlay
                .position()
                .flexibleConnectedTo(t)
                .withFlexibleDimensions(!1)
                .withPush(!0)
                .withPositions(pp)
            }
            getPositionStrategy() {
              return this.overlay
                .position()
                .global()
                .top(this.getPosition())
                .right(this.overlogConfig.position.right + 'px')
            }
            getPosition() {
              return (
                (this.lastOverlog && this.lastOverlog.isVisible()
                  ? this.lastOverlog.getPosition().bottom
                  : this.overlogConfig.position.top) + 'px'
              )
            }
            getInjector(t, e, n) {
              const i = new WeakMap()
              return i.set(up, t), i.set(mp, e), new gd(n, i)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(Gd), vi(ho), vi(fp))
            }),
            (t.ɵprov = ht({ token: t, factory: t.ɵfac, providedIn: 'root' })),
            t
          )
        })(),
        bp = (() => {
          class t {
            static forRoot(e = dp) {
              return {
                ngModule: t,
                providers: [
                  {
                    provide: fp,
                    useValue: Object.assign(Object.assign({}, dp), e),
                  },
                ],
              }
            }
          }
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
              providers: [vp],
              imports: [[Gh, Zd]],
            })),
            t
          )
        })()
      class wp extends x {
        constructor(t) {
          super(), (this._value = t)
        }
        get value() {
          return this.getValue()
        }
        _subscribe(t) {
          const e = super._subscribe(t)
          return e && !e.closed && t.next(this._value), e
        }
        getValue() {
          if (this.hasError) throw this.thrownError
          if (this.closed) throw new b()
          return this._value
        }
        next(t) {
          super.next((this._value = t))
        }
      }
      function Cp() {}
      function xp(t, e, n) {
        return function (i) {
          return i.lift(new Sp(t, e, n))
        }
      }
      class Sp {
        constructor(t, e, n) {
          ;(this.nextOrObserver = t), (this.error = e), (this.complete = n)
        }
        call(t, e) {
          return e.subscribe(
            new Ep(t, this.nextOrObserver, this.error, this.complete)
          )
        }
      }
      class Ep extends f {
        constructor(t, e, n, s) {
          super(t),
            (this._tapNext = Cp),
            (this._tapError = Cp),
            (this._tapComplete = Cp),
            (this._tapError = n || Cp),
            (this._tapComplete = s || Cp),
            i(e)
              ? ((this._context = this), (this._tapNext = e))
              : e &&
                ((this._context = e),
                (this._tapNext = e.next || Cp),
                (this._tapError = e.error || Cp),
                (this._tapComplete = e.complete || Cp))
        }
        _next(t) {
          try {
            this._tapNext.call(this._context, t)
          } catch (e) {
            return void this.destination.error(e)
          }
          this.destination.next(t)
        }
        _error(t) {
          try {
            this._tapError.call(this._context, t)
          } catch (t) {
            return void this.destination.error(t)
          }
          this.destination.error(t)
        }
        _complete() {
          try {
            this._tapComplete.call(this._context)
          } catch (t) {
            return void this.destination.error(t)
          }
          return this.destination.complete()
        }
      }
      function kp(t, e = Su) {
        return (n) => n.lift(new Tp(t, e))
      }
      class Tp {
        constructor(t, e) {
          ;(this.dueTime = t), (this.scheduler = e)
        }
        call(t, e) {
          return e.subscribe(new Ap(t, this.dueTime, this.scheduler))
        }
      }
      class Ap extends f {
        constructor(t, e, n) {
          super(t),
            (this.dueTime = e),
            (this.scheduler = n),
            (this.debouncedSubscription = null),
            (this.lastValue = null),
            (this.hasValue = !1)
        }
        _next(t) {
          this.clearDebounce(),
            (this.lastValue = t),
            (this.hasValue = !0),
            this.add(
              (this.debouncedSubscription = this.scheduler.schedule(
                Op,
                this.dueTime,
                this
              ))
            )
        }
        _complete() {
          this.debouncedNext(), this.destination.complete()
        }
        debouncedNext() {
          if ((this.clearDebounce(), this.hasValue)) {
            const { lastValue: t } = this
            ;(this.lastValue = null),
              (this.hasValue = !1),
              this.destination.next(t)
          }
        }
        clearDebounce() {
          const t = this.debouncedSubscription
          null !== t &&
            (this.remove(t),
            t.unsubscribe(),
            (this.debouncedSubscription = null))
        }
      }
      function Op(t) {
        t.debouncedNext()
      }
      let Ip = (() => {
          class t {
            create(t) {
              return 'undefined' == typeof MutationObserver
                ? null
                : new MutationObserver(t)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵprov = ht({
              factory: function () {
                return new t()
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        Rp = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
              providers: [Ip],
            })),
            t
          )
        })()
      function Pp(t, e) {
        return (t.getAttribute(e) || '').match(/\S+/g) || []
      }
      const Dp = 'cdk-describedby-message-container',
        Np = 'cdk-describedby-host'
      let Fp = 0
      const Mp = new Map()
      let Lp = null,
        jp = (() => {
          class t {
            constructor(t, e) {
              ;(this._platform = e), (this._document = t)
            }
            describe(t, e) {
              this._canBeDescribed(t, e) &&
                ('string' != typeof e
                  ? (this._setMessageId(e),
                    Mp.set(e, { messageElement: e, referenceCount: 0 }))
                  : Mp.has(e) || this._createMessageElement(e),
                this._isElementDescribedByMessage(t, e) ||
                  this._addMessageReference(t, e))
            }
            removeDescription(t, e) {
              if (e && this._isElementNode(t)) {
                if (
                  (this._isElementDescribedByMessage(t, e) &&
                    this._removeMessageReference(t, e),
                  'string' == typeof e)
                ) {
                  const t = Mp.get(e)
                  t && 0 === t.referenceCount && this._deleteMessageElement(e)
                }
                Lp &&
                  0 === Lp.childNodes.length &&
                  this._deleteMessagesContainer()
              }
            }
            ngOnDestroy() {
              const t = this._document.querySelectorAll(
                '[cdk-describedby-host]'
              )
              for (let e = 0; e < t.length; e++)
                this._removeCdkDescribedByReferenceIds(t[e]),
                  t[e].removeAttribute(Np)
              Lp && this._deleteMessagesContainer(), Mp.clear()
            }
            _createMessageElement(t) {
              const e = this._document.createElement('div')
              this._setMessageId(e),
                (e.textContent = t),
                this._createMessagesContainer(),
                Lp.appendChild(e),
                Mp.set(t, { messageElement: e, referenceCount: 0 })
            }
            _setMessageId(t) {
              t.id || (t.id = 'cdk-describedby-message-' + Fp++)
            }
            _deleteMessageElement(t) {
              const e = Mp.get(t),
                n = e && e.messageElement
              Lp && n && Lp.removeChild(n), Mp.delete(t)
            }
            _createMessagesContainer() {
              if (!Lp) {
                const t =
                    !this._platform ||
                    (!this._platform.EDGE && !this._platform.TRIDENT),
                  e = this._document.getElementById(Dp)
                e && e.parentNode && e.parentNode.removeChild(e),
                  (Lp = this._document.createElement('div')),
                  (Lp.id = Dp),
                  Lp.classList.add('cdk-visually-hidden'),
                  Lp.setAttribute('aria-hidden', t + ''),
                  this._document.body.appendChild(Lp)
              }
            }
            _deleteMessagesContainer() {
              Lp &&
                Lp.parentNode &&
                (Lp.parentNode.removeChild(Lp), (Lp = null))
            }
            _removeCdkDescribedByReferenceIds(t) {
              const e = Pp(t, 'aria-describedby').filter(
                (t) => 0 != t.indexOf('cdk-describedby-message')
              )
              t.setAttribute('aria-describedby', e.join(' '))
            }
            _addMessageReference(t, e) {
              const n = Mp.get(e)
              !(function (t, e, n) {
                const i = Pp(t, e)
                i.some((t) => t.trim() == n.trim()) ||
                  (i.push(n.trim()), t.setAttribute(e, i.join(' ')))
              })(t, 'aria-describedby', n.messageElement.id),
                t.setAttribute(Np, ''),
                n.referenceCount++
            }
            _removeMessageReference(t, e) {
              const n = Mp.get(e)
              n.referenceCount--,
                (function (t, e, n) {
                  const i = Pp(t, e).filter((t) => t != n.trim())
                  i.length
                    ? t.setAttribute(e, i.join(' '))
                    : t.removeAttribute(e)
                })(t, 'aria-describedby', n.messageElement.id),
                t.removeAttribute(Np)
            }
            _isElementDescribedByMessage(t, e) {
              const n = Pp(t, 'aria-describedby'),
                i = Mp.get(e),
                s = i && i.messageElement.id
              return !!s && -1 != n.indexOf(s)
            }
            _canBeDescribed(t, e) {
              if (!this._isElementNode(t)) return !1
              if (e && 'object' == typeof e) return !0
              const n = null == e ? '' : ('' + e).trim(),
                i = t.getAttribute('aria-label')
              return !(!n || (i && i.trim() === n))
            }
            _isElementNode(t) {
              return t.nodeType === this._document.ELEMENT_NODE
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(mh), vi(Xu))
            }),
            (t.ɵprov = ht({
              factory: function () {
                return new t(vi(mh), vi(Xu))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })()
      class Bp extends class {
        constructor(t) {
          ;(this._items = t),
            (this._activeItemIndex = -1),
            (this._activeItem = null),
            (this._wrap = !1),
            (this._letterKeyStream = new x()),
            (this._typeaheadSubscription = u.EMPTY),
            (this._vertical = !0),
            (this._allowedModifierKeys = []),
            (this._homeAndEnd = !1),
            (this._skipPredicateFn = (t) => t.disabled),
            (this._pressedLetters = []),
            (this.tabOut = new x()),
            (this.change = new x()),
            t instanceof ql &&
              t.changes.subscribe((t) => {
                if (this._activeItem) {
                  const e = t.toArray().indexOf(this._activeItem)
                  e > -1 &&
                    e !== this._activeItemIndex &&
                    (this._activeItemIndex = e)
                }
              })
        }
        skipPredicate(t) {
          return (this._skipPredicateFn = t), this
        }
        withWrap(t = !0) {
          return (this._wrap = t), this
        }
        withVerticalOrientation(t = !0) {
          return (this._vertical = t), this
        }
        withHorizontalOrientation(t) {
          return (this._horizontal = t), this
        }
        withAllowedModifierKeys(t) {
          return (this._allowedModifierKeys = t), this
        }
        withTypeAhead(t = 200) {
          return (
            this._typeaheadSubscription.unsubscribe(),
            (this._typeaheadSubscription = this._letterKeyStream
              .pipe(
                xp((t) => this._pressedLetters.push(t)),
                kp(t),
                Iu(() => this._pressedLetters.length > 0),
                F(() => this._pressedLetters.join(''))
              )
              .subscribe((t) => {
                const e = this._getItemsArray()
                for (let n = 1; n < e.length + 1; n++) {
                  const i = (this._activeItemIndex + n) % e.length,
                    s = e[i]
                  if (
                    !this._skipPredicateFn(s) &&
                    0 === s.getLabel().toUpperCase().trim().indexOf(t)
                  ) {
                    this.setActiveItem(i)
                    break
                  }
                }
                this._pressedLetters = []
              })),
            this
          )
        }
        withHomeAndEnd(t = !0) {
          return (this._homeAndEnd = t), this
        }
        setActiveItem(t) {
          const e = this._activeItem
          this.updateActiveItem(t),
            this._activeItem !== e && this.change.next(this._activeItemIndex)
        }
        onKeydown(t) {
          const e = t.keyCode,
            n = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].every(
              (e) => !t[e] || this._allowedModifierKeys.indexOf(e) > -1
            )
          switch (e) {
            case 9:
              return void this.tabOut.next()
            case 40:
              if (this._vertical && n) {
                this.setNextItemActive()
                break
              }
              return
            case 38:
              if (this._vertical && n) {
                this.setPreviousItemActive()
                break
              }
              return
            case 39:
              if (this._horizontal && n) {
                'rtl' === this._horizontal
                  ? this.setPreviousItemActive()
                  : this.setNextItemActive()
                break
              }
              return
            case 37:
              if (this._horizontal && n) {
                'rtl' === this._horizontal
                  ? this.setNextItemActive()
                  : this.setPreviousItemActive()
                break
              }
              return
            case 36:
              if (this._homeAndEnd && n) {
                this.setFirstItemActive()
                break
              }
              return
            case 35:
              if (this._homeAndEnd && n) {
                this.setLastItemActive()
                break
              }
              return
            default:
              return void (
                (n || wd(t, 'shiftKey')) &&
                (t.key && 1 === t.key.length
                  ? this._letterKeyStream.next(t.key.toLocaleUpperCase())
                  : ((e >= 65 && e <= 90) || (e >= 48 && e <= 57)) &&
                    this._letterKeyStream.next(String.fromCharCode(e)))
              )
          }
          ;(this._pressedLetters = []), t.preventDefault()
        }
        get activeItemIndex() {
          return this._activeItemIndex
        }
        get activeItem() {
          return this._activeItem
        }
        isTyping() {
          return this._pressedLetters.length > 0
        }
        setFirstItemActive() {
          this._setActiveItemByIndex(0, 1)
        }
        setLastItemActive() {
          this._setActiveItemByIndex(this._items.length - 1, -1)
        }
        setNextItemActive() {
          this._activeItemIndex < 0
            ? this.setFirstItemActive()
            : this._setActiveItemByDelta(1)
        }
        setPreviousItemActive() {
          this._activeItemIndex < 0 && this._wrap
            ? this.setLastItemActive()
            : this._setActiveItemByDelta(-1)
        }
        updateActiveItem(t) {
          const e = this._getItemsArray(),
            n = 'number' == typeof t ? t : e.indexOf(t),
            i = e[n]
          ;(this._activeItem = null == i ? null : i),
            (this._activeItemIndex = n)
        }
        _setActiveItemByDelta(t) {
          this._wrap
            ? this._setActiveInWrapMode(t)
            : this._setActiveInDefaultMode(t)
        }
        _setActiveInWrapMode(t) {
          const e = this._getItemsArray()
          for (let n = 1; n <= e.length; n++) {
            const i = (this._activeItemIndex + t * n + e.length) % e.length
            if (!this._skipPredicateFn(e[i])) return void this.setActiveItem(i)
          }
        }
        _setActiveInDefaultMode(t) {
          this._setActiveItemByIndex(this._activeItemIndex + t, t)
        }
        _setActiveItemByIndex(t, e) {
          const n = this._getItemsArray()
          if (n[t]) {
            for (; this._skipPredicateFn(n[t]); ) if (!n[(t += e)]) return
            this.setActiveItem(t)
          }
        }
        _getItemsArray() {
          return this._items instanceof ql ? this._items.toArray() : this._items
        }
      } {
        constructor() {
          super(...arguments), (this._origin = 'program')
        }
        setFocusOrigin(t) {
          return (this._origin = t), this
        }
        setActiveItem(t) {
          super.setActiveItem(t),
            this.activeItem && this.activeItem.focus(this._origin)
        }
      }
      let Vp = (() => {
        class t {
          constructor(t) {
            this._platform = t
          }
          isDisabled(t) {
            return t.hasAttribute('disabled')
          }
          isVisible(t) {
            return (
              (function (t) {
                return !!(
                  t.offsetWidth ||
                  t.offsetHeight ||
                  ('function' == typeof t.getClientRects &&
                    t.getClientRects().length)
                )
              })(t) && 'visible' === getComputedStyle(t).visibility
            )
          }
          isTabbable(t) {
            if (!this._platform.isBrowser) return !1
            const e = (function (t) {
              try {
                return t.frameElement
              } catch (mS) {
                return null
              }
            })(((n = t).ownerDocument && n.ownerDocument.defaultView) || window)
            var n
            if (e) {
              if (-1 === zp(e)) return !1
              if (!this.isVisible(e)) return !1
            }
            let i = t.nodeName.toLowerCase(),
              s = zp(t)
            return t.hasAttribute('contenteditable')
              ? -1 !== s
              : 'iframe' !== i &&
                  'object' !== i &&
                  !(
                    this._platform.WEBKIT &&
                    this._platform.IOS &&
                    !(function (t) {
                      let e = t.nodeName.toLowerCase(),
                        n = 'input' === e && t.type
                      return (
                        'text' === n ||
                        'password' === n ||
                        'select' === e ||
                        'textarea' === e
                      )
                    })(t)
                  ) &&
                  ('audio' === i
                    ? !!t.hasAttribute('controls') && -1 !== s
                    : 'video' === i
                    ? -1 !== s &&
                      (null !== s ||
                        this._platform.FIREFOX ||
                        t.hasAttribute('controls'))
                    : t.tabIndex >= 0)
          }
          isFocusable(t, e) {
            return (
              (function (t) {
                return (
                  !(function (t) {
                    return (
                      (function (t) {
                        return 'input' == t.nodeName.toLowerCase()
                      })(t) && 'hidden' == t.type
                    )
                  })(t) &&
                  ((function (t) {
                    let e = t.nodeName.toLowerCase()
                    return (
                      'input' === e ||
                      'select' === e ||
                      'button' === e ||
                      'textarea' === e
                    )
                  })(t) ||
                    (function (t) {
                      return (
                        (function (t) {
                          return 'a' == t.nodeName.toLowerCase()
                        })(t) && t.hasAttribute('href')
                      )
                    })(t) ||
                    t.hasAttribute('contenteditable') ||
                    Up(t))
                )
              })(t) &&
              !this.isDisabled(t) &&
              ((null == e ? void 0 : e.ignoreVisibility) || this.isVisible(t))
            )
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(Xu))
          }),
          (t.ɵprov = ht({
            factory: function () {
              return new t(vi(Xu))
            },
            token: t,
            providedIn: 'root',
          })),
          t
        )
      })()
      function Up(t) {
        if (!t.hasAttribute('tabindex') || void 0 === t.tabIndex) return !1
        let e = t.getAttribute('tabindex')
        return '-32768' != e && !(!e || isNaN(parseInt(e, 10)))
      }
      function zp(t) {
        if (!Up(t)) return null
        const e = parseInt(t.getAttribute('tabindex') || '', 10)
        return isNaN(e) ? -1 : e
      }
      class Hp {
        constructor(t, e, n, i, s = !1) {
          ;(this._element = t),
            (this._checker = e),
            (this._ngZone = n),
            (this._document = i),
            (this._hasAttached = !1),
            (this.startAnchorListener = () => this.focusLastTabbableElement()),
            (this.endAnchorListener = () => this.focusFirstTabbableElement()),
            (this._enabled = !0),
            s || this.attachAnchors()
        }
        get enabled() {
          return this._enabled
        }
        set enabled(t) {
          ;(this._enabled = t),
            this._startAnchor &&
              this._endAnchor &&
              (this._toggleAnchorTabIndex(t, this._startAnchor),
              this._toggleAnchorTabIndex(t, this._endAnchor))
        }
        destroy() {
          const t = this._startAnchor,
            e = this._endAnchor
          t &&
            (t.removeEventListener('focus', this.startAnchorListener),
            t.parentNode && t.parentNode.removeChild(t)),
            e &&
              (e.removeEventListener('focus', this.endAnchorListener),
              e.parentNode && e.parentNode.removeChild(e)),
            (this._startAnchor = this._endAnchor = null),
            (this._hasAttached = !1)
        }
        attachAnchors() {
          return (
            !!this._hasAttached ||
            (this._ngZone.runOutsideAngular(() => {
              this._startAnchor ||
                ((this._startAnchor = this._createAnchor()),
                this._startAnchor.addEventListener(
                  'focus',
                  this.startAnchorListener
                )),
                this._endAnchor ||
                  ((this._endAnchor = this._createAnchor()),
                  this._endAnchor.addEventListener(
                    'focus',
                    this.endAnchorListener
                  ))
            }),
            this._element.parentNode &&
              (this._element.parentNode.insertBefore(
                this._startAnchor,
                this._element
              ),
              this._element.parentNode.insertBefore(
                this._endAnchor,
                this._element.nextSibling
              ),
              (this._hasAttached = !0)),
            this._hasAttached)
          )
        }
        focusInitialElementWhenReady() {
          return new Promise((t) => {
            this._executeOnStable(() => t(this.focusInitialElement()))
          })
        }
        focusFirstTabbableElementWhenReady() {
          return new Promise((t) => {
            this._executeOnStable(() => t(this.focusFirstTabbableElement()))
          })
        }
        focusLastTabbableElementWhenReady() {
          return new Promise((t) => {
            this._executeOnStable(() => t(this.focusLastTabbableElement()))
          })
        }
        _getRegionBoundary(t) {
          let e = this._element.querySelectorAll(
            `[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`
          )
          for (let n = 0; n < e.length; n++)
            e[n].hasAttribute('cdk-focus-' + t)
              ? console.warn(
                  `Found use of deprecated attribute 'cdk-focus-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`,
                  e[n]
                )
              : e[n].hasAttribute('cdk-focus-region-' + t) &&
                console.warn(
                  `Found use of deprecated attribute 'cdk-focus-region-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`,
                  e[n]
                )
          return 'start' == t
            ? e.length
              ? e[0]
              : this._getFirstTabbableElement(this._element)
            : e.length
            ? e[e.length - 1]
            : this._getLastTabbableElement(this._element)
        }
        focusInitialElement() {
          const t = this._element.querySelector(
            '[cdk-focus-initial], [cdkFocusInitial]'
          )
          if (t) {
            if (
              (t.hasAttribute('cdk-focus-initial') &&
                console.warn(
                  "Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0",
                  t
                ),
              !this._checker.isFocusable(t))
            ) {
              const e = this._getFirstTabbableElement(t)
              return null == e || e.focus(), !!e
            }
            return t.focus(), !0
          }
          return this.focusFirstTabbableElement()
        }
        focusFirstTabbableElement() {
          const t = this._getRegionBoundary('start')
          return t && t.focus(), !!t
        }
        focusLastTabbableElement() {
          const t = this._getRegionBoundary('end')
          return t && t.focus(), !!t
        }
        hasAttached() {
          return this._hasAttached
        }
        _getFirstTabbableElement(t) {
          if (this._checker.isFocusable(t) && this._checker.isTabbable(t))
            return t
          let e = t.children || t.childNodes
          for (let n = 0; n < e.length; n++) {
            let t =
              e[n].nodeType === this._document.ELEMENT_NODE
                ? this._getFirstTabbableElement(e[n])
                : null
            if (t) return t
          }
          return null
        }
        _getLastTabbableElement(t) {
          if (this._checker.isFocusable(t) && this._checker.isTabbable(t))
            return t
          let e = t.children || t.childNodes
          for (let n = e.length - 1; n >= 0; n--) {
            let t =
              e[n].nodeType === this._document.ELEMENT_NODE
                ? this._getLastTabbableElement(e[n])
                : null
            if (t) return t
          }
          return null
        }
        _createAnchor() {
          const t = this._document.createElement('div')
          return (
            this._toggleAnchorTabIndex(this._enabled, t),
            t.classList.add('cdk-visually-hidden'),
            t.classList.add('cdk-focus-trap-anchor'),
            t.setAttribute('aria-hidden', 'true'),
            t
          )
        }
        _toggleAnchorTabIndex(t, e) {
          t ? e.setAttribute('tabindex', '0') : e.removeAttribute('tabindex')
        }
        toggleAnchors(t) {
          this._startAnchor &&
            this._endAnchor &&
            (this._toggleAnchorTabIndex(t, this._startAnchor),
            this._toggleAnchorTabIndex(t, this._endAnchor))
        }
        _executeOnStable(t) {
          this._ngZone.isStable
            ? t()
            : this._ngZone.onStable.pipe(_d(1)).subscribe(t)
        }
      }
      let qp = (() => {
        class t {
          constructor(t, e, n) {
            ;(this._checker = t), (this._ngZone = e), (this._document = n)
          }
          create(t, e = !1) {
            return new Hp(t, this._checker, this._ngZone, this._document, e)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(Vp), vi(Oc), vi(mh))
          }),
          (t.ɵprov = ht({
            factory: function () {
              return new t(vi(Vp), vi(Oc), vi(mh))
            },
            token: t,
            providedIn: 'root',
          })),
          t
        )
      })()
      function $p(t) {
        return 0 === t.buttons
      }
      'undefined' != typeof Element && Element
      const Wp = new Yn('cdk-focus-monitor-default-options'),
        Kp = td({ passive: !0, capture: !0 })
      let Gp = (() => {
        class t {
          constructor(t, e, n, i) {
            ;(this._ngZone = t),
              (this._platform = e),
              (this._origin = null),
              (this._windowFocused = !1),
              (this._elementInfo = new Map()),
              (this._monitoredElementCount = 0),
              (this._rootNodeFocusListenerCount = new Map()),
              (this._documentKeydownListener = () => {
                ;(this._lastTouchTarget = null),
                  this._setOriginForCurrentEventQueue('keyboard')
              }),
              (this._documentMousedownListener = (t) => {
                if (!this._lastTouchTarget) {
                  const e = $p(t) ? 'keyboard' : 'mouse'
                  this._setOriginForCurrentEventQueue(e)
                }
              }),
              (this._documentTouchstartListener = (t) => {
                null != this._touchTimeoutId &&
                  clearTimeout(this._touchTimeoutId),
                  (this._lastTouchTarget = Qp(t)),
                  (this._touchTimeoutId = setTimeout(
                    () => (this._lastTouchTarget = null),
                    650
                  ))
              }),
              (this._windowFocusListener = () => {
                ;(this._windowFocused = !0),
                  (this._windowFocusTimeoutId = setTimeout(
                    () => (this._windowFocused = !1)
                  ))
              }),
              (this._rootNodeFocusAndBlurListener = (t) => {
                const e = Qp(t),
                  n = 'focus' === t.type ? this._onFocus : this._onBlur
                for (let i = e; i; i = i.parentElement) n.call(this, t, i)
              }),
              (this._document = n),
              (this._detectionMode =
                (null == i ? void 0 : i.detectionMode) || 0)
          }
          monitor(t, e = !1) {
            const n = fu(t)
            if (!this._platform.isBrowser || 1 !== n.nodeType) return mu(null)
            const i =
                (function (t) {
                  if (
                    (function () {
                      if (null == Yu) {
                        const t =
                          'undefined' != typeof document ? document.head : null
                        Yu = !(!t || (!t.createShadowRoot && !t.attachShadow))
                      }
                      return Yu
                    })()
                  ) {
                    const e = t.getRootNode ? t.getRootNode() : null
                    if (
                      'undefined' != typeof ShadowRoot &&
                      ShadowRoot &&
                      e instanceof ShadowRoot
                    )
                      return e
                  }
                  return null
                })(n) || this._getDocument(),
              s = this._elementInfo.get(n)
            if (s) return e && (s.checkChildren = !0), s.subject
            const r = { checkChildren: e, subject: new x(), rootNode: i }
            return (
              this._elementInfo.set(n, r),
              this._registerGlobalListeners(r),
              r.subject
            )
          }
          stopMonitoring(t) {
            const e = fu(t),
              n = this._elementInfo.get(e)
            n &&
              (n.subject.complete(),
              this._setClasses(e),
              this._elementInfo.delete(e),
              this._removeGlobalListeners(n))
          }
          focusVia(t, e, n) {
            const i = fu(t)
            i === this._getDocument().activeElement && this._elementInfo.has(i)
              ? this._originChanged(i, e, this._elementInfo.get(i))
              : (this._setOriginForCurrentEventQueue(e),
                'function' == typeof i.focus && i.focus(n))
          }
          ngOnDestroy() {
            this._elementInfo.forEach((t, e) => this.stopMonitoring(e))
          }
          _getDocument() {
            return this._document || document
          }
          _getWindow() {
            return this._getDocument().defaultView || window
          }
          _toggleClass(t, e, n) {
            n ? t.classList.add(e) : t.classList.remove(e)
          }
          _getFocusOrigin(t) {
            return this._origin
              ? this._origin
              : this._windowFocused && this._lastFocusOrigin
              ? this._lastFocusOrigin
              : this._wasCausedByTouch(t)
              ? 'touch'
              : 'program'
          }
          _setClasses(t, e) {
            this._toggleClass(t, 'cdk-focused', !!e),
              this._toggleClass(t, 'cdk-touch-focused', 'touch' === e),
              this._toggleClass(t, 'cdk-keyboard-focused', 'keyboard' === e),
              this._toggleClass(t, 'cdk-mouse-focused', 'mouse' === e),
              this._toggleClass(t, 'cdk-program-focused', 'program' === e)
          }
          _setOriginForCurrentEventQueue(t) {
            this._ngZone.runOutsideAngular(() => {
              ;(this._origin = t),
                0 === this._detectionMode &&
                  (this._originTimeoutId = setTimeout(
                    () => (this._origin = null),
                    1
                  ))
            })
          }
          _wasCausedByTouch(t) {
            const e = Qp(t)
            return (
              this._lastTouchTarget instanceof Node &&
              e instanceof Node &&
              (e === this._lastTouchTarget || e.contains(this._lastTouchTarget))
            )
          }
          _onFocus(t, e) {
            const n = this._elementInfo.get(e)
            n &&
              (n.checkChildren || e === Qp(t)) &&
              this._originChanged(e, this._getFocusOrigin(t), n)
          }
          _onBlur(t, e) {
            const n = this._elementInfo.get(e)
            !n ||
              (n.checkChildren &&
                t.relatedTarget instanceof Node &&
                e.contains(t.relatedTarget)) ||
              (this._setClasses(e), this._emitOrigin(n.subject, null))
          }
          _emitOrigin(t, e) {
            this._ngZone.run(() => t.next(e))
          }
          _registerGlobalListeners(t) {
            if (!this._platform.isBrowser) return
            const e = t.rootNode,
              n = this._rootNodeFocusListenerCount.get(e) || 0
            n ||
              this._ngZone.runOutsideAngular(() => {
                e.addEventListener(
                  'focus',
                  this._rootNodeFocusAndBlurListener,
                  Kp
                ),
                  e.addEventListener(
                    'blur',
                    this._rootNodeFocusAndBlurListener,
                    Kp
                  )
              }),
              this._rootNodeFocusListenerCount.set(e, n + 1),
              1 == ++this._monitoredElementCount &&
                this._ngZone.runOutsideAngular(() => {
                  const t = this._getDocument(),
                    e = this._getWindow()
                  t.addEventListener(
                    'keydown',
                    this._documentKeydownListener,
                    Kp
                  ),
                    t.addEventListener(
                      'mousedown',
                      this._documentMousedownListener,
                      Kp
                    ),
                    t.addEventListener(
                      'touchstart',
                      this._documentTouchstartListener,
                      Kp
                    ),
                    e.addEventListener('focus', this._windowFocusListener)
                })
          }
          _removeGlobalListeners(t) {
            const e = t.rootNode
            if (this._rootNodeFocusListenerCount.has(e)) {
              const t = this._rootNodeFocusListenerCount.get(e)
              t > 1
                ? this._rootNodeFocusListenerCount.set(e, t - 1)
                : (e.removeEventListener(
                    'focus',
                    this._rootNodeFocusAndBlurListener,
                    Kp
                  ),
                  e.removeEventListener(
                    'blur',
                    this._rootNodeFocusAndBlurListener,
                    Kp
                  ),
                  this._rootNodeFocusListenerCount.delete(e))
            }
            if (!--this._monitoredElementCount) {
              const t = this._getDocument(),
                e = this._getWindow()
              t.removeEventListener(
                'keydown',
                this._documentKeydownListener,
                Kp
              ),
                t.removeEventListener(
                  'mousedown',
                  this._documentMousedownListener,
                  Kp
                ),
                t.removeEventListener(
                  'touchstart',
                  this._documentTouchstartListener,
                  Kp
                ),
                e.removeEventListener('focus', this._windowFocusListener),
                clearTimeout(this._windowFocusTimeoutId),
                clearTimeout(this._touchTimeoutId),
                clearTimeout(this._originTimeoutId)
            }
          }
          _originChanged(t, e, n) {
            this._setClasses(t, e),
              this._emitOrigin(n.subject, e),
              (this._lastFocusOrigin = e)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(Oc), vi(Xu), vi(mh, 8), vi(Wp, 8))
          }),
          (t.ɵprov = ht({
            factory: function () {
              return new t(vi(Oc), vi(Xu), vi(mh, 8), vi(Wp, 8))
            },
            token: t,
            providedIn: 'root',
          })),
          t
        )
      })()
      function Qp(t) {
        return t.composedPath ? t.composedPath()[0] : t.target
      }
      const Zp = 'cdk-high-contrast-black-on-white',
        Yp = 'cdk-high-contrast-white-on-black',
        Xp = 'cdk-high-contrast-active'
      let Jp = (() => {
          class t {
            constructor(t, e) {
              ;(this._platform = t), (this._document = e)
            }
            getHighContrastMode() {
              if (!this._platform.isBrowser) return 0
              const t = this._document.createElement('div')
              ;(t.style.backgroundColor = 'rgb(1,2,3)'),
                (t.style.position = 'absolute'),
                this._document.body.appendChild(t)
              const e = this._document.defaultView || window,
                n = e && e.getComputedStyle ? e.getComputedStyle(t) : null,
                i = ((n && n.backgroundColor) || '').replace(/ /g, '')
              switch ((this._document.body.removeChild(t), i)) {
                case 'rgb(0,0,0)':
                  return 2
                case 'rgb(255,255,255)':
                  return 1
              }
              return 0
            }
            _applyBodyHighContrastModeCssClasses() {
              if (this._platform.isBrowser && this._document.body) {
                const t = this._document.body.classList
                t.remove(Xp), t.remove(Zp), t.remove(Yp)
                const e = this.getHighContrastMode()
                1 === e
                  ? (t.add(Xp), t.add(Zp))
                  : 2 === e && (t.add(Xp), t.add(Yp))
              }
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(Xu), vi(mh))
            }),
            (t.ɵprov = ht({
              factory: function () {
                return new t(vi(Xu), vi(mh))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        tf = (() => {
          class t {
            constructor(t) {
              t._applyBodyHighContrastModeCssClasses()
            }
          }
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)(vi(Jp))
              },
              imports: [[Ju, Rp]],
            })),
            t
          )
        })()
      const ef = new $a('11.0.3')
      class nf extends class extends class {} {
        constructor() {
          super()
        }
        supportsDOMEvents() {
          return !0
        }
      } {
        static makeCurrent() {
          var t
          ;(t = new nf()), ph || (ph = t)
        }
        getProperty(t, e) {
          return t[e]
        }
        log(t) {
          window.console && window.console.log && window.console.log(t)
        }
        logGroup(t) {
          window.console && window.console.group && window.console.group(t)
        }
        logGroupEnd() {
          window.console && window.console.groupEnd && window.console.groupEnd()
        }
        onAndCancel(t, e, n) {
          return (
            t.addEventListener(e, n, !1),
            () => {
              t.removeEventListener(e, n, !1)
            }
          )
        }
        dispatchEvent(t, e) {
          t.dispatchEvent(e)
        }
        remove(t) {
          return t.parentNode && t.parentNode.removeChild(t), t
        }
        getValue(t) {
          return t.value
        }
        createElement(t, e) {
          return (e = e || this.getDefaultDocument()).createElement(t)
        }
        createHtmlDocument() {
          return document.implementation.createHTMLDocument('fakeTitle')
        }
        getDefaultDocument() {
          return document
        }
        isElementNode(t) {
          return t.nodeType === Node.ELEMENT_NODE
        }
        isShadowRoot(t) {
          return t instanceof DocumentFragment
        }
        getGlobalEventTarget(t, e) {
          return 'window' === e
            ? window
            : 'document' === e
            ? t
            : 'body' === e
            ? t.body
            : null
        }
        getHistory() {
          return window.history
        }
        getLocation() {
          return window.location
        }
        getBaseHref(t) {
          const e =
            rf || ((rf = document.querySelector('base')), rf)
              ? rf.getAttribute('href')
              : null
          return null == e
            ? null
            : ((n = e),
              sf || (sf = document.createElement('a')),
              sf.setAttribute('href', n),
              '/' === sf.pathname.charAt(0) ? sf.pathname : '/' + sf.pathname)
          var n
        }
        resetBaseElement() {
          rf = null
        }
        getUserAgent() {
          return window.navigator.userAgent
        }
        performanceNow() {
          return window.performance && window.performance.now
            ? window.performance.now()
            : new Date().getTime()
        }
        supportsCookies() {
          return !0
        }
        getCookie(t) {
          return (function (t, e) {
            e = encodeURIComponent(e)
            for (const n of t.split(';')) {
              const t = n.indexOf('='),
                [i, s] = -1 == t ? [n, ''] : [n.slice(0, t), n.slice(t + 1)]
              if (i.trim() === e) return decodeURIComponent(s)
            }
            return null
          })(document.cookie, t)
        }
      }
      let sf,
        rf = null
      const of = new Yn('TRANSITION_ID'),
        af = [
          {
            provide: lc,
            useFactory: function (t, e, n) {
              return () => {
                n.get(cc).donePromise.then(() => {
                  const n = fh()
                  Array.prototype.slice
                    .apply(e.querySelectorAll('style[ng-transition]'))
                    .filter((e) => e.getAttribute('ng-transition') === t)
                    .forEach((t) => n.remove(t))
                })
              }
            },
            deps: [of, mh, ho],
            multi: !0,
          },
        ]
      class lf {
        static init() {
          var t
          ;(t = new lf()), (Vc = t)
        }
        addToWindow(t) {
          ;(It.getAngularTestability = (e, n = !0) => {
            const i = t.findTestabilityInTree(e, n)
            if (null == i)
              throw new Error('Could not find testability for element.')
            return i
          }),
            (It.getAllAngularTestabilities = () => t.getAllTestabilities()),
            (It.getAllAngularRootElements = () => t.getAllRootElements()),
            It.frameworkStabilizers || (It.frameworkStabilizers = []),
            It.frameworkStabilizers.push((t) => {
              const e = It.getAllAngularTestabilities()
              let n = e.length,
                i = !1
              const s = function (e) {
                ;(i = i || e), n--, 0 == n && t(i)
              }
              e.forEach(function (t) {
                t.whenStable(s)
              })
            })
        }
        findTestabilityInTree(t, e, n) {
          if (null == e) return null
          const i = t.getTestability(e)
          return null != i
            ? i
            : n
            ? fh().isShadowRoot(e)
              ? this.findTestabilityInTree(t, e.host, !0)
              : this.findTestabilityInTree(t, e.parentElement, !0)
            : null
        }
      }
      const cf = new Yn('EventManagerPlugins')
      let hf = (() => {
        class t {
          constructor(t, e) {
            ;(this._zone = e),
              (this._eventNameToPlugin = new Map()),
              t.forEach((t) => (t.manager = this)),
              (this._plugins = t.slice().reverse())
          }
          addEventListener(t, e, n) {
            return this._findPluginFor(e).addEventListener(t, e, n)
          }
          addGlobalEventListener(t, e, n) {
            return this._findPluginFor(e).addGlobalEventListener(t, e, n)
          }
          getZone() {
            return this._zone
          }
          _findPluginFor(t) {
            const e = this._eventNameToPlugin.get(t)
            if (e) return e
            const n = this._plugins
            for (let i = 0; i < n.length; i++) {
              const e = n[i]
              if (e.supports(t)) return this._eventNameToPlugin.set(t, e), e
            }
            throw new Error('No event manager plugin found for event ' + t)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(cf), vi(Oc))
          }),
          (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      class uf {
        constructor(t) {
          this._doc = t
        }
        addGlobalEventListener(t, e, n) {
          const i = fh().getGlobalEventTarget(this._doc, t)
          if (!i)
            throw new Error(`Unsupported event target ${i} for event ${e}`)
          return this.addEventListener(i, e, n)
        }
      }
      let df = (() => {
          class t {
            constructor() {
              this._stylesSet = new Set()
            }
            addStyles(t) {
              const e = new Set()
              t.forEach((t) => {
                this._stylesSet.has(t) || (this._stylesSet.add(t), e.add(t))
              }),
                this.onStylesAdded(e)
            }
            onStylesAdded(t) {}
            getAllStyles() {
              return Array.from(this._stylesSet)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        pf = (() => {
          class t extends df {
            constructor(t) {
              super(),
                (this._doc = t),
                (this._hostNodes = new Set()),
                (this._styleNodes = new Set()),
                this._hostNodes.add(t.head)
            }
            _addStylesToHost(t, e) {
              t.forEach((t) => {
                const n = this._doc.createElement('style')
                ;(n.textContent = t), this._styleNodes.add(e.appendChild(n))
              })
            }
            addHost(t) {
              this._addStylesToHost(this._stylesSet, t), this._hostNodes.add(t)
            }
            removeHost(t) {
              this._hostNodes.delete(t)
            }
            onStylesAdded(t) {
              this._hostNodes.forEach((e) => this._addStylesToHost(t, e))
            }
            ngOnDestroy() {
              this._styleNodes.forEach((t) => fh().remove(t))
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(mh))
            }),
            (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
            t
          )
        })()
      const ff = {
          svg: 'http://www.w3.org/2000/svg',
          xhtml: 'http://www.w3.org/1999/xhtml',
          xlink: 'http://www.w3.org/1999/xlink',
          xml: 'http://www.w3.org/XML/1998/namespace',
          xmlns: 'http://www.w3.org/2000/xmlns/',
        },
        mf = /%COMP%/g
      function gf(t, e, n) {
        for (let i = 0; i < e.length; i++) {
          let s = e[i]
          Array.isArray(s) ? gf(t, s, n) : ((s = s.replace(mf, t)), n.push(s))
        }
        return n
      }
      function yf(t) {
        return (e) => {
          if ('__ngUnwrap__' === e) return t
          !1 === t(e) && (e.preventDefault(), (e.returnValue = !1))
        }
      }
      let _f = (() => {
        class t {
          constructor(t, e, n) {
            ;(this.eventManager = t),
              (this.sharedStylesHost = e),
              (this.appId = n),
              (this.rendererByCompId = new Map()),
              (this.defaultRenderer = new vf(t))
          }
          createRenderer(t, e) {
            if (!t || !e) return this.defaultRenderer
            switch (e.encapsulation) {
              case Et.Emulated: {
                let n = this.rendererByCompId.get(e.id)
                return (
                  n ||
                    ((n = new bf(
                      this.eventManager,
                      this.sharedStylesHost,
                      e,
                      this.appId
                    )),
                    this.rendererByCompId.set(e.id, n)),
                  n.applyToHost(t),
                  n
                )
              }
              case 1:
              case Et.ShadowDom:
                return new wf(this.eventManager, this.sharedStylesHost, t, e)
              default:
                if (!this.rendererByCompId.has(e.id)) {
                  const t = gf(e.id, e.styles, [])
                  this.sharedStylesHost.addStyles(t),
                    this.rendererByCompId.set(e.id, this.defaultRenderer)
                }
                return this.defaultRenderer
            }
          }
          begin() {}
          end() {}
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(hf), vi(pf), vi(hc))
          }),
          (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      class vf {
        constructor(t) {
          ;(this.eventManager = t), (this.data = Object.create(null))
        }
        destroy() {}
        createElement(t, e) {
          return e
            ? document.createElementNS(ff[e] || e, t)
            : document.createElement(t)
        }
        createComment(t) {
          return document.createComment(t)
        }
        createText(t) {
          return document.createTextNode(t)
        }
        appendChild(t, e) {
          t.appendChild(e)
        }
        insertBefore(t, e, n) {
          t && t.insertBefore(e, n)
        }
        removeChild(t, e) {
          t && t.removeChild(e)
        }
        selectRootElement(t, e) {
          let n = 'string' == typeof t ? document.querySelector(t) : t
          if (!n)
            throw new Error(`The selector "${t}" did not match any elements`)
          return e || (n.textContent = ''), n
        }
        parentNode(t) {
          return t.parentNode
        }
        nextSibling(t) {
          return t.nextSibling
        }
        setAttribute(t, e, n, i) {
          if (i) {
            e = i + ':' + e
            const s = ff[i]
            s ? t.setAttributeNS(s, e, n) : t.setAttribute(e, n)
          } else t.setAttribute(e, n)
        }
        removeAttribute(t, e, n) {
          if (n) {
            const i = ff[n]
            i ? t.removeAttributeNS(i, e) : t.removeAttribute(`${n}:${e}`)
          } else t.removeAttribute(e)
        }
        addClass(t, e) {
          t.classList.add(e)
        }
        removeClass(t, e) {
          t.classList.remove(e)
        }
        setStyle(t, e, n, i) {
          i & (ds.DashCase | ds.Important)
            ? t.style.setProperty(e, n, i & ds.Important ? 'important' : '')
            : (t.style[e] = n)
        }
        removeStyle(t, e, n) {
          n & ds.DashCase ? t.style.removeProperty(e) : (t.style[e] = '')
        }
        setProperty(t, e, n) {
          t[e] = n
        }
        setValue(t, e) {
          t.nodeValue = e
        }
        listen(t, e, n) {
          return 'string' == typeof t
            ? this.eventManager.addGlobalEventListener(t, e, yf(n))
            : this.eventManager.addEventListener(t, e, yf(n))
        }
      }
      class bf extends vf {
        constructor(t, e, n, i) {
          super(t), (this.component = n)
          const s = gf(i + '-' + n.id, n.styles, [])
          e.addStyles(s),
            (this.contentAttr = '_ngcontent-%COMP%'.replace(
              mf,
              i + '-' + n.id
            )),
            (this.hostAttr = '_nghost-%COMP%'.replace(mf, i + '-' + n.id))
        }
        applyToHost(t) {
          super.setAttribute(t, this.hostAttr, '')
        }
        createElement(t, e) {
          const n = super.createElement(t, e)
          return super.setAttribute(n, this.contentAttr, ''), n
        }
      }
      class wf extends vf {
        constructor(t, e, n, i) {
          super(t),
            (this.sharedStylesHost = e),
            (this.hostEl = n),
            (this.shadowRoot = n.attachShadow({ mode: 'open' })),
            this.sharedStylesHost.addHost(this.shadowRoot)
          const s = gf(i.id, i.styles, [])
          for (let r = 0; r < s.length; r++) {
            const t = document.createElement('style')
            ;(t.textContent = s[r]), this.shadowRoot.appendChild(t)
          }
        }
        nodeOrShadowRoot(t) {
          return t === this.hostEl ? this.shadowRoot : t
        }
        destroy() {
          this.sharedStylesHost.removeHost(this.shadowRoot)
        }
        appendChild(t, e) {
          return super.appendChild(this.nodeOrShadowRoot(t), e)
        }
        insertBefore(t, e, n) {
          return super.insertBefore(this.nodeOrShadowRoot(t), e, n)
        }
        removeChild(t, e) {
          return super.removeChild(this.nodeOrShadowRoot(t), e)
        }
        parentNode(t) {
          return this.nodeOrShadowRoot(
            super.parentNode(this.nodeOrShadowRoot(t))
          )
        }
      }
      let Cf = (() => {
        class t extends uf {
          constructor(t) {
            super(t)
          }
          supports(t) {
            return !0
          }
          addEventListener(t, e, n) {
            return (
              t.addEventListener(e, n, !1),
              () => this.removeEventListener(t, e, n)
            )
          }
          removeEventListener(t, e, n) {
            return t.removeEventListener(e, n)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(mh))
          }),
          (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      const xf = ['alt', 'control', 'meta', 'shift'],
        Sf = {
          '\b': 'Backspace',
          '\t': 'Tab',
          '\x7f': 'Delete',
          '\x1b': 'Escape',
          Del: 'Delete',
          Esc: 'Escape',
          Left: 'ArrowLeft',
          Right: 'ArrowRight',
          Up: 'ArrowUp',
          Down: 'ArrowDown',
          Menu: 'ContextMenu',
          Scroll: 'ScrollLock',
          Win: 'OS',
        },
        Ef = {
          A: '1',
          B: '2',
          C: '3',
          D: '4',
          E: '5',
          F: '6',
          G: '7',
          H: '8',
          I: '9',
          J: '*',
          K: '+',
          M: '-',
          N: '.',
          O: '/',
          '`': '0',
          '\x90': 'NumLock',
        },
        kf = {
          alt: (t) => t.altKey,
          control: (t) => t.ctrlKey,
          meta: (t) => t.metaKey,
          shift: (t) => t.shiftKey,
        }
      let Tf = (() => {
          class t extends uf {
            constructor(t) {
              super(t)
            }
            supports(e) {
              return null != t.parseEventName(e)
            }
            addEventListener(e, n, i) {
              const s = t.parseEventName(n),
                r = t.eventCallback(s.fullKey, i, this.manager.getZone())
              return this.manager
                .getZone()
                .runOutsideAngular(() => fh().onAndCancel(e, s.domEventName, r))
            }
            static parseEventName(e) {
              const n = e.toLowerCase().split('.'),
                i = n.shift()
              if (0 === n.length || ('keydown' !== i && 'keyup' !== i))
                return null
              const s = t._normalizeKey(n.pop())
              let r = ''
              if (
                (xf.forEach((t) => {
                  const e = n.indexOf(t)
                  e > -1 && (n.splice(e, 1), (r += t + '.'))
                }),
                (r += s),
                0 != n.length || 0 === s.length)
              )
                return null
              const o = {}
              return (o.domEventName = i), (o.fullKey = r), o
            }
            static getEventFullKey(t) {
              let e = '',
                n = (function (t) {
                  let e = t.key
                  if (null == e) {
                    if (((e = t.keyIdentifier), null == e))
                      return 'Unidentified'
                    e.startsWith('U+') &&
                      ((e = String.fromCharCode(parseInt(e.substring(2), 16))),
                      3 === t.location && Ef.hasOwnProperty(e) && (e = Ef[e]))
                  }
                  return Sf[e] || e
                })(t)
              return (
                (n = n.toLowerCase()),
                ' ' === n ? (n = 'space') : '.' === n && (n = 'dot'),
                xf.forEach((i) => {
                  i != n && (0, kf[i])(t) && (e += i + '.')
                }),
                (e += n),
                e
              )
            }
            static eventCallback(e, n, i) {
              return (s) => {
                t.getEventFullKey(s) === e && i.runGuarded(() => n(s))
              }
            }
            static _normalizeKey(t) {
              switch (t) {
                case 'esc':
                  return 'escape'
                default:
                  return t
              }
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(mh))
            }),
            (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        Af = (() => {
          class t {}
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵprov = ht({
              factory: function () {
                return vi(Of)
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        Of = (() => {
          class t extends Af {
            constructor(t) {
              super(), (this._doc = t)
            }
            sanitize(t, e) {
              if (null == e) return null
              switch (t) {
                case es.NONE:
                  return e
                case es.HTML:
                  return Ri(e, 'HTML')
                    ? Ii(e)
                    : (function (t, e) {
                        let n = null
                        try {
                          Ji =
                            Ji ||
                            (function (t) {
                              return (function () {
                                try {
                                  return !!new window.DOMParser().parseFromString(
                                    xi(''),
                                    'text/html'
                                  )
                                } catch (mS) {
                                  return !1
                                }
                              })()
                                ? new Di()
                                : new Ni(t)
                            })(t)
                          let i = e ? String(e) : ''
                          n = Ji.getInertBodyElement(i)
                          let s = 5,
                            r = i
                          do {
                            if (0 === s)
                              throw new Error(
                                'Failed to sanitize html because the input is unstable'
                              )
                            s--,
                              (i = r),
                              (r = n.innerHTML),
                              (n = Ji.getInertBodyElement(i))
                          } while (i !== r)
                          return new Qi().sanitizeChildren(ts(n) || n)
                        } finally {
                          if (n) {
                            const t = ts(n) || n
                            for (; t.firstChild; ) t.removeChild(t.firstChild)
                          }
                        }
                      })(this._doc, String(e))
                case es.STYLE:
                  return Ri(e, 'Style') ? Ii(e) : e
                case es.SCRIPT:
                  if (Ri(e, 'Script')) return Ii(e)
                  throw new Error('unsafe value used in a script context')
                case es.URL:
                  return Pi(e), Ri(e, 'URL') ? Ii(e) : Li(String(e))
                case es.RESOURCE_URL:
                  if (Ri(e, 'ResourceURL')) return Ii(e)
                  throw new Error(
                    'unsafe value used in a resource URL context (see https://g.co/ng/security#xss)'
                  )
                default:
                  throw new Error(
                    `Unexpected SecurityContext ${t} (see https://g.co/ng/security#xss)`
                  )
              }
            }
            bypassSecurityTrustHtml(t) {
              return new Ei(t)
            }
            bypassSecurityTrustStyle(t) {
              return new ki(t)
            }
            bypassSecurityTrustScript(t) {
              return new Ti(t)
            }
            bypassSecurityTrustUrl(t) {
              return new Ai(t)
            }
            bypassSecurityTrustResourceUrl(t) {
              return new Oi(t)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(mh))
            }),
            (t.ɵprov = ht({
              factory: function () {
                return (t = vi(Gr)), new Of(t.get(mh))
                var t
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })()
      const If = Wc(ih, 'browser', [
          { provide: fc, useValue: 'browser' },
          {
            provide: pc,
            useValue: function () {
              nf.makeCurrent(), lf.init()
            },
            multi: !0,
          },
          {
            provide: mh,
            useFactory: function () {
              return (
                (function (t) {
                  ye = t
                })(document),
                document
              )
            },
            deps: [],
          },
        ]),
        Rf = [
          [],
          { provide: Zr, useValue: 'root' },
          {
            provide: os,
            useFactory: function () {
              return new os()
            },
            deps: [],
          },
          { provide: cf, useClass: Cf, multi: !0, deps: [mh, Oc, fc] },
          { provide: cf, useClass: Tf, multi: !0, deps: [mh] },
          [],
          { provide: _f, useClass: _f, deps: [hf, pf, hc] },
          { provide: Ua, useExisting: _f },
          { provide: df, useExisting: pf },
          { provide: pf, useClass: pf, deps: [mh] },
          { provide: Mc, useClass: Mc, deps: [Oc] },
          { provide: hf, useClass: hf, deps: [cf, Oc] },
          [],
        ]
      let Pf = (() => {
        class t {
          constructor(t) {
            if (t)
              throw new Error(
                'BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.'
              )
          }
          static withServerTransition(e) {
            return {
              ngModule: t,
              providers: [
                { provide: hc, useValue: e.appId },
                { provide: of, useExisting: hc },
                af,
              ],
            }
          }
        }
        return (
          (t.ɵmod = $t({ type: t })),
          (t.ɵinj = ut({
            factory: function (e) {
              return new (e || t)(vi(t, 12))
            },
            providers: Rf,
            imports: [Gh, rh],
          })),
          t
        )
      })()
      function Df() {
        return (
          'undefined' != typeof process &&
          '[object process]' === {}.toString.call(process)
        )
      }
      function Nf(t) {
        switch (t.length) {
          case 0:
            return new lp()
          case 1:
            return t[0]
          default:
            return new cp(t)
        }
      }
      function Ff(t, e, n, i, s = {}, r = {}) {
        const o = [],
          a = []
        let l = -1,
          c = null
        if (
          (i.forEach((t) => {
            const n = t.offset,
              i = n == l,
              h = (i && c) || {}
            Object.keys(t).forEach((n) => {
              let i = n,
                a = t[n]
              if ('offset' !== n)
                switch (((i = e.normalizePropertyName(i, o)), a)) {
                  case '!':
                    a = s[n]
                    break
                  case Xd:
                    a = r[n]
                    break
                  default:
                    a = e.normalizeStyleValue(n, i, a, o)
                }
              h[i] = a
            }),
              i || a.push(h),
              (c = h),
              (l = n)
          }),
          o.length)
        ) {
          const t = '\n - '
          throw new Error(
            `Unable to animate due to the following errors:${t}${o.join(t)}`
          )
        }
        return a
      }
      function Mf(t, e, n, i) {
        switch (e) {
          case 'start':
            t.onStart(() => i(n && Lf(n, 'start', t)))
            break
          case 'done':
            t.onDone(() => i(n && Lf(n, 'done', t)))
            break
          case 'destroy':
            t.onDestroy(() => i(n && Lf(n, 'destroy', t)))
        }
      }
      function Lf(t, e, n) {
        const i = n.totalTime,
          s = jf(
            t.element,
            t.triggerName,
            t.fromState,
            t.toState,
            e || t.phaseName,
            null == i ? t.totalTime : i,
            !!n.disabled
          ),
          r = t._data
        return null != r && (s._data = r), s
      }
      function jf(t, e, n, i, s = '', r = 0, o) {
        return {
          element: t,
          triggerName: e,
          fromState: n,
          toState: i,
          phaseName: s,
          totalTime: r,
          disabled: !!o,
        }
      }
      function Bf(t, e, n) {
        let i
        return (
          t instanceof Map
            ? ((i = t.get(e)), i || t.set(e, (i = n)))
            : ((i = t[e]), i || (i = t[e] = n)),
          i
        )
      }
      function Vf(t) {
        const e = t.indexOf(':')
        return [t.substring(1, e), t.substr(e + 1)]
      }
      'undefined' != typeof window && window
      let Uf = (t, e) => !1,
        zf = (t, e) => !1,
        Hf = (t, e, n) => []
      const qf = Df()
      ;(qf || 'undefined' != typeof Element) &&
        ((Uf = (t, e) => t.contains(e)),
        (zf = (() => {
          if (qf || Element.prototype.matches) return (t, e) => t.matches(e)
          {
            const t = Element.prototype,
              e =
                t.matchesSelector ||
                t.mozMatchesSelector ||
                t.msMatchesSelector ||
                t.oMatchesSelector ||
                t.webkitMatchesSelector
            return e ? (t, n) => e.apply(t, [n]) : zf
          }
        })()),
        (Hf = (t, e, n) => {
          let i = []
          if (n) {
            const n = t.querySelectorAll(e)
            for (let t = 0; t < n.length; t++) i.push(n[t])
          } else {
            const n = t.querySelector(e)
            n && i.push(n)
          }
          return i
        }))
      let $f = null,
        Wf = !1
      function Kf(t) {
        $f ||
          (($f = ('undefined' != typeof document ? document.body : null) || {}),
          (Wf = !!$f.style && 'WebkitAppearance' in $f.style))
        let e = !0
        return (
          $f.style &&
            !(function (t) {
              return 'ebkit' == t.substring(1, 6)
            })(t) &&
            ((e = t in $f.style), !e && Wf) &&
            (e =
              'Webkit' + t.charAt(0).toUpperCase() + t.substr(1) in $f.style),
          e
        )
      }
      const Gf = zf,
        Qf = Uf,
        Zf = Hf
      function Yf(t) {
        const e = {}
        return (
          Object.keys(t).forEach((n) => {
            const i = n.replace(/([a-z])([A-Z])/g, '$1-$2')
            e[i] = t[n]
          }),
          e
        )
      }
      let Xf = (() => {
          class t {
            validateStyleProperty(t) {
              return Kf(t)
            }
            matchesElement(t, e) {
              return Gf(t, e)
            }
            containsElement(t, e) {
              return Qf(t, e)
            }
            query(t, e, n) {
              return Zf(t, e, n)
            }
            computeStyle(t, e, n) {
              return n || ''
            }
            animate(t, e, n, i, s, r = [], o) {
              return new lp(n, i)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        Jf = (() => {
          class t {}
          return (t.NOOP = new Xf()), t
        })()
      const tm = 'ng-enter',
        em = 'ng-leave',
        nm = 'ng-trigger',
        im = '.ng-trigger',
        sm = 'ng-animating',
        rm = '.ng-animating'
      function om(t) {
        if ('number' == typeof t) return t
        const e = t.match(/^(-?[\.\d]+)(m?s)/)
        return !e || e.length < 2 ? 0 : am(parseFloat(e[1]), e[2])
      }
      function am(t, e) {
        switch (e) {
          case 's':
            return 1e3 * t
          default:
            return t
        }
      }
      function lm(t, e, n) {
        return t.hasOwnProperty('duration')
          ? t
          : (function (t, e, n) {
              let i,
                s = 0,
                r = ''
              if ('string' == typeof t) {
                const n = t.match(
                  /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i
                )
                if (null === n)
                  return (
                    e.push(`The provided timing value "${t}" is invalid.`),
                    { duration: 0, delay: 0, easing: '' }
                  )
                i = am(parseFloat(n[1]), n[2])
                const o = n[3]
                null != o && (s = am(parseFloat(o), n[4]))
                const a = n[5]
                a && (r = a)
              } else i = t
              if (!n) {
                let n = !1,
                  r = e.length
                i < 0 &&
                  (e.push(
                    'Duration values below 0 are not allowed for this animation step.'
                  ),
                  (n = !0)),
                  s < 0 &&
                    (e.push(
                      'Delay values below 0 are not allowed for this animation step.'
                    ),
                    (n = !0)),
                  n &&
                    e.splice(
                      r,
                      0,
                      `The provided timing value "${t}" is invalid.`
                    )
              }
              return { duration: i, delay: s, easing: r }
            })(t, e, n)
      }
      function cm(t, e = {}) {
        return (
          Object.keys(t).forEach((n) => {
            e[n] = t[n]
          }),
          e
        )
      }
      function hm(t, e, n = {}) {
        if (e) for (let i in t) n[i] = t[i]
        else cm(t, n)
        return n
      }
      function um(t, e, n) {
        return n ? e + ':' + n + ';' : ''
      }
      function dm(t) {
        let e = ''
        for (let n = 0; n < t.style.length; n++) {
          const i = t.style.item(n)
          e += um(0, i, t.style.getPropertyValue(i))
        }
        for (const n in t.style)
          t.style.hasOwnProperty(n) &&
            !n.startsWith('_') &&
            (e += um(
              0,
              n.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase(),
              t.style[n]
            ))
        t.setAttribute('style', e)
      }
      function pm(t, e, n) {
        t.style &&
          (Object.keys(e).forEach((i) => {
            const s = wm(i)
            n && !n.hasOwnProperty(i) && (n[i] = t.style[s]),
              (t.style[s] = e[i])
          }),
          Df() && dm(t))
      }
      function fm(t, e) {
        t.style &&
          (Object.keys(e).forEach((e) => {
            const n = wm(e)
            t.style[n] = ''
          }),
          Df() && dm(t))
      }
      function mm(t) {
        return Array.isArray(t) ? (1 == t.length ? t[0] : ep(t)) : t
      }
      const gm = new RegExp('{{\\s*(.+?)\\s*}}', 'g')
      function ym(t) {
        let e = []
        if ('string' == typeof t) {
          let n
          for (; (n = gm.exec(t)); ) e.push(n[1])
          gm.lastIndex = 0
        }
        return e
      }
      function _m(t, e, n) {
        const i = t.toString(),
          s = i.replace(gm, (t, i) => {
            let s = e[i]
            return (
              e.hasOwnProperty(i) ||
                (n.push('Please provide a value for the animation param ' + i),
                (s = '')),
              s.toString()
            )
          })
        return s == i ? t : s
      }
      function vm(t) {
        const e = []
        let n = t.next()
        for (; !n.done; ) e.push(n.value), (n = t.next())
        return e
      }
      const bm = /-+([a-z0-9])/g
      function wm(t) {
        return t.replace(bm, (...t) => t[1].toUpperCase())
      }
      function Cm(t, e) {
        return 0 === t || 0 === e
      }
      function xm(t, e, n) {
        const i = Object.keys(n)
        if (i.length && e.length) {
          let r = e[0],
            o = []
          if (
            (i.forEach((t) => {
              r.hasOwnProperty(t) || o.push(t), (r[t] = n[t])
            }),
            o.length)
          )
            for (var s = 1; s < e.length; s++) {
              let n = e[s]
              o.forEach(function (e) {
                n[e] = Em(t, e)
              })
            }
        }
        return e
      }
      function Sm(t, e, n) {
        switch (e.type) {
          case 7:
            return t.visitTrigger(e, n)
          case 0:
            return t.visitState(e, n)
          case 1:
            return t.visitTransition(e, n)
          case 2:
            return t.visitSequence(e, n)
          case 3:
            return t.visitGroup(e, n)
          case 4:
            return t.visitAnimate(e, n)
          case 5:
            return t.visitKeyframes(e, n)
          case 6:
            return t.visitStyle(e, n)
          case 8:
            return t.visitReference(e, n)
          case 9:
            return t.visitAnimateChild(e, n)
          case 10:
            return t.visitAnimateRef(e, n)
          case 11:
            return t.visitQuery(e, n)
          case 12:
            return t.visitStagger(e, n)
          default:
            throw new Error(
              'Unable to resolve animation metadata node #' + e.type
            )
        }
      }
      function Em(t, e) {
        return window.getComputedStyle(t)[e]
      }
      const km = '*'
      function Tm(t, e) {
        const n = []
        return (
          'string' == typeof t
            ? t.split(/\s*,\s*/).forEach((t) =>
                (function (t, e, n) {
                  if (':' == t[0]) {
                    const i = (function (t, e) {
                      switch (t) {
                        case ':enter':
                          return 'void => *'
                        case ':leave':
                          return '* => void'
                        case ':increment':
                          return (t, e) => parseFloat(e) > parseFloat(t)
                        case ':decrement':
                          return (t, e) => parseFloat(e) < parseFloat(t)
                        default:
                          return (
                            e.push(
                              `The transition alias value "${t}" is not supported`
                            ),
                            '* => *'
                          )
                      }
                    })(t, n)
                    if ('function' == typeof i) return void e.push(i)
                    t = i
                  }
                  const i = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/)
                  if (null == i || i.length < 4)
                    return (
                      n.push(
                        `The provided transition expression "${t}" is not supported`
                      ),
                      e
                    )
                  const s = i[1],
                    r = i[2],
                    o = i[3]
                  e.push(Im(s, o)),
                    '<' != r[0] || (s == km && o == km) || e.push(Im(o, s))
                })(t, n, e)
              )
            : n.push(t),
          n
        )
      }
      const Am = new Set(['true', '1']),
        Om = new Set(['false', '0'])
      function Im(t, e) {
        const n = Am.has(t) || Om.has(t),
          i = Am.has(e) || Om.has(e)
        return (s, r) => {
          let o = t == km || t == s,
            a = e == km || e == r
          return (
            !o && n && 'boolean' == typeof s && (o = s ? Am.has(t) : Om.has(t)),
            !a && i && 'boolean' == typeof r && (a = r ? Am.has(e) : Om.has(e)),
            o && a
          )
        }
      }
      const Rm = new RegExp('s*:selfs*,?', 'g')
      function Pm(t, e, n) {
        return new Dm(t).build(e, n)
      }
      class Dm {
        constructor(t) {
          this._driver = t
        }
        build(t, e) {
          const n = new Nm(e)
          return this._resetContextStyleTimingState(n), Sm(this, mm(t), n)
        }
        _resetContextStyleTimingState(t) {
          ;(t.currentQuerySelector = ''),
            (t.collectedStyles = {}),
            (t.collectedStyles[''] = {}),
            (t.currentTime = 0)
        }
        visitTrigger(t, e) {
          let n = (e.queryCount = 0),
            i = (e.depCount = 0)
          const s = [],
            r = []
          return (
            '@' == t.name.charAt(0) &&
              e.errors.push(
                "animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"
              ),
            t.definitions.forEach((t) => {
              if ((this._resetContextStyleTimingState(e), 0 == t.type)) {
                const n = t,
                  i = n.name
                i
                  .toString()
                  .split(/\s*,\s*/)
                  .forEach((t) => {
                    ;(n.name = t), s.push(this.visitState(n, e))
                  }),
                  (n.name = i)
              } else if (1 == t.type) {
                const s = this.visitTransition(t, e)
                ;(n += s.queryCount), (i += s.depCount), r.push(s)
              } else
                e.errors.push(
                  'only state() and transition() definitions can sit inside of a trigger()'
                )
            }),
            {
              type: 7,
              name: t.name,
              states: s,
              transitions: r,
              queryCount: n,
              depCount: i,
              options: null,
            }
          )
        }
        visitState(t, e) {
          const n = this.visitStyle(t.styles, e),
            i = (t.options && t.options.params) || null
          if (n.containsDynamicStyles) {
            const s = new Set(),
              r = i || {}
            if (
              (n.styles.forEach((t) => {
                if (Fm(t)) {
                  const e = t
                  Object.keys(e).forEach((t) => {
                    ym(e[t]).forEach((t) => {
                      r.hasOwnProperty(t) || s.add(t)
                    })
                  })
                }
              }),
              s.size)
            ) {
              const n = vm(s.values())
              e.errors.push(
                `state("${
                  t.name
                }", ...) must define default values for all the following style substitutions: ${n.join(
                  ', '
                )}`
              )
            }
          }
          return {
            type: 0,
            name: t.name,
            style: n,
            options: i ? { params: i } : null,
          }
        }
        visitTransition(t, e) {
          ;(e.queryCount = 0), (e.depCount = 0)
          const n = Sm(this, mm(t.animation), e)
          return {
            type: 1,
            matchers: Tm(t.expr, e.errors),
            animation: n,
            queryCount: e.queryCount,
            depCount: e.depCount,
            options: Mm(t.options),
          }
        }
        visitSequence(t, e) {
          return {
            type: 2,
            steps: t.steps.map((t) => Sm(this, t, e)),
            options: Mm(t.options),
          }
        }
        visitGroup(t, e) {
          const n = e.currentTime
          let i = 0
          const s = t.steps.map((t) => {
            e.currentTime = n
            const s = Sm(this, t, e)
            return (i = Math.max(i, e.currentTime)), s
          })
          return (
            (e.currentTime = i), { type: 3, steps: s, options: Mm(t.options) }
          )
        }
        visitAnimate(t, e) {
          const n = (function (t, e) {
            let n = null
            if (t.hasOwnProperty('duration')) n = t
            else if ('number' == typeof t) return Lm(lm(t, e).duration, 0, '')
            const i = t
            if (
              i
                .split(/\s+/)
                .some((t) => '{' == t.charAt(0) && '{' == t.charAt(1))
            ) {
              const t = Lm(0, 0, '')
              return (t.dynamic = !0), (t.strValue = i), t
            }
            return (n = n || lm(i, e)), Lm(n.duration, n.delay, n.easing)
          })(t.timings, e.errors)
          let i
          e.currentAnimateTimings = n
          let s = t.styles ? t.styles : np({})
          if (5 == s.type) i = this.visitKeyframes(s, e)
          else {
            let s = t.styles,
              r = !1
            if (!s) {
              r = !0
              const t = {}
              n.easing && (t.easing = n.easing), (s = np(t))
            }
            e.currentTime += n.duration + n.delay
            const o = this.visitStyle(s, e)
            ;(o.isEmptyStep = r), (i = o)
          }
          return (
            (e.currentAnimateTimings = null),
            { type: 4, timings: n, style: i, options: null }
          )
        }
        visitStyle(t, e) {
          const n = this._makeStyleAst(t, e)
          return this._validateStyleAst(n, e), n
        }
        _makeStyleAst(t, e) {
          const n = []
          Array.isArray(t.styles)
            ? t.styles.forEach((t) => {
                'string' == typeof t
                  ? t == Xd
                    ? n.push(t)
                    : e.errors.push(
                        `The provided style string value ${t} is not allowed.`
                      )
                  : n.push(t)
              })
            : n.push(t.styles)
          let i = !1,
            s = null
          return (
            n.forEach((t) => {
              if (Fm(t)) {
                const e = t,
                  n = e.easing
                if ((n && ((s = n), delete e.easing), !i))
                  for (let t in e)
                    if (e[t].toString().indexOf('{{') >= 0) {
                      i = !0
                      break
                    }
              }
            }),
            {
              type: 6,
              styles: n,
              easing: s,
              offset: t.offset,
              containsDynamicStyles: i,
              options: null,
            }
          )
        }
        _validateStyleAst(t, e) {
          const n = e.currentAnimateTimings
          let i = e.currentTime,
            s = e.currentTime
          n && s > 0 && (s -= n.duration + n.delay),
            t.styles.forEach((t) => {
              'string' != typeof t &&
                Object.keys(t).forEach((n) => {
                  if (!this._driver.validateStyleProperty(n))
                    return void e.errors.push(
                      `The provided animation property "${n}" is not a supported CSS property for animations`
                    )
                  const r = e.collectedStyles[e.currentQuerySelector],
                    o = r[n]
                  let a = !0
                  o &&
                    (s != i &&
                      s >= o.startTime &&
                      i <= o.endTime &&
                      (e.errors.push(
                        `The CSS property "${n}" that exists between the times of "${o.startTime}ms" and "${o.endTime}ms" is also being animated in a parallel animation between the times of "${s}ms" and "${i}ms"`
                      ),
                      (a = !1)),
                    (s = o.startTime)),
                    a && (r[n] = { startTime: s, endTime: i }),
                    e.options &&
                      (function (t, e, n) {
                        const i = e.params || {},
                          s = ym(t)
                        s.length &&
                          s.forEach((t) => {
                            i.hasOwnProperty(t) ||
                              n.push(
                                `Unable to resolve the local animation param ${t} in the given list of values`
                              )
                          })
                      })(t[n], e.options, e.errors)
                })
            })
        }
        visitKeyframes(t, e) {
          const n = { type: 5, styles: [], options: null }
          if (!e.currentAnimateTimings)
            return (
              e.errors.push(
                'keyframes() must be placed inside of a call to animate()'
              ),
              n
            )
          let i = 0
          const s = []
          let r = !1,
            o = !1,
            a = 0
          const l = t.steps.map((t) => {
            const n = this._makeStyleAst(t, e)
            let l =
                null != n.offset
                  ? n.offset
                  : (function (t) {
                      if ('string' == typeof t) return null
                      let e = null
                      if (Array.isArray(t))
                        t.forEach((t) => {
                          if (Fm(t) && t.hasOwnProperty('offset')) {
                            const n = t
                            ;(e = parseFloat(n.offset)), delete n.offset
                          }
                        })
                      else if (Fm(t) && t.hasOwnProperty('offset')) {
                        const n = t
                        ;(e = parseFloat(n.offset)), delete n.offset
                      }
                      return e
                    })(n.styles),
              c = 0
            return (
              null != l && (i++, (c = n.offset = l)),
              (o = o || c < 0 || c > 1),
              (r = r || c < a),
              (a = c),
              s.push(c),
              n
            )
          })
          o &&
            e.errors.push(
              'Please ensure that all keyframe offsets are between 0 and 1'
            ),
            r &&
              e.errors.push(
                'Please ensure that all keyframe offsets are in order'
              )
          const c = t.steps.length
          let h = 0
          i > 0 && i < c
            ? e.errors.push(
                'Not all style() steps within the declared keyframes() contain offsets'
              )
            : 0 == i && (h = 1 / (c - 1))
          const u = c - 1,
            d = e.currentTime,
            p = e.currentAnimateTimings,
            f = p.duration
          return (
            l.forEach((t, i) => {
              const r = h > 0 ? (i == u ? 1 : h * i) : s[i],
                o = r * f
              ;(e.currentTime = d + p.delay + o),
                (p.duration = o),
                this._validateStyleAst(t, e),
                (t.offset = r),
                n.styles.push(t)
            }),
            n
          )
        }
        visitReference(t, e) {
          return {
            type: 8,
            animation: Sm(this, mm(t.animation), e),
            options: Mm(t.options),
          }
        }
        visitAnimateChild(t, e) {
          return e.depCount++, { type: 9, options: Mm(t.options) }
        }
        visitAnimateRef(t, e) {
          return {
            type: 10,
            animation: this.visitReference(t.animation, e),
            options: Mm(t.options),
          }
        }
        visitQuery(t, e) {
          const n = e.currentQuerySelector,
            i = t.options || {}
          e.queryCount++, (e.currentQuery = t)
          const [s, r] = (function (t) {
            const e = !!t.split(/\s*,\s*/).find((t) => ':self' == t)
            return (
              e && (t = t.replace(Rm, '')),
              [
                (t = t
                  .replace(/@\*/g, im)
                  .replace(/@\w+/g, (t) => '.ng-trigger-' + t.substr(1))
                  .replace(/:animating/g, rm)),
                e,
              ]
            )
          })(t.selector)
          ;(e.currentQuerySelector = n.length ? n + ' ' + s : s),
            Bf(e.collectedStyles, e.currentQuerySelector, {})
          const o = Sm(this, mm(t.animation), e)
          return (
            (e.currentQuery = null),
            (e.currentQuerySelector = n),
            {
              type: 11,
              selector: s,
              limit: i.limit || 0,
              optional: !!i.optional,
              includeSelf: r,
              animation: o,
              originalSelector: t.selector,
              options: Mm(t.options),
            }
          )
        }
        visitStagger(t, e) {
          e.currentQuery ||
            e.errors.push('stagger() can only be used inside of query()')
          const n =
            'full' === t.timings
              ? { duration: 0, delay: 0, easing: 'full' }
              : lm(t.timings, e.errors, !0)
          return {
            type: 12,
            animation: Sm(this, mm(t.animation), e),
            timings: n,
            options: null,
          }
        }
      }
      class Nm {
        constructor(t) {
          ;(this.errors = t),
            (this.queryCount = 0),
            (this.depCount = 0),
            (this.currentTransition = null),
            (this.currentQuery = null),
            (this.currentQuerySelector = null),
            (this.currentAnimateTimings = null),
            (this.currentTime = 0),
            (this.collectedStyles = {}),
            (this.options = null)
        }
      }
      function Fm(t) {
        return !Array.isArray(t) && 'object' == typeof t
      }
      function Mm(t) {
        var e
        return (
          t
            ? (t = cm(t)).params && (t.params = (e = t.params) ? cm(e) : null)
            : (t = {}),
          t
        )
      }
      function Lm(t, e, n) {
        return { duration: t, delay: e, easing: n }
      }
      function jm(t, e, n, i, s, r, o = null, a = !1) {
        return {
          type: 1,
          element: t,
          keyframes: e,
          preStyleProps: n,
          postStyleProps: i,
          duration: s,
          delay: r,
          totalTime: s + r,
          easing: o,
          subTimeline: a,
        }
      }
      class Bm {
        constructor() {
          this._map = new Map()
        }
        consume(t) {
          let e = this._map.get(t)
          return e ? this._map.delete(t) : (e = []), e
        }
        append(t, e) {
          let n = this._map.get(t)
          n || this._map.set(t, (n = [])), n.push(...e)
        }
        has(t) {
          return this._map.has(t)
        }
        clear() {
          this._map.clear()
        }
      }
      const Vm = new RegExp(':enter', 'g'),
        Um = new RegExp(':leave', 'g')
      function zm(t, e, n, i, s, r = {}, o = {}, a, l, c = []) {
        return new Hm().buildKeyframes(t, e, n, i, s, r, o, a, l, c)
      }
      class Hm {
        buildKeyframes(t, e, n, i, s, r, o, a, l, c = []) {
          l = l || new Bm()
          const h = new $m(t, e, l, i, s, c, [])
          ;(h.options = a),
            h.currentTimeline.setStyles([r], null, h.errors, a),
            Sm(this, n, h)
          const u = h.timelines.filter((t) => t.containsAnimation())
          if (u.length && Object.keys(o).length) {
            const t = u[u.length - 1]
            t.allowOnlyTimelineStyles() || t.setStyles([o], null, h.errors, a)
          }
          return u.length
            ? u.map((t) => t.buildKeyframes())
            : [jm(e, [], [], [], 0, 0, '', !1)]
        }
        visitTrigger(t, e) {}
        visitState(t, e) {}
        visitTransition(t, e) {}
        visitAnimateChild(t, e) {
          const n = e.subInstructions.consume(e.element)
          if (n) {
            const i = e.createSubContext(t.options),
              s = e.currentTimeline.currentTime,
              r = this._visitSubInstructions(n, i, i.options)
            s != r && e.transformIntoNewTimeline(r)
          }
          e.previousNode = t
        }
        visitAnimateRef(t, e) {
          const n = e.createSubContext(t.options)
          n.transformIntoNewTimeline(),
            this.visitReference(t.animation, n),
            e.transformIntoNewTimeline(n.currentTimeline.currentTime),
            (e.previousNode = t)
        }
        _visitSubInstructions(t, e, n) {
          let i = e.currentTimeline.currentTime
          const s = null != n.duration ? om(n.duration) : null,
            r = null != n.delay ? om(n.delay) : null
          return (
            0 !== s &&
              t.forEach((t) => {
                const n = e.appendInstructionToTimeline(t, s, r)
                i = Math.max(i, n.duration + n.delay)
              }),
            i
          )
        }
        visitReference(t, e) {
          e.updateOptions(t.options, !0),
            Sm(this, t.animation, e),
            (e.previousNode = t)
        }
        visitSequence(t, e) {
          const n = e.subContextCount
          let i = e
          const s = t.options
          if (
            s &&
            (s.params || s.delay) &&
            ((i = e.createSubContext(s)),
            i.transformIntoNewTimeline(),
            null != s.delay)
          ) {
            6 == i.previousNode.type &&
              (i.currentTimeline.snapshotCurrentStyles(), (i.previousNode = qm))
            const t = om(s.delay)
            i.delayNextStep(t)
          }
          t.steps.length &&
            (t.steps.forEach((t) => Sm(this, t, i)),
            i.currentTimeline.applyStylesToKeyframe(),
            i.subContextCount > n && i.transformIntoNewTimeline()),
            (e.previousNode = t)
        }
        visitGroup(t, e) {
          const n = []
          let i = e.currentTimeline.currentTime
          const s = t.options && t.options.delay ? om(t.options.delay) : 0
          t.steps.forEach((r) => {
            const o = e.createSubContext(t.options)
            s && o.delayNextStep(s),
              Sm(this, r, o),
              (i = Math.max(i, o.currentTimeline.currentTime)),
              n.push(o.currentTimeline)
          }),
            n.forEach((t) => e.currentTimeline.mergeTimelineCollectedStyles(t)),
            e.transformIntoNewTimeline(i),
            (e.previousNode = t)
        }
        _visitTiming(t, e) {
          if (t.dynamic) {
            const n = t.strValue
            return lm(e.params ? _m(n, e.params, e.errors) : n, e.errors)
          }
          return { duration: t.duration, delay: t.delay, easing: t.easing }
        }
        visitAnimate(t, e) {
          const n = (e.currentAnimateTimings = this._visitTiming(t.timings, e)),
            i = e.currentTimeline
          n.delay && (e.incrementTime(n.delay), i.snapshotCurrentStyles())
          const s = t.style
          5 == s.type
            ? this.visitKeyframes(s, e)
            : (e.incrementTime(n.duration),
              this.visitStyle(s, e),
              i.applyStylesToKeyframe()),
            (e.currentAnimateTimings = null),
            (e.previousNode = t)
        }
        visitStyle(t, e) {
          const n = e.currentTimeline,
            i = e.currentAnimateTimings
          !i && n.getCurrentStyleProperties().length && n.forwardFrame()
          const s = (i && i.easing) || t.easing
          t.isEmptyStep
            ? n.applyEmptyStep(s)
            : n.setStyles(t.styles, s, e.errors, e.options),
            (e.previousNode = t)
        }
        visitKeyframes(t, e) {
          const n = e.currentAnimateTimings,
            i = e.currentTimeline.duration,
            s = n.duration,
            r = e.createSubContext().currentTimeline
          ;(r.easing = n.easing),
            t.styles.forEach((t) => {
              r.forwardTime((t.offset || 0) * s),
                r.setStyles(t.styles, t.easing, e.errors, e.options),
                r.applyStylesToKeyframe()
            }),
            e.currentTimeline.mergeTimelineCollectedStyles(r),
            e.transformIntoNewTimeline(i + s),
            (e.previousNode = t)
        }
        visitQuery(t, e) {
          const n = e.currentTimeline.currentTime,
            i = t.options || {},
            s = i.delay ? om(i.delay) : 0
          s &&
            (6 === e.previousNode.type ||
              (0 == n &&
                e.currentTimeline.getCurrentStyleProperties().length)) &&
            (e.currentTimeline.snapshotCurrentStyles(), (e.previousNode = qm))
          let r = n
          const o = e.invokeQuery(
            t.selector,
            t.originalSelector,
            t.limit,
            t.includeSelf,
            !!i.optional,
            e.errors
          )
          e.currentQueryTotal = o.length
          let a = null
          o.forEach((n, i) => {
            e.currentQueryIndex = i
            const o = e.createSubContext(t.options, n)
            s && o.delayNextStep(s),
              n === e.element && (a = o.currentTimeline),
              Sm(this, t.animation, o),
              o.currentTimeline.applyStylesToKeyframe(),
              (r = Math.max(r, o.currentTimeline.currentTime))
          }),
            (e.currentQueryIndex = 0),
            (e.currentQueryTotal = 0),
            e.transformIntoNewTimeline(r),
            a &&
              (e.currentTimeline.mergeTimelineCollectedStyles(a),
              e.currentTimeline.snapshotCurrentStyles()),
            (e.previousNode = t)
        }
        visitStagger(t, e) {
          const n = e.parentContext,
            i = e.currentTimeline,
            s = t.timings,
            r = Math.abs(s.duration),
            o = r * (e.currentQueryTotal - 1)
          let a = r * e.currentQueryIndex
          switch (s.duration < 0 ? 'reverse' : s.easing) {
            case 'reverse':
              a = o - a
              break
            case 'full':
              a = n.currentStaggerTime
          }
          const l = e.currentTimeline
          a && l.delayNextStep(a)
          const c = l.currentTime
          Sm(this, t.animation, e),
            (e.previousNode = t),
            (n.currentStaggerTime =
              i.currentTime - c + (i.startTime - n.currentTimeline.startTime))
        }
      }
      const qm = {}
      class $m {
        constructor(t, e, n, i, s, r, o, a) {
          ;(this._driver = t),
            (this.element = e),
            (this.subInstructions = n),
            (this._enterClassName = i),
            (this._leaveClassName = s),
            (this.errors = r),
            (this.timelines = o),
            (this.parentContext = null),
            (this.currentAnimateTimings = null),
            (this.previousNode = qm),
            (this.subContextCount = 0),
            (this.options = {}),
            (this.currentQueryIndex = 0),
            (this.currentQueryTotal = 0),
            (this.currentStaggerTime = 0),
            (this.currentTimeline = a || new Wm(this._driver, e, 0)),
            o.push(this.currentTimeline)
        }
        get params() {
          return this.options.params
        }
        updateOptions(t, e) {
          if (!t) return
          const n = t
          let i = this.options
          null != n.duration && (i.duration = om(n.duration)),
            null != n.delay && (i.delay = om(n.delay))
          const s = n.params
          if (s) {
            let t = i.params
            t || (t = this.options.params = {}),
              Object.keys(s).forEach((n) => {
                ;(e && t.hasOwnProperty(n)) || (t[n] = _m(s[n], t, this.errors))
              })
          }
        }
        _copyOptions() {
          const t = {}
          if (this.options) {
            const e = this.options.params
            if (e) {
              const n = (t.params = {})
              Object.keys(e).forEach((t) => {
                n[t] = e[t]
              })
            }
          }
          return t
        }
        createSubContext(t = null, e, n) {
          const i = e || this.element,
            s = new $m(
              this._driver,
              i,
              this.subInstructions,
              this._enterClassName,
              this._leaveClassName,
              this.errors,
              this.timelines,
              this.currentTimeline.fork(i, n || 0)
            )
          return (
            (s.previousNode = this.previousNode),
            (s.currentAnimateTimings = this.currentAnimateTimings),
            (s.options = this._copyOptions()),
            s.updateOptions(t),
            (s.currentQueryIndex = this.currentQueryIndex),
            (s.currentQueryTotal = this.currentQueryTotal),
            (s.parentContext = this),
            this.subContextCount++,
            s
          )
        }
        transformIntoNewTimeline(t) {
          return (
            (this.previousNode = qm),
            (this.currentTimeline = this.currentTimeline.fork(this.element, t)),
            this.timelines.push(this.currentTimeline),
            this.currentTimeline
          )
        }
        appendInstructionToTimeline(t, e, n) {
          const i = {
              duration: null != e ? e : t.duration,
              delay:
                this.currentTimeline.currentTime +
                (null != n ? n : 0) +
                t.delay,
              easing: '',
            },
            s = new Km(
              this._driver,
              t.element,
              t.keyframes,
              t.preStyleProps,
              t.postStyleProps,
              i,
              t.stretchStartingKeyframe
            )
          return this.timelines.push(s), i
        }
        incrementTime(t) {
          this.currentTimeline.forwardTime(this.currentTimeline.duration + t)
        }
        delayNextStep(t) {
          t > 0 && this.currentTimeline.delayNextStep(t)
        }
        invokeQuery(t, e, n, i, s, r) {
          let o = []
          if ((i && o.push(this.element), t.length > 0)) {
            t = (t = t.replace(Vm, '.' + this._enterClassName)).replace(
              Um,
              '.' + this._leaveClassName
            )
            let e = this._driver.query(this.element, t, 1 != n)
            0 !== n &&
              (e = n < 0 ? e.slice(e.length + n, e.length) : e.slice(0, n)),
              o.push(...e)
          }
          return (
            s ||
              0 != o.length ||
              r.push(
                `\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`
              ),
            o
          )
        }
      }
      class Wm {
        constructor(t, e, n, i) {
          ;(this._driver = t),
            (this.element = e),
            (this.startTime = n),
            (this._elementTimelineStylesLookup = i),
            (this.duration = 0),
            (this._previousKeyframe = {}),
            (this._currentKeyframe = {}),
            (this._keyframes = new Map()),
            (this._styleSummary = {}),
            (this._pendingStyles = {}),
            (this._backFill = {}),
            (this._currentEmptyStepKeyframe = null),
            this._elementTimelineStylesLookup ||
              (this._elementTimelineStylesLookup = new Map()),
            (this._localTimelineStyles = Object.create(this._backFill, {})),
            (this._globalTimelineStyles = this._elementTimelineStylesLookup.get(
              e
            )),
            this._globalTimelineStyles ||
              ((this._globalTimelineStyles = this._localTimelineStyles),
              this._elementTimelineStylesLookup.set(
                e,
                this._localTimelineStyles
              )),
            this._loadKeyframe()
        }
        containsAnimation() {
          switch (this._keyframes.size) {
            case 0:
              return !1
            case 1:
              return this.getCurrentStyleProperties().length > 0
            default:
              return !0
          }
        }
        getCurrentStyleProperties() {
          return Object.keys(this._currentKeyframe)
        }
        get currentTime() {
          return this.startTime + this.duration
        }
        delayNextStep(t) {
          const e =
            1 == this._keyframes.size && Object.keys(this._pendingStyles).length
          this.duration || e
            ? (this.forwardTime(this.currentTime + t),
              e && this.snapshotCurrentStyles())
            : (this.startTime += t)
        }
        fork(t, e) {
          return (
            this.applyStylesToKeyframe(),
            new Wm(
              this._driver,
              t,
              e || this.currentTime,
              this._elementTimelineStylesLookup
            )
          )
        }
        _loadKeyframe() {
          this._currentKeyframe &&
            (this._previousKeyframe = this._currentKeyframe),
            (this._currentKeyframe = this._keyframes.get(this.duration)),
            this._currentKeyframe ||
              ((this._currentKeyframe = Object.create(this._backFill, {})),
              this._keyframes.set(this.duration, this._currentKeyframe))
        }
        forwardFrame() {
          ;(this.duration += 1), this._loadKeyframe()
        }
        forwardTime(t) {
          this.applyStylesToKeyframe(),
            (this.duration = t),
            this._loadKeyframe()
        }
        _updateStyle(t, e) {
          ;(this._localTimelineStyles[t] = e),
            (this._globalTimelineStyles[t] = e),
            (this._styleSummary[t] = { time: this.currentTime, value: e })
        }
        allowOnlyTimelineStyles() {
          return this._currentEmptyStepKeyframe !== this._currentKeyframe
        }
        applyEmptyStep(t) {
          t && (this._previousKeyframe.easing = t),
            Object.keys(this._globalTimelineStyles).forEach((t) => {
              ;(this._backFill[t] = this._globalTimelineStyles[t] || Xd),
                (this._currentKeyframe[t] = Xd)
            }),
            (this._currentEmptyStepKeyframe = this._currentKeyframe)
        }
        setStyles(t, e, n, i) {
          e && (this._previousKeyframe.easing = e)
          const s = (i && i.params) || {},
            r = (function (t, e) {
              const n = {}
              let i
              return (
                t.forEach((t) => {
                  '*' === t
                    ? ((i = i || Object.keys(e)),
                      i.forEach((t) => {
                        n[t] = Xd
                      }))
                    : hm(t, !1, n)
                }),
                n
              )
            })(t, this._globalTimelineStyles)
          Object.keys(r).forEach((t) => {
            const e = _m(r[t], s, n)
            ;(this._pendingStyles[t] = e),
              this._localTimelineStyles.hasOwnProperty(t) ||
                (this._backFill[t] = this._globalTimelineStyles.hasOwnProperty(
                  t
                )
                  ? this._globalTimelineStyles[t]
                  : Xd),
              this._updateStyle(t, e)
          })
        }
        applyStylesToKeyframe() {
          const t = this._pendingStyles,
            e = Object.keys(t)
          0 != e.length &&
            ((this._pendingStyles = {}),
            e.forEach((e) => {
              this._currentKeyframe[e] = t[e]
            }),
            Object.keys(this._localTimelineStyles).forEach((t) => {
              this._currentKeyframe.hasOwnProperty(t) ||
                (this._currentKeyframe[t] = this._localTimelineStyles[t])
            }))
        }
        snapshotCurrentStyles() {
          Object.keys(this._localTimelineStyles).forEach((t) => {
            const e = this._localTimelineStyles[t]
            ;(this._pendingStyles[t] = e), this._updateStyle(t, e)
          })
        }
        getFinalKeyframe() {
          return this._keyframes.get(this.duration)
        }
        get properties() {
          const t = []
          for (let e in this._currentKeyframe) t.push(e)
          return t
        }
        mergeTimelineCollectedStyles(t) {
          Object.keys(t._styleSummary).forEach((e) => {
            const n = this._styleSummary[e],
              i = t._styleSummary[e]
            ;(!n || i.time > n.time) && this._updateStyle(e, i.value)
          })
        }
        buildKeyframes() {
          this.applyStylesToKeyframe()
          const t = new Set(),
            e = new Set(),
            n = 1 === this._keyframes.size && 0 === this.duration
          let i = []
          this._keyframes.forEach((s, r) => {
            const o = hm(s, !0)
            Object.keys(o).forEach((n) => {
              const i = o[n]
              '!' == i ? t.add(n) : i == Xd && e.add(n)
            }),
              n || (o.offset = r / this.duration),
              i.push(o)
          })
          const s = t.size ? vm(t.values()) : [],
            r = e.size ? vm(e.values()) : []
          if (n) {
            const t = i[0],
              e = cm(t)
            ;(t.offset = 0), (e.offset = 1), (i = [t, e])
          }
          return jm(
            this.element,
            i,
            s,
            r,
            this.duration,
            this.startTime,
            this.easing,
            !1
          )
        }
      }
      class Km extends Wm {
        constructor(t, e, n, i, s, r, o = !1) {
          super(t, e, r.delay),
            (this.element = e),
            (this.keyframes = n),
            (this.preStyleProps = i),
            (this.postStyleProps = s),
            (this._stretchStartingKeyframe = o),
            (this.timings = {
              duration: r.duration,
              delay: r.delay,
              easing: r.easing,
            })
        }
        containsAnimation() {
          return this.keyframes.length > 1
        }
        buildKeyframes() {
          let t = this.keyframes,
            { delay: e, duration: n, easing: i } = this.timings
          if (this._stretchStartingKeyframe && e) {
            const s = [],
              r = n + e,
              o = e / r,
              a = hm(t[0], !1)
            ;(a.offset = 0), s.push(a)
            const l = hm(t[0], !1)
            ;(l.offset = Gm(o)), s.push(l)
            const c = t.length - 1
            for (let i = 1; i <= c; i++) {
              let o = hm(t[i], !1)
              ;(o.offset = Gm((e + o.offset * n) / r)), s.push(o)
            }
            ;(n = r), (e = 0), (i = ''), (t = s)
          }
          return jm(
            this.element,
            t,
            this.preStyleProps,
            this.postStyleProps,
            n,
            e,
            i,
            !0
          )
        }
      }
      function Gm(t, e = 3) {
        const n = Math.pow(10, e - 1)
        return Math.round(t * n) / n
      }
      class Qm {}
      class Zm extends Qm {
        normalizePropertyName(t, e) {
          return wm(t)
        }
        normalizeStyleValue(t, e, n, i) {
          let s = ''
          const r = n.toString().trim()
          if (Ym[e] && 0 !== n && '0' !== n)
            if ('number' == typeof n) s = 'px'
            else {
              const e = n.match(/^[+-]?[\d\.]+([a-z]*)$/)
              e &&
                0 == e[1].length &&
                i.push(`Please provide a CSS unit value for ${t}:${n}`)
            }
          return r + s
        }
      }
      const Ym = (() =>
        (function (t) {
          const e = {}
          return t.forEach((t) => (e[t] = !0)), e
        })(
          'width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective'.split(
            ','
          )
        ))()
      function Xm(t, e, n, i, s, r, o, a, l, c, h, u, d) {
        return {
          type: 0,
          element: t,
          triggerName: e,
          isRemovalTransition: s,
          fromState: n,
          fromStyles: r,
          toState: i,
          toStyles: o,
          timelines: a,
          queriedElements: l,
          preStyleProps: c,
          postStyleProps: h,
          totalTime: u,
          errors: d,
        }
      }
      const Jm = {}
      class tg {
        constructor(t, e, n) {
          ;(this._triggerName = t), (this.ast = e), (this._stateStyles = n)
        }
        match(t, e, n, i) {
          return (function (t, e, n, i, s) {
            return t.some((t) => t(e, n, i, s))
          })(this.ast.matchers, t, e, n, i)
        }
        buildStyles(t, e, n) {
          const i = this._stateStyles['*'],
            s = this._stateStyles[t],
            r = i ? i.buildStyles(e, n) : {}
          return s ? s.buildStyles(e, n) : r
        }
        build(t, e, n, i, s, r, o, a, l, c) {
          const h = [],
            u = (this.ast.options && this.ast.options.params) || Jm,
            d = this.buildStyles(n, (o && o.params) || Jm, h),
            p = (a && a.params) || Jm,
            f = this.buildStyles(i, p, h),
            m = new Set(),
            g = new Map(),
            y = new Map(),
            _ = 'void' === i,
            v = { params: Object.assign(Object.assign({}, u), p) },
            b = c ? [] : zm(t, e, this.ast.animation, s, r, d, f, v, l, h)
          let w = 0
          if (
            (b.forEach((t) => {
              w = Math.max(t.duration + t.delay, w)
            }),
            h.length)
          )
            return Xm(e, this._triggerName, n, i, _, d, f, [], [], g, y, w, h)
          b.forEach((t) => {
            const n = t.element,
              i = Bf(g, n, {})
            t.preStyleProps.forEach((t) => (i[t] = !0))
            const s = Bf(y, n, {})
            t.postStyleProps.forEach((t) => (s[t] = !0)), n !== e && m.add(n)
          })
          const C = vm(m.values())
          return Xm(e, this._triggerName, n, i, _, d, f, b, C, g, y, w)
        }
      }
      class eg {
        constructor(t, e) {
          ;(this.styles = t), (this.defaultParams = e)
        }
        buildStyles(t, e) {
          const n = {},
            i = cm(this.defaultParams)
          return (
            Object.keys(t).forEach((e) => {
              const n = t[e]
              null != n && (i[e] = n)
            }),
            this.styles.styles.forEach((t) => {
              if ('string' != typeof t) {
                const s = t
                Object.keys(s).forEach((t) => {
                  let r = s[t]
                  r.length > 1 && (r = _m(r, i, e)), (n[t] = r)
                })
              }
            }),
            n
          )
        }
      }
      class ng {
        constructor(t, e) {
          ;(this.name = t),
            (this.ast = e),
            (this.transitionFactories = []),
            (this.states = {}),
            e.states.forEach((t) => {
              this.states[t.name] = new eg(
                t.style,
                (t.options && t.options.params) || {}
              )
            }),
            ig(this.states, 'true', '1'),
            ig(this.states, 'false', '0'),
            e.transitions.forEach((e) => {
              this.transitionFactories.push(new tg(t, e, this.states))
            }),
            (this.fallbackTransition = new tg(
              t,
              {
                type: 1,
                animation: { type: 2, steps: [], options: null },
                matchers: [(t, e) => !0],
                options: null,
                queryCount: 0,
                depCount: 0,
              },
              this.states
            ))
        }
        get containsQueries() {
          return this.ast.queryCount > 0
        }
        matchTransition(t, e, n, i) {
          return (
            this.transitionFactories.find((s) => s.match(t, e, n, i)) || null
          )
        }
        matchStyles(t, e, n) {
          return this.fallbackTransition.buildStyles(t, e, n)
        }
      }
      function ig(t, e, n) {
        t.hasOwnProperty(e)
          ? t.hasOwnProperty(n) || (t[n] = t[e])
          : t.hasOwnProperty(n) && (t[e] = t[n])
      }
      const sg = new Bm()
      class rg {
        constructor(t, e, n) {
          ;(this.bodyNode = t),
            (this._driver = e),
            (this._normalizer = n),
            (this._animations = {}),
            (this._playersById = {}),
            (this.players = [])
        }
        register(t, e) {
          const n = [],
            i = Pm(this._driver, e, n)
          if (n.length)
            throw new Error(
              'Unable to build the animation due to the following errors: ' +
                n.join('\n')
            )
          this._animations[t] = i
        }
        _buildPlayer(t, e, n) {
          const i = t.element,
            s = Ff(0, this._normalizer, 0, t.keyframes, e, n)
          return this._driver.animate(
            i,
            s,
            t.duration,
            t.delay,
            t.easing,
            [],
            !0
          )
        }
        create(t, e, n = {}) {
          const i = [],
            s = this._animations[t]
          let r
          const o = new Map()
          if (
            (s
              ? ((r = zm(this._driver, e, s, tm, em, {}, {}, n, sg, i)),
                r.forEach((t) => {
                  const e = Bf(o, t.element, {})
                  t.postStyleProps.forEach((t) => (e[t] = null))
                }))
              : (i.push(
                  "The requested animation doesn't exist or has already been destroyed"
                ),
                (r = [])),
            i.length)
          )
            throw new Error(
              'Unable to create the animation due to the following errors: ' +
                i.join('\n')
            )
          o.forEach((t, e) => {
            Object.keys(t).forEach((n) => {
              t[n] = this._driver.computeStyle(e, n, Xd)
            })
          })
          const a = Nf(
            r.map((t) => {
              const e = o.get(t.element)
              return this._buildPlayer(t, {}, e)
            })
          )
          return (
            (this._playersById[t] = a),
            a.onDestroy(() => this.destroy(t)),
            this.players.push(a),
            a
          )
        }
        destroy(t) {
          const e = this._getPlayer(t)
          e.destroy(), delete this._playersById[t]
          const n = this.players.indexOf(e)
          n >= 0 && this.players.splice(n, 1)
        }
        _getPlayer(t) {
          const e = this._playersById[t]
          if (!e)
            throw new Error(
              'Unable to find the timeline player referenced by ' + t
            )
          return e
        }
        listen(t, e, n, i) {
          const s = jf(e, '', '', '')
          return Mf(this._getPlayer(t), n, s, i), () => {}
        }
        command(t, e, n, i) {
          if ('register' == n) return void this.register(t, i[0])
          if ('create' == n) return void this.create(t, e, i[0] || {})
          const s = this._getPlayer(t)
          switch (n) {
            case 'play':
              s.play()
              break
            case 'pause':
              s.pause()
              break
            case 'reset':
              s.reset()
              break
            case 'restart':
              s.restart()
              break
            case 'finish':
              s.finish()
              break
            case 'init':
              s.init()
              break
            case 'setPosition':
              s.setPosition(parseFloat(i[0]))
              break
            case 'destroy':
              this.destroy(t)
          }
        }
      }
      const og = 'ng-animate-queued',
        ag = 'ng-animate-disabled',
        lg = '.ng-animate-disabled',
        cg = [],
        hg = {
          namespaceId: '',
          setForRemoval: !1,
          setForMove: !1,
          hasAnimation: !1,
          removedBeforeQueried: !1,
        },
        ug = {
          namespaceId: '',
          setForMove: !1,
          setForRemoval: !1,
          hasAnimation: !1,
          removedBeforeQueried: !0,
        }
      class dg {
        constructor(t, e = '') {
          this.namespaceId = e
          const n = t && t.hasOwnProperty('value')
          if (((this.value = null != (i = n ? t.value : t) ? i : null), n)) {
            const e = cm(t)
            delete e.value, (this.options = e)
          } else this.options = {}
          var i
          this.options.params || (this.options.params = {})
        }
        get params() {
          return this.options.params
        }
        absorbOptions(t) {
          const e = t.params
          if (e) {
            const t = this.options.params
            Object.keys(e).forEach((n) => {
              null == t[n] && (t[n] = e[n])
            })
          }
        }
      }
      const pg = 'void',
        fg = new dg(pg)
      class mg {
        constructor(t, e, n) {
          ;(this.id = t),
            (this.hostElement = e),
            (this._engine = n),
            (this.players = []),
            (this._triggers = {}),
            (this._queue = []),
            (this._elementListeners = new Map()),
            (this._hostClassName = 'ng-tns-' + t),
            Cg(e, this._hostClassName)
        }
        listen(t, e, n, i) {
          if (!this._triggers.hasOwnProperty(e))
            throw new Error(
              `Unable to listen on the animation trigger event "${n}" because the animation trigger "${e}" doesn't exist!`
            )
          if (null == n || 0 == n.length)
            throw new Error(
              `Unable to listen on the animation trigger "${e}" because the provided event is undefined!`
            )
          if ('start' != (s = n) && 'done' != s)
            throw new Error(
              `The provided animation trigger event "${n}" for the animation trigger "${e}" is not supported!`
            )
          var s
          const r = Bf(this._elementListeners, t, []),
            o = { name: e, phase: n, callback: i }
          r.push(o)
          const a = Bf(this._engine.statesByElement, t, {})
          return (
            a.hasOwnProperty(e) ||
              (Cg(t, nm), Cg(t, 'ng-trigger-' + e), (a[e] = fg)),
            () => {
              this._engine.afterFlush(() => {
                const t = r.indexOf(o)
                t >= 0 && r.splice(t, 1), this._triggers[e] || delete a[e]
              })
            }
          )
        }
        register(t, e) {
          return !this._triggers[t] && ((this._triggers[t] = e), !0)
        }
        _getTrigger(t) {
          const e = this._triggers[t]
          if (!e)
            throw new Error(
              `The provided animation trigger "${t}" has not been registered!`
            )
          return e
        }
        trigger(t, e, n, i = !0) {
          const s = this._getTrigger(e),
            r = new yg(this.id, e, t)
          let o = this._engine.statesByElement.get(t)
          o ||
            (Cg(t, nm),
            Cg(t, 'ng-trigger-' + e),
            this._engine.statesByElement.set(t, (o = {})))
          let a = o[e]
          const l = new dg(n, this.id)
          if (
            (!(n && n.hasOwnProperty('value')) &&
              a &&
              l.absorbOptions(a.options),
            (o[e] = l),
            a || (a = fg),
            l.value !== pg && a.value === l.value)
          ) {
            if (
              !(function (t, e) {
                const n = Object.keys(t),
                  i = Object.keys(e)
                if (n.length != i.length) return !1
                for (let s = 0; s < n.length; s++) {
                  const i = n[s]
                  if (!e.hasOwnProperty(i) || t[i] !== e[i]) return !1
                }
                return !0
              })(a.params, l.params)
            ) {
              const e = [],
                n = s.matchStyles(a.value, a.params, e),
                i = s.matchStyles(l.value, l.params, e)
              e.length
                ? this._engine.reportError(e)
                : this._engine.afterFlush(() => {
                    fm(t, n), pm(t, i)
                  })
            }
            return
          }
          const c = Bf(this._engine.playersByElement, t, [])
          c.forEach((t) => {
            t.namespaceId == this.id &&
              t.triggerName == e &&
              t.queued &&
              t.destroy()
          })
          let h = s.matchTransition(a.value, l.value, t, l.params),
            u = !1
          if (!h) {
            if (!i) return
            ;(h = s.fallbackTransition), (u = !0)
          }
          return (
            this._engine.totalQueuedPlayers++,
            this._queue.push({
              element: t,
              triggerName: e,
              transition: h,
              fromState: a,
              toState: l,
              player: r,
              isFallbackTransition: u,
            }),
            u ||
              (Cg(t, og),
              r.onStart(() => {
                xg(t, og)
              })),
            r.onDone(() => {
              let e = this.players.indexOf(r)
              e >= 0 && this.players.splice(e, 1)
              const n = this._engine.playersByElement.get(t)
              if (n) {
                let t = n.indexOf(r)
                t >= 0 && n.splice(t, 1)
              }
            }),
            this.players.push(r),
            c.push(r),
            r
          )
        }
        deregister(t) {
          delete this._triggers[t],
            this._engine.statesByElement.forEach((e, n) => {
              delete e[t]
            }),
            this._elementListeners.forEach((e, n) => {
              this._elementListeners.set(
                n,
                e.filter((e) => e.name != t)
              )
            })
        }
        clearElementCache(t) {
          this._engine.statesByElement.delete(t),
            this._elementListeners.delete(t)
          const e = this._engine.playersByElement.get(t)
          e &&
            (e.forEach((t) => t.destroy()),
            this._engine.playersByElement.delete(t))
        }
        _signalRemovalForInnerTriggers(t, e) {
          const n = this._engine.driver.query(t, im, !0)
          n.forEach((t) => {
            if (t.__ng_removed) return
            const n = this._engine.fetchNamespacesByElement(t)
            n.size
              ? n.forEach((n) => n.triggerLeaveAnimation(t, e, !1, !0))
              : this.clearElementCache(t)
          }),
            this._engine.afterFlushAnimationsDone(() =>
              n.forEach((t) => this.clearElementCache(t))
            )
        }
        triggerLeaveAnimation(t, e, n, i) {
          const s = this._engine.statesByElement.get(t)
          if (s) {
            const r = []
            if (
              (Object.keys(s).forEach((e) => {
                if (this._triggers[e]) {
                  const n = this.trigger(t, e, pg, i)
                  n && r.push(n)
                }
              }),
              r.length)
            )
              return (
                this._engine.markElementAsRemoved(this.id, t, !0, e),
                n && Nf(r).onDone(() => this._engine.processLeaveNode(t)),
                !0
              )
          }
          return !1
        }
        prepareLeaveAnimationListeners(t) {
          const e = this._elementListeners.get(t)
          if (e) {
            const n = new Set()
            e.forEach((e) => {
              const i = e.name
              if (n.has(i)) return
              n.add(i)
              const s = this._triggers[i].fallbackTransition,
                r = this._engine.statesByElement.get(t)[i] || fg,
                o = new dg(pg),
                a = new yg(this.id, i, t)
              this._engine.totalQueuedPlayers++,
                this._queue.push({
                  element: t,
                  triggerName: i,
                  transition: s,
                  fromState: r,
                  toState: o,
                  player: a,
                  isFallbackTransition: !0,
                })
            })
          }
        }
        removeNode(t, e) {
          const n = this._engine
          if (
            (t.childElementCount && this._signalRemovalForInnerTriggers(t, e),
            this.triggerLeaveAnimation(t, e, !0))
          )
            return
          let i = !1
          if (n.totalAnimations) {
            const e = n.players.length ? n.playersByQueriedElement.get(t) : []
            if (e && e.length) i = !0
            else {
              let e = t
              for (; (e = e.parentNode); )
                if (n.statesByElement.get(e)) {
                  i = !0
                  break
                }
            }
          }
          if ((this.prepareLeaveAnimationListeners(t), i))
            n.markElementAsRemoved(this.id, t, !1, e)
          else {
            const i = t.__ng_removed
            ;(i && i !== hg) ||
              (n.afterFlush(() => this.clearElementCache(t)),
              n.destroyInnerAnimations(t),
              n._onRemovalComplete(t, e))
          }
        }
        insertNode(t, e) {
          Cg(t, this._hostClassName)
        }
        drainQueuedTransitions(t) {
          const e = []
          return (
            this._queue.forEach((n) => {
              const i = n.player
              if (i.destroyed) return
              const s = n.element,
                r = this._elementListeners.get(s)
              r &&
                r.forEach((e) => {
                  if (e.name == n.triggerName) {
                    const i = jf(
                      s,
                      n.triggerName,
                      n.fromState.value,
                      n.toState.value
                    )
                    ;(i._data = t), Mf(n.player, e.phase, i, e.callback)
                  }
                }),
                i.markedForDestroy
                  ? this._engine.afterFlush(() => {
                      i.destroy()
                    })
                  : e.push(n)
            }),
            (this._queue = []),
            e.sort((t, e) => {
              const n = t.transition.ast.depCount,
                i = e.transition.ast.depCount
              return 0 == n || 0 == i
                ? n - i
                : this._engine.driver.containsElement(t.element, e.element)
                ? 1
                : -1
            })
          )
        }
        destroy(t) {
          this.players.forEach((t) => t.destroy()),
            this._signalRemovalForInnerTriggers(this.hostElement, t)
        }
        elementContainsData(t) {
          let e = !1
          return (
            this._elementListeners.has(t) && (e = !0),
            (e = !!this._queue.find((e) => e.element === t) || e),
            e
          )
        }
      }
      class gg {
        constructor(t, e, n) {
          ;(this.bodyNode = t),
            (this.driver = e),
            (this._normalizer = n),
            (this.players = []),
            (this.newHostElements = new Map()),
            (this.playersByElement = new Map()),
            (this.playersByQueriedElement = new Map()),
            (this.statesByElement = new Map()),
            (this.disabledNodes = new Set()),
            (this.totalAnimations = 0),
            (this.totalQueuedPlayers = 0),
            (this._namespaceLookup = {}),
            (this._namespaceList = []),
            (this._flushFns = []),
            (this._whenQuietFns = []),
            (this.namespacesByHostElement = new Map()),
            (this.collectedEnterElements = []),
            (this.collectedLeaveElements = []),
            (this.onRemovalComplete = (t, e) => {})
        }
        _onRemovalComplete(t, e) {
          this.onRemovalComplete(t, e)
        }
        get queuedPlayers() {
          const t = []
          return (
            this._namespaceList.forEach((e) => {
              e.players.forEach((e) => {
                e.queued && t.push(e)
              })
            }),
            t
          )
        }
        createNamespace(t, e) {
          const n = new mg(t, e, this)
          return (
            e.parentNode
              ? this._balanceNamespaceList(n, e)
              : (this.newHostElements.set(e, n), this.collectEnterElement(e)),
            (this._namespaceLookup[t] = n)
          )
        }
        _balanceNamespaceList(t, e) {
          const n = this._namespaceList.length - 1
          if (n >= 0) {
            let i = !1
            for (let s = n; s >= 0; s--)
              if (
                this.driver.containsElement(
                  this._namespaceList[s].hostElement,
                  e
                )
              ) {
                this._namespaceList.splice(s + 1, 0, t), (i = !0)
                break
              }
            i || this._namespaceList.splice(0, 0, t)
          } else this._namespaceList.push(t)
          return this.namespacesByHostElement.set(e, t), t
        }
        register(t, e) {
          let n = this._namespaceLookup[t]
          return n || (n = this.createNamespace(t, e)), n
        }
        registerTrigger(t, e, n) {
          let i = this._namespaceLookup[t]
          i && i.register(e, n) && this.totalAnimations++
        }
        destroy(t, e) {
          if (!t) return
          const n = this._fetchNamespace(t)
          this.afterFlush(() => {
            this.namespacesByHostElement.delete(n.hostElement),
              delete this._namespaceLookup[t]
            const e = this._namespaceList.indexOf(n)
            e >= 0 && this._namespaceList.splice(e, 1)
          }),
            this.afterFlushAnimationsDone(() => n.destroy(e))
        }
        _fetchNamespace(t) {
          return this._namespaceLookup[t]
        }
        fetchNamespacesByElement(t) {
          const e = new Set(),
            n = this.statesByElement.get(t)
          if (n) {
            const t = Object.keys(n)
            for (let i = 0; i < t.length; i++) {
              const s = n[t[i]].namespaceId
              if (s) {
                const t = this._fetchNamespace(s)
                t && e.add(t)
              }
            }
          }
          return e
        }
        trigger(t, e, n, i) {
          if (_g(e)) {
            const s = this._fetchNamespace(t)
            if (s) return s.trigger(e, n, i), !0
          }
          return !1
        }
        insertNode(t, e, n, i) {
          if (!_g(e)) return
          const s = e.__ng_removed
          if (s && s.setForRemoval) {
            ;(s.setForRemoval = !1), (s.setForMove = !0)
            const t = this.collectedLeaveElements.indexOf(e)
            t >= 0 && this.collectedLeaveElements.splice(t, 1)
          }
          if (t) {
            const i = this._fetchNamespace(t)
            i && i.insertNode(e, n)
          }
          i && this.collectEnterElement(e)
        }
        collectEnterElement(t) {
          this.collectedEnterElements.push(t)
        }
        markElementAsDisabled(t, e) {
          e
            ? this.disabledNodes.has(t) ||
              (this.disabledNodes.add(t), Cg(t, ag))
            : this.disabledNodes.has(t) &&
              (this.disabledNodes.delete(t), xg(t, ag))
        }
        removeNode(t, e, n, i) {
          if (_g(e)) {
            const s = t ? this._fetchNamespace(t) : null
            if (
              (s ? s.removeNode(e, i) : this.markElementAsRemoved(t, e, !1, i),
              n)
            ) {
              const n = this.namespacesByHostElement.get(e)
              n && n.id !== t && n.removeNode(e, i)
            }
          } else this._onRemovalComplete(e, i)
        }
        markElementAsRemoved(t, e, n, i) {
          this.collectedLeaveElements.push(e),
            (e.__ng_removed = {
              namespaceId: t,
              setForRemoval: i,
              hasAnimation: n,
              removedBeforeQueried: !1,
            })
        }
        listen(t, e, n, i, s) {
          return _g(e) ? this._fetchNamespace(t).listen(e, n, i, s) : () => {}
        }
        _buildInstruction(t, e, n, i, s) {
          return t.transition.build(
            this.driver,
            t.element,
            t.fromState.value,
            t.toState.value,
            n,
            i,
            t.fromState.options,
            t.toState.options,
            e,
            s
          )
        }
        destroyInnerAnimations(t) {
          let e = this.driver.query(t, im, !0)
          e.forEach((t) => this.destroyActiveAnimationsForElement(t)),
            0 != this.playersByQueriedElement.size &&
              ((e = this.driver.query(t, rm, !0)),
              e.forEach((t) => this.finishActiveQueriedAnimationOnElement(t)))
        }
        destroyActiveAnimationsForElement(t) {
          const e = this.playersByElement.get(t)
          e &&
            e.forEach((t) => {
              t.queued ? (t.markedForDestroy = !0) : t.destroy()
            })
        }
        finishActiveQueriedAnimationOnElement(t) {
          const e = this.playersByQueriedElement.get(t)
          e && e.forEach((t) => t.finish())
        }
        whenRenderingDone() {
          return new Promise((t) => {
            if (this.players.length) return Nf(this.players).onDone(() => t())
            t()
          })
        }
        processLeaveNode(t) {
          const e = t.__ng_removed
          if (e && e.setForRemoval) {
            if (((t.__ng_removed = hg), e.namespaceId)) {
              this.destroyInnerAnimations(t)
              const n = this._fetchNamespace(e.namespaceId)
              n && n.clearElementCache(t)
            }
            this._onRemovalComplete(t, e.setForRemoval)
          }
          this.driver.matchesElement(t, lg) &&
            this.markElementAsDisabled(t, !1),
            this.driver.query(t, lg, !0).forEach((t) => {
              this.markElementAsDisabled(t, !1)
            })
        }
        flush(t = -1) {
          let e = []
          if (
            (this.newHostElements.size &&
              (this.newHostElements.forEach((t, e) =>
                this._balanceNamespaceList(t, e)
              ),
              this.newHostElements.clear()),
            this.totalAnimations && this.collectedEnterElements.length)
          )
            for (let n = 0; n < this.collectedEnterElements.length; n++)
              Cg(this.collectedEnterElements[n], 'ng-star-inserted')
          if (
            this._namespaceList.length &&
            (this.totalQueuedPlayers || this.collectedLeaveElements.length)
          ) {
            const n = []
            try {
              e = this._flushAnimations(n, t)
            } finally {
              for (let t = 0; t < n.length; t++) n[t]()
            }
          } else
            for (let n = 0; n < this.collectedLeaveElements.length; n++)
              this.processLeaveNode(this.collectedLeaveElements[n])
          if (
            ((this.totalQueuedPlayers = 0),
            (this.collectedEnterElements.length = 0),
            (this.collectedLeaveElements.length = 0),
            this._flushFns.forEach((t) => t()),
            (this._flushFns = []),
            this._whenQuietFns.length)
          ) {
            const t = this._whenQuietFns
            ;(this._whenQuietFns = []),
              e.length
                ? Nf(e).onDone(() => {
                    t.forEach((t) => t())
                  })
                : t.forEach((t) => t())
          }
        }
        reportError(t) {
          throw new Error(
            'Unable to process animations due to the following failed trigger transitions\n ' +
              t.join('\n')
          )
        }
        _flushAnimations(t, e) {
          const n = new Bm(),
            i = [],
            s = new Map(),
            r = [],
            o = new Map(),
            a = new Map(),
            l = new Map(),
            c = new Set()
          this.disabledNodes.forEach((t) => {
            c.add(t)
            const e = this.driver.query(t, '.ng-animate-queued', !0)
            for (let n = 0; n < e.length; n++) c.add(e[n])
          })
          const h = this.bodyNode,
            u = Array.from(this.statesByElement.keys()),
            d = wg(u, this.collectedEnterElements),
            p = new Map()
          let f = 0
          d.forEach((t, e) => {
            const n = tm + f++
            p.set(e, n), t.forEach((t) => Cg(t, n))
          })
          const m = [],
            g = new Set(),
            y = new Set()
          for (let I = 0; I < this.collectedLeaveElements.length; I++) {
            const t = this.collectedLeaveElements[I],
              e = t.__ng_removed
            e &&
              e.setForRemoval &&
              (m.push(t),
              g.add(t),
              e.hasAnimation
                ? this.driver
                    .query(t, '.ng-star-inserted', !0)
                    .forEach((t) => g.add(t))
                : y.add(t))
          }
          const _ = new Map(),
            v = wg(u, Array.from(g))
          v.forEach((t, e) => {
            const n = em + f++
            _.set(e, n), t.forEach((t) => Cg(t, n))
          }),
            t.push(() => {
              d.forEach((t, e) => {
                const n = p.get(e)
                t.forEach((t) => xg(t, n))
              }),
                v.forEach((t, e) => {
                  const n = _.get(e)
                  t.forEach((t) => xg(t, n))
                }),
                m.forEach((t) => {
                  this.processLeaveNode(t)
                })
            })
          const b = [],
            w = []
          for (let I = this._namespaceList.length - 1; I >= 0; I--)
            this._namespaceList[I].drainQueuedTransitions(e).forEach((t) => {
              const e = t.player,
                s = t.element
              if ((b.push(e), this.collectedEnterElements.length)) {
                const t = s.__ng_removed
                if (t && t.setForMove) return void e.destroy()
              }
              const c = !h || !this.driver.containsElement(h, s),
                u = _.get(s),
                d = p.get(s),
                f = this._buildInstruction(t, n, d, u, c)
              if (f.errors && f.errors.length) w.push(f)
              else {
                if (c)
                  return (
                    e.onStart(() => fm(s, f.fromStyles)),
                    e.onDestroy(() => pm(s, f.toStyles)),
                    void i.push(e)
                  )
                if (t.isFallbackTransition)
                  return (
                    e.onStart(() => fm(s, f.fromStyles)),
                    e.onDestroy(() => pm(s, f.toStyles)),
                    void i.push(e)
                  )
                f.timelines.forEach((t) => (t.stretchStartingKeyframe = !0)),
                  n.append(s, f.timelines),
                  r.push({ instruction: f, player: e, element: s }),
                  f.queriedElements.forEach((t) => Bf(o, t, []).push(e)),
                  f.preStyleProps.forEach((t, e) => {
                    const n = Object.keys(t)
                    if (n.length) {
                      let t = a.get(e)
                      t || a.set(e, (t = new Set())), n.forEach((e) => t.add(e))
                    }
                  }),
                  f.postStyleProps.forEach((t, e) => {
                    const n = Object.keys(t)
                    let i = l.get(e)
                    i || l.set(e, (i = new Set())), n.forEach((t) => i.add(t))
                  })
              }
            })
          if (w.length) {
            const t = []
            w.forEach((e) => {
              t.push(`@${e.triggerName} has failed due to:\n`),
                e.errors.forEach((e) => t.push(`- ${e}\n`))
            }),
              b.forEach((t) => t.destroy()),
              this.reportError(t)
          }
          const C = new Map(),
            x = new Map()
          r.forEach((t) => {
            const e = t.element
            n.has(e) &&
              (x.set(e, e),
              this._beforeAnimationBuild(
                t.player.namespaceId,
                t.instruction,
                C
              ))
          }),
            i.forEach((t) => {
              const e = t.element
              this._getPreviousPlayers(
                e,
                !1,
                t.namespaceId,
                t.triggerName,
                null
              ).forEach((t) => {
                Bf(C, e, []).push(t), t.destroy()
              })
            })
          const S = m.filter((t) => kg(t, a, l)),
            E = new Map()
          bg(E, this.driver, y, l, Xd).forEach((t) => {
            kg(t, a, l) && S.push(t)
          })
          const k = new Map()
          d.forEach((t, e) => {
            bg(k, this.driver, new Set(t), a, '!')
          }),
            S.forEach((t) => {
              const e = E.get(t),
                n = k.get(t)
              E.set(t, Object.assign(Object.assign({}, e), n))
            })
          const T = [],
            A = [],
            O = {}
          r.forEach((t) => {
            const { element: e, player: r, instruction: o } = t
            if (n.has(e)) {
              if (c.has(e))
                return (
                  r.onDestroy(() => pm(e, o.toStyles)),
                  (r.disabled = !0),
                  r.overrideTotalTime(o.totalTime),
                  void i.push(r)
                )
              let t = O
              if (x.size > 1) {
                let n = e
                const i = []
                for (; (n = n.parentNode); ) {
                  const e = x.get(n)
                  if (e) {
                    t = e
                    break
                  }
                  i.push(n)
                }
                i.forEach((e) => x.set(e, t))
              }
              const n = this._buildAnimation(r.namespaceId, o, C, s, k, E)
              if ((r.setRealPlayer(n), t === O)) T.push(r)
              else {
                const e = this.playersByElement.get(t)
                e && e.length && (r.parentPlayer = Nf(e)), i.push(r)
              }
            } else
              fm(e, o.fromStyles),
                r.onDestroy(() => pm(e, o.toStyles)),
                A.push(r),
                c.has(e) && i.push(r)
          }),
            A.forEach((t) => {
              const e = s.get(t.element)
              if (e && e.length) {
                const n = Nf(e)
                t.setRealPlayer(n)
              }
            }),
            i.forEach((t) => {
              t.parentPlayer ? t.syncPlayerEvents(t.parentPlayer) : t.destroy()
            })
          for (let I = 0; I < m.length; I++) {
            const t = m[I],
              e = t.__ng_removed
            if ((xg(t, em), e && e.hasAnimation)) continue
            let n = []
            if (o.size) {
              let e = o.get(t)
              e && e.length && n.push(...e)
              let i = this.driver.query(t, rm, !0)
              for (let t = 0; t < i.length; t++) {
                let e = o.get(i[t])
                e && e.length && n.push(...e)
              }
            }
            const i = n.filter((t) => !t.destroyed)
            i.length ? Sg(this, t, i) : this.processLeaveNode(t)
          }
          return (
            (m.length = 0),
            T.forEach((t) => {
              this.players.push(t),
                t.onDone(() => {
                  t.destroy()
                  const e = this.players.indexOf(t)
                  this.players.splice(e, 1)
                }),
                t.play()
            }),
            T
          )
        }
        elementContainsData(t, e) {
          let n = !1
          const i = e.__ng_removed
          return (
            i && i.setForRemoval && (n = !0),
            this.playersByElement.has(e) && (n = !0),
            this.playersByQueriedElement.has(e) && (n = !0),
            this.statesByElement.has(e) && (n = !0),
            this._fetchNamespace(t).elementContainsData(e) || n
          )
        }
        afterFlush(t) {
          this._flushFns.push(t)
        }
        afterFlushAnimationsDone(t) {
          this._whenQuietFns.push(t)
        }
        _getPreviousPlayers(t, e, n, i, s) {
          let r = []
          if (e) {
            const e = this.playersByQueriedElement.get(t)
            e && (r = e)
          } else {
            const e = this.playersByElement.get(t)
            if (e) {
              const t = !s || s == pg
              e.forEach((e) => {
                e.queued || ((t || e.triggerName == i) && r.push(e))
              })
            }
          }
          return (
            (n || i) &&
              (r = r.filter(
                (t) => !((n && n != t.namespaceId) || (i && i != t.triggerName))
              )),
            r
          )
        }
        _beforeAnimationBuild(t, e, n) {
          const i = e.element,
            s = e.isRemovalTransition ? void 0 : t,
            r = e.isRemovalTransition ? void 0 : e.triggerName
          for (const o of e.timelines) {
            const t = o.element,
              a = t !== i,
              l = Bf(n, t, [])
            this._getPreviousPlayers(t, a, s, r, e.toState).forEach((t) => {
              const e = t.getRealPlayer()
              e.beforeDestroy && e.beforeDestroy(), t.destroy(), l.push(t)
            })
          }
          fm(i, e.fromStyles)
        }
        _buildAnimation(t, e, n, i, s, r) {
          const o = e.triggerName,
            a = e.element,
            l = [],
            c = new Set(),
            h = new Set(),
            u = e.timelines.map((e) => {
              const u = e.element
              c.add(u)
              const d = u.__ng_removed
              if (d && d.removedBeforeQueried)
                return new lp(e.duration, e.delay)
              const p = u !== a,
                f = (function (t) {
                  const e = []
                  return Eg(t, e), e
                })((n.get(u) || cg).map((t) => t.getRealPlayer())).filter(
                  (t) => !!t.element && t.element === u
                ),
                m = s.get(u),
                g = r.get(u),
                y = Ff(0, this._normalizer, 0, e.keyframes, m, g),
                _ = this._buildPlayer(e, y, f)
              if ((e.subTimeline && i && h.add(u), p)) {
                const e = new yg(t, o, u)
                e.setRealPlayer(_), l.push(e)
              }
              return _
            })
          l.forEach((t) => {
            Bf(this.playersByQueriedElement, t.element, []).push(t),
              t.onDone(() =>
                (function (t, e, n) {
                  let i
                  if (t instanceof Map) {
                    if (((i = t.get(e)), i)) {
                      if (i.length) {
                        const t = i.indexOf(n)
                        i.splice(t, 1)
                      }
                      0 == i.length && t.delete(e)
                    }
                  } else if (((i = t[e]), i)) {
                    if (i.length) {
                      const t = i.indexOf(n)
                      i.splice(t, 1)
                    }
                    0 == i.length && delete t[e]
                  }
                  return i
                })(this.playersByQueriedElement, t.element, t)
              )
          }),
            c.forEach((t) => Cg(t, sm))
          const d = Nf(u)
          return (
            d.onDestroy(() => {
              c.forEach((t) => xg(t, sm)), pm(a, e.toStyles)
            }),
            h.forEach((t) => {
              Bf(i, t, []).push(d)
            }),
            d
          )
        }
        _buildPlayer(t, e, n) {
          return e.length > 0
            ? this.driver.animate(
                t.element,
                e,
                t.duration,
                t.delay,
                t.easing,
                n
              )
            : new lp(t.duration, t.delay)
        }
      }
      class yg {
        constructor(t, e, n) {
          ;(this.namespaceId = t),
            (this.triggerName = e),
            (this.element = n),
            (this._player = new lp()),
            (this._containsRealPlayer = !1),
            (this._queuedCallbacks = {}),
            (this.destroyed = !1),
            (this.markedForDestroy = !1),
            (this.disabled = !1),
            (this.queued = !0),
            (this.totalTime = 0)
        }
        setRealPlayer(t) {
          this._containsRealPlayer ||
            ((this._player = t),
            Object.keys(this._queuedCallbacks).forEach((e) => {
              this._queuedCallbacks[e].forEach((n) => Mf(t, e, void 0, n))
            }),
            (this._queuedCallbacks = {}),
            (this._containsRealPlayer = !0),
            this.overrideTotalTime(t.totalTime),
            (this.queued = !1))
        }
        getRealPlayer() {
          return this._player
        }
        overrideTotalTime(t) {
          this.totalTime = t
        }
        syncPlayerEvents(t) {
          const e = this._player
          e.triggerCallback && t.onStart(() => e.triggerCallback('start')),
            t.onDone(() => this.finish()),
            t.onDestroy(() => this.destroy())
        }
        _queueEvent(t, e) {
          Bf(this._queuedCallbacks, t, []).push(e)
        }
        onDone(t) {
          this.queued && this._queueEvent('done', t), this._player.onDone(t)
        }
        onStart(t) {
          this.queued && this._queueEvent('start', t), this._player.onStart(t)
        }
        onDestroy(t) {
          this.queued && this._queueEvent('destroy', t),
            this._player.onDestroy(t)
        }
        init() {
          this._player.init()
        }
        hasStarted() {
          return !this.queued && this._player.hasStarted()
        }
        play() {
          !this.queued && this._player.play()
        }
        pause() {
          !this.queued && this._player.pause()
        }
        restart() {
          !this.queued && this._player.restart()
        }
        finish() {
          this._player.finish()
        }
        destroy() {
          ;(this.destroyed = !0), this._player.destroy()
        }
        reset() {
          !this.queued && this._player.reset()
        }
        setPosition(t) {
          this.queued || this._player.setPosition(t)
        }
        getPosition() {
          return this.queued ? 0 : this._player.getPosition()
        }
        triggerCallback(t) {
          const e = this._player
          e.triggerCallback && e.triggerCallback(t)
        }
      }
      function _g(t) {
        return t && 1 === t.nodeType
      }
      function vg(t, e) {
        const n = t.style.display
        return (t.style.display = null != e ? e : 'none'), n
      }
      function bg(t, e, n, i, s) {
        const r = []
        n.forEach((t) => r.push(vg(t)))
        const o = []
        i.forEach((n, i) => {
          const r = {}
          n.forEach((t) => {
            const n = (r[t] = e.computeStyle(i, t, s))
            ;(n && 0 != n.length) || ((i.__ng_removed = ug), o.push(i))
          }),
            t.set(i, r)
        })
        let a = 0
        return n.forEach((t) => vg(t, r[a++])), o
      }
      function wg(t, e) {
        const n = new Map()
        if ((t.forEach((t) => n.set(t, [])), 0 == e.length)) return n
        const i = new Set(e),
          s = new Map()
        function r(t) {
          if (!t) return 1
          let e = s.get(t)
          if (e) return e
          const o = t.parentNode
          return (e = n.has(o) ? o : i.has(o) ? 1 : r(o)), s.set(t, e), e
        }
        return (
          e.forEach((t) => {
            const e = r(t)
            1 !== e && n.get(e).push(t)
          }),
          n
        )
      }
      function Cg(t, e) {
        if (t.classList) t.classList.add(e)
        else {
          let n = t.$$classes
          n || (n = t.$$classes = {}), (n[e] = !0)
        }
      }
      function xg(t, e) {
        if (t.classList) t.classList.remove(e)
        else {
          let n = t.$$classes
          n && delete n[e]
        }
      }
      function Sg(t, e, n) {
        Nf(n).onDone(() => t.processLeaveNode(e))
      }
      function Eg(t, e) {
        for (let n = 0; n < t.length; n++) {
          const i = t[n]
          i instanceof cp ? Eg(i.players, e) : e.push(i)
        }
      }
      function kg(t, e, n) {
        const i = n.get(t)
        if (!i) return !1
        let s = e.get(t)
        return s ? i.forEach((t) => s.add(t)) : e.set(t, i), n.delete(t), !0
      }
      class Tg {
        constructor(t, e, n) {
          ;(this.bodyNode = t),
            (this._driver = e),
            (this._triggerCache = {}),
            (this.onRemovalComplete = (t, e) => {}),
            (this._transitionEngine = new gg(t, e, n)),
            (this._timelineEngine = new rg(t, e, n)),
            (this._transitionEngine.onRemovalComplete = (t, e) =>
              this.onRemovalComplete(t, e))
        }
        registerTrigger(t, e, n, i, s) {
          const r = t + '-' + i
          let o = this._triggerCache[r]
          if (!o) {
            const t = [],
              e = Pm(this._driver, s, t)
            if (t.length)
              throw new Error(
                `The animation trigger "${i}" has failed to build due to the following errors:\n - ${t.join(
                  '\n - '
                )}`
              )
            ;(o = (function (t, e) {
              return new ng(t, e)
            })(i, e)),
              (this._triggerCache[r] = o)
          }
          this._transitionEngine.registerTrigger(e, i, o)
        }
        register(t, e) {
          this._transitionEngine.register(t, e)
        }
        destroy(t, e) {
          this._transitionEngine.destroy(t, e)
        }
        onInsert(t, e, n, i) {
          this._transitionEngine.insertNode(t, e, n, i)
        }
        onRemove(t, e, n, i) {
          this._transitionEngine.removeNode(t, e, i || !1, n)
        }
        disableAnimations(t, e) {
          this._transitionEngine.markElementAsDisabled(t, e)
        }
        process(t, e, n, i) {
          if ('@' == n.charAt(0)) {
            const [t, s] = Vf(n)
            this._timelineEngine.command(t, e, s, i)
          } else this._transitionEngine.trigger(t, e, n, i)
        }
        listen(t, e, n, i, s) {
          if ('@' == n.charAt(0)) {
            const [t, i] = Vf(n)
            return this._timelineEngine.listen(t, e, i, s)
          }
          return this._transitionEngine.listen(t, e, n, i, s)
        }
        flush(t = -1) {
          this._transitionEngine.flush(t)
        }
        get players() {
          return this._transitionEngine.players.concat(
            this._timelineEngine.players
          )
        }
        whenRenderingDone() {
          return this._transitionEngine.whenRenderingDone()
        }
      }
      function Ag(t, e) {
        let n = null,
          i = null
        return (
          Array.isArray(e) && e.length
            ? ((n = Ig(e[0])), e.length > 1 && (i = Ig(e[e.length - 1])))
            : e && (n = Ig(e)),
          n || i ? new Og(t, n, i) : null
        )
      }
      let Og = (() => {
        class t {
          constructor(e, n, i) {
            ;(this._element = e),
              (this._startStyles = n),
              (this._endStyles = i),
              (this._state = 0)
            let s = t.initialStylesByElement.get(e)
            s || t.initialStylesByElement.set(e, (s = {})),
              (this._initialStyles = s)
          }
          start() {
            this._state < 1 &&
              (this._startStyles &&
                pm(this._element, this._startStyles, this._initialStyles),
              (this._state = 1))
          }
          finish() {
            this.start(),
              this._state < 2 &&
                (pm(this._element, this._initialStyles),
                this._endStyles &&
                  (pm(this._element, this._endStyles),
                  (this._endStyles = null)),
                (this._state = 1))
          }
          destroy() {
            this.finish(),
              this._state < 3 &&
                (t.initialStylesByElement.delete(this._element),
                this._startStyles &&
                  (fm(this._element, this._startStyles),
                  (this._endStyles = null)),
                this._endStyles &&
                  (fm(this._element, this._endStyles),
                  (this._endStyles = null)),
                pm(this._element, this._initialStyles),
                (this._state = 3))
          }
        }
        return (t.initialStylesByElement = new WeakMap()), t
      })()
      function Ig(t) {
        let e = null
        const n = Object.keys(t)
        for (let i = 0; i < n.length; i++) {
          const s = n[i]
          Rg(s) && ((e = e || {}), (e[s] = t[s]))
        }
        return e
      }
      function Rg(t) {
        return 'display' === t || 'position' === t
      }
      const Pg = 'animation',
        Dg = 'animationend'
      class Ng {
        constructor(t, e, n, i, s, r, o) {
          ;(this._element = t),
            (this._name = e),
            (this._duration = n),
            (this._delay = i),
            (this._easing = s),
            (this._fillMode = r),
            (this._onDoneFn = o),
            (this._finished = !1),
            (this._destroyed = !1),
            (this._startTime = 0),
            (this._position = 0),
            (this._eventFn = (t) => this._handleCallback(t))
        }
        apply() {
          !(function (t, e) {
            const n = Vg(t, '').trim()
            n.length &&
              ((function (t, e) {
                let n = 0
                for (let i = 0; i < t.length; i++) ',' === t.charAt(i) && n++
              })(n),
              (e = `${n}, ${e}`)),
              Bg(t, '', e)
          })(
            this._element,
            `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`
          ),
            jg(this._element, this._eventFn, !1),
            (this._startTime = Date.now())
        }
        pause() {
          Fg(this._element, this._name, 'paused')
        }
        resume() {
          Fg(this._element, this._name, 'running')
        }
        setPosition(t) {
          const e = Mg(this._element, this._name)
          ;(this._position = t * this._duration),
            Bg(this._element, 'Delay', `-${this._position}ms`, e)
        }
        getPosition() {
          return this._position
        }
        _handleCallback(t) {
          const e = t._ngTestManualTimestamp || Date.now(),
            n = 1e3 * parseFloat(t.elapsedTime.toFixed(3))
          t.animationName == this._name &&
            Math.max(e - this._startTime, 0) >= this._delay &&
            n >= this._duration &&
            this.finish()
        }
        finish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFn(),
            jg(this._element, this._eventFn, !0))
        }
        destroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this.finish(),
            (function (t, e) {
              const n = Vg(t, '').split(','),
                i = Lg(n, e)
              i >= 0 && (n.splice(i, 1), Bg(t, '', n.join(',')))
            })(this._element, this._name))
        }
      }
      function Fg(t, e, n) {
        Bg(t, 'PlayState', n, Mg(t, e))
      }
      function Mg(t, e) {
        const n = Vg(t, '')
        return n.indexOf(',') > 0 ? Lg(n.split(','), e) : Lg([n], e)
      }
      function Lg(t, e) {
        for (let n = 0; n < t.length; n++) if (t[n].indexOf(e) >= 0) return n
        return -1
      }
      function jg(t, e, n) {
        n ? t.removeEventListener(Dg, e) : t.addEventListener(Dg, e)
      }
      function Bg(t, e, n, i) {
        const s = Pg + e
        if (null != i) {
          const e = t.style[s]
          if (e.length) {
            const t = e.split(',')
            ;(t[i] = n), (n = t.join(','))
          }
        }
        t.style[s] = n
      }
      function Vg(t, e) {
        return t.style[Pg + e] || ''
      }
      class Ug {
        constructor(t, e, n, i, s, r, o, a) {
          ;(this.element = t),
            (this.keyframes = e),
            (this.animationName = n),
            (this._duration = i),
            (this._delay = s),
            (this._finalStyles = o),
            (this._specialStyles = a),
            (this._onDoneFns = []),
            (this._onStartFns = []),
            (this._onDestroyFns = []),
            (this._started = !1),
            (this.currentSnapshot = {}),
            (this._state = 0),
            (this.easing = r || 'linear'),
            (this.totalTime = i + s),
            this._buildStyler()
        }
        onStart(t) {
          this._onStartFns.push(t)
        }
        onDone(t) {
          this._onDoneFns.push(t)
        }
        onDestroy(t) {
          this._onDestroyFns.push(t)
        }
        destroy() {
          this.init(),
            this._state >= 4 ||
              ((this._state = 4),
              this._styler.destroy(),
              this._flushStartFns(),
              this._flushDoneFns(),
              this._specialStyles && this._specialStyles.destroy(),
              this._onDestroyFns.forEach((t) => t()),
              (this._onDestroyFns = []))
        }
        _flushDoneFns() {
          this._onDoneFns.forEach((t) => t()), (this._onDoneFns = [])
        }
        _flushStartFns() {
          this._onStartFns.forEach((t) => t()), (this._onStartFns = [])
        }
        finish() {
          this.init(),
            this._state >= 3 ||
              ((this._state = 3),
              this._styler.finish(),
              this._flushStartFns(),
              this._specialStyles && this._specialStyles.finish(),
              this._flushDoneFns())
        }
        setPosition(t) {
          this._styler.setPosition(t)
        }
        getPosition() {
          return this._styler.getPosition()
        }
        hasStarted() {
          return this._state >= 2
        }
        init() {
          this._state >= 1 ||
            ((this._state = 1),
            this._styler.apply(),
            this._delay && this._styler.pause())
        }
        play() {
          this.init(),
            this.hasStarted() ||
              (this._flushStartFns(),
              (this._state = 2),
              this._specialStyles && this._specialStyles.start()),
            this._styler.resume()
        }
        pause() {
          this.init(), this._styler.pause()
        }
        restart() {
          this.reset(), this.play()
        }
        reset() {
          this._styler.destroy(), this._buildStyler(), this._styler.apply()
        }
        _buildStyler() {
          this._styler = new Ng(
            this.element,
            this.animationName,
            this._duration,
            this._delay,
            this.easing,
            'forwards',
            () => this.finish()
          )
        }
        triggerCallback(t) {
          const e = 'start' == t ? this._onStartFns : this._onDoneFns
          e.forEach((t) => t()), (e.length = 0)
        }
        beforeDestroy() {
          this.init()
          const t = {}
          if (this.hasStarted()) {
            const e = this._state >= 3
            Object.keys(this._finalStyles).forEach((n) => {
              'offset' != n &&
                (t[n] = e ? this._finalStyles[n] : Em(this.element, n))
            })
          }
          this.currentSnapshot = t
        }
      }
      class zg extends lp {
        constructor(t, e) {
          super(),
            (this.element = t),
            (this._startingStyles = {}),
            (this.__initialized = !1),
            (this._styles = Yf(e))
        }
        init() {
          !this.__initialized &&
            this._startingStyles &&
            ((this.__initialized = !0),
            Object.keys(this._styles).forEach((t) => {
              this._startingStyles[t] = this.element.style[t]
            }),
            super.init())
        }
        play() {
          this._startingStyles &&
            (this.init(),
            Object.keys(this._styles).forEach((t) =>
              this.element.style.setProperty(t, this._styles[t])
            ),
            super.play())
        }
        destroy() {
          this._startingStyles &&
            (Object.keys(this._startingStyles).forEach((t) => {
              const e = this._startingStyles[t]
              e
                ? this.element.style.setProperty(t, e)
                : this.element.style.removeProperty(t)
            }),
            (this._startingStyles = null),
            super.destroy())
        }
      }
      class Hg {
        constructor() {
          ;(this._count = 0), (this._head = document.querySelector('head'))
        }
        validateStyleProperty(t) {
          return Kf(t)
        }
        matchesElement(t, e) {
          return Gf(t, e)
        }
        containsElement(t, e) {
          return Qf(t, e)
        }
        query(t, e, n) {
          return Zf(t, e, n)
        }
        computeStyle(t, e, n) {
          return window.getComputedStyle(t)[e]
        }
        buildKeyframeElement(t, e, n) {
          n = n.map((t) => Yf(t))
          let i = `@keyframes ${e} {\n`,
            s = ''
          n.forEach((t) => {
            s = ' '
            const e = parseFloat(t.offset)
            ;(i += `${s}${100 * e}% {\n`),
              (s += ' '),
              Object.keys(t).forEach((e) => {
                const n = t[e]
                switch (e) {
                  case 'offset':
                    return
                  case 'easing':
                    return void (
                      n && (i += `${s}animation-timing-function: ${n};\n`)
                    )
                  default:
                    return void (i += `${s}${e}: ${n};\n`)
                }
              }),
              (i += s + '}\n')
          }),
            (i += '}\n')
          const r = document.createElement('style')
          return (r.textContent = i), r
        }
        animate(t, e, n, i, s, r = [], o) {
          const a = r.filter((t) => t instanceof Ug),
            l = {}
          Cm(n, i) &&
            a.forEach((t) => {
              let e = t.currentSnapshot
              Object.keys(e).forEach((t) => (l[t] = e[t]))
            })
          const c = (function (t) {
            let e = {}
            return (
              t &&
                (Array.isArray(t) ? t : [t]).forEach((t) => {
                  Object.keys(t).forEach((n) => {
                    'offset' != n && 'easing' != n && (e[n] = t[n])
                  })
                }),
              e
            )
          })((e = xm(t, e, l)))
          if (0 == n) return new zg(t, c)
          const h = 'gen_css_kf_' + this._count++,
            u = this.buildKeyframeElement(t, h, e)
          document.querySelector('head').appendChild(u)
          const d = Ag(t, e),
            p = new Ug(t, e, h, n, i, s, c, d)
          return (
            p.onDestroy(() => {
              var t
              ;(t = u).parentNode.removeChild(t)
            }),
            p
          )
        }
      }
      class qg {
        constructor(t, e, n, i) {
          ;(this.element = t),
            (this.keyframes = e),
            (this.options = n),
            (this._specialStyles = i),
            (this._onDoneFns = []),
            (this._onStartFns = []),
            (this._onDestroyFns = []),
            (this._initialized = !1),
            (this._finished = !1),
            (this._started = !1),
            (this._destroyed = !1),
            (this.time = 0),
            (this.parentPlayer = null),
            (this.currentSnapshot = {}),
            (this._duration = n.duration),
            (this._delay = n.delay || 0),
            (this.time = this._duration + this._delay)
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((t) => t()),
            (this._onDoneFns = []))
        }
        init() {
          this._buildPlayer(), this._preparePlayerBeforeStart()
        }
        _buildPlayer() {
          if (this._initialized) return
          this._initialized = !0
          const t = this.keyframes
          ;(this.domPlayer = this._triggerWebAnimation(
            this.element,
            t,
            this.options
          )),
            (this._finalKeyframe = t.length ? t[t.length - 1] : {}),
            this.domPlayer.addEventListener('finish', () => this._onFinish())
        }
        _preparePlayerBeforeStart() {
          this._delay ? this._resetDomPlayerState() : this.domPlayer.pause()
        }
        _triggerWebAnimation(t, e, n) {
          return t.animate(e, n)
        }
        onStart(t) {
          this._onStartFns.push(t)
        }
        onDone(t) {
          this._onDoneFns.push(t)
        }
        onDestroy(t) {
          this._onDestroyFns.push(t)
        }
        play() {
          this._buildPlayer(),
            this.hasStarted() ||
              (this._onStartFns.forEach((t) => t()),
              (this._onStartFns = []),
              (this._started = !0),
              this._specialStyles && this._specialStyles.start()),
            this.domPlayer.play()
        }
        pause() {
          this.init(), this.domPlayer.pause()
        }
        finish() {
          this.init(),
            this._specialStyles && this._specialStyles.finish(),
            this._onFinish(),
            this.domPlayer.finish()
        }
        reset() {
          this._resetDomPlayerState(),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._started = !1)
        }
        _resetDomPlayerState() {
          this.domPlayer && this.domPlayer.cancel()
        }
        restart() {
          this.reset(), this.play()
        }
        hasStarted() {
          return this._started
        }
        destroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this._resetDomPlayerState(),
            this._onFinish(),
            this._specialStyles && this._specialStyles.destroy(),
            this._onDestroyFns.forEach((t) => t()),
            (this._onDestroyFns = []))
        }
        setPosition(t) {
          this.domPlayer.currentTime = t * this.time
        }
        getPosition() {
          return this.domPlayer.currentTime / this.time
        }
        get totalTime() {
          return this._delay + this._duration
        }
        beforeDestroy() {
          const t = {}
          this.hasStarted() &&
            Object.keys(this._finalKeyframe).forEach((e) => {
              'offset' != e &&
                (t[e] = this._finished
                  ? this._finalKeyframe[e]
                  : Em(this.element, e))
            }),
            (this.currentSnapshot = t)
        }
        triggerCallback(t) {
          const e = 'start' == t ? this._onStartFns : this._onDoneFns
          e.forEach((t) => t()), (e.length = 0)
        }
      }
      class $g {
        constructor() {
          ;(this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(
            Wg().toString()
          )),
            (this._cssKeyframesDriver = new Hg())
        }
        validateStyleProperty(t) {
          return Kf(t)
        }
        matchesElement(t, e) {
          return Gf(t, e)
        }
        containsElement(t, e) {
          return Qf(t, e)
        }
        query(t, e, n) {
          return Zf(t, e, n)
        }
        computeStyle(t, e, n) {
          return window.getComputedStyle(t)[e]
        }
        overrideWebAnimationsSupport(t) {
          this._isNativeImpl = t
        }
        animate(t, e, n, i, s, r = [], o) {
          if (!o && !this._isNativeImpl)
            return this._cssKeyframesDriver.animate(t, e, n, i, s, r)
          const a = {
            duration: n,
            delay: i,
            fill: 0 == i ? 'both' : 'forwards',
          }
          s && (a.easing = s)
          const l = {},
            c = r.filter((t) => t instanceof qg)
          Cm(n, i) &&
            c.forEach((t) => {
              let e = t.currentSnapshot
              Object.keys(e).forEach((t) => (l[t] = e[t]))
            })
          const h = Ag(t, (e = xm(t, (e = e.map((t) => hm(t, !1))), l)))
          return new qg(t, e, a, h)
        }
      }
      function Wg() {
        return (
          ('undefined' != typeof window &&
            void 0 !== window.document &&
            Element.prototype.animate) ||
          {}
        )
      }
      let Kg = (() => {
        class t extends Yd {
          constructor(t, e) {
            super(),
              (this._nextAnimationId = 0),
              (this._renderer = t.createRenderer(e.body, {
                id: '0',
                encapsulation: Et.None,
                styles: [],
                data: { animation: [] },
              }))
          }
          build(t) {
            const e = this._nextAnimationId.toString()
            this._nextAnimationId++
            const n = Array.isArray(t) ? ep(t) : t
            return (
              Zg(this._renderer, null, e, 'register', [n]),
              new Gg(e, this._renderer)
            )
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(Ua), vi(mh))
          }),
          (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      class Gg extends class {} {
        constructor(t, e) {
          super(), (this._id = t), (this._renderer = e)
        }
        create(t, e) {
          return new Qg(this._id, t, e || {}, this._renderer)
        }
      }
      class Qg {
        constructor(t, e, n, i) {
          ;(this.id = t),
            (this.element = e),
            (this._renderer = i),
            (this.parentPlayer = null),
            (this._started = !1),
            (this.totalTime = 0),
            this._command('create', n)
        }
        _listen(t, e) {
          return this._renderer.listen(this.element, `@@${this.id}:${t}`, e)
        }
        _command(t, ...e) {
          return Zg(this._renderer, this.element, this.id, t, e)
        }
        onDone(t) {
          this._listen('done', t)
        }
        onStart(t) {
          this._listen('start', t)
        }
        onDestroy(t) {
          this._listen('destroy', t)
        }
        init() {
          this._command('init')
        }
        hasStarted() {
          return this._started
        }
        play() {
          this._command('play'), (this._started = !0)
        }
        pause() {
          this._command('pause')
        }
        restart() {
          this._command('restart')
        }
        finish() {
          this._command('finish')
        }
        destroy() {
          this._command('destroy')
        }
        reset() {
          this._command('reset')
        }
        setPosition(t) {
          this._command('setPosition', t)
        }
        getPosition() {
          var t, e
          return null !==
            (e =
              null === (t = this._renderer.engine.players[+this.id]) ||
              void 0 === t
                ? void 0
                : t.getPosition()) && void 0 !== e
            ? e
            : 0
        }
      }
      function Zg(t, e, n, i, s) {
        return t.setProperty(e, `@@${n}:${i}`, s)
      }
      const Yg = '@',
        Xg = '@.disabled'
      let Jg = (() => {
        class t {
          constructor(t, e, n) {
            ;(this.delegate = t),
              (this.engine = e),
              (this._zone = n),
              (this._currentId = 0),
              (this._microtaskId = 1),
              (this._animationCallbacksBuffer = []),
              (this._rendererCache = new Map()),
              (this._cdRecurDepth = 0),
              (this.promise = Promise.resolve(0)),
              (e.onRemovalComplete = (t, e) => {
                e && e.parentNode(t) && e.removeChild(t.parentNode, t)
              })
          }
          createRenderer(t, e) {
            const n = this.delegate.createRenderer(t, e)
            if (!(t && e && e.data && e.data.animation)) {
              let t = this._rendererCache.get(n)
              return (
                t ||
                  ((t = new ty('', n, this.engine)),
                  this._rendererCache.set(n, t)),
                t
              )
            }
            const i = e.id,
              s = e.id + '-' + this._currentId
            this._currentId++, this.engine.register(s, t)
            const r = (e) => {
              Array.isArray(e)
                ? e.forEach(r)
                : this.engine.registerTrigger(i, s, t, e.name, e)
            }
            return e.data.animation.forEach(r), new ey(this, s, n, this.engine)
          }
          begin() {
            this._cdRecurDepth++, this.delegate.begin && this.delegate.begin()
          }
          _scheduleCountTask() {
            this.promise.then(() => {
              this._microtaskId++
            })
          }
          scheduleListenerCallback(t, e, n) {
            t >= 0 && t < this._microtaskId
              ? this._zone.run(() => e(n))
              : (0 == this._animationCallbacksBuffer.length &&
                  Promise.resolve(null).then(() => {
                    this._zone.run(() => {
                      this._animationCallbacksBuffer.forEach((t) => {
                        const [e, n] = t
                        e(n)
                      }),
                        (this._animationCallbacksBuffer = [])
                    })
                  }),
                this._animationCallbacksBuffer.push([e, n]))
          }
          end() {
            this._cdRecurDepth--,
              0 == this._cdRecurDepth &&
                this._zone.runOutsideAngular(() => {
                  this._scheduleCountTask(),
                    this.engine.flush(this._microtaskId)
                }),
              this.delegate.end && this.delegate.end()
          }
          whenRenderingDone() {
            return this.engine.whenRenderingDone()
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(Ua), vi(Tg), vi(Oc))
          }),
          (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      class ty {
        constructor(t, e, n) {
          ;(this.namespaceId = t),
            (this.delegate = e),
            (this.engine = n),
            (this.destroyNode = this.delegate.destroyNode
              ? (t) => e.destroyNode(t)
              : null)
        }
        get data() {
          return this.delegate.data
        }
        destroy() {
          this.engine.destroy(this.namespaceId, this.delegate),
            this.delegate.destroy()
        }
        createElement(t, e) {
          return this.delegate.createElement(t, e)
        }
        createComment(t) {
          return this.delegate.createComment(t)
        }
        createText(t) {
          return this.delegate.createText(t)
        }
        appendChild(t, e) {
          this.delegate.appendChild(t, e),
            this.engine.onInsert(this.namespaceId, e, t, !1)
        }
        insertBefore(t, e, n, i = !0) {
          this.delegate.insertBefore(t, e, n),
            this.engine.onInsert(this.namespaceId, e, t, i)
        }
        removeChild(t, e, n) {
          this.engine.onRemove(this.namespaceId, e, this.delegate, n)
        }
        selectRootElement(t, e) {
          return this.delegate.selectRootElement(t, e)
        }
        parentNode(t) {
          return this.delegate.parentNode(t)
        }
        nextSibling(t) {
          return this.delegate.nextSibling(t)
        }
        setAttribute(t, e, n, i) {
          this.delegate.setAttribute(t, e, n, i)
        }
        removeAttribute(t, e, n) {
          this.delegate.removeAttribute(t, e, n)
        }
        addClass(t, e) {
          this.delegate.addClass(t, e)
        }
        removeClass(t, e) {
          this.delegate.removeClass(t, e)
        }
        setStyle(t, e, n, i) {
          this.delegate.setStyle(t, e, n, i)
        }
        removeStyle(t, e, n) {
          this.delegate.removeStyle(t, e, n)
        }
        setProperty(t, e, n) {
          e.charAt(0) == Yg && e == Xg
            ? this.disableAnimations(t, !!n)
            : this.delegate.setProperty(t, e, n)
        }
        setValue(t, e) {
          this.delegate.setValue(t, e)
        }
        listen(t, e, n) {
          return this.delegate.listen(t, e, n)
        }
        disableAnimations(t, e) {
          this.engine.disableAnimations(t, e)
        }
      }
      class ey extends ty {
        constructor(t, e, n, i) {
          super(e, n, i), (this.factory = t), (this.namespaceId = e)
        }
        setProperty(t, e, n) {
          e.charAt(0) == Yg
            ? '.' == e.charAt(1) && e == Xg
              ? this.disableAnimations(t, (n = void 0 === n || !!n))
              : this.engine.process(this.namespaceId, t, e.substr(1), n)
            : this.delegate.setProperty(t, e, n)
        }
        listen(t, e, n) {
          if (e.charAt(0) == Yg) {
            const i = (function (t) {
              switch (t) {
                case 'body':
                  return document.body
                case 'document':
                  return document
                case 'window':
                  return window
                default:
                  return t
              }
            })(t)
            let s = e.substr(1),
              r = ''
            return (
              s.charAt(0) != Yg &&
                ([s, r] = (function (t) {
                  const e = t.indexOf('.')
                  return [t.substring(0, e), t.substr(e + 1)]
                })(s)),
              this.engine.listen(this.namespaceId, i, s, r, (t) => {
                this.factory.scheduleListenerCallback(t._data || -1, n, t)
              })
            )
          }
          return this.delegate.listen(t, e, n)
        }
      }
      let ny = (() => {
        class t extends Tg {
          constructor(t, e, n) {
            super(t.body, e, n)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(mh), vi(Jf), vi(Qm))
          }),
          (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      const iy = new Yn('AnimationModuleType'),
        sy = [
          {
            provide: Jf,
            useFactory: function () {
              return 'function' == typeof Wg() ? new $g() : new Hg()
            },
          },
          { provide: iy, useValue: 'BrowserAnimations' },
          { provide: Yd, useClass: Kg },
          {
            provide: Qm,
            useFactory: function () {
              return new Zm()
            },
          },
          { provide: Tg, useClass: ny },
          {
            provide: Ua,
            useFactory: function (t, e, n) {
              return new Jg(t, e, n)
            },
            deps: [_f, Tg, Oc],
          },
        ]
      let ry = (() => {
        class t {}
        return (
          (t.ɵmod = $t({ type: t })),
          (t.ɵinj = ut({
            factory: function (e) {
              return new (e || t)()
            },
            providers: sy,
            imports: [Pf],
          })),
          t
        )
      })()
      const oy = new $a('11.0.3'),
        ay = new Yn('mat-sanity-checks', {
          providedIn: 'root',
          factory: function () {
            return !0
          },
        })
      let ly,
        cy = (() => {
          class t {
            constructor(t, e, n) {
              ;(this._hasDoneGlobalChecks = !1),
                (this._document = n),
                t._applyBodyHighContrastModeCssClasses(),
                (this._sanityChecks = e),
                this._hasDoneGlobalChecks ||
                  (this._checkDoctypeIsDefined(),
                  this._checkThemeIsPresent(),
                  this._checkCdkVersionMatch(),
                  (this._hasDoneGlobalChecks = !0))
            }
            _getWindow() {
              const t = this._document.defaultView || window
              return 'object' == typeof t && t ? t : null
            }
            _checksAreEnabled() {
              return Hc() && !this._isTestEnv()
            }
            _isTestEnv() {
              const t = this._getWindow()
              return t && (t.__karma__ || t.jasmine)
            }
            _checkDoctypeIsDefined() {
              this._checksAreEnabled() &&
                (!0 === this._sanityChecks || this._sanityChecks.doctype) &&
                !this._document.doctype &&
                console.warn(
                  'Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.'
                )
            }
            _checkThemeIsPresent() {
              if (
                !this._checksAreEnabled() ||
                !1 === this._sanityChecks ||
                !this._sanityChecks.theme ||
                !this._document.body ||
                'function' != typeof getComputedStyle
              )
                return
              const t = this._document.createElement('div')
              t.classList.add('mat-theme-loaded-marker'),
                this._document.body.appendChild(t)
              const e = getComputedStyle(t)
              e &&
                'none' !== e.display &&
                console.warn(
                  'Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming'
                ),
                this._document.body.removeChild(t)
            }
            _checkCdkVersionMatch() {
              this._checksAreEnabled() &&
                (!0 === this._sanityChecks || this._sanityChecks.version) &&
                oy.full !== ef.full &&
                console.warn(
                  'The Angular Material version (' +
                    oy.full +
                    ') does not match the Angular CDK version (' +
                    ef.full +
                    ').\nPlease ensure the versions of these two packages exactly match.'
                )
            }
          }
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)(vi(Jp), vi(ay, 8), vi(mh))
              },
              imports: [[sd], sd],
            })),
            t
          )
        })()
      function hy(t) {
        return class extends t {
          constructor(...t) {
            super(...t), (this._disabled = !1)
          }
          get disabled() {
            return this._disabled
          }
          set disabled(t) {
            this._disabled = hu(t)
          }
        }
      }
      function uy(t, e) {
        return class extends t {
          constructor(...t) {
            super(...t), (this.defaultColor = e), (this.color = e)
          }
          get color() {
            return this._color
          }
          set color(t) {
            const e = t || this.defaultColor
            e !== this._color &&
              (this._color &&
                this._elementRef.nativeElement.classList.remove(
                  'mat-' + this._color
                ),
              e && this._elementRef.nativeElement.classList.add('mat-' + e),
              (this._color = e))
          }
        }
      }
      function dy(t) {
        return class extends t {
          constructor(...t) {
            super(...t), (this._disableRipple = !1)
          }
          get disableRipple() {
            return this._disableRipple
          }
          set disableRipple(t) {
            this._disableRipple = hu(t)
          }
        }
      }
      try {
        ly = 'undefined' != typeof Intl
      } catch (mS) {
        ly = !1
      }
      let py = (() => {
        class t {}
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵdir = Kt({
            type: t,
            selectors: [
              ['', 'mat-line', ''],
              ['', 'matLine', ''],
            ],
            hostAttrs: [1, 'mat-line'],
          })),
          t
        )
      })()
      function fy(t, e, n) {
        const i = t.nativeElement.classList
        n ? i.add(e) : i.remove(e)
      }
      let my = (() => {
        class t {}
        return (
          (t.ɵmod = $t({ type: t })),
          (t.ɵinj = ut({
            factory: function (e) {
              return new (e || t)()
            },
            imports: [[cy], cy],
          })),
          t
        )
      })()
      class gy {
        constructor(t, e, n) {
          ;(this._renderer = t),
            (this.element = e),
            (this.config = n),
            (this.state = 3)
        }
        fadeOut() {
          this._renderer.fadeOutRipple(this)
        }
      }
      const yy = { enterDuration: 450, exitDuration: 400 },
        _y = td({ passive: !0 }),
        vy = ['mousedown', 'touchstart'],
        by = ['mouseup', 'mouseleave', 'touchend', 'touchcancel']
      class wy {
        constructor(t, e, n, i) {
          ;(this._target = t),
            (this._ngZone = e),
            (this._isPointerDown = !1),
            (this._activeRipples = new Set()),
            (this._pointerUpEventsRegistered = !1),
            i.isBrowser && (this._containerElement = fu(n))
        }
        fadeInRipple(t, e, n = {}) {
          const i = (this._containerRect =
              this._containerRect ||
              this._containerElement.getBoundingClientRect()),
            s = Object.assign(Object.assign({}, yy), n.animation)
          n.centered && ((t = i.left + i.width / 2), (e = i.top + i.height / 2))
          const r =
              n.radius ||
              (function (t, e, n) {
                const i = Math.max(Math.abs(t - n.left), Math.abs(t - n.right)),
                  s = Math.max(Math.abs(e - n.top), Math.abs(e - n.bottom))
                return Math.sqrt(i * i + s * s)
              })(t, e, i),
            o = t - i.left,
            a = e - i.top,
            l = s.enterDuration,
            c = document.createElement('div')
          c.classList.add('mat-ripple-element'),
            (c.style.left = o - r + 'px'),
            (c.style.top = a - r + 'px'),
            (c.style.height = 2 * r + 'px'),
            (c.style.width = 2 * r + 'px'),
            null != n.color && (c.style.backgroundColor = n.color),
            (c.style.transitionDuration = l + 'ms'),
            this._containerElement.appendChild(c),
            window.getComputedStyle(c).getPropertyValue('opacity'),
            (c.style.transform = 'scale(1)')
          const h = new gy(this, c, n)
          return (
            (h.state = 0),
            this._activeRipples.add(h),
            n.persistent || (this._mostRecentTransientRipple = h),
            this._runTimeoutOutsideZone(() => {
              const t = h === this._mostRecentTransientRipple
              ;(h.state = 1),
                n.persistent || (t && this._isPointerDown) || h.fadeOut()
            }, l),
            h
          )
        }
        fadeOutRipple(t) {
          const e = this._activeRipples.delete(t)
          if (
            (t === this._mostRecentTransientRipple &&
              (this._mostRecentTransientRipple = null),
            this._activeRipples.size || (this._containerRect = null),
            !e)
          )
            return
          const n = t.element,
            i = Object.assign(Object.assign({}, yy), t.config.animation)
          ;(n.style.transitionDuration = i.exitDuration + 'ms'),
            (n.style.opacity = '0'),
            (t.state = 2),
            this._runTimeoutOutsideZone(() => {
              ;(t.state = 3), n.parentNode.removeChild(n)
            }, i.exitDuration)
        }
        fadeOutAll() {
          this._activeRipples.forEach((t) => t.fadeOut())
        }
        setupTriggerEvents(t) {
          const e = fu(t)
          e &&
            e !== this._triggerElement &&
            (this._removeTriggerEvents(),
            (this._triggerElement = e),
            this._registerEvents(vy))
        }
        handleEvent(t) {
          'mousedown' === t.type
            ? this._onMousedown(t)
            : 'touchstart' === t.type
            ? this._onTouchStart(t)
            : this._onPointerUp(),
            this._pointerUpEventsRegistered ||
              (this._registerEvents(by), (this._pointerUpEventsRegistered = !0))
        }
        _onMousedown(t) {
          const e = $p(t),
            n =
              this._lastTouchStartEvent &&
              Date.now() < this._lastTouchStartEvent + 800
          this._target.rippleDisabled ||
            e ||
            n ||
            ((this._isPointerDown = !0),
            this.fadeInRipple(t.clientX, t.clientY, this._target.rippleConfig))
        }
        _onTouchStart(t) {
          if (!this._target.rippleDisabled) {
            ;(this._lastTouchStartEvent = Date.now()),
              (this._isPointerDown = !0)
            const e = t.changedTouches
            for (let t = 0; t < e.length; t++)
              this.fadeInRipple(
                e[t].clientX,
                e[t].clientY,
                this._target.rippleConfig
              )
          }
        }
        _onPointerUp() {
          this._isPointerDown &&
            ((this._isPointerDown = !1),
            this._activeRipples.forEach((t) => {
              !t.config.persistent &&
                (1 === t.state ||
                  (t.config.terminateOnPointerUp && 0 === t.state)) &&
                t.fadeOut()
            }))
        }
        _runTimeoutOutsideZone(t, e = 0) {
          this._ngZone.runOutsideAngular(() => setTimeout(t, e))
        }
        _registerEvents(t) {
          this._ngZone.runOutsideAngular(() => {
            t.forEach((t) => {
              this._triggerElement.addEventListener(t, this, _y)
            })
          })
        }
        _removeTriggerEvents() {
          this._triggerElement &&
            (vy.forEach((t) => {
              this._triggerElement.removeEventListener(t, this, _y)
            }),
            this._pointerUpEventsRegistered &&
              by.forEach((t) => {
                this._triggerElement.removeEventListener(t, this, _y)
              }))
        }
      }
      const Cy = new Yn('mat-ripple-global-options')
      let xy = (() => {
          class t {
            constructor(t, e, n, i, s) {
              ;(this._elementRef = t),
                (this._animationMode = s),
                (this.radius = 0),
                (this._disabled = !1),
                (this._isInitialized = !1),
                (this._globalOptions = i || {}),
                (this._rippleRenderer = new wy(this, e, t, n))
            }
            get disabled() {
              return this._disabled
            }
            set disabled(t) {
              ;(this._disabled = t), this._setupTriggerEventsIfEnabled()
            }
            get trigger() {
              return this._trigger || this._elementRef.nativeElement
            }
            set trigger(t) {
              ;(this._trigger = t), this._setupTriggerEventsIfEnabled()
            }
            ngOnInit() {
              ;(this._isInitialized = !0), this._setupTriggerEventsIfEnabled()
            }
            ngOnDestroy() {
              this._rippleRenderer._removeTriggerEvents()
            }
            fadeOutAll() {
              this._rippleRenderer.fadeOutAll()
            }
            get rippleConfig() {
              return {
                centered: this.centered,
                radius: this.radius,
                color: this.color,
                animation: Object.assign(
                  Object.assign(
                    Object.assign({}, this._globalOptions.animation),
                    'NoopAnimations' === this._animationMode
                      ? { enterDuration: 0, exitDuration: 0 }
                      : {}
                  ),
                  this.animation
                ),
                terminateOnPointerUp: this._globalOptions.terminateOnPointerUp,
              }
            }
            get rippleDisabled() {
              return this.disabled || !!this._globalOptions.disabled
            }
            _setupTriggerEventsIfEnabled() {
              !this.disabled &&
                this._isInitialized &&
                this._rippleRenderer.setupTriggerEvents(this.trigger)
            }
            launch(t, e = 0, n) {
              return 'number' == typeof t
                ? this._rippleRenderer.fadeInRipple(
                    t,
                    e,
                    Object.assign(Object.assign({}, this.rippleConfig), n)
                  )
                : this._rippleRenderer.fadeInRipple(
                    0,
                    0,
                    Object.assign(Object.assign({}, this.rippleConfig), t)
                  )
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(Ao(Va), Ao(Oc), Ao(Xu), Ao(Cy, 8), Ao(iy, 8))
            }),
            (t.ɵdir = Kt({
              type: t,
              selectors: [
                ['', 'mat-ripple', ''],
                ['', 'matRipple', ''],
              ],
              hostAttrs: [1, 'mat-ripple'],
              hostVars: 2,
              hostBindings: function (t, e) {
                2 & t && na('mat-ripple-unbounded', e.unbounded)
              },
              inputs: {
                radius: ['matRippleRadius', 'radius'],
                disabled: ['matRippleDisabled', 'disabled'],
                trigger: ['matRippleTrigger', 'trigger'],
                color: ['matRippleColor', 'color'],
                unbounded: ['matRippleUnbounded', 'unbounded'],
                centered: ['matRippleCentered', 'centered'],
                animation: ['matRippleAnimation', 'animation'],
              },
              exportAs: ['matRipple'],
            })),
            t
          )
        })(),
        Sy = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[cy, Ju], cy],
            })),
            t
          )
        })(),
        Ey = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[cy]],
            })),
            t
          )
        })(),
        ky = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[Sy, Gh, cy, Ey]],
            })),
            t
          )
        })()
      const Ty = ['*', [['mat-toolbar-row']]],
        Ay = ['*', 'mat-toolbar-row']
      class Oy {
        constructor(t) {
          this._elementRef = t
        }
      }
      const Iy = uy(Oy)
      let Ry = (() => {
          class t {}
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵdir = Kt({
              type: t,
              selectors: [['mat-toolbar-row']],
              hostAttrs: [1, 'mat-toolbar-row'],
              exportAs: ['matToolbarRow'],
            })),
            t
          )
        })(),
        Py = (() => {
          class t extends Iy {
            constructor(t, e, n) {
              super(t), (this._platform = e), (this._document = n)
            }
            ngAfterViewInit() {
              this._platform.isBrowser &&
                (this._checkToolbarMixedModes(),
                this._toolbarRows.changes.subscribe(() =>
                  this._checkToolbarMixedModes()
                ))
            }
            _checkToolbarMixedModes() {}
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(Ao(Va), Ao(Xu), Ao(mh))
            }),
            (t.ɵcmp = Ut({
              type: t,
              selectors: [['mat-toolbar']],
              contentQueries: function (t, e, n) {
                if ((1 & t && nc(n, Ry, !0), 2 & t)) {
                  let t
                  tc((t = ic())) && (e._toolbarRows = t)
                }
              },
              hostAttrs: [1, 'mat-toolbar'],
              hostVars: 4,
              hostBindings: function (t, e) {
                2 & t &&
                  na('mat-toolbar-multiple-rows', e._toolbarRows.length > 0)(
                    'mat-toolbar-single-row',
                    0 === e._toolbarRows.length
                  )
              },
              inputs: { color: 'color' },
              exportAs: ['matToolbar'],
              features: [po],
              ngContentSelectors: Ay,
              decls: 2,
              vars: 0,
              template: function (t, e) {
                1 & t && (Wo(Ty), Ko(0), Ko(1, 1))
              },
              styles: [
                '.cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}\n',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        Dy = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[cy], cy],
            })),
            t
          )
        })()
      const Ny = ['*', [['mat-card-footer']]],
        Fy = ['*', 'mat-card-footer']
      let My = (() => {
          class t {}
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵdir = Kt({
              type: t,
              selectors: [
                ['mat-card-title'],
                ['', 'mat-card-title', ''],
                ['', 'matCardTitle', ''],
              ],
              hostAttrs: [1, 'mat-card-title'],
            })),
            t
          )
        })(),
        Ly = (() => {
          class t {}
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵdir = Kt({
              type: t,
              selectors: [
                ['mat-card-subtitle'],
                ['', 'mat-card-subtitle', ''],
                ['', 'matCardSubtitle', ''],
              ],
              hostAttrs: [1, 'mat-card-subtitle'],
            })),
            t
          )
        })(),
        jy = (() => {
          class t {}
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵdir = Kt({
              type: t,
              selectors: [
                ['', 'mat-card-image', ''],
                ['', 'matCardImage', ''],
              ],
              hostAttrs: [1, 'mat-card-image'],
            })),
            t
          )
        })(),
        By = (() => {
          class t {
            constructor(t) {
              this._animationMode = t
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(Ao(iy, 8))
            }),
            (t.ɵcmp = Ut({
              type: t,
              selectors: [['mat-card']],
              hostAttrs: [1, 'mat-card', 'mat-focus-indicator'],
              hostVars: 2,
              hostBindings: function (t, e) {
                2 & t &&
                  na(
                    '_mat-animation-noopable',
                    'NoopAnimations' === e._animationMode
                  )
              },
              exportAs: ['matCard'],
              ngContentSelectors: Fy,
              decls: 2,
              vars: 0,
              template: function (t, e) {
                1 & t && (Wo(Ny), Ko(0), Ko(1, 1))
              },
              styles: [
                '.mat-card{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:block;position:relative;padding:16px;border-radius:4px}._mat-animation-noopable.mat-card{transition:none;animation:none}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}.cdk-high-contrast-active .mat-card{outline:solid 1px}.mat-card-actions,.mat-card-subtitle,.mat-card-content{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button,.mat-card-actions .mat-stroked-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px}@media(max-width: 599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card>:first-child,.mat-card-content>:first-child{margin-top:0}.mat-card>:last-child:not(.mat-card-footer),.mat-card-content>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions .mat-button:first-child,.mat-card-actions .mat-raised-button:first-child,.mat-card-actions .mat-stroked-button:first-child{margin-left:0;margin-right:0}.mat-card-title:not(:first-child),.mat-card-subtitle:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}\n',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        Vy = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[cy], cy],
            })),
            t
          )
        })()
      const Uy = ['mat-button', ''],
        zy = ['*'],
        Hy =
          '.mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:block;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\n',
        qy = [
          'mat-button',
          'mat-flat-button',
          'mat-icon-button',
          'mat-raised-button',
          'mat-stroked-button',
          'mat-mini-fab',
          'mat-fab',
        ]
      class $y {
        constructor(t) {
          this._elementRef = t
        }
      }
      const Wy = uy(hy(dy($y)))
      let Ky = (() => {
          class t extends Wy {
            constructor(t, e, n) {
              super(t),
                (this._focusMonitor = e),
                (this._animationMode = n),
                (this.isRoundButton = this._hasHostAttributes(
                  'mat-fab',
                  'mat-mini-fab'
                )),
                (this.isIconButton = this._hasHostAttributes('mat-icon-button'))
              for (const i of qy)
                this._hasHostAttributes(i) &&
                  this._getHostElement().classList.add(i)
              t.nativeElement.classList.add('mat-button-base'),
                this.isRoundButton && (this.color = 'accent')
            }
            ngAfterViewInit() {
              this._focusMonitor.monitor(this._elementRef, !0)
            }
            ngOnDestroy() {
              this._focusMonitor.stopMonitoring(this._elementRef)
            }
            focus(t = 'program', e) {
              this._focusMonitor.focusVia(this._getHostElement(), t, e)
            }
            _getHostElement() {
              return this._elementRef.nativeElement
            }
            _isRippleDisabled() {
              return this.disableRipple || this.disabled
            }
            _hasHostAttributes(...t) {
              return t.some((t) => this._getHostElement().hasAttribute(t))
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(Ao(Va), Ao(Gp), Ao(iy, 8))
            }),
            (t.ɵcmp = Ut({
              type: t,
              selectors: [
                ['button', 'mat-button', ''],
                ['button', 'mat-raised-button', ''],
                ['button', 'mat-icon-button', ''],
                ['button', 'mat-fab', ''],
                ['button', 'mat-mini-fab', ''],
                ['button', 'mat-stroked-button', ''],
                ['button', 'mat-flat-button', ''],
              ],
              viewQuery: function (t, e) {
                if ((1 & t && ec(xy, !0), 2 & t)) {
                  let t
                  tc((t = ic())) && (e.ripple = t.first)
                }
              },
              hostAttrs: [1, 'mat-focus-indicator'],
              hostVars: 5,
              hostBindings: function (t, e) {
                2 & t &&
                  (Eo('disabled', e.disabled || null),
                  na(
                    '_mat-animation-noopable',
                    'NoopAnimations' === e._animationMode
                  )('mat-button-disabled', e.disabled))
              },
              inputs: {
                disabled: 'disabled',
                disableRipple: 'disableRipple',
                color: 'color',
              },
              exportAs: ['matButton'],
              features: [po],
              attrs: Uy,
              ngContentSelectors: zy,
              decls: 4,
              vars: 5,
              consts: [
                [1, 'mat-button-wrapper'],
                [
                  'matRipple',
                  '',
                  1,
                  'mat-button-ripple',
                  3,
                  'matRippleDisabled',
                  'matRippleCentered',
                  'matRippleTrigger',
                ],
                [1, 'mat-button-focus-overlay'],
              ],
              template: function (t, e) {
                1 & t &&
                  (Wo(),
                  Ro(0, 'span', 0),
                  Ko(1),
                  Po(),
                  Do(2, 'span', 1),
                  Do(3, 'span', 2)),
                  2 & t &&
                    (Xs(2),
                    na(
                      'mat-button-ripple-round',
                      e.isRoundButton || e.isIconButton
                    ),
                    Oo('matRippleDisabled', e._isRippleDisabled())(
                      'matRippleCentered',
                      e.isIconButton
                    )('matRippleTrigger', e._getHostElement()))
              },
              directives: [xy],
              styles: [Hy],
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        Gy = (() => {
          class t extends Ky {
            constructor(t, e, n) {
              super(e, t, n)
            }
            _haltDisabledEvents(t) {
              this.disabled &&
                (t.preventDefault(), t.stopImmediatePropagation())
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(Ao(Gp), Ao(Va), Ao(iy, 8))
            }),
            (t.ɵcmp = Ut({
              type: t,
              selectors: [
                ['a', 'mat-button', ''],
                ['a', 'mat-raised-button', ''],
                ['a', 'mat-icon-button', ''],
                ['a', 'mat-fab', ''],
                ['a', 'mat-mini-fab', ''],
                ['a', 'mat-stroked-button', ''],
                ['a', 'mat-flat-button', ''],
              ],
              hostAttrs: [1, 'mat-focus-indicator'],
              hostVars: 7,
              hostBindings: function (t, e) {
                1 & t &&
                  Bo('click', function (t) {
                    return e._haltDisabledEvents(t)
                  }),
                  2 & t &&
                    (Eo('tabindex', e.disabled ? -1 : e.tabIndex || 0)(
                      'disabled',
                      e.disabled || null
                    )('aria-disabled', e.disabled.toString()),
                    na(
                      '_mat-animation-noopable',
                      'NoopAnimations' === e._animationMode
                    )('mat-button-disabled', e.disabled))
              },
              inputs: {
                disabled: 'disabled',
                disableRipple: 'disableRipple',
                color: 'color',
                tabIndex: 'tabIndex',
              },
              exportAs: ['matButton', 'matAnchor'],
              features: [po],
              attrs: Uy,
              ngContentSelectors: zy,
              decls: 4,
              vars: 5,
              consts: [
                [1, 'mat-button-wrapper'],
                [
                  'matRipple',
                  '',
                  1,
                  'mat-button-ripple',
                  3,
                  'matRippleDisabled',
                  'matRippleCentered',
                  'matRippleTrigger',
                ],
                [1, 'mat-button-focus-overlay'],
              ],
              template: function (t, e) {
                1 & t &&
                  (Wo(),
                  Ro(0, 'span', 0),
                  Ko(1),
                  Po(),
                  Do(2, 'span', 1),
                  Do(3, 'span', 2)),
                  2 & t &&
                    (Xs(2),
                    na(
                      'mat-button-ripple-round',
                      e.isRoundButton || e.isIconButton
                    ),
                    Oo('matRippleDisabled', e._isRippleDisabled())(
                      'matRippleCentered',
                      e.isIconButton
                    )('matRippleTrigger', e._getHostElement()))
              },
              directives: [xy],
              styles: [Hy],
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        Qy = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[Sy, cy], cy],
            })),
            t
          )
        })()
      const Zy = ['localVideo'],
        Yy = ['remoteVideo']
      function Xy(t, e) {
        if (
          (1 & t &&
            (No(0),
            pa(1, ' ID: '),
            Ro(2, 'span', 20),
            pa(3),
            Po(),
            pa(4, ' - IP: '),
            Ro(5, 'span', 20),
            pa(6),
            Po(),
            pa(7, ' - Port: '),
            Ro(8, 'span', 20),
            pa(9),
            Po(),
            pa(10, ' - Protocol: '),
            Ro(11, 'span', 20),
            pa(12),
            Po(),
            Fo()),
          2 & t)
        ) {
          const t = qo()
          Xs(3),
            fa(t.localCandidate.id),
            Xs(3),
            fa(t.localCandidate.ip),
            Xs(3),
            fa(t.localCandidate.port),
            Xs(3),
            fa(t.localCandidate.protocol)
        }
      }
      function Jy(t, e) {
        1 & t && (Ro(0, 'span', 21), pa(1, 'Not connected'), Po())
      }
      function t_(t, e) {
        if (
          (1 & t &&
            (No(0),
            pa(1, ' ID: '),
            Ro(2, 'span', 20),
            pa(3),
            Po(),
            pa(4, ' - IP: '),
            Ro(5, 'span', 20),
            pa(6),
            Po(),
            pa(7, ' - Port: '),
            Ro(8, 'span', 20),
            pa(9),
            Po(),
            pa(10, ' - Protocol: '),
            Ro(11, 'span', 20),
            pa(12),
            Po(),
            Fo()),
          2 & t)
        ) {
          const t = qo()
          Xs(3),
            fa(t.remoteCandidate.id),
            Xs(3),
            fa(t.remoteCandidate.ip),
            Xs(3),
            fa(t.remoteCandidate.port),
            Xs(3),
            fa(t.remoteCandidate.protocol)
        }
      }
      function e_(t, e) {
        1 & t && (Ro(0, 'span', 21), pa(1, 'Not connected'), Po())
      }
      const n_ = ch
      let i_ = (() => {
        class t {
          constructor(t) {
            ;(this.overlog = t),
              (this.offerOptions = {
                offerToReceiveAudio: !0,
                offerToReceiveVideo: !0,
              }),
              (this._startButton = new wp(!1)),
              (this.startButton$ = this._startButton.asObservable()),
              (this._callButton = new wp(!0)),
              (this.callButton$ = this._callButton.asObservable()),
              (this._restartButton = new wp(!0)),
              (this.restartButton$ = this._restartButton.asObservable()),
              (this._hangupButton = new wp(!0)),
              (this.hangupButton$ = this._hangupButton.asObservable()),
              (this.getName = (t) => (t === this.pc1 ? 'pc1' : 'pc2')),
              (this.getOtherPc = (t) => (t === this.pc1 ? this.pc2 : this.pc1)),
              (this.gotStream = (t) => {
                n_.log('Received local stream'),
                  (this.localVideo.srcObject = t),
                  (this.localStream = t),
                  this._callButton.next(!1)
              }),
              (this.start = () => {
                n_.log('Requesting local stream'),
                  this._startButton.next(!0),
                  navigator.mediaDevices
                    .getUserMedia({ audio: !0, video: !0 })
                    .then(this.gotStream)
                    .catch((t) => alert('getUserMedia() error: ' + t.name))
              }),
              (this.restart = () => {
                this._restartButton.next(!0),
                  (this.offerOptions.iceRestart = !0),
                  this.overlog.show({ text: 'pc1 createOffer restart' }),
                  this.pc1
                    .createOffer(this.offerOptions)
                    .then(
                      this.onCreateOfferSuccess,
                      this.onCreateSessionDescriptionError
                    )
              }),
              (this.call = () => {
                this._callButton.next(!0),
                  this._hangupButton.next(!1),
                  n_.log('Starting call'),
                  (this.startTime = window.performance.now())
                const t = this.localStream.getVideoTracks(),
                  e = this.localStream.getAudioTracks()
                t.length > 0 && n_.log('Using video device: ' + t[0].label),
                  e.length > 0 && n_.log('Using audio device: ' + e[0].label),
                  (this.pc1 = this.pc1 = new RTCPeerConnection(null)),
                  n_.log('Created local peer connection object this.pc1'),
                  (this.pc1.onicecandidate = (t) =>
                    this.onIceCandidate(this.pc1, t)),
                  (this.pc2 = this.pc2 = new RTCPeerConnection(null)),
                  n_.log('Created remote peer connection object this.pc2'),
                  (this.pc2.onicecandidate = (t) =>
                    this.onIceCandidate(this.pc2, t)),
                  (this.pc1.oniceconnectionstatechange = (t) => {
                    this.onIceStateChange(this.pc1, t),
                      this.pc1 &&
                        this.pc1.iceConnectionState === uh.Connected &&
                        this._restartButton.next(!1)
                  }),
                  (this.pc2.oniceconnectionstatechange = (t) =>
                    this.onIceStateChange(this.pc2, t)),
                  (this.pc2.ontrack = this.gotRemoteStream),
                  this.localStream
                    .getTracks()
                    .forEach((t) => this.pc1.addTrack(t, this.localStream)),
                  n_.log('Added local stream to this.pc1'),
                  this.overlog.show({ text: 'this.pc1 createOffer start' }),
                  this.pc1
                    .createOffer(this.offerOptions)
                    .then(
                      this.onCreateOfferSuccess,
                      this.onCreateSessionDescriptionError
                    )
              }),
              (this.onCreateSessionDescriptionError = (t) => {
                n_.log('Failed to create session description: ' + t.toString())
              }),
              (this.onCreateOfferSuccess = (t) => {
                n_.log('Offer from pc1\n' + t.sdp),
                  n_.log('pc1 setLocalDescription start'),
                  this.pc1
                    .setLocalDescription(t)
                    .then(
                      () => this.onSetLocalSuccess(this.pc1),
                      this.onSetSessionDescriptionError
                    ),
                  n_.log('pc2 setRemoteDescription start'),
                  this.pc2
                    .setRemoteDescription(t)
                    .then(
                      () => this.onSetRemoteSuccess(this.pc2),
                      this.onSetSessionDescriptionError
                    ),
                  n_.log('pc2 createAnswer start'),
                  this.pc2
                    .createAnswer()
                    .then(
                      this.onCreateAnswerSuccess,
                      this.onCreateSessionDescriptionError
                    )
              }),
              (this.onSetLocalSuccess = (t) => {
                n_.log(this.getName(t) + ' setLocalDescription complete')
              }),
              (this.onSetRemoteSuccess = (t) => {
                n_.log(this.getName(t) + ' setRemoteDescription complete')
              }),
              (this.onSetSessionDescriptionError = (t) => {
                n_.log('Failed to set session description: ' + t.toString())
              }),
              (this.gotRemoteStream = (t) => {
                this.remoteVideo.srcObject !== t.streams[0] &&
                  ((this.remoteVideo.srcObject = t.streams[0]),
                  this.overlog.show({ text: 'pc2 received remote stream' }))
              }),
              (this.onCreateAnswerSuccess = (t) => {
                n_.log('Answer from pc2:\n' + t.sdp),
                  n_.log('pc2 setLocalDescription start'),
                  this.pc2
                    .setLocalDescription(t)
                    .then(
                      () => this.onSetLocalSuccess(this.pc2),
                      this.onSetSessionDescriptionError
                    ),
                  n_.log('pc1 setRemoteDescription start'),
                  this.pc1
                    .setRemoteDescription(t)
                    .then(
                      () => this.onSetRemoteSuccess(this.pc1),
                      this.onSetSessionDescriptionError
                    )
              }),
              (this.onIceCandidate = (t, e) => {
                e.candidate &&
                  (this.getOtherPc(t)
                    .addIceCandidate(e.candidate)
                    .then(
                      () => this.onAddIceCandidateSuccess(t),
                      (e) => this.onAddIceCandidateError(t, e)
                    ),
                  n_.log(
                    `${this.getName(t)} ICE candidate: \n${
                      e.candidate ? e.candidate.candidate : '(null)'
                    }`
                  ))
              }),
              (this.onAddIceCandidateSuccess = (t) => {
                n_.log(this.getName(t) + ' addIceCandidate success')
              }),
              (this.onAddIceCandidateError = (t, e) => {
                n_.log(
                  `${this.getName(
                    t
                  )} failed to add ICE Candidate: ${e.toString()}`
                )
              }),
              (this.onIceStateChange = (t, e) => {
                t &&
                  (n_.log(
                    `${this.getName(t)} ICE state: ${t.iceConnectionState}`
                  ),
                  n_.log('ICE state change event: ', e),
                  (t.iceConnectionState !== uh.Connected &&
                    t.iceConnectionState !== uh.Completed) ||
                    this.checkStats(t))
              }),
              (this.checkStats = (t) => {
                t.getStats(null).then((e) => {
                  let n = null,
                    i = null
                  e.forEach((t) => {
                    'transport' === t.type &&
                      (n = e.get(t.selectedCandidatePairId))
                  }),
                    n ||
                      e.forEach((t) => {
                        'candidate-pair' === t.type &&
                          'succeeded' === t.state &&
                          t.selected &&
                          (n = t)
                      }),
                    n &&
                      n.remoteCandidateId &&
                      e.forEach((t) => {
                        'remote-candidate' === t.type &&
                          t.id === n.remoteCandidateId &&
                          (i = t)
                      }),
                    i &&
                      i.id &&
                      (t === this.pc1
                        ? (this.localCandidate = i)
                        : (this.remoteCandidate = i))
                })
              })
          }
          ngAfterViewInit() {
            ;(this.localVideo = this.localVideoRef.nativeElement),
              (this.remoteVideo = this.remoteVideoRef.nativeElement),
              this.localVideo.addEventListener(
                'loadedmetadata',
                ({ target: t }) => {
                  ch.log(`Local video: ${t.videoWidth}x${t.videoHeight}px`)
                }
              ),
              this.remoteVideo.addEventListener(
                'loadedmetadata',
                ({ target: t }) => {
                  n_.log(`Remote video: ${t.videoWidth}x${t.videoHeight}px`)
                }
              ),
              (this.remoteVideo.onresize = () => {
                if (
                  (n_.log(
                    `Remote video size changed to ${this.remoteVideo.videoWidth}x${this.remoteVideo.videoHeight}px`
                  ),
                  this.startTime)
                ) {
                  const t = window.performance.now() - this.startTime
                  n_.log(`Setup time: ${t.toFixed(3)}ms`),
                    (this.startTime = null),
                    this.checkStats(this.pc1),
                    this.checkStats(this.pc2)
                }
              })
          }
          hangup() {
            this.overlog.show({ text: 'Ending call' }),
              this.pc1.close(),
              this.pc2.close(),
              (this.pc1 = null),
              (this.pc2 = null),
              this._hangupButton.next(!0),
              this._restartButton.next(!0),
              this._callButton.next(!1)
          }
          ngOnDestroy() {
            this.localStream &&
              this.localStream.getTracks().forEach((t) => t.stop())
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(Ao(vp))
          }),
          (t.ɵcmp = Ut({
            type: t,
            selectors: [['app-restart-ice']],
            viewQuery: function (t, e) {
              if ((1 & t && (ec(Zy, !0), ec(Yy, !0)), 2 & t)) {
                let t
                tc((t = ic())) && (e.localVideoRef = t.first),
                  tc((t = ic())) && (e.remoteVideoRef = t.first)
              }
            },
            decls: 39,
            vars: 16,
            consts: [
              ['id', 'video'],
              ['mat-card-title', '', 'for', 'localCandidate'],
              ['mat-card-subtitle', '', 'id', 'localCandidate'],
              [4, 'ngIf', 'ngIfElse'],
              ['localOff', ''],
              [
                'mat-card-image',
                '',
                'id',
                'localVideo',
                'playsinline',
                '',
                'autoplay',
                '',
                'muted',
                '',
              ],
              ['localVideo', ''],
              ['mat-card-subtitle', '', 'id', 'remoteCandidate'],
              ['remoteOff', ''],
              [
                'mat-card-image',
                '',
                'id',
                'remoteVideo',
                'playsinline',
                '',
                'autoplay',
                '',
                'muted',
                '',
              ],
              ['remoteVideo', ''],
              ['color', 'accent', 1, 'toolbar-footer'],
              ['mat-button', '', 'id', 'startButton', 3, 'disabled', 'click'],
              ['startButton', ''],
              ['mat-button', '', 'id', 'callButton', 3, 'disabled', 'click'],
              ['callButton', ''],
              ['mat-button', '', 'id', 'restartButton', 3, 'disabled', 'click'],
              ['restartButton', ''],
              ['mat-button', '', 'id', 'hangupButton', 3, 'disabled', 'click'],
              ['hangupButton', ''],
              [1, 'glare'],
              [1, 'mat-hint'],
            ],
            template: function (t, e) {
              if (
                (1 & t &&
                  (Ro(0, 'mat-toolbar'),
                  Ro(1, 'h1'),
                  pa(2, 'restart-ice works!'),
                  Po(),
                  Po(),
                  Ro(3, 'div', 0),
                  Ro(4, 'mat-card'),
                  Ro(5, 'label', 1),
                  pa(6, 'Local candidate'),
                  Po(),
                  Ro(7, 'p', 2),
                  ko(8, Xy, 13, 4, 'ng-container', 3),
                  ko(9, Jy, 2, 0, 'ng-template', null, 4, ac),
                  Po(),
                  Do(11, 'video', 5, 6),
                  Po(),
                  Ro(13, 'mat-card'),
                  Ro(14, 'label', 1),
                  pa(15, 'Remote candidate '),
                  Po(),
                  Ro(16, 'p', 7),
                  ko(17, t_, 13, 4, 'ng-container', 3),
                  ko(18, e_, 2, 0, 'ng-template', null, 8, ac),
                  Po(),
                  Do(20, 'video', 9, 10),
                  Po(),
                  Po(),
                  Ro(22, 'mat-toolbar', 11),
                  Ro(23, 'button', 12, 13),
                  Bo('click', function () {
                    return e.start()
                  }),
                  Vl(25, 'async'),
                  pa(26, ' Start '),
                  Po(),
                  Ro(27, 'button', 14, 15),
                  Bo('click', function () {
                    return e.call()
                  }),
                  Vl(29, 'async'),
                  pa(30, ' Call '),
                  Po(),
                  Ro(31, 'button', 16, 17),
                  Bo('click', function () {
                    return e.restart()
                  }),
                  Vl(33, 'async'),
                  pa(34, ' Restart ICE '),
                  Po(),
                  Ro(35, 'button', 18, 19),
                  Bo('click', function () {
                    return e.hangup()
                  }),
                  Vl(37, 'async'),
                  pa(38, ' Hang Up '),
                  Po(),
                  Po()),
                2 & t)
              ) {
                const t = To(10),
                  n = To(19)
                Xs(8),
                  Oo('ngIf', e.localCandidate)('ngIfElse', t),
                  Xs(9),
                  Oo('ngIf', e.remoteCandidate)('ngIfElse', n),
                  Xs(6),
                  Oo('disabled', Ul(25, 8, e.startButton$)),
                  Xs(4),
                  Oo('disabled', Ul(29, 10, e.callButton$)),
                  Xs(4),
                  Oo('disabled', Ul(33, 12, e.restartButton$)),
                  Xs(4),
                  Oo('disabled', Ul(37, 14, e.hangupButton$))
              }
            },
            directives: [Py, By, My, Ly, Vh, jy, Ky],
            pipes: [Kh],
            styles: [
              '[_nghost-%COMP%]{display:block;padding-bottom:64px;width:100%;--width:100%}video[_ngcontent-%COMP%]{width:var(--width);height:calc(var(--width) * .75);object-fit:cover;margin:0}.glare[_ngcontent-%COMP%]{color:#000}div#video[_ngcontent-%COMP%]{display:flex;row-gap:8px;column-gap:8px;padding:8px}div#video[_ngcontent-%COMP%] > .mat-card[_ngcontent-%COMP%]{display:inline-block;vertical-align:top;width:calc(50% - 32px)}div#video[_ngcontent-%COMP%] > .mat-card[_ngcontent-%COMP%] > video[_ngcontent-%COMP%]{width:100%}@media screen and (max-width:400px){button[_ngcontent-%COMP%]{margin:0 11px 10px 0}}.toolbar-footer[_ngcontent-%COMP%]{position:fixed;bottom:0;justify-content:center}',
            ],
          })),
          t
        )
      })()
      function s_(...t) {
        if (1 === t.length) {
          const e = t[0]
          if (l(e)) return r_(e, null)
          if (c(e) && Object.getPrototypeOf(e) === Object.prototype) {
            const t = Object.keys(e)
            return r_(
              t.map((t) => e[t]),
              t
            )
          }
        }
        if ('function' == typeof t[t.length - 1]) {
          const e = t.pop()
          return r_((t = 1 === t.length && l(t[0]) ? t[0] : t), null).pipe(
            F((t) => e(...t))
          )
        }
        return r_(t, null)
      }
      function r_(t, e) {
        return new _((n) => {
          const i = t.length
          if (0 === i) return void n.complete()
          const s = new Array(i)
          let r = 0,
            o = 0
          for (let a = 0; a < i; a++) {
            const l = B(t[a])
            let c = !1
            n.add(
              l.subscribe({
                next: (t) => {
                  c || ((c = !0), o++), (s[a] = t)
                },
                error: (t) => n.error(t),
                complete: () => {
                  r++,
                    (r !== i && c) ||
                      (o === i &&
                        n.next(
                          e ? e.reduce((t, e, n) => ((t[e] = s[n]), t), {}) : s
                        ),
                      n.complete())
                },
              })
            )
          }
        })
      }
      function o_(t) {
        return function (e) {
          const n = new a_(t),
            i = e.lift(n)
          return (n.caught = i)
        }
      }
      class a_ {
        constructor(t) {
          this.selector = t
        }
        call(t, e) {
          return e.subscribe(new l_(t, this.selector, this.caught))
        }
      }
      class l_ extends N {
        constructor(t, e, n) {
          super(t), (this.selector = e), (this.caught = n)
        }
        error(t) {
          if (!this.isStopped) {
            let n
            try {
              n = this.selector(t, this.caught)
            } catch (e) {
              return void super.error(e)
            }
            this._unsubscribeAndRecycle()
            const i = new k(this, void 0, void 0)
            this.add(i)
            const s = D(this, n, void 0, void 0, i)
            s !== i && this.add(s)
          }
        }
      }
      function c_(t) {
        return (e) => e.lift(new h_(t))
      }
      class h_ {
        constructor(t) {
          this.callback = t
        }
        call(t, e) {
          return e.subscribe(new u_(t, this.callback))
        }
      }
      class u_ extends f {
        constructor(t, e) {
          super(t), this.add(new u(e))
        }
      }
      function d_(t, e) {
        return V(t, e, 1)
      }
      class p_ {}
      class f_ {
        constructor(t) {
          ;(this.normalizedNames = new Map()),
            (this.lazyUpdate = null),
            t
              ? (this.lazyInit =
                  'string' == typeof t
                    ? () => {
                        ;(this.headers = new Map()),
                          t.split('\n').forEach((t) => {
                            const e = t.indexOf(':')
                            if (e > 0) {
                              const n = t.slice(0, e),
                                i = n.toLowerCase(),
                                s = t.slice(e + 1).trim()
                              this.maybeSetNormalizedName(n, i),
                                this.headers.has(i)
                                  ? this.headers.get(i).push(s)
                                  : this.headers.set(i, [s])
                            }
                          })
                      }
                    : () => {
                        ;(this.headers = new Map()),
                          Object.keys(t).forEach((e) => {
                            let n = t[e]
                            const i = e.toLowerCase()
                            'string' == typeof n && (n = [n]),
                              n.length > 0 &&
                                (this.headers.set(i, n),
                                this.maybeSetNormalizedName(e, i))
                          })
                      })
              : (this.headers = new Map())
        }
        has(t) {
          return this.init(), this.headers.has(t.toLowerCase())
        }
        get(t) {
          this.init()
          const e = this.headers.get(t.toLowerCase())
          return e && e.length > 0 ? e[0] : null
        }
        keys() {
          return this.init(), Array.from(this.normalizedNames.values())
        }
        getAll(t) {
          return this.init(), this.headers.get(t.toLowerCase()) || null
        }
        append(t, e) {
          return this.clone({ name: t, value: e, op: 'a' })
        }
        set(t, e) {
          return this.clone({ name: t, value: e, op: 's' })
        }
        delete(t, e) {
          return this.clone({ name: t, value: e, op: 'd' })
        }
        maybeSetNormalizedName(t, e) {
          this.normalizedNames.has(e) || this.normalizedNames.set(e, t)
        }
        init() {
          this.lazyInit &&
            (this.lazyInit instanceof f_
              ? this.copyFrom(this.lazyInit)
              : this.lazyInit(),
            (this.lazyInit = null),
            this.lazyUpdate &&
              (this.lazyUpdate.forEach((t) => this.applyUpdate(t)),
              (this.lazyUpdate = null)))
        }
        copyFrom(t) {
          t.init(),
            Array.from(t.headers.keys()).forEach((e) => {
              this.headers.set(e, t.headers.get(e)),
                this.normalizedNames.set(e, t.normalizedNames.get(e))
            })
        }
        clone(t) {
          const e = new f_()
          return (
            (e.lazyInit =
              this.lazyInit && this.lazyInit instanceof f_
                ? this.lazyInit
                : this),
            (e.lazyUpdate = (this.lazyUpdate || []).concat([t])),
            e
          )
        }
        applyUpdate(t) {
          const e = t.name.toLowerCase()
          switch (t.op) {
            case 'a':
            case 's':
              let n = t.value
              if (('string' == typeof n && (n = [n]), 0 === n.length)) return
              this.maybeSetNormalizedName(t.name, e)
              const i = ('a' === t.op ? this.headers.get(e) : void 0) || []
              i.push(...n), this.headers.set(e, i)
              break
            case 'd':
              const s = t.value
              if (s) {
                let t = this.headers.get(e)
                if (!t) return
                ;(t = t.filter((t) => -1 === s.indexOf(t))),
                  0 === t.length
                    ? (this.headers.delete(e), this.normalizedNames.delete(e))
                    : this.headers.set(e, t)
              } else this.headers.delete(e), this.normalizedNames.delete(e)
          }
        }
        forEach(t) {
          this.init(),
            Array.from(this.normalizedNames.keys()).forEach((e) =>
              t(this.normalizedNames.get(e), this.headers.get(e))
            )
        }
      }
      class m_ {
        encodeKey(t) {
          return g_(t)
        }
        encodeValue(t) {
          return g_(t)
        }
        decodeKey(t) {
          return decodeURIComponent(t)
        }
        decodeValue(t) {
          return decodeURIComponent(t)
        }
      }
      function g_(t) {
        return encodeURIComponent(t)
          .replace(/%40/gi, '@')
          .replace(/%3A/gi, ':')
          .replace(/%24/gi, '$')
          .replace(/%2C/gi, ',')
          .replace(/%3B/gi, ';')
          .replace(/%2B/gi, '+')
          .replace(/%3D/gi, '=')
          .replace(/%3F/gi, '?')
          .replace(/%2F/gi, '/')
      }
      class y_ {
        constructor(t = {}) {
          if (
            ((this.updates = null),
            (this.cloneFrom = null),
            (this.encoder = t.encoder || new m_()),
            t.fromString)
          ) {
            if (t.fromObject)
              throw new Error('Cannot specify both fromString and fromObject.')
            this.map = (function (t, e) {
              const n = new Map()
              return (
                t.length > 0 &&
                  t.split('&').forEach((t) => {
                    const i = t.indexOf('='),
                      [s, r] =
                        -1 == i
                          ? [e.decodeKey(t), '']
                          : [
                              e.decodeKey(t.slice(0, i)),
                              e.decodeValue(t.slice(i + 1)),
                            ],
                      o = n.get(s) || []
                    o.push(r), n.set(s, o)
                  }),
                n
              )
            })(t.fromString, this.encoder)
          } else
            t.fromObject
              ? ((this.map = new Map()),
                Object.keys(t.fromObject).forEach((e) => {
                  const n = t.fromObject[e]
                  this.map.set(e, Array.isArray(n) ? n : [n])
                }))
              : (this.map = null)
        }
        has(t) {
          return this.init(), this.map.has(t)
        }
        get(t) {
          this.init()
          const e = this.map.get(t)
          return e ? e[0] : null
        }
        getAll(t) {
          return this.init(), this.map.get(t) || null
        }
        keys() {
          return this.init(), Array.from(this.map.keys())
        }
        append(t, e) {
          return this.clone({ param: t, value: e, op: 'a' })
        }
        set(t, e) {
          return this.clone({ param: t, value: e, op: 's' })
        }
        delete(t, e) {
          return this.clone({ param: t, value: e, op: 'd' })
        }
        toString() {
          return (
            this.init(),
            this.keys()
              .map((t) => {
                const e = this.encoder.encodeKey(t)
                return this.map
                  .get(t)
                  .map((t) => e + '=' + this.encoder.encodeValue(t))
                  .join('&')
              })
              .filter((t) => '' !== t)
              .join('&')
          )
        }
        clone(t) {
          const e = new y_({ encoder: this.encoder })
          return (
            (e.cloneFrom = this.cloneFrom || this),
            (e.updates = (this.updates || []).concat([t])),
            e
          )
        }
        init() {
          null === this.map && (this.map = new Map()),
            null !== this.cloneFrom &&
              (this.cloneFrom.init(),
              this.cloneFrom
                .keys()
                .forEach((t) => this.map.set(t, this.cloneFrom.map.get(t))),
              this.updates.forEach((t) => {
                switch (t.op) {
                  case 'a':
                  case 's':
                    const e =
                      ('a' === t.op ? this.map.get(t.param) : void 0) || []
                    e.push(t.value), this.map.set(t.param, e)
                    break
                  case 'd':
                    if (void 0 === t.value) {
                      this.map.delete(t.param)
                      break
                    }
                    {
                      let e = this.map.get(t.param) || []
                      const n = e.indexOf(t.value)
                      ;-1 !== n && e.splice(n, 1),
                        e.length > 0
                          ? this.map.set(t.param, e)
                          : this.map.delete(t.param)
                    }
                }
              }),
              (this.cloneFrom = this.updates = null))
        }
      }
      function __(t) {
        return 'undefined' != typeof ArrayBuffer && t instanceof ArrayBuffer
      }
      function v_(t) {
        return 'undefined' != typeof Blob && t instanceof Blob
      }
      function b_(t) {
        return 'undefined' != typeof FormData && t instanceof FormData
      }
      class w_ {
        constructor(t, e, n, i) {
          let s
          if (
            ((this.url = e),
            (this.body = null),
            (this.reportProgress = !1),
            (this.withCredentials = !1),
            (this.responseType = 'json'),
            (this.method = t.toUpperCase()),
            (function (t) {
              switch (t) {
                case 'DELETE':
                case 'GET':
                case 'HEAD':
                case 'OPTIONS':
                case 'JSONP':
                  return !1
                default:
                  return !0
              }
            })(this.method) || i
              ? ((this.body = void 0 !== n ? n : null), (s = i))
              : (s = n),
            s &&
              ((this.reportProgress = !!s.reportProgress),
              (this.withCredentials = !!s.withCredentials),
              s.responseType && (this.responseType = s.responseType),
              s.headers && (this.headers = s.headers),
              s.params && (this.params = s.params)),
            this.headers || (this.headers = new f_()),
            this.params)
          ) {
            const t = this.params.toString()
            if (0 === t.length) this.urlWithParams = e
            else {
              const n = e.indexOf('?')
              this.urlWithParams =
                e + (-1 === n ? '?' : n < e.length - 1 ? '&' : '') + t
            }
          } else (this.params = new y_()), (this.urlWithParams = e)
        }
        serializeBody() {
          return null === this.body
            ? null
            : __(this.body) ||
              v_(this.body) ||
              b_(this.body) ||
              'string' == typeof this.body
            ? this.body
            : this.body instanceof y_
            ? this.body.toString()
            : 'object' == typeof this.body ||
              'boolean' == typeof this.body ||
              Array.isArray(this.body)
            ? JSON.stringify(this.body)
            : this.body.toString()
        }
        detectContentTypeHeader() {
          return null === this.body || b_(this.body)
            ? null
            : v_(this.body)
            ? this.body.type || null
            : __(this.body)
            ? null
            : 'string' == typeof this.body
            ? 'text/plain'
            : this.body instanceof y_
            ? 'application/x-www-form-urlencoded;charset=UTF-8'
            : 'object' == typeof this.body ||
              'number' == typeof this.body ||
              Array.isArray(this.body)
            ? 'application/json'
            : null
        }
        clone(t = {}) {
          const e = t.method || this.method,
            n = t.url || this.url,
            i = t.responseType || this.responseType,
            s = void 0 !== t.body ? t.body : this.body,
            r =
              void 0 !== t.withCredentials
                ? t.withCredentials
                : this.withCredentials,
            o =
              void 0 !== t.reportProgress
                ? t.reportProgress
                : this.reportProgress
          let a = t.headers || this.headers,
            l = t.params || this.params
          return (
            void 0 !== t.setHeaders &&
              (a = Object.keys(t.setHeaders).reduce(
                (e, n) => e.set(n, t.setHeaders[n]),
                a
              )),
            t.setParams &&
              (l = Object.keys(t.setParams).reduce(
                (e, n) => e.set(n, t.setParams[n]),
                l
              )),
            new w_(e, n, s, {
              params: l,
              headers: a,
              reportProgress: o,
              responseType: i,
              withCredentials: r,
            })
          )
        }
      }
      var C_ = (function (t) {
        return (
          (t[(t.Sent = 0)] = 'Sent'),
          (t[(t.UploadProgress = 1)] = 'UploadProgress'),
          (t[(t.ResponseHeader = 2)] = 'ResponseHeader'),
          (t[(t.DownloadProgress = 3)] = 'DownloadProgress'),
          (t[(t.Response = 4)] = 'Response'),
          (t[(t.User = 5)] = 'User'),
          t
        )
      })({})
      class x_ extends class {
        constructor(t, e = 200, n = 'OK') {
          ;(this.headers = t.headers || new f_()),
            (this.status = void 0 !== t.status ? t.status : e),
            (this.statusText = t.statusText || n),
            (this.url = t.url || null),
            (this.ok = this.status >= 200 && this.status < 300)
        }
      } {
        constructor(t = {}) {
          super(t),
            (this.type = C_.Response),
            (this.body = void 0 !== t.body ? t.body : null)
        }
        clone(t = {}) {
          return new x_({
            body: void 0 !== t.body ? t.body : this.body,
            headers: t.headers || this.headers,
            status: void 0 !== t.status ? t.status : this.status,
            statusText: t.statusText || this.statusText,
            url: t.url || this.url || void 0,
          })
        }
      }
      function S_(t, e) {
        return {
          body: e,
          headers: t.headers,
          observe: t.observe,
          params: t.params,
          reportProgress: t.reportProgress,
          responseType: t.responseType,
          withCredentials: t.withCredentials,
        }
      }
      let E_ = (() => {
        class t {
          constructor(t) {
            this.handler = t
          }
          request(t, e, n = {}) {
            let i
            if (t instanceof w_) i = t
            else {
              let s = void 0
              s = n.headers instanceof f_ ? n.headers : new f_(n.headers)
              let r = void 0
              n.params &&
                (r =
                  n.params instanceof y_
                    ? n.params
                    : new y_({ fromObject: n.params })),
                (i = new w_(t, e, void 0 !== n.body ? n.body : null, {
                  headers: s,
                  params: r,
                  reportProgress: n.reportProgress,
                  responseType: n.responseType || 'json',
                  withCredentials: n.withCredentials,
                }))
            }
            const s = mu(i).pipe(d_((t) => this.handler.handle(t)))
            if (t instanceof w_ || 'events' === n.observe) return s
            const r = s.pipe(Iu((t) => t instanceof x_))
            switch (n.observe || 'body') {
              case 'body':
                switch (i.responseType) {
                  case 'arraybuffer':
                    return r.pipe(
                      F((t) => {
                        if (null !== t.body && !(t.body instanceof ArrayBuffer))
                          throw new Error('Response is not an ArrayBuffer.')
                        return t.body
                      })
                    )
                  case 'blob':
                    return r.pipe(
                      F((t) => {
                        if (null !== t.body && !(t.body instanceof Blob))
                          throw new Error('Response is not a Blob.')
                        return t.body
                      })
                    )
                  case 'text':
                    return r.pipe(
                      F((t) => {
                        if (null !== t.body && 'string' != typeof t.body)
                          throw new Error('Response is not a string.')
                        return t.body
                      })
                    )
                  case 'json':
                  default:
                    return r.pipe(F((t) => t.body))
                }
              case 'response':
                return r
              default:
                throw new Error(
                  `Unreachable: unhandled observe type ${n.observe}}`
                )
            }
          }
          delete(t, e = {}) {
            return this.request('DELETE', t, e)
          }
          get(t, e = {}) {
            return this.request('GET', t, e)
          }
          head(t, e = {}) {
            return this.request('HEAD', t, e)
          }
          jsonp(t, e) {
            return this.request('JSONP', t, {
              params: new y_().append(e, 'JSONP_CALLBACK'),
              observe: 'body',
              responseType: 'json',
            })
          }
          options(t, e = {}) {
            return this.request('OPTIONS', t, e)
          }
          patch(t, e, n = {}) {
            return this.request('PATCH', t, S_(n, e))
          }
          post(t, e, n = {}) {
            return this.request('POST', t, S_(n, e))
          }
          put(t, e, n = {}) {
            return this.request('PUT', t, S_(n, e))
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(p_))
          }),
          (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      const k_ = ['*']
      function T_(t) {
        return Error(`Unable to find icon with the name "${t}"`)
      }
      function A_(t) {
        return Error(
          `The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${t}".`
        )
      }
      function O_(t) {
        return Error(
          `The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${t}".`
        )
      }
      class I_ {
        constructor(t, e, n) {
          ;(this.url = t), (this.svgText = e), (this.options = n)
        }
      }
      let R_ = (() => {
        class t {
          constructor(t, e, n, i) {
            ;(this._httpClient = t),
              (this._sanitizer = e),
              (this._errorHandler = i),
              (this._svgIconConfigs = new Map()),
              (this._iconSetConfigs = new Map()),
              (this._cachedIconsByUrl = new Map()),
              (this._inProgressUrlFetches = new Map()),
              (this._fontCssClassesByAlias = new Map()),
              (this._defaultFontSetClass = 'material-icons'),
              (this._document = n)
          }
          addSvgIcon(t, e, n) {
            return this.addSvgIconInNamespace('', t, e, n)
          }
          addSvgIconLiteral(t, e, n) {
            return this.addSvgIconLiteralInNamespace('', t, e, n)
          }
          addSvgIconInNamespace(t, e, n, i) {
            return this._addSvgIconConfig(t, e, new I_(n, null, i))
          }
          addSvgIconLiteralInNamespace(t, e, n, i) {
            const s = this._sanitizer.sanitize(es.HTML, n)
            if (!s) throw O_(n)
            return this._addSvgIconConfig(t, e, new I_('', s, i))
          }
          addSvgIconSet(t, e) {
            return this.addSvgIconSetInNamespace('', t, e)
          }
          addSvgIconSetLiteral(t, e) {
            return this.addSvgIconSetLiteralInNamespace('', t, e)
          }
          addSvgIconSetInNamespace(t, e, n) {
            return this._addSvgIconSetConfig(t, new I_(e, null, n))
          }
          addSvgIconSetLiteralInNamespace(t, e, n) {
            const i = this._sanitizer.sanitize(es.HTML, e)
            if (!i) throw O_(e)
            return this._addSvgIconSetConfig(t, new I_('', i, n))
          }
          registerFontClassAlias(t, e = t) {
            return this._fontCssClassesByAlias.set(t, e), this
          }
          classNameForFontAlias(t) {
            return this._fontCssClassesByAlias.get(t) || t
          }
          setDefaultFontSetClass(t) {
            return (this._defaultFontSetClass = t), this
          }
          getDefaultFontSetClass() {
            return this._defaultFontSetClass
          }
          getSvgIconFromUrl(t) {
            const e = this._sanitizer.sanitize(es.RESOURCE_URL, t)
            if (!e) throw A_(t)
            const n = this._cachedIconsByUrl.get(e)
            return n
              ? mu(P_(n))
              : this._loadSvgIconFromConfig(new I_(t, null)).pipe(
                  xp((t) => this._cachedIconsByUrl.set(e, t)),
                  F((t) => P_(t))
                )
          }
          getNamedSvgIcon(t, e = '') {
            const n = D_(e, t),
              i = this._svgIconConfigs.get(n)
            if (i) return this._getSvgFromConfig(i)
            const s = this._iconSetConfigs.get(e)
            return s ? this._getSvgFromIconSetConfigs(t, s) : qu(T_(n))
          }
          ngOnDestroy() {
            this._svgIconConfigs.clear(),
              this._iconSetConfigs.clear(),
              this._cachedIconsByUrl.clear()
          }
          _getSvgFromConfig(t) {
            return t.svgText
              ? mu(P_(this._svgElementFromConfig(t)))
              : this._loadSvgIconFromConfig(t).pipe(F((t) => P_(t)))
          }
          _getSvgFromIconSetConfigs(t, e) {
            const n = this._extractIconWithNameFromAnySet(t, e)
            return n
              ? mu(n)
              : s_(
                  e
                    .filter((t) => !t.svgText)
                    .map((t) =>
                      this._loadSvgIconSetFromConfig(t).pipe(
                        o_((e) => {
                          const n = this._sanitizer.sanitize(
                            es.RESOURCE_URL,
                            t.url
                          )
                          return (
                            this._errorHandler.handleError(
                              new Error(
                                `Loading icon set URL: ${n} failed: ${e.message}`
                              )
                            ),
                            mu(null)
                          )
                        })
                      )
                    )
                ).pipe(
                  F(() => {
                    const n = this._extractIconWithNameFromAnySet(t, e)
                    if (!n) throw T_(t)
                    return n
                  })
                )
          }
          _extractIconWithNameFromAnySet(t, e) {
            for (let n = e.length - 1; n >= 0; n--) {
              const i = e[n]
              if (i.svgText && i.svgText.indexOf(t) > -1) {
                const e = this._svgElementFromConfig(i),
                  n = this._extractSvgIconFromSet(e, t, i.options)
                if (n) return n
              }
            }
            return null
          }
          _loadSvgIconFromConfig(t) {
            return this._fetchIcon(t).pipe(
              xp((e) => (t.svgText = e)),
              F(() => this._svgElementFromConfig(t))
            )
          }
          _loadSvgIconSetFromConfig(t) {
            return t.svgText
              ? mu(null)
              : this._fetchIcon(t).pipe(xp((e) => (t.svgText = e)))
          }
          _extractSvgIconFromSet(t, e, n) {
            const i = t.querySelector(`[id="${e}"]`)
            if (!i) return null
            const s = i.cloneNode(!0)
            if ((s.removeAttribute('id'), 'svg' === s.nodeName.toLowerCase()))
              return this._setSvgAttributes(s, n)
            if ('symbol' === s.nodeName.toLowerCase())
              return this._setSvgAttributes(this._toSvgElement(s), n)
            const r = this._svgElementFromString('<svg></svg>')
            return r.appendChild(s), this._setSvgAttributes(r, n)
          }
          _svgElementFromString(t) {
            const e = this._document.createElement('DIV')
            e.innerHTML = t
            const n = e.querySelector('svg')
            if (!n) throw Error('<svg> tag not found')
            return n
          }
          _toSvgElement(t) {
            const e = this._svgElementFromString('<svg></svg>'),
              n = t.attributes
            for (let i = 0; i < n.length; i++) {
              const { name: t, value: s } = n[i]
              'id' !== t && e.setAttribute(t, s)
            }
            for (let i = 0; i < t.childNodes.length; i++)
              t.childNodes[i].nodeType === this._document.ELEMENT_NODE &&
                e.appendChild(t.childNodes[i].cloneNode(!0))
            return e
          }
          _setSvgAttributes(t, e) {
            return (
              t.setAttribute('fit', ''),
              t.setAttribute('height', '100%'),
              t.setAttribute('width', '100%'),
              t.setAttribute('preserveAspectRatio', 'xMidYMid meet'),
              t.setAttribute('focusable', 'false'),
              e && e.viewBox && t.setAttribute('viewBox', e.viewBox),
              t
            )
          }
          _fetchIcon(t) {
            var e
            const { url: n, options: i } = t,
              s =
                null !== (e = null == i ? void 0 : i.withCredentials) &&
                void 0 !== e &&
                e
            if (!this._httpClient)
              throw Error(
                'Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports.'
              )
            if (null == n) throw Error(`Cannot fetch icon from URL "${n}".`)
            const r = this._sanitizer.sanitize(es.RESOURCE_URL, n)
            if (!r) throw A_(n)
            const o = this._inProgressUrlFetches.get(r)
            if (o) return o
            const a = this._httpClient
              .get(r, { responseType: 'text', withCredentials: s })
              .pipe(
                c_(() => this._inProgressUrlFetches.delete(r)),
                et()
              )
            return this._inProgressUrlFetches.set(r, a), a
          }
          _addSvgIconConfig(t, e, n) {
            return this._svgIconConfigs.set(D_(t, e), n), this
          }
          _addSvgIconSetConfig(t, e) {
            const n = this._iconSetConfigs.get(t)
            return n ? n.push(e) : this._iconSetConfigs.set(t, [e]), this
          }
          _svgElementFromConfig(t) {
            if (!t.svgElement) {
              const e = this._svgElementFromString(t.svgText)
              this._setSvgAttributes(e, t.options), (t.svgElement = e)
            }
            return t.svgElement
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(E_, 8), vi(Af), vi(mh, 8), vi(os))
          }),
          (t.ɵprov = ht({
            factory: function () {
              return new t(vi(E_, 8), vi(Af), vi(mh, 8), vi(os))
            },
            token: t,
            providedIn: 'root',
          })),
          t
        )
      })()
      function P_(t) {
        return t.cloneNode(!0)
      }
      function D_(t, e) {
        return t + ':' + e
      }
      class N_ {
        constructor(t) {
          this._elementRef = t
        }
      }
      const F_ = uy(N_),
        M_ = new Yn('mat-icon-location', {
          providedIn: 'root',
          factory: function () {
            const t = bi(mh),
              e = t ? t.location : null
            return { getPathname: () => (e ? e.pathname + e.search : '') }
          },
        }),
        L_ = [
          'clip-path',
          'color-profile',
          'src',
          'cursor',
          'fill',
          'filter',
          'marker',
          'marker-start',
          'marker-mid',
          'marker-end',
          'mask',
          'stroke',
        ],
        j_ = L_.map((t) => `[${t}]`).join(', '),
        B_ = /^url\(['"]?#(.*?)['"]?\)$/
      let V_ = (() => {
          class t extends F_ {
            constructor(t, e, n, i, s) {
              super(t),
                (this._iconRegistry = e),
                (this._location = i),
                (this._errorHandler = s),
                (this._inline = !1),
                (this._currentIconFetch = u.EMPTY),
                n || t.nativeElement.setAttribute('aria-hidden', 'true')
            }
            get inline() {
              return this._inline
            }
            set inline(t) {
              this._inline = hu(t)
            }
            get svgIcon() {
              return this._svgIcon
            }
            set svgIcon(t) {
              t !== this._svgIcon &&
                (t
                  ? this._updateSvgIcon(t)
                  : this._svgIcon && this._clearSvgElement(),
                (this._svgIcon = t))
            }
            get fontSet() {
              return this._fontSet
            }
            set fontSet(t) {
              const e = this._cleanupFontValue(t)
              e !== this._fontSet &&
                ((this._fontSet = e), this._updateFontIconClasses())
            }
            get fontIcon() {
              return this._fontIcon
            }
            set fontIcon(t) {
              const e = this._cleanupFontValue(t)
              e !== this._fontIcon &&
                ((this._fontIcon = e), this._updateFontIconClasses())
            }
            _splitIconName(t) {
              if (!t) return ['', '']
              const e = t.split(':')
              switch (e.length) {
                case 1:
                  return ['', e[0]]
                case 2:
                  return e
                default:
                  throw Error(`Invalid icon name: "${t}"`)
              }
            }
            ngOnInit() {
              this._updateFontIconClasses()
            }
            ngAfterViewChecked() {
              const t = this._elementsWithExternalReferences
              if (t && t.size) {
                const t = this._location.getPathname()
                t !== this._previousPath &&
                  ((this._previousPath = t), this._prependPathToReferences(t))
              }
            }
            ngOnDestroy() {
              this._currentIconFetch.unsubscribe(),
                this._elementsWithExternalReferences &&
                  this._elementsWithExternalReferences.clear()
            }
            _usingFontIcon() {
              return !this.svgIcon
            }
            _setSvgElement(t) {
              this._clearSvgElement()
              const e = t.querySelectorAll('style')
              for (let i = 0; i < e.length; i++) e[i].textContent += ' '
              const n = this._location.getPathname()
              ;(this._previousPath = n),
                this._cacheChildrenWithExternalReferences(t),
                this._prependPathToReferences(n),
                this._elementRef.nativeElement.appendChild(t)
            }
            _clearSvgElement() {
              const t = this._elementRef.nativeElement
              let e = t.childNodes.length
              for (
                this._elementsWithExternalReferences &&
                this._elementsWithExternalReferences.clear();
                e--;

              ) {
                const n = t.childNodes[e]
                ;(1 === n.nodeType && 'svg' !== n.nodeName.toLowerCase()) ||
                  t.removeChild(n)
              }
            }
            _updateFontIconClasses() {
              if (!this._usingFontIcon()) return
              const t = this._elementRef.nativeElement,
                e = this.fontSet
                  ? this._iconRegistry.classNameForFontAlias(this.fontSet)
                  : this._iconRegistry.getDefaultFontSetClass()
              e != this._previousFontSetClass &&
                (this._previousFontSetClass &&
                  t.classList.remove(this._previousFontSetClass),
                e && t.classList.add(e),
                (this._previousFontSetClass = e)),
                this.fontIcon != this._previousFontIconClass &&
                  (this._previousFontIconClass &&
                    t.classList.remove(this._previousFontIconClass),
                  this.fontIcon && t.classList.add(this.fontIcon),
                  (this._previousFontIconClass = this.fontIcon))
            }
            _cleanupFontValue(t) {
              return 'string' == typeof t ? t.trim().split(' ')[0] : t
            }
            _prependPathToReferences(t) {
              const e = this._elementsWithExternalReferences
              e &&
                e.forEach((e, n) => {
                  e.forEach((e) => {
                    n.setAttribute(e.name, `url('${t}#${e.value}')`)
                  })
                })
            }
            _cacheChildrenWithExternalReferences(t) {
              const e = t.querySelectorAll(j_),
                n = (this._elementsWithExternalReferences =
                  this._elementsWithExternalReferences || new Map())
              for (let i = 0; i < e.length; i++)
                L_.forEach((t) => {
                  const s = e[i],
                    r = s.getAttribute(t),
                    o = r ? r.match(B_) : null
                  if (o) {
                    let e = n.get(s)
                    e || ((e = []), n.set(s, e)),
                      e.push({ name: t, value: o[1] })
                  }
                })
            }
            _updateSvgIcon(t) {
              if (
                ((this._svgNamespace = null),
                (this._svgName = null),
                this._currentIconFetch.unsubscribe(),
                t)
              ) {
                const [e, n] = this._splitIconName(t)
                e && (this._svgNamespace = e),
                  n && (this._svgName = n),
                  (this._currentIconFetch = this._iconRegistry
                    .getNamedSvgIcon(n, e)
                    .pipe(_d(1))
                    .subscribe(
                      (t) => this._setSvgElement(t),
                      (t) => {
                        this._errorHandler.handleError(
                          new Error(
                            `Error retrieving icon ${e}:${n}! ${t.message}`
                          )
                        )
                      }
                    ))
              }
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                Ao(Va),
                Ao(R_),
                Gn('aria-hidden'),
                Ao(M_),
                Ao(os)
              )
            }),
            (t.ɵcmp = Ut({
              type: t,
              selectors: [['mat-icon']],
              hostAttrs: ['role', 'img', 1, 'mat-icon', 'notranslate'],
              hostVars: 7,
              hostBindings: function (t, e) {
                2 & t &&
                  (Eo(
                    'data-mat-icon-type',
                    e._usingFontIcon() ? 'font' : 'svg'
                  )('data-mat-icon-name', e._svgName || e.fontIcon)(
                    'data-mat-icon-namespace',
                    e._svgNamespace || e.fontSet
                  ),
                  na('mat-icon-inline', e.inline)(
                    'mat-icon-no-color',
                    'primary' !== e.color &&
                      'accent' !== e.color &&
                      'warn' !== e.color
                  ))
              },
              inputs: {
                color: 'color',
                inline: 'inline',
                svgIcon: 'svgIcon',
                fontSet: 'fontSet',
                fontIcon: 'fontIcon',
              },
              exportAs: ['matIcon'],
              features: [po],
              ngContentSelectors: k_,
              decls: 1,
              vars: 0,
              template: function (t, e) {
                1 & t && (Wo(), Ko(0))
              },
              styles: [
                '.mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\n',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        U_ = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[cy], cy],
            })),
            t
          )
        })()
      const z_ = ['contentWrapper']
      function H_(t, e) {
        if (1 & t) {
          const t = Mo()
          Ro(0, 'button', 5),
            Bo('click', function () {
              return Me(t), qo().previous()
            }),
            Ro(1, 'mat-icon'),
            pa(2, 'navigate_before'),
            Po(),
            Po()
        }
      }
      function q_(t, e) {
        if (1 & t) {
          const t = Mo()
          Ro(0, 'button', 6),
            Bo('click', function () {
              return Me(t), qo().next()
            }),
            Ro(1, 'mat-icon'),
            pa(2, 'navigate_next'),
            Po(),
            Po()
        }
      }
      const $_ = ['*']
      let W_ = (() => {
          class t {
            constructor(t, e) {
              ;(this.carousel = t),
                (this.element = e),
                (this.role = 'listitem'),
                (this.width = this.carousel.itemWidth),
                (this.tabindex = '-1')
            }
            focus() {
              this.element.nativeElement.focus({ preventScroll: !0 })
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(Ao(K_), Ao(Va))
            }),
            (t.ɵdir = Kt({
              type: t,
              selectors: [['', 'carousel-item', '']],
              hostVars: 4,
              hostBindings: function (t, e) {
                2 & t &&
                  (ga('tabindex', e.tabindex),
                  Eo('role', e.role),
                  ea('width', e.width, 'px'))
              },
            })),
            t
          )
        })(),
        K_ = (() => {
          class t {
            constructor(t) {
              ;(this.element = t),
                (this.position = 0),
                (this.showPrevArrow = !1),
                (this.showNextArrow = !0),
                (this._index = 0)
            }
            get index() {
              return this._index
            }
            set index(t) {
              ;(this._index = t),
                (this.showPrevArrow = t > 0),
                (this.showNextArrow = t < this.items.length - this.visibleItems)
            }
            onKeydown(t) {
              switch (t.key) {
                case 'Tab':
                  this.focusKeyManager.activeItem ||
                    (this.focusKeyManager.setFirstItemActive(),
                    this._updateItemTabIndices())
                  break
                case 'ArrowLeft':
                  this.focusKeyManager.activeItemIndex === this.index &&
                    this.previous(),
                    this.focusKeyManager.setPreviousItemActive(),
                    this._updateItemTabIndices()
                  break
                case 'ArrowRight':
                  this.focusKeyManager.activeItemIndex ===
                    this.index + this.visibleItems - 1 && this.next(),
                    this.focusKeyManager.setNextItemActive(),
                    this._updateItemTabIndices()
              }
            }
            onResize() {
              this._resizeCarousel()
            }
            ngAfterContentInit() {
              ;(this.focusKeyManager = new Bp(this.items)),
                setTimeout(() => {
                  ;(this.itemsArray = this.items.toArray()),
                    (this.shiftWidth = this.items.first.element.nativeElement.clientWidth),
                    this._resizeCarousel()
                })
            }
            next() {
              this.showNextArrow && this._shiftItems(1)
            }
            previous() {
              this.showPrevArrow && this._shiftItems(-1)
            }
            _updateItemTabIndices() {
              this.items.forEach((t) => {
                t.tabindex = t === this.focusKeyManager.activeItem ? '0' : '-1'
              })
            }
            _shiftItems(t) {
              ;(this.index += t),
                (this.position += t * this.shiftWidth),
                this.items.forEach((t) => {
                  t.element.nativeElement.style.transform = `translateX(-${this.position}px)`
                })
            }
            _resizeCarousel() {
              const t = Math.max(
                1,
                Math.min(
                  Math.floor(
                    this.element.nativeElement.offsetWidth / this.shiftWidth
                  ),
                  this.items.length
                )
              )
              if (this.visibleItems !== t) {
                if (this.visibleItems < t) {
                  const t =
                    this.index - (this.items.length - this.visibleItems) + 1
                  t > 0 && this._shiftItems(-t)
                } else
                  this.focusKeyManager.activeItemIndex &&
                    this.focusKeyManager.activeItemIndex > this.index + t - 1 &&
                    (this.focusKeyManager.setPreviousItemActive(),
                    this._updateItemTabIndices())
                ;(this.visibleItems = t),
                  (this.showNextArrow =
                    this.index < this.items.length - this.visibleItems)
              }
              this.wrapper.nativeElement.style.width =
                this.visibleItems * this.shiftWidth + 'px'
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(Ao(Va))
            }),
            (t.ɵcmp = Ut({
              type: t,
              selectors: [['quertc-carousel']],
              contentQueries: function (t, e, n) {
                if ((1 & t && nc(n, W_, !1), 2 & t)) {
                  let t
                  tc((t = ic())) && (e.items = t)
                }
              },
              viewQuery: function (t, e) {
                if ((1 & t && ec(z_, !0), 2 & t)) {
                  let t
                  tc((t = ic())) && (e.wrapper = t.first)
                }
              },
              inputs: {
                ariaLabel: ['aria-label', 'ariaLabel'],
                itemWidth: 'itemWidth',
              },
              ngContentSelectors: $_,
              decls: 6,
              vars: 4,
              consts: [
                [
                  'role',
                  'region',
                  1,
                  'docs-carousel-content-wrapper',
                  3,
                  'keyup',
                  'resize',
                ],
                ['contentWrapper', ''],
                [
                  'aria-hidden',
                  'true',
                  'tabindex',
                  '-1',
                  'class',
                  'docs-carousel-nav docs-carousel-nav-prev',
                  'mat-mini-fab',
                  '',
                  'aria-label',
                  'previous',
                  3,
                  'click',
                  4,
                  'ngIf',
                ],
                ['role', 'list', 'tabindex', '0', 1, 'docs-carousel-content'],
                [
                  'aria-hidden',
                  'true',
                  'tabindex',
                  '-1',
                  'class',
                  'docs-carousel-nav docs-carousel-nav-next',
                  'mat-mini-fab',
                  '',
                  'aria-label',
                  'next',
                  3,
                  'click',
                  4,
                  'ngIf',
                ],
                [
                  'aria-hidden',
                  'true',
                  'tabindex',
                  '-1',
                  'mat-mini-fab',
                  '',
                  'aria-label',
                  'previous',
                  1,
                  'docs-carousel-nav',
                  'docs-carousel-nav-prev',
                  3,
                  'click',
                ],
                [
                  'aria-hidden',
                  'true',
                  'tabindex',
                  '-1',
                  'mat-mini-fab',
                  '',
                  'aria-label',
                  'next',
                  1,
                  'docs-carousel-nav',
                  'docs-carousel-nav-next',
                  3,
                  'click',
                ],
              ],
              template: function (t, e) {
                1 & t &&
                  (Wo(),
                  Ro(0, 'div', 0, 1),
                  Bo('keyup', function (t) {
                    return e.onKeydown(t)
                  })(
                    'resize',
                    function () {
                      return e.onResize()
                    },
                    !1,
                    cs
                  ),
                  ko(2, H_, 3, 0, 'button', 2),
                  Ro(3, 'div', 3),
                  Ko(4),
                  Po(),
                  ko(5, q_, 3, 0, 'button', 4),
                  Po()),
                  2 & t &&
                    (ea('min-width', e.shiftWidth + 'px'),
                    Xs(2),
                    Oo('ngIf', e.showPrevArrow),
                    Xs(3),
                    Oo('ngIf', e.showNextArrow))
              },
              directives: [Vh, Ky, V_],
              styles: [
                'quertc-carousel{display:flex;align-items:center;justify-content:center;margin:0 40px}.docs-carousel-content{display:flex;flex-direction:row;overflow:hidden;outline:none}.docs-carousel-content-wrapper{position:relative}[carousel-item]{flex-shrink:0;transition:transform .5s ease-in-out}.docs-carousel-nav{position:absolute;top:50%;transform:translateY(-50%)}.docs-carousel-nav-prev{left:-40px}.docs-carousel-nav-next{right:-40px}',
              ],
              encapsulation: 2,
            })),
            t
          )
        })(),
        G_ = (() => {
          class t {
            constructor() {
              ;(this._vertical = !1), (this._inset = !1)
            }
            get vertical() {
              return this._vertical
            }
            set vertical(t) {
              this._vertical = hu(t)
            }
            get inset() {
              return this._inset
            }
            set inset(t) {
              this._inset = hu(t)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵcmp = Ut({
              type: t,
              selectors: [['mat-divider']],
              hostAttrs: ['role', 'separator', 1, 'mat-divider'],
              hostVars: 7,
              hostBindings: function (t, e) {
                2 & t &&
                  (Eo(
                    'aria-orientation',
                    e.vertical ? 'vertical' : 'horizontal'
                  ),
                  na('mat-divider-vertical', e.vertical)(
                    'mat-divider-horizontal',
                    !e.vertical
                  )('mat-divider-inset', e.inset))
              },
              inputs: { vertical: 'vertical', inset: 'inset' },
              decls: 0,
              vars: 0,
              template: function (t, e) {},
              styles: [
                '.mat-divider{display:block;margin:0;border-top-width:1px;border-top-style:solid}.mat-divider.mat-divider-vertical{border-top:0;border-right-width:1px;border-right-style:solid}.mat-divider.mat-divider-inset{margin-left:80px}[dir=rtl] .mat-divider.mat-divider-inset{margin-left:auto;margin-right:80px}\n',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        Q_ = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[cy], cy],
            })),
            t
          )
        })()
      const Z_ = {}
      function Y_(...t) {
        let e = null,
          n = null
        return (
          E(t[t.length - 1]) && (n = t.pop()),
          'function' == typeof t[t.length - 1] && (e = t.pop()),
          1 === t.length && l(t[0]) && (t = t[0]),
          q(t, n).lift(new X_(e))
        )
      }
      class X_ {
        constructor(t) {
          this.resultSelector = t
        }
        call(t, e) {
          return e.subscribe(new J_(t, this.resultSelector))
        }
      }
      class J_ extends N {
        constructor(t, e) {
          super(t),
            (this.resultSelector = e),
            (this.active = 0),
            (this.values = []),
            (this.observables = [])
        }
        _next(t) {
          this.values.push(Z_), this.observables.push(t)
        }
        _complete() {
          const t = this.observables,
            e = t.length
          if (0 === e) this.destination.complete()
          else {
            ;(this.active = e), (this.toRespond = e)
            for (let n = 0; n < e; n++) {
              const e = t[n]
              this.add(D(this, e, e, n))
            }
          }
        }
        notifyComplete(t) {
          0 == (this.active -= 1) && this.destination.complete()
        }
        notifyNext(t, e, n, i, s) {
          const r = this.values,
            o = this.toRespond
              ? r[n] === Z_
                ? --this.toRespond
                : this.toRespond
              : 0
          ;(r[n] = e),
            0 === o &&
              (this.resultSelector
                ? this._tryResultSelector(r)
                : this.destination.next(r.slice()))
        }
        _tryResultSelector(t) {
          let e
          try {
            e = this.resultSelector.apply(this, t)
          } catch (n) {
            return void this.destination.error(n)
          }
          this.destination.next(e)
        }
      }
      const tv = (() => {
        function t() {
          return (
            Error.call(this),
            (this.message = 'no elements in sequence'),
            (this.name = 'EmptyError'),
            this
          )
        }
        return (t.prototype = Object.create(Error.prototype)), t
      })()
      function ev(t) {
        return new _((e) => {
          let n
          try {
            n = t()
          } catch (i) {
            return void e.error(i)
          }
          return (n ? B(n) : Hu()).subscribe(e)
        })
      }
      function nv(t) {
        return function (e) {
          return 0 === t ? Hu() : e.lift(new iv(t))
        }
      }
      class iv {
        constructor(t) {
          if (((this.total = t), this.total < 0)) throw new yd()
        }
        call(t, e) {
          return e.subscribe(new sv(t, this.total))
        }
      }
      class sv extends f {
        constructor(t, e) {
          super(t),
            (this.total = e),
            (this.ring = new Array()),
            (this.count = 0)
        }
        _next(t) {
          const e = this.ring,
            n = this.total,
            i = this.count++
          e.length < n ? e.push(t) : (e[i % n] = t)
        }
        _complete() {
          const t = this.destination
          let e = this.count
          if (e > 0) {
            const n = this.count >= this.total ? this.total : this.count,
              i = this.ring
            for (let s = 0; s < n; s++) {
              const s = e++ % n
              t.next(i[s])
            }
          }
          t.complete()
        }
      }
      function rv(t = lv) {
        return (e) => e.lift(new ov(t))
      }
      class ov {
        constructor(t) {
          this.errorFactory = t
        }
        call(t, e) {
          return e.subscribe(new av(t, this.errorFactory))
        }
      }
      class av extends f {
        constructor(t, e) {
          super(t), (this.errorFactory = e), (this.hasValue = !1)
        }
        _next(t) {
          ;(this.hasValue = !0), this.destination.next(t)
        }
        _complete() {
          if (this.hasValue) return this.destination.complete()
          {
            let e
            try {
              e = this.errorFactory()
            } catch (t) {
              e = t
            }
            this.destination.error(e)
          }
        }
      }
      function lv() {
        return new tv()
      }
      function cv(t = null) {
        return (e) => e.lift(new hv(t))
      }
      class hv {
        constructor(t) {
          this.defaultValue = t
        }
        call(t, e) {
          return e.subscribe(new uv(t, this.defaultValue))
        }
      }
      class uv extends f {
        constructor(t, e) {
          super(t), (this.defaultValue = e), (this.isEmpty = !0)
        }
        _next(t) {
          ;(this.isEmpty = !1), this.destination.next(t)
        }
        _complete() {
          this.isEmpty && this.destination.next(this.defaultValue),
            this.destination.complete()
        }
      }
      class dv {
        constructor(t, e, n = !1) {
          ;(this.accumulator = t), (this.seed = e), (this.hasSeed = n)
        }
        call(t, e) {
          return e.subscribe(
            new pv(t, this.accumulator, this.seed, this.hasSeed)
          )
        }
      }
      class pv extends f {
        constructor(t, e, n, i) {
          super(t),
            (this.accumulator = e),
            (this._seed = n),
            (this.hasSeed = i),
            (this.index = 0)
        }
        get seed() {
          return this._seed
        }
        set seed(t) {
          ;(this.hasSeed = !0), (this._seed = t)
        }
        _next(t) {
          if (this.hasSeed) return this._tryNext(t)
          ;(this.seed = t), this.destination.next(t)
        }
        _tryNext(t) {
          const e = this.index++
          let n
          try {
            n = this.accumulator(this.seed, t, e)
          } catch (i) {
            this.destination.error(i)
          }
          ;(this.seed = n), this.destination.next(n)
        }
      }
      function fv(t, e) {
        const n = arguments.length >= 2
        return (i) =>
          i.pipe(
            t ? Iu((e, n) => t(e, n, i)) : y,
            _d(1),
            n ? cv(e) : rv(() => new tv())
          )
      }
      class mv {
        constructor(t, e) {
          ;(this.id = t), (this.url = e)
        }
      }
      class gv extends mv {
        constructor(t, e, n = 'imperative', i = null) {
          super(t, e), (this.navigationTrigger = n), (this.restoredState = i)
        }
        toString() {
          return `NavigationStart(id: ${this.id}, url: '${this.url}')`
        }
      }
      class yv extends mv {
        constructor(t, e, n) {
          super(t, e), (this.urlAfterRedirects = n)
        }
        toString() {
          return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`
        }
      }
      class _v extends mv {
        constructor(t, e, n) {
          super(t, e), (this.reason = n)
        }
        toString() {
          return `NavigationCancel(id: ${this.id}, url: '${this.url}')`
        }
      }
      class vv extends mv {
        constructor(t, e, n) {
          super(t, e), (this.error = n)
        }
        toString() {
          return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`
        }
      }
      class bv extends mv {
        constructor(t, e, n, i) {
          super(t, e), (this.urlAfterRedirects = n), (this.state = i)
        }
        toString() {
          return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
        }
      }
      class wv extends mv {
        constructor(t, e, n, i) {
          super(t, e), (this.urlAfterRedirects = n), (this.state = i)
        }
        toString() {
          return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
        }
      }
      class Cv extends mv {
        constructor(t, e, n, i, s) {
          super(t, e),
            (this.urlAfterRedirects = n),
            (this.state = i),
            (this.shouldActivate = s)
        }
        toString() {
          return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`
        }
      }
      class xv extends mv {
        constructor(t, e, n, i) {
          super(t, e), (this.urlAfterRedirects = n), (this.state = i)
        }
        toString() {
          return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
        }
      }
      class Sv extends mv {
        constructor(t, e, n, i) {
          super(t, e), (this.urlAfterRedirects = n), (this.state = i)
        }
        toString() {
          return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
        }
      }
      class Ev {
        constructor(t) {
          this.route = t
        }
        toString() {
          return `RouteConfigLoadStart(path: ${this.route.path})`
        }
      }
      class kv {
        constructor(t) {
          this.route = t
        }
        toString() {
          return `RouteConfigLoadEnd(path: ${this.route.path})`
        }
      }
      class Tv {
        constructor(t) {
          this.snapshot = t
        }
        toString() {
          return `ChildActivationStart(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ''
          }')`
        }
      }
      class Av {
        constructor(t) {
          this.snapshot = t
        }
        toString() {
          return `ChildActivationEnd(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ''
          }')`
        }
      }
      class Ov {
        constructor(t) {
          this.snapshot = t
        }
        toString() {
          return `ActivationStart(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ''
          }')`
        }
      }
      class Iv {
        constructor(t) {
          this.snapshot = t
        }
        toString() {
          return `ActivationEnd(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ''
          }')`
        }
      }
      class Rv {
        constructor(t, e, n) {
          ;(this.routerEvent = t), (this.position = e), (this.anchor = n)
        }
        toString() {
          return `Scroll(anchor: '${this.anchor}', position: '${
            this.position ? `${this.position[0]}, ${this.position[1]}` : null
          }')`
        }
      }
      const Pv = 'primary'
      class Dv {
        constructor(t) {
          this.params = t || {}
        }
        has(t) {
          return Object.prototype.hasOwnProperty.call(this.params, t)
        }
        get(t) {
          if (this.has(t)) {
            const e = this.params[t]
            return Array.isArray(e) ? e[0] : e
          }
          return null
        }
        getAll(t) {
          if (this.has(t)) {
            const e = this.params[t]
            return Array.isArray(e) ? e : [e]
          }
          return []
        }
        get keys() {
          return Object.keys(this.params)
        }
      }
      function Nv(t) {
        return new Dv(t)
      }
      function Fv(t) {
        const e = Error('NavigationCancelingError: ' + t)
        return (e.ngNavigationCancelingError = !0), e
      }
      function Mv(t, e, n) {
        const i = n.path.split('/')
        if (i.length > t.length) return null
        if ('full' === n.pathMatch && (e.hasChildren() || i.length < t.length))
          return null
        const s = {}
        for (let r = 0; r < i.length; r++) {
          const e = i[r],
            n = t[r]
          if (e.startsWith(':')) s[e.substring(1)] = n
          else if (e !== n.path) return null
        }
        return { consumed: t.slice(0, i.length), posParams: s }
      }
      function Lv(t, e) {
        const n = Object.keys(t),
          i = Object.keys(e)
        if (!n || !i || n.length != i.length) return !1
        let s
        for (let r = 0; r < n.length; r++)
          if (((s = n[r]), !jv(t[s], e[s]))) return !1
        return !0
      }
      function jv(t, e) {
        if (Array.isArray(t) && Array.isArray(e)) {
          if (t.length !== e.length) return !1
          const n = [...t].sort(),
            i = [...e].sort()
          return n.every((t, e) => i[e] === t)
        }
        return t === e
      }
      function Bv(t) {
        return Array.prototype.concat.apply([], t)
      }
      function Vv(t) {
        return t.length > 0 ? t[t.length - 1] : null
      }
      function Uv(t, e) {
        for (const n in t) t.hasOwnProperty(n) && e(t[n], n)
      }
      function zv(t) {
        return jo(t) ? t : Lo(t) ? B(Promise.resolve(t)) : mu(t)
      }
      function Hv(t, e, n) {
        return n
          ? (function (t, e) {
              return Lv(t, e)
            })(t.queryParams, e.queryParams) && qv(t.root, e.root)
          : (function (t, e) {
              return (
                Object.keys(e).length <= Object.keys(t).length &&
                Object.keys(e).every((n) => jv(t[n], e[n]))
              )
            })(t.queryParams, e.queryParams) && $v(t.root, e.root)
      }
      function qv(t, e) {
        if (!Zv(t.segments, e.segments)) return !1
        if (t.numberOfChildren !== e.numberOfChildren) return !1
        for (const n in e.children) {
          if (!t.children[n]) return !1
          if (!qv(t.children[n], e.children[n])) return !1
        }
        return !0
      }
      function $v(t, e) {
        return Wv(t, e, e.segments)
      }
      function Wv(t, e, n) {
        if (t.segments.length > n.length)
          return !!Zv(t.segments.slice(0, n.length), n) && !e.hasChildren()
        if (t.segments.length === n.length) {
          if (!Zv(t.segments, n)) return !1
          for (const n in e.children) {
            if (!t.children[n]) return !1
            if (!$v(t.children[n], e.children[n])) return !1
          }
          return !0
        }
        {
          const i = n.slice(0, t.segments.length),
            s = n.slice(t.segments.length)
          return (
            !!Zv(t.segments, i) &&
            !!t.children.primary &&
            Wv(t.children.primary, e, s)
          )
        }
      }
      class Kv {
        constructor(t, e, n) {
          ;(this.root = t), (this.queryParams = e), (this.fragment = n)
        }
        get queryParamMap() {
          return (
            this._queryParamMap || (this._queryParamMap = Nv(this.queryParams)),
            this._queryParamMap
          )
        }
        toString() {
          return tb.serialize(this)
        }
      }
      class Gv {
        constructor(t, e) {
          ;(this.segments = t),
            (this.children = e),
            (this.parent = null),
            Uv(e, (t, e) => (t.parent = this))
        }
        hasChildren() {
          return this.numberOfChildren > 0
        }
        get numberOfChildren() {
          return Object.keys(this.children).length
        }
        toString() {
          return eb(this)
        }
      }
      class Qv {
        constructor(t, e) {
          ;(this.path = t), (this.parameters = e)
        }
        get parameterMap() {
          return (
            this._parameterMap || (this._parameterMap = Nv(this.parameters)),
            this._parameterMap
          )
        }
        toString() {
          return lb(this)
        }
      }
      function Zv(t, e) {
        return t.length === e.length && t.every((t, n) => t.path === e[n].path)
      }
      function Yv(t, e) {
        let n = []
        return (
          Uv(t.children, (t, i) => {
            i === Pv && (n = n.concat(e(t, i)))
          }),
          Uv(t.children, (t, i) => {
            i !== Pv && (n = n.concat(e(t, i)))
          }),
          n
        )
      }
      class Xv {}
      class Jv {
        parse(t) {
          const e = new pb(t)
          return new Kv(
            e.parseRootSegment(),
            e.parseQueryParams(),
            e.parseFragment()
          )
        }
        serialize(t) {
          return `${'/' + nb(t.root, !0)}${(function (t) {
            const e = Object.keys(t).map((e) => {
              const n = t[e]
              return Array.isArray(n)
                ? n.map((t) => `${sb(e)}=${sb(t)}`).join('&')
                : `${sb(e)}=${sb(n)}`
            })
            return e.length ? '?' + e.join('&') : ''
          })(t.queryParams)}${
            'string' == typeof t.fragment ? '#' + encodeURI(t.fragment) : ''
          }`
        }
      }
      const tb = new Jv()
      function eb(t) {
        return t.segments.map((t) => lb(t)).join('/')
      }
      function nb(t, e) {
        if (!t.hasChildren()) return eb(t)
        if (e) {
          const e = t.children.primary ? nb(t.children.primary, !1) : '',
            n = []
          return (
            Uv(t.children, (t, e) => {
              e !== Pv && n.push(`${e}:${nb(t, !1)}`)
            }),
            n.length > 0 ? `${e}(${n.join('//')})` : e
          )
        }
        {
          const e = Yv(t, (e, n) =>
            n === Pv ? [nb(t.children.primary, !1)] : [`${n}:${nb(e, !1)}`]
          )
          return 1 === Object.keys(t.children).length &&
            null != t.children.primary
            ? `${eb(t)}/${e[0]}`
            : `${eb(t)}/(${e.join('//')})`
        }
      }
      function ib(t) {
        return encodeURIComponent(t)
          .replace(/%40/g, '@')
          .replace(/%3A/gi, ':')
          .replace(/%24/g, '$')
          .replace(/%2C/gi, ',')
      }
      function sb(t) {
        return ib(t).replace(/%3B/gi, ';')
      }
      function rb(t) {
        return ib(t)
          .replace(/\(/g, '%28')
          .replace(/\)/g, '%29')
          .replace(/%26/gi, '&')
      }
      function ob(t) {
        return decodeURIComponent(t)
      }
      function ab(t) {
        return ob(t.replace(/\+/g, '%20'))
      }
      function lb(t) {
        return `${rb(t.path)}${
          ((e = t.parameters),
          Object.keys(e)
            .map((t) => `;${rb(t)}=${rb(e[t])}`)
            .join(''))
        }`
        var e
      }
      const cb = /^[^\/()?;=#]+/
      function hb(t) {
        const e = t.match(cb)
        return e ? e[0] : ''
      }
      const ub = /^[^=?&#]+/,
        db = /^[^?&#]+/
      class pb {
        constructor(t) {
          ;(this.url = t), (this.remaining = t)
        }
        parseRootSegment() {
          return (
            this.consumeOptional('/'),
            '' === this.remaining ||
            this.peekStartsWith('?') ||
            this.peekStartsWith('#')
              ? new Gv([], {})
              : new Gv([], this.parseChildren())
          )
        }
        parseQueryParams() {
          const t = {}
          if (this.consumeOptional('?'))
            do {
              this.parseQueryParam(t)
            } while (this.consumeOptional('&'))
          return t
        }
        parseFragment() {
          return this.consumeOptional('#')
            ? decodeURIComponent(this.remaining)
            : null
        }
        parseChildren() {
          if ('' === this.remaining) return {}
          this.consumeOptional('/')
          const t = []
          for (
            this.peekStartsWith('(') || t.push(this.parseSegment());
            this.peekStartsWith('/') &&
            !this.peekStartsWith('//') &&
            !this.peekStartsWith('/(');

          )
            this.capture('/'), t.push(this.parseSegment())
          let e = {}
          this.peekStartsWith('/(') &&
            (this.capture('/'), (e = this.parseParens(!0)))
          let n = {}
          return (
            this.peekStartsWith('(') && (n = this.parseParens(!1)),
            (t.length > 0 || Object.keys(e).length > 0) &&
              (n.primary = new Gv(t, e)),
            n
          )
        }
        parseSegment() {
          const t = hb(this.remaining)
          if ('' === t && this.peekStartsWith(';'))
            throw new Error(
              `Empty path url segment cannot have parameters: '${this.remaining}'.`
            )
          return this.capture(t), new Qv(ob(t), this.parseMatrixParams())
        }
        parseMatrixParams() {
          const t = {}
          for (; this.consumeOptional(';'); ) this.parseParam(t)
          return t
        }
        parseParam(t) {
          const e = hb(this.remaining)
          if (!e) return
          this.capture(e)
          let n = ''
          if (this.consumeOptional('=')) {
            const t = hb(this.remaining)
            t && ((n = t), this.capture(n))
          }
          t[ob(e)] = ob(n)
        }
        parseQueryParam(t) {
          const e = (function (t) {
            const e = t.match(ub)
            return e ? e[0] : ''
          })(this.remaining)
          if (!e) return
          this.capture(e)
          let n = ''
          if (this.consumeOptional('=')) {
            const t = (function (t) {
              const e = t.match(db)
              return e ? e[0] : ''
            })(this.remaining)
            t && ((n = t), this.capture(n))
          }
          const i = ab(e),
            s = ab(n)
          if (t.hasOwnProperty(i)) {
            let e = t[i]
            Array.isArray(e) || ((e = [e]), (t[i] = e)), e.push(s)
          } else t[i] = s
        }
        parseParens(t) {
          const e = {}
          for (
            this.capture('(');
            !this.consumeOptional(')') && this.remaining.length > 0;

          ) {
            const n = hb(this.remaining),
              i = this.remaining[n.length]
            if ('/' !== i && ')' !== i && ';' !== i)
              throw new Error(`Cannot parse url '${this.url}'`)
            let s = void 0
            n.indexOf(':') > -1
              ? ((s = n.substr(0, n.indexOf(':'))),
                this.capture(s),
                this.capture(':'))
              : t && (s = Pv)
            const r = this.parseChildren()
            ;(e[s] = 1 === Object.keys(r).length ? r.primary : new Gv([], r)),
              this.consumeOptional('//')
          }
          return e
        }
        peekStartsWith(t) {
          return this.remaining.startsWith(t)
        }
        consumeOptional(t) {
          return (
            !!this.peekStartsWith(t) &&
            ((this.remaining = this.remaining.substring(t.length)), !0)
          )
        }
        capture(t) {
          if (!this.consumeOptional(t)) throw new Error(`Expected "${t}".`)
        }
      }
      class fb {
        constructor(t) {
          this._root = t
        }
        get root() {
          return this._root.value
        }
        parent(t) {
          const e = this.pathFromRoot(t)
          return e.length > 1 ? e[e.length - 2] : null
        }
        children(t) {
          const e = mb(t, this._root)
          return e ? e.children.map((t) => t.value) : []
        }
        firstChild(t) {
          const e = mb(t, this._root)
          return e && e.children.length > 0 ? e.children[0].value : null
        }
        siblings(t) {
          const e = gb(t, this._root)
          return e.length < 2
            ? []
            : e[e.length - 2].children
                .map((t) => t.value)
                .filter((e) => e !== t)
        }
        pathFromRoot(t) {
          return gb(t, this._root).map((t) => t.value)
        }
      }
      function mb(t, e) {
        if (t === e.value) return e
        for (const n of e.children) {
          const e = mb(t, n)
          if (e) return e
        }
        return null
      }
      function gb(t, e) {
        if (t === e.value) return [e]
        for (const n of e.children) {
          const i = gb(t, n)
          if (i.length) return i.unshift(e), i
        }
        return []
      }
      class yb {
        constructor(t, e) {
          ;(this.value = t), (this.children = e)
        }
        toString() {
          return `TreeNode(${this.value})`
        }
      }
      function _b(t) {
        const e = {}
        return t && t.children.forEach((t) => (e[t.value.outlet] = t)), e
      }
      class vb extends fb {
        constructor(t, e) {
          super(t), (this.snapshot = e), Eb(this, t)
        }
        toString() {
          return this.snapshot.toString()
        }
      }
      function bb(t, e) {
        const n = (function (t, e) {
            const n = new xb([], {}, {}, '', {}, Pv, e, null, t.root, -1, {})
            return new Sb('', new yb(n, []))
          })(t, e),
          i = new wp([new Qv('', {})]),
          s = new wp({}),
          r = new wp({}),
          o = new wp({}),
          a = new wp(''),
          l = new wb(i, s, o, a, r, Pv, e, n.root)
        return (l.snapshot = n.root), new vb(new yb(l, []), n)
      }
      class wb {
        constructor(t, e, n, i, s, r, o, a) {
          ;(this.url = t),
            (this.params = e),
            (this.queryParams = n),
            (this.fragment = i),
            (this.data = s),
            (this.outlet = r),
            (this.component = o),
            (this._futureSnapshot = a)
        }
        get routeConfig() {
          return this._futureSnapshot.routeConfig
        }
        get root() {
          return this._routerState.root
        }
        get parent() {
          return this._routerState.parent(this)
        }
        get firstChild() {
          return this._routerState.firstChild(this)
        }
        get children() {
          return this._routerState.children(this)
        }
        get pathFromRoot() {
          return this._routerState.pathFromRoot(this)
        }
        get paramMap() {
          return (
            this._paramMap ||
              (this._paramMap = this.params.pipe(F((t) => Nv(t)))),
            this._paramMap
          )
        }
        get queryParamMap() {
          return (
            this._queryParamMap ||
              (this._queryParamMap = this.queryParams.pipe(F((t) => Nv(t)))),
            this._queryParamMap
          )
        }
        toString() {
          return this.snapshot
            ? this.snapshot.toString()
            : `Future(${this._futureSnapshot})`
        }
      }
      function Cb(t, e = 'emptyOnly') {
        const n = t.pathFromRoot
        let i = 0
        if ('always' !== e)
          for (i = n.length - 1; i >= 1; ) {
            const t = n[i],
              e = n[i - 1]
            if (t.routeConfig && '' === t.routeConfig.path) i--
            else {
              if (e.component) break
              i--
            }
          }
        return (function (t) {
          return t.reduce(
            (t, e) => ({
              params: Object.assign(Object.assign({}, t.params), e.params),
              data: Object.assign(Object.assign({}, t.data), e.data),
              resolve: Object.assign(
                Object.assign({}, t.resolve),
                e._resolvedData
              ),
            }),
            { params: {}, data: {}, resolve: {} }
          )
        })(n.slice(i))
      }
      class xb {
        constructor(t, e, n, i, s, r, o, a, l, c, h) {
          ;(this.url = t),
            (this.params = e),
            (this.queryParams = n),
            (this.fragment = i),
            (this.data = s),
            (this.outlet = r),
            (this.component = o),
            (this.routeConfig = a),
            (this._urlSegment = l),
            (this._lastPathIndex = c),
            (this._resolve = h)
        }
        get root() {
          return this._routerState.root
        }
        get parent() {
          return this._routerState.parent(this)
        }
        get firstChild() {
          return this._routerState.firstChild(this)
        }
        get children() {
          return this._routerState.children(this)
        }
        get pathFromRoot() {
          return this._routerState.pathFromRoot(this)
        }
        get paramMap() {
          return (
            this._paramMap || (this._paramMap = Nv(this.params)), this._paramMap
          )
        }
        get queryParamMap() {
          return (
            this._queryParamMap || (this._queryParamMap = Nv(this.queryParams)),
            this._queryParamMap
          )
        }
        toString() {
          return `Route(url:'${this.url
            .map((t) => t.toString())
            .join('/')}', path:'${
            this.routeConfig ? this.routeConfig.path : ''
          }')`
        }
      }
      class Sb extends fb {
        constructor(t, e) {
          super(e), (this.url = t), Eb(this, e)
        }
        toString() {
          return kb(this._root)
        }
      }
      function Eb(t, e) {
        ;(e.value._routerState = t), e.children.forEach((e) => Eb(t, e))
      }
      function kb(t) {
        const e =
          t.children.length > 0 ? ` { ${t.children.map(kb).join(', ')} } ` : ''
        return `${t.value}${e}`
      }
      function Tb(t) {
        if (t.snapshot) {
          const e = t.snapshot,
            n = t._futureSnapshot
          ;(t.snapshot = n),
            Lv(e.queryParams, n.queryParams) ||
              t.queryParams.next(n.queryParams),
            e.fragment !== n.fragment && t.fragment.next(n.fragment),
            Lv(e.params, n.params) || t.params.next(n.params),
            (function (t, e) {
              if (t.length !== e.length) return !1
              for (let n = 0; n < t.length; ++n) if (!Lv(t[n], e[n])) return !1
              return !0
            })(e.url, n.url) || t.url.next(n.url),
            Lv(e.data, n.data) || t.data.next(n.data)
        } else
          (t.snapshot = t._futureSnapshot), t.data.next(t._futureSnapshot.data)
      }
      function Ab(t, e) {
        var n, i
        return (
          Lv(t.params, e.params) &&
          Zv((n = t.url), (i = e.url)) &&
          n.every((t, e) => Lv(t.parameters, i[e].parameters)) &&
          !(!t.parent != !e.parent) &&
          (!t.parent || Ab(t.parent, e.parent))
        )
      }
      function Ob(t, e, n) {
        if (n && t.shouldReuseRoute(e.value, n.value.snapshot)) {
          const i = n.value
          i._futureSnapshot = e.value
          const s = (function (t, e, n) {
            return e.children.map((e) => {
              for (const i of n.children)
                if (t.shouldReuseRoute(e.value, i.value.snapshot))
                  return Ob(t, e, i)
              return Ob(t, e)
            })
          })(t, e, n)
          return new yb(i, s)
        }
        {
          const n = t.retrieve(e.value)
          if (n) {
            const t = n.route
            return Ib(e, t), t
          }
          {
            const n = new wb(
                new wp((i = e.value).url),
                new wp(i.params),
                new wp(i.queryParams),
                new wp(i.fragment),
                new wp(i.data),
                i.outlet,
                i.component,
                i
              ),
              s = e.children.map((e) => Ob(t, e))
            return new yb(n, s)
          }
        }
        var i
      }
      function Ib(t, e) {
        if (t.value.routeConfig !== e.value.routeConfig)
          throw new Error(
            'Cannot reattach ActivatedRouteSnapshot created from a different route'
          )
        if (t.children.length !== e.children.length)
          throw new Error(
            'Cannot reattach ActivatedRouteSnapshot with a different number of children'
          )
        e.value._futureSnapshot = t.value
        for (let n = 0; n < t.children.length; ++n)
          Ib(t.children[n], e.children[n])
      }
      function Rb(t) {
        return 'object' == typeof t && null != t && !t.outlets && !t.segmentPath
      }
      function Pb(t) {
        return 'object' == typeof t && null != t && t.outlets
      }
      function Db(t, e, n, i, s) {
        let r = {}
        return (
          i &&
            Uv(i, (t, e) => {
              r[e] = Array.isArray(t) ? t.map((t) => '' + t) : '' + t
            }),
          new Kv(n.root === t ? e : Nb(n.root, t, e), r, s)
        )
      }
      function Nb(t, e, n) {
        const i = {}
        return (
          Uv(t.children, (t, s) => {
            i[s] = t === e ? n : Nb(t, e, n)
          }),
          new Gv(t.segments, i)
        )
      }
      class Fb {
        constructor(t, e, n) {
          if (
            ((this.isAbsolute = t),
            (this.numberOfDoubleDots = e),
            (this.commands = n),
            t && n.length > 0 && Rb(n[0]))
          )
            throw new Error('Root segment cannot have matrix parameters')
          const i = n.find(Pb)
          if (i && i !== Vv(n))
            throw new Error('{outlets:{}} has to be the last command')
        }
        toRoot() {
          return (
            this.isAbsolute &&
            1 === this.commands.length &&
            '/' == this.commands[0]
          )
        }
      }
      class Mb {
        constructor(t, e, n) {
          ;(this.segmentGroup = t), (this.processChildren = e), (this.index = n)
        }
      }
      function Lb(t, e, n) {
        if (
          (t || (t = new Gv([], {})),
          0 === t.segments.length && t.hasChildren())
        )
          return jb(t, e, n)
        const i = (function (t, e, n) {
            let i = 0,
              s = e
            const r = { match: !1, pathIndex: 0, commandIndex: 0 }
            for (; s < t.segments.length; ) {
              if (i >= n.length) return r
              const e = t.segments[s],
                o = n[i]
              if (Pb(o)) break
              const a = '' + o,
                l = i < n.length - 1 ? n[i + 1] : null
              if (s > 0 && void 0 === a) break
              if (a && l && 'object' == typeof l && void 0 === l.outlets) {
                if (!zb(a, l, e)) return r
                i += 2
              } else {
                if (!zb(a, {}, e)) return r
                i++
              }
              s++
            }
            return { match: !0, pathIndex: s, commandIndex: i }
          })(t, e, n),
          s = n.slice(i.commandIndex)
        if (i.match && i.pathIndex < t.segments.length) {
          const e = new Gv(t.segments.slice(0, i.pathIndex), {})
          return (
            (e.children.primary = new Gv(
              t.segments.slice(i.pathIndex),
              t.children
            )),
            jb(e, 0, s)
          )
        }
        return i.match && 0 === s.length
          ? new Gv(t.segments, {})
          : i.match && !t.hasChildren()
          ? Bb(t, e, n)
          : i.match
          ? jb(t, 0, s)
          : Bb(t, e, n)
      }
      function jb(t, e, n) {
        if (0 === n.length) return new Gv(t.segments, {})
        {
          const i = (function (t) {
              return Pb(t[0]) ? t[0].outlets : { [Pv]: t }
            })(n),
            s = {}
          return (
            Uv(i, (n, i) => {
              'string' == typeof n && (n = [n]),
                null !== n && (s[i] = Lb(t.children[i], e, n))
            }),
            Uv(t.children, (t, e) => {
              void 0 === i[e] && (s[e] = t)
            }),
            new Gv(t.segments, s)
          )
        }
      }
      function Bb(t, e, n) {
        const i = t.segments.slice(0, e)
        let s = 0
        for (; s < n.length; ) {
          const r = n[s]
          if (Pb(r)) {
            const t = Vb(r.outlets)
            return new Gv(i, t)
          }
          if (0 === s && Rb(n[0])) {
            i.push(new Qv(t.segments[e].path, n[0])), s++
            continue
          }
          const o = Pb(r) ? r.outlets.primary : '' + r,
            a = s < n.length - 1 ? n[s + 1] : null
          o && a && Rb(a)
            ? (i.push(new Qv(o, Ub(a))), (s += 2))
            : (i.push(new Qv(o, {})), s++)
        }
        return new Gv(i, {})
      }
      function Vb(t) {
        const e = {}
        return (
          Uv(t, (t, n) => {
            'string' == typeof t && (t = [t]),
              null !== t && (e[n] = Bb(new Gv([], {}), 0, t))
          }),
          e
        )
      }
      function Ub(t) {
        const e = {}
        return Uv(t, (t, n) => (e[n] = '' + t)), e
      }
      function zb(t, e, n) {
        return t == n.path && Lv(e, n.parameters)
      }
      class Hb {
        constructor(t, e, n, i) {
          ;(this.routeReuseStrategy = t),
            (this.futureState = e),
            (this.currState = n),
            (this.forwardEvent = i)
        }
        activate(t) {
          const e = this.futureState._root,
            n = this.currState ? this.currState._root : null
          this.deactivateChildRoutes(e, n, t),
            Tb(this.futureState.root),
            this.activateChildRoutes(e, n, t)
        }
        deactivateChildRoutes(t, e, n) {
          const i = _b(e)
          t.children.forEach((t) => {
            const e = t.value.outlet
            this.deactivateRoutes(t, i[e], n), delete i[e]
          }),
            Uv(i, (t, e) => {
              this.deactivateRouteAndItsChildren(t, n)
            })
        }
        deactivateRoutes(t, e, n) {
          const i = t.value,
            s = e ? e.value : null
          if (i === s)
            if (i.component) {
              const s = n.getContext(i.outlet)
              s && this.deactivateChildRoutes(t, e, s.children)
            } else this.deactivateChildRoutes(t, e, n)
          else s && this.deactivateRouteAndItsChildren(e, n)
        }
        deactivateRouteAndItsChildren(t, e) {
          this.routeReuseStrategy.shouldDetach(t.value.snapshot)
            ? this.detachAndStoreRouteSubtree(t, e)
            : this.deactivateRouteAndOutlet(t, e)
        }
        detachAndStoreRouteSubtree(t, e) {
          const n = e.getContext(t.value.outlet)
          if (n && n.outlet) {
            const e = n.outlet.detach(),
              i = n.children.onOutletDeactivated()
            this.routeReuseStrategy.store(t.value.snapshot, {
              componentRef: e,
              route: t,
              contexts: i,
            })
          }
        }
        deactivateRouteAndOutlet(t, e) {
          const n = e.getContext(t.value.outlet)
          if (n) {
            const i = _b(t),
              s = t.value.component ? n.children : e
            Uv(i, (t, e) => this.deactivateRouteAndItsChildren(t, s)),
              n.outlet &&
                (n.outlet.deactivate(), n.children.onOutletDeactivated())
          }
        }
        activateChildRoutes(t, e, n) {
          const i = _b(e)
          t.children.forEach((t) => {
            this.activateRoutes(t, i[t.value.outlet], n),
              this.forwardEvent(new Iv(t.value.snapshot))
          }),
            t.children.length && this.forwardEvent(new Av(t.value.snapshot))
        }
        activateRoutes(t, e, n) {
          const i = t.value,
            s = e ? e.value : null
          if ((Tb(i), i === s))
            if (i.component) {
              const s = n.getOrCreateContext(i.outlet)
              this.activateChildRoutes(t, e, s.children)
            } else this.activateChildRoutes(t, e, n)
          else if (i.component) {
            const e = n.getOrCreateContext(i.outlet)
            if (this.routeReuseStrategy.shouldAttach(i.snapshot)) {
              const t = this.routeReuseStrategy.retrieve(i.snapshot)
              this.routeReuseStrategy.store(i.snapshot, null),
                e.children.onOutletReAttached(t.contexts),
                (e.attachRef = t.componentRef),
                (e.route = t.route.value),
                e.outlet && e.outlet.attach(t.componentRef, t.route.value),
                qb(t.route)
            } else {
              const n = (function (t) {
                  for (let e = t.parent; e; e = e.parent) {
                    const t = e.routeConfig
                    if (t && t._loadedConfig) return t._loadedConfig
                    if (t && t.component) return null
                  }
                  return null
                })(i.snapshot),
                s = n ? n.module.componentFactoryResolver : null
              ;(e.attachRef = null),
                (e.route = i),
                (e.resolver = s),
                e.outlet && e.outlet.activateWith(i, s),
                this.activateChildRoutes(t, null, e.children)
            }
          } else this.activateChildRoutes(t, null, n)
        }
      }
      function qb(t) {
        Tb(t.value), t.children.forEach(qb)
      }
      class $b {
        constructor(t, e) {
          ;(this.routes = t), (this.module = e)
        }
      }
      function Wb(t) {
        return 'function' == typeof t
      }
      function Kb(t) {
        return t instanceof Kv
      }
      const Gb = Symbol('INITIAL_VALUE')
      function Qb() {
        return Bu((t) =>
          Y_(...t.map((t) => t.pipe(_d(1), ju(Gb)))).pipe(
            (function (t, e) {
              let n = !1
              return (
                arguments.length >= 2 && (n = !0),
                function (i) {
                  return i.lift(new dv(t, e, n))
                }
              )
            })((t, e) => {
              let n = !1
              return e.reduce((t, i, s) => {
                if (t !== Gb) return t
                if ((i === Gb && (n = !0), !n)) {
                  if (!1 === i) return i
                  if (s === e.length - 1 || Kb(i)) return i
                }
                return t
              }, t)
            }, Gb),
            Iu((t) => t !== Gb),
            F((t) => (Kb(t) ? t : !0 === t)),
            _d(1)
          )
        )
      }
      let Zb = (() => {
        class t {}
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵcmp = Ut({
            type: t,
            selectors: [['ng-component']],
            decls: 1,
            vars: 0,
            template: function (t, e) {
              1 & t && Do(0, 'router-outlet')
            },
            directives: function () {
              return [zw]
            },
            encapsulation: 2,
          })),
          t
        )
      })()
      function Yb(t, e = '') {
        for (let n = 0; n < t.length; n++) {
          const i = t[n]
          Xb(i, Jb(e, i))
        }
      }
      function Xb(t, e) {
        t.children && Yb(t.children, e)
      }
      function Jb(t, e) {
        return e
          ? t || e.path
            ? t && !e.path
              ? t + '/'
              : !t && e.path
              ? e.path
              : `${t}/${e.path}`
            : ''
          : t
      }
      function tw(t) {
        const e = t.children && t.children.map(tw),
          n = e
            ? Object.assign(Object.assign({}, t), { children: e })
            : Object.assign({}, t)
        return (
          !n.component &&
            (e || n.loadChildren) &&
            n.outlet &&
            n.outlet !== Pv &&
            (n.component = Zb),
          n
        )
      }
      function ew(t) {
        return t.outlet || Pv
      }
      class nw {
        constructor(t) {
          this.segmentGroup = t || null
        }
      }
      class iw {
        constructor(t) {
          this.urlTree = t
        }
      }
      function sw(t) {
        return new _((e) => e.error(new nw(t)))
      }
      function rw(t) {
        return new _((e) => e.error(new iw(t)))
      }
      function ow(t) {
        return new _((e) =>
          e.error(
            new Error(
              `Only absolute redirects can have named outlets. redirectTo: '${t}'`
            )
          )
        )
      }
      class aw {
        constructor(t, e, n, i, s) {
          ;(this.configLoader = e),
            (this.urlSerializer = n),
            (this.urlTree = i),
            (this.config = s),
            (this.allowRedirects = !0),
            (this.ngModule = t.get(vl))
        }
        apply() {
          return this.expandSegmentGroup(
            this.ngModule,
            this.config,
            this.urlTree.root,
            Pv
          )
            .pipe(
              F((t) =>
                this.createUrlTree(
                  t,
                  this.urlTree.queryParams,
                  this.urlTree.fragment
                )
              )
            )
            .pipe(
              o_((t) => {
                if (t instanceof iw)
                  return (this.allowRedirects = !1), this.match(t.urlTree)
                if (t instanceof nw) throw this.noMatchError(t)
                throw t
              })
            )
        }
        match(t) {
          return this.expandSegmentGroup(this.ngModule, this.config, t.root, Pv)
            .pipe(F((e) => this.createUrlTree(e, t.queryParams, t.fragment)))
            .pipe(
              o_((t) => {
                if (t instanceof nw) throw this.noMatchError(t)
                throw t
              })
            )
        }
        noMatchError(t) {
          return new Error(
            `Cannot match any routes. URL Segment: '${t.segmentGroup}'`
          )
        }
        createUrlTree(t, e, n) {
          const i = t.segments.length > 0 ? new Gv([], { [Pv]: t }) : t
          return new Kv(i, e, n)
        }
        expandSegmentGroup(t, e, n, i) {
          return 0 === n.segments.length && n.hasChildren()
            ? this.expandChildren(t, e, n).pipe(F((t) => new Gv([], t)))
            : this.expandSegment(t, n, e, n.segments, i, !0)
        }
        expandChildren(t, e, n) {
          return (function (t, e) {
            if (0 === Object.keys(t).length) return mu({})
            const n = [],
              i = [],
              s = {}
            return (
              Uv(t, (t, r) => {
                const o = e(r, t).pipe(F((t) => (s[r] = t)))
                r === Pv ? n.push(o) : i.push(o)
              }),
              mu.apply(null, n.concat(i)).pipe(
                Mu(),
                (function (t, e) {
                  const n = arguments.length >= 2
                  return (i) =>
                    i.pipe(
                      t ? Iu((e, n) => t(e, n, i)) : y,
                      nv(1),
                      n ? cv(e) : rv(() => new tv())
                    )
                })(),
                F(() => s)
              )
            )
          })(n.children, (n, i) => this.expandSegmentGroup(t, e, i, n))
        }
        expandSegment(t, e, n, i, s, r) {
          const o = (function (t) {
            return t.reduce((t, e) => {
              const n = ew(e)
              return t.has(n) ? t.get(n).push(e) : t.set(n, [e]), t
            }, new Map())
          })(n)
          o.has(s) || o.set(s, [])
          const a = (n) =>
            B(n).pipe(
              d_((o) =>
                this.expandSegmentAgainstRoute(t, e, n, o, i, s, r).pipe(
                  o_((t) => {
                    if (t instanceof nw) return mu(null)
                    throw t
                  })
                )
              ),
              fv((t) => null !== t),
              o_((t) => {
                if (t instanceof tv || 'EmptyError' === t.name) {
                  if (this.noLeftoversInUrl(e, i, s)) return mu(new Gv([], {}))
                  throw new nw(e)
                }
                throw t
              })
            )
          return B(
            Array.from(o.entries()).map(([t, e]) => {
              const n = a(e)
              return t === s
                ? n
                : n.pipe(
                    F(() => null),
                    o_(() => mu(null))
                  )
            })
          ).pipe(
            (t) => t.lift(new X_(void 0)),
            fv(),
            F((t) => t.find((t) => null !== t))
          )
        }
        noLeftoversInUrl(t, e, n) {
          return 0 === e.length && !t.children[n]
        }
        expandSegmentAgainstRoute(t, e, n, i, s, r, o) {
          return ew(i) !== r && '' !== i.path
            ? sw(e)
            : void 0 === i.redirectTo
            ? this.matchSegmentAgainstRoute(t, e, i, s)
            : o && this.allowRedirects
            ? this.expandSegmentAgainstRouteUsingRedirect(t, e, n, i, s, r)
            : sw(e)
        }
        expandSegmentAgainstRouteUsingRedirect(t, e, n, i, s, r) {
          return '**' === i.path
            ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, n, i, r)
            : this.expandRegularSegmentAgainstRouteUsingRedirect(
                t,
                e,
                n,
                i,
                s,
                r
              )
        }
        expandWildCardWithParamsAgainstRouteUsingRedirect(t, e, n, i) {
          const s = this.applyRedirectCommands([], n.redirectTo, {})
          return n.redirectTo.startsWith('/')
            ? rw(s)
            : this.lineralizeSegments(n, s).pipe(
                V((n) => {
                  const s = new Gv(n, {})
                  return this.expandSegment(t, s, e, n, i, !1)
                })
              )
        }
        expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, i, s, r) {
          const {
            matched: o,
            consumedSegments: a,
            lastChild: l,
            positionalParamSegments: c,
          } = lw(e, i, s)
          if (!o) return sw(e)
          const h = this.applyRedirectCommands(a, i.redirectTo, c)
          return i.redirectTo.startsWith('/')
            ? rw(h)
            : this.lineralizeSegments(i, h).pipe(
                V((i) =>
                  this.expandSegment(t, e, n, i.concat(s.slice(l)), r, !1)
                )
              )
        }
        matchSegmentAgainstRoute(t, e, n, i) {
          if ('**' === n.path)
            return n.loadChildren
              ? this.configLoader
                  .load(t.injector, n)
                  .pipe(F((t) => ((n._loadedConfig = t), new Gv(i, {}))))
              : mu(new Gv(i, {}))
          const { matched: s, consumedSegments: r, lastChild: o } = lw(e, n, i)
          if (!s) return sw(e)
          const a = i.slice(o)
          return this.getChildConfig(t, n, i).pipe(
            V((t) => {
              const n = t.module,
                i = t.routes,
                { segmentGroup: s, slicedSegments: o } = (function (
                  t,
                  e,
                  n,
                  i
                ) {
                  return n.length > 0 &&
                    (function (t, e, n) {
                      return n.some((n) => hw(t, e, n) && ew(n) !== Pv)
                    })(t, n, i)
                    ? {
                        segmentGroup: cw(
                          new Gv(
                            e,
                            (function (t, e) {
                              const n = {}
                              n.primary = e
                              for (const i of t)
                                '' === i.path &&
                                  ew(i) !== Pv &&
                                  (n[ew(i)] = new Gv([], {}))
                              return n
                            })(i, new Gv(n, t.children))
                          )
                        ),
                        slicedSegments: [],
                      }
                    : 0 === n.length &&
                      (function (t, e, n) {
                        return n.some((n) => hw(t, e, n))
                      })(t, n, i)
                    ? {
                        segmentGroup: cw(
                          new Gv(
                            t.segments,
                            (function (t, e, n, i) {
                              const s = {}
                              for (const r of n)
                                hw(t, e, r) &&
                                  !i[ew(r)] &&
                                  (s[ew(r)] = new Gv([], {}))
                              return Object.assign(Object.assign({}, i), s)
                            })(t, n, i, t.children)
                          )
                        ),
                        slicedSegments: n,
                      }
                    : { segmentGroup: t, slicedSegments: n }
                })(e, r, a, i)
              return 0 === o.length && s.hasChildren()
                ? this.expandChildren(n, i, s).pipe(F((t) => new Gv(r, t)))
                : 0 === i.length && 0 === o.length
                ? mu(new Gv(r, {}))
                : this.expandSegment(n, s, i, o, Pv, !0).pipe(
                    F((t) => new Gv(r.concat(t.segments), t.children))
                  )
            })
          )
        }
        getChildConfig(t, e, n) {
          return e.children
            ? mu(new $b(e.children, t))
            : e.loadChildren
            ? void 0 !== e._loadedConfig
              ? mu(e._loadedConfig)
              : this.runCanLoadGuards(t.injector, e, n).pipe(
                  V((n) =>
                    n
                      ? this.configLoader
                          .load(t.injector, e)
                          .pipe(F((t) => ((e._loadedConfig = t), t)))
                      : (function (t) {
                          return new _((e) =>
                            e.error(
                              Fv(
                                `Cannot load children because the guard of the route "path: '${t.path}'" returned false`
                              )
                            )
                          )
                        })(e)
                  )
                )
            : mu(new $b([], t))
        }
        runCanLoadGuards(t, e, n) {
          const i = e.canLoad
          return i && 0 !== i.length
            ? mu(
                i.map((i) => {
                  const s = t.get(i)
                  let r
                  if (
                    (function (t) {
                      return t && Wb(t.canLoad)
                    })(s)
                  )
                    r = s.canLoad(e, n)
                  else {
                    if (!Wb(s)) throw new Error('Invalid CanLoad guard')
                    r = s(e, n)
                  }
                  return zv(r)
                })
              ).pipe(
                Qb(),
                xp((t) => {
                  if (!Kb(t)) return
                  const e = Fv(
                    `Redirecting to "${this.urlSerializer.serialize(t)}"`
                  )
                  throw ((e.url = t), e)
                }),
                F((t) => !0 === t)
              )
            : mu(!0)
        }
        lineralizeSegments(t, e) {
          let n = [],
            i = e.root
          for (;;) {
            if (((n = n.concat(i.segments)), 0 === i.numberOfChildren))
              return mu(n)
            if (i.numberOfChildren > 1 || !i.children.primary)
              return ow(t.redirectTo)
            i = i.children.primary
          }
        }
        applyRedirectCommands(t, e, n) {
          return this.applyRedirectCreatreUrlTree(
            e,
            this.urlSerializer.parse(e),
            t,
            n
          )
        }
        applyRedirectCreatreUrlTree(t, e, n, i) {
          const s = this.createSegmentGroup(t, e.root, n, i)
          return new Kv(
            s,
            this.createQueryParams(e.queryParams, this.urlTree.queryParams),
            e.fragment
          )
        }
        createQueryParams(t, e) {
          const n = {}
          return (
            Uv(t, (t, i) => {
              if ('string' == typeof t && t.startsWith(':')) {
                const s = t.substring(1)
                n[i] = e[s]
              } else n[i] = t
            }),
            n
          )
        }
        createSegmentGroup(t, e, n, i) {
          const s = this.createSegments(t, e.segments, n, i)
          let r = {}
          return (
            Uv(e.children, (e, s) => {
              r[s] = this.createSegmentGroup(t, e, n, i)
            }),
            new Gv(s, r)
          )
        }
        createSegments(t, e, n, i) {
          return e.map((e) =>
            e.path.startsWith(':')
              ? this.findPosParam(t, e, i)
              : this.findOrReturn(e, n)
          )
        }
        findPosParam(t, e, n) {
          const i = n[e.path.substring(1)]
          if (!i)
            throw new Error(
              `Cannot redirect to '${t}'. Cannot find '${e.path}'.`
            )
          return i
        }
        findOrReturn(t, e) {
          let n = 0
          for (const i of e) {
            if (i.path === t.path) return e.splice(n), i
            n++
          }
          return t
        }
      }
      function lw(t, e, n) {
        if ('' === e.path)
          return 'full' === e.pathMatch && (t.hasChildren() || n.length > 0)
            ? {
                matched: !1,
                consumedSegments: [],
                lastChild: 0,
                positionalParamSegments: {},
              }
            : {
                matched: !0,
                consumedSegments: [],
                lastChild: 0,
                positionalParamSegments: {},
              }
        const i = (e.matcher || Mv)(n, t, e)
        return i
          ? {
              matched: !0,
              consumedSegments: i.consumed,
              lastChild: i.consumed.length,
              positionalParamSegments: i.posParams,
            }
          : {
              matched: !1,
              consumedSegments: [],
              lastChild: 0,
              positionalParamSegments: {},
            }
      }
      function cw(t) {
        if (1 === t.numberOfChildren && t.children.primary) {
          const e = t.children.primary
          return new Gv(t.segments.concat(e.segments), e.children)
        }
        return t
      }
      function hw(t, e, n) {
        return (
          (!(t.hasChildren() || e.length > 0) || 'full' !== n.pathMatch) &&
          '' === n.path &&
          void 0 !== n.redirectTo
        )
      }
      class uw {
        constructor(t) {
          ;(this.path = t), (this.route = this.path[this.path.length - 1])
        }
      }
      class dw {
        constructor(t, e) {
          ;(this.component = t), (this.route = e)
        }
      }
      function pw(t, e, n) {
        const i = t._root
        return mw(i, e ? e._root : null, n, [i.value])
      }
      function fw(t, e, n) {
        const i = (function (t) {
          if (!t) return null
          for (let e = t.parent; e; e = e.parent) {
            const t = e.routeConfig
            if (t && t._loadedConfig) return t._loadedConfig
          }
          return null
        })(e)
        return (i ? i.module.injector : n).get(t)
      }
      function mw(
        t,
        e,
        n,
        i,
        s = { canDeactivateChecks: [], canActivateChecks: [] }
      ) {
        const r = _b(e)
        return (
          t.children.forEach((t) => {
            !(function (
              t,
              e,
              n,
              i,
              s = { canDeactivateChecks: [], canActivateChecks: [] }
            ) {
              const r = t.value,
                o = e ? e.value : null,
                a = n ? n.getContext(t.value.outlet) : null
              if (o && r.routeConfig === o.routeConfig) {
                const l = (function (t, e, n) {
                  if ('function' == typeof n) return n(t, e)
                  switch (n) {
                    case 'pathParamsChange':
                      return !Zv(t.url, e.url)
                    case 'pathParamsOrQueryParamsChange':
                      return (
                        !Zv(t.url, e.url) || !Lv(t.queryParams, e.queryParams)
                      )
                    case 'always':
                      return !0
                    case 'paramsOrQueryParamsChange':
                      return !Ab(t, e) || !Lv(t.queryParams, e.queryParams)
                    case 'paramsChange':
                    default:
                      return !Ab(t, e)
                  }
                })(o, r, r.routeConfig.runGuardsAndResolvers)
                l
                  ? s.canActivateChecks.push(new uw(i))
                  : ((r.data = o.data), (r._resolvedData = o._resolvedData)),
                  mw(t, e, r.component ? (a ? a.children : null) : n, i, s),
                  l &&
                    a &&
                    a.outlet &&
                    a.outlet.isActivated &&
                    s.canDeactivateChecks.push(new dw(a.outlet.component, o))
              } else
                o && gw(e, a, s),
                  s.canActivateChecks.push(new uw(i)),
                  mw(t, null, r.component ? (a ? a.children : null) : n, i, s)
            })(t, r[t.value.outlet], n, i.concat([t.value]), s),
              delete r[t.value.outlet]
          }),
          Uv(r, (t, e) => gw(t, n.getContext(e), s)),
          s
        )
      }
      function gw(t, e, n) {
        const i = _b(t),
          s = t.value
        Uv(i, (t, i) => {
          gw(t, s.component ? (e ? e.children.getContext(i) : null) : e, n)
        }),
          n.canDeactivateChecks.push(
            new dw(
              s.component && e && e.outlet && e.outlet.isActivated
                ? e.outlet.component
                : null,
              s
            )
          )
      }
      function yw(t, e) {
        return null !== t && e && e(new Ov(t)), mu(!0)
      }
      function _w(t, e) {
        return null !== t && e && e(new Tv(t)), mu(!0)
      }
      function vw(t, e, n) {
        const i = e.routeConfig ? e.routeConfig.canActivate : null
        return i && 0 !== i.length
          ? mu(
              i.map((i) =>
                ev(() => {
                  const s = fw(i, e, n)
                  let r
                  if (
                    (function (t) {
                      return t && Wb(t.canActivate)
                    })(s)
                  )
                    r = zv(s.canActivate(e, t))
                  else {
                    if (!Wb(s)) throw new Error('Invalid CanActivate guard')
                    r = zv(s(e, t))
                  }
                  return r.pipe(fv())
                })
              )
            ).pipe(Qb())
          : mu(!0)
      }
      function bw(t, e, n) {
        const i = e[e.length - 1],
          s = e
            .slice(0, e.length - 1)
            .reverse()
            .map((t) =>
              (function (t) {
                const e = t.routeConfig ? t.routeConfig.canActivateChild : null
                return e && 0 !== e.length ? { node: t, guards: e } : null
              })(t)
            )
            .filter((t) => null !== t)
            .map((e) =>
              ev(() =>
                mu(
                  e.guards.map((s) => {
                    const r = fw(s, e.node, n)
                    let o
                    if (
                      (function (t) {
                        return t && Wb(t.canActivateChild)
                      })(r)
                    )
                      o = zv(r.canActivateChild(i, t))
                    else {
                      if (!Wb(r))
                        throw new Error('Invalid CanActivateChild guard')
                      o = zv(r(i, t))
                    }
                    return o.pipe(fv())
                  })
                ).pipe(Qb())
              )
            )
        return mu(s).pipe(Qb())
      }
      class ww {}
      class Cw {
        constructor(t, e, n, i, s, r) {
          ;(this.rootComponentType = t),
            (this.config = e),
            (this.urlTree = n),
            (this.url = i),
            (this.paramsInheritanceStrategy = s),
            (this.relativeLinkResolution = r)
        }
        recognize() {
          try {
            const t = Ew(
                this.urlTree.root,
                [],
                [],
                this.config,
                this.relativeLinkResolution
              ).segmentGroup,
              e = this.processSegmentGroup(this.config, t, Pv),
              n = new xb(
                [],
                Object.freeze({}),
                Object.freeze(Object.assign({}, this.urlTree.queryParams)),
                this.urlTree.fragment,
                {},
                Pv,
                this.rootComponentType,
                null,
                this.urlTree.root,
                -1,
                {}
              ),
              i = new yb(n, e),
              s = new Sb(this.url, i)
            return this.inheritParamsAndData(s._root), mu(s)
          } catch (t) {
            return new _((e) => e.error(t))
          }
        }
        inheritParamsAndData(t) {
          const e = t.value,
            n = Cb(e, this.paramsInheritanceStrategy)
          ;(e.params = Object.freeze(n.params)),
            (e.data = Object.freeze(n.data)),
            t.children.forEach((t) => this.inheritParamsAndData(t))
        }
        processSegmentGroup(t, e, n) {
          return 0 === e.segments.length && e.hasChildren()
            ? this.processChildren(t, e)
            : this.processSegment(t, e, e.segments, n)
        }
        processChildren(t, e) {
          const n = Yv(e, (e, n) => this.processSegmentGroup(t, e, n))
          return (
            (function (t) {
              const e = {}
              t.forEach((t) => {
                const n = e[t.value.outlet]
                if (n) {
                  const e = n.url.map((t) => t.toString()).join('/'),
                    i = t.value.url.map((t) => t.toString()).join('/')
                  throw new Error(
                    `Two segments cannot have the same outlet name: '${e}' and '${i}'.`
                  )
                }
                e[t.value.outlet] = t.value
              })
            })(n),
            n.sort((t, e) =>
              t.value.outlet === Pv
                ? -1
                : e.value.outlet === Pv
                ? 1
                : t.value.outlet.localeCompare(e.value.outlet)
            ),
            n
          )
        }
        processSegment(t, e, n, i) {
          for (const r of t)
            try {
              return this.processSegmentAgainstRoute(r, e, n, i)
            } catch (s) {
              if (!(s instanceof ww)) throw s
            }
          if (this.noLeftoversInUrl(e, n, i)) return []
          throw new ww()
        }
        noLeftoversInUrl(t, e, n) {
          return 0 === e.length && !t.children[n]
        }
        processSegmentAgainstRoute(t, e, n, i) {
          if (t.redirectTo) throw new ww()
          if ((t.outlet || Pv) !== i) throw new ww()
          let s,
            r = [],
            o = []
          if ('**' === t.path) {
            const r = n.length > 0 ? Vv(n).parameters : {}
            s = new xb(
              n,
              r,
              Object.freeze(Object.assign({}, this.urlTree.queryParams)),
              this.urlTree.fragment,
              Tw(t),
              i,
              t.component,
              t,
              xw(e),
              Sw(e) + n.length,
              Aw(t)
            )
          } else {
            const a = (function (t, e, n) {
              if ('' === e.path) {
                if ('full' === e.pathMatch && (t.hasChildren() || n.length > 0))
                  throw new ww()
                return { consumedSegments: [], lastChild: 0, parameters: {} }
              }
              const i = (e.matcher || Mv)(n, t, e)
              if (!i) throw new ww()
              const s = {}
              Uv(i.posParams, (t, e) => {
                s[e] = t.path
              })
              const r =
                i.consumed.length > 0
                  ? Object.assign(
                      Object.assign({}, s),
                      i.consumed[i.consumed.length - 1].parameters
                    )
                  : s
              return {
                consumedSegments: i.consumed,
                lastChild: i.consumed.length,
                parameters: r,
              }
            })(e, t, n)
            ;(r = a.consumedSegments),
              (o = n.slice(a.lastChild)),
              (s = new xb(
                r,
                a.parameters,
                Object.freeze(Object.assign({}, this.urlTree.queryParams)),
                this.urlTree.fragment,
                Tw(t),
                i,
                t.component,
                t,
                xw(e),
                Sw(e) + r.length,
                Aw(t)
              ))
          }
          const a = (function (t) {
              return t.children
                ? t.children
                : t.loadChildren
                ? t._loadedConfig.routes
                : []
            })(t),
            { segmentGroup: l, slicedSegments: c } = Ew(
              e,
              r,
              o,
              a,
              this.relativeLinkResolution
            )
          if (0 === c.length && l.hasChildren()) {
            const t = this.processChildren(a, l)
            return [new yb(s, t)]
          }
          if (0 === a.length && 0 === c.length) return [new yb(s, [])]
          const h = this.processSegment(a, l, c, Pv)
          return [new yb(s, h)]
        }
      }
      function xw(t) {
        let e = t
        for (; e._sourceSegment; ) e = e._sourceSegment
        return e
      }
      function Sw(t) {
        let e = t,
          n = e._segmentIndexShift ? e._segmentIndexShift : 0
        for (; e._sourceSegment; )
          (e = e._sourceSegment),
            (n += e._segmentIndexShift ? e._segmentIndexShift : 0)
        return n - 1
      }
      function Ew(t, e, n, i, s) {
        if (
          n.length > 0 &&
          (function (t, e, n) {
            return n.some((n) => kw(t, e, n) && ew(n) !== Pv)
          })(t, n, i)
        ) {
          const s = new Gv(
            e,
            (function (t, e, n, i) {
              const s = {}
              ;(s.primary = i),
                (i._sourceSegment = t),
                (i._segmentIndexShift = e.length)
              for (const r of n)
                if ('' === r.path && ew(r) !== Pv) {
                  const n = new Gv([], {})
                  ;(n._sourceSegment = t),
                    (n._segmentIndexShift = e.length),
                    (s[ew(r)] = n)
                }
              return s
            })(t, e, i, new Gv(n, t.children))
          )
          return (
            (s._sourceSegment = t),
            (s._segmentIndexShift = e.length),
            { segmentGroup: s, slicedSegments: [] }
          )
        }
        if (
          0 === n.length &&
          (function (t, e, n) {
            return n.some((n) => kw(t, e, n))
          })(t, n, i)
        ) {
          const r = new Gv(
            t.segments,
            (function (t, e, n, i, s, r) {
              const o = {}
              for (const a of i)
                if (kw(t, n, a) && !s[ew(a)]) {
                  const n = new Gv([], {})
                  ;(n._sourceSegment = t),
                    (n._segmentIndexShift =
                      'legacy' === r ? t.segments.length : e.length),
                    (o[ew(a)] = n)
                }
              return Object.assign(Object.assign({}, s), o)
            })(t, e, n, i, t.children, s)
          )
          return (
            (r._sourceSegment = t),
            (r._segmentIndexShift = e.length),
            { segmentGroup: r, slicedSegments: n }
          )
        }
        const r = new Gv(t.segments, t.children)
        return (
          (r._sourceSegment = t),
          (r._segmentIndexShift = e.length),
          { segmentGroup: r, slicedSegments: n }
        )
      }
      function kw(t, e, n) {
        return (
          (!(t.hasChildren() || e.length > 0) || 'full' !== n.pathMatch) &&
          '' === n.path &&
          void 0 === n.redirectTo
        )
      }
      function Tw(t) {
        return t.data || {}
      }
      function Aw(t) {
        return t.resolve || {}
      }
      function Ow(t) {
        return function (e) {
          return e.pipe(
            Bu((e) => {
              const n = t(e)
              return n ? B(n).pipe(F(() => e)) : B([e])
            })
          )
        }
      }
      class Iw extends class {
        shouldDetach(t) {
          return !1
        }
        store(t, e) {}
        shouldAttach(t) {
          return !1
        }
        retrieve(t) {
          return null
        }
        shouldReuseRoute(t, e) {
          return t.routeConfig === e.routeConfig
        }
      } {}
      const Rw = new Yn('ROUTES')
      class Pw {
        constructor(t, e, n, i) {
          ;(this.loader = t),
            (this.compiler = e),
            (this.onLoadStartListener = n),
            (this.onLoadEndListener = i)
        }
        load(t, e) {
          return (
            this.onLoadStartListener && this.onLoadStartListener(e),
            this.loadModuleFactory(e.loadChildren).pipe(
              F((n) => {
                this.onLoadEndListener && this.onLoadEndListener(e)
                const i = n.create(t)
                return new $b(Bv(i.injector.get(Rw)).map(tw), i)
              })
            )
          )
        }
        loadModuleFactory(t) {
          return 'string' == typeof t
            ? B(this.loader.load(t))
            : zv(t()).pipe(
                V((t) =>
                  t instanceof bl
                    ? mu(t)
                    : B(this.compiler.compileModuleAsync(t))
                )
              )
        }
      }
      class Dw {
        constructor() {
          ;(this.outlet = null),
            (this.route = null),
            (this.resolver = null),
            (this.children = new Nw()),
            (this.attachRef = null)
        }
      }
      class Nw {
        constructor() {
          this.contexts = new Map()
        }
        onChildOutletCreated(t, e) {
          const n = this.getOrCreateContext(t)
          ;(n.outlet = e), this.contexts.set(t, n)
        }
        onChildOutletDestroyed(t) {
          const e = this.getContext(t)
          e && (e.outlet = null)
        }
        onOutletDeactivated() {
          const t = this.contexts
          return (this.contexts = new Map()), t
        }
        onOutletReAttached(t) {
          this.contexts = t
        }
        getOrCreateContext(t) {
          let e = this.getContext(t)
          return e || ((e = new Dw()), this.contexts.set(t, e)), e
        }
        getContext(t) {
          return this.contexts.get(t) || null
        }
      }
      class Fw {
        shouldProcessUrl(t) {
          return !0
        }
        extract(t) {
          return t
        }
        merge(t, e) {
          return t
        }
      }
      function Mw(t) {
        throw t
      }
      function Lw(t, e, n) {
        return e.parse('/')
      }
      function jw(t, e) {
        return mu(null)
      }
      let Bw = (() => {
          class t {
            constructor(t, e, n, i, s, r, o, a) {
              ;(this.rootComponentType = t),
                (this.urlSerializer = e),
                (this.rootContexts = n),
                (this.location = i),
                (this.config = a),
                (this.lastSuccessfulNavigation = null),
                (this.currentNavigation = null),
                (this.lastLocationChangeInfo = null),
                (this.navigationId = 0),
                (this.isNgZoneEnabled = !1),
                (this.events = new x()),
                (this.errorHandler = Mw),
                (this.malformedUriErrorHandler = Lw),
                (this.navigated = !1),
                (this.lastSuccessfulId = -1),
                (this.hooks = {
                  beforePreactivation: jw,
                  afterPreactivation: jw,
                }),
                (this.urlHandlingStrategy = new Fw()),
                (this.routeReuseStrategy = new Iw()),
                (this.onSameUrlNavigation = 'ignore'),
                (this.paramsInheritanceStrategy = 'emptyOnly'),
                (this.urlUpdateStrategy = 'deferred'),
                (this.relativeLinkResolution = 'corrected'),
                (this.ngModule = s.get(vl)),
                (this.console = s.get(gc))
              const l = s.get(Oc)
              ;(this.isNgZoneEnabled = l instanceof Oc),
                this.resetConfig(a),
                (this.currentUrlTree = new Kv(new Gv([], {}), {}, null)),
                (this.rawUrlTree = this.currentUrlTree),
                (this.browserUrlTree = this.currentUrlTree),
                (this.configLoader = new Pw(
                  r,
                  o,
                  (t) => this.triggerEvent(new Ev(t)),
                  (t) => this.triggerEvent(new kv(t))
                )),
                (this.routerState = bb(
                  this.currentUrlTree,
                  this.rootComponentType
                )),
                (this.transitions = new wp({
                  id: 0,
                  currentUrlTree: this.currentUrlTree,
                  currentRawUrl: this.currentUrlTree,
                  extractedUrl: this.urlHandlingStrategy.extract(
                    this.currentUrlTree
                  ),
                  urlAfterRedirects: this.urlHandlingStrategy.extract(
                    this.currentUrlTree
                  ),
                  rawUrl: this.currentUrlTree,
                  extras: {},
                  resolve: null,
                  reject: null,
                  promise: Promise.resolve(!0),
                  source: 'imperative',
                  restoredState: null,
                  currentSnapshot: this.routerState.snapshot,
                  targetSnapshot: null,
                  currentRouterState: this.routerState,
                  targetRouterState: null,
                  guards: { canActivateChecks: [], canDeactivateChecks: [] },
                  guardsResult: null,
                })),
                (this.navigations = this.setupNavigations(this.transitions)),
                this.processNavigations()
            }
            setupNavigations(t) {
              const e = this.events
              return t.pipe(
                Iu((t) => 0 !== t.id),
                F((t) =>
                  Object.assign(Object.assign({}, t), {
                    extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl),
                  })
                ),
                Bu((t) => {
                  let n = !1,
                    i = !1
                  return mu(t).pipe(
                    xp((t) => {
                      this.currentNavigation = {
                        id: t.id,
                        initialUrl: t.currentRawUrl,
                        extractedUrl: t.extractedUrl,
                        trigger: t.source,
                        extras: t.extras,
                        previousNavigation: this.lastSuccessfulNavigation
                          ? Object.assign(
                              Object.assign({}, this.lastSuccessfulNavigation),
                              { previousNavigation: null }
                            )
                          : null,
                      }
                    }),
                    Bu((t) => {
                      const n =
                        !this.navigated ||
                        t.extractedUrl.toString() !==
                          this.browserUrlTree.toString()
                      if (
                        ('reload' === this.onSameUrlNavigation || n) &&
                        this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)
                      )
                        return mu(t).pipe(
                          Bu((t) => {
                            const n = this.transitions.getValue()
                            return (
                              e.next(
                                new gv(
                                  t.id,
                                  this.serializeUrl(t.extractedUrl),
                                  t.source,
                                  t.restoredState
                                )
                              ),
                              n !== this.transitions.getValue() ? zu : [t]
                            )
                          }),
                          Bu((t) => Promise.resolve(t)),
                          ((i = this.ngModule.injector),
                          (s = this.configLoader),
                          (r = this.urlSerializer),
                          (o = this.config),
                          function (t) {
                            return t.pipe(
                              Bu((t) =>
                                (function (t, e, n, i, s) {
                                  return new aw(t, e, n, i, s).apply()
                                })(i, s, r, t.extractedUrl, o).pipe(
                                  F((e) =>
                                    Object.assign(Object.assign({}, t), {
                                      urlAfterRedirects: e,
                                    })
                                  )
                                )
                              )
                            )
                          }),
                          xp((t) => {
                            this.currentNavigation = Object.assign(
                              Object.assign({}, this.currentNavigation),
                              { finalUrl: t.urlAfterRedirects }
                            )
                          }),
                          (function (t, e, n, i, s) {
                            return function (r) {
                              return r.pipe(
                                V((r) =>
                                  (function (
                                    t,
                                    e,
                                    n,
                                    i,
                                    s = 'emptyOnly',
                                    r = 'legacy'
                                  ) {
                                    return new Cw(t, e, n, i, s, r).recognize()
                                  })(
                                    t,
                                    e,
                                    r.urlAfterRedirects,
                                    n(r.urlAfterRedirects),
                                    i,
                                    s
                                  ).pipe(
                                    F((t) =>
                                      Object.assign(Object.assign({}, r), {
                                        targetSnapshot: t,
                                      })
                                    )
                                  )
                                )
                              )
                            }
                          })(
                            this.rootComponentType,
                            this.config,
                            (t) => this.serializeUrl(t),
                            this.paramsInheritanceStrategy,
                            this.relativeLinkResolution
                          ),
                          xp((t) => {
                            'eager' === this.urlUpdateStrategy &&
                              (t.extras.skipLocationChange ||
                                this.setBrowserUrl(
                                  t.urlAfterRedirects,
                                  !!t.extras.replaceUrl,
                                  t.id,
                                  t.extras.state
                                ),
                              (this.browserUrlTree = t.urlAfterRedirects))
                          }),
                          xp((t) => {
                            const n = new bv(
                              t.id,
                              this.serializeUrl(t.extractedUrl),
                              this.serializeUrl(t.urlAfterRedirects),
                              t.targetSnapshot
                            )
                            e.next(n)
                          })
                        )
                      var i, s, r, o
                      if (
                        n &&
                        this.rawUrlTree &&
                        this.urlHandlingStrategy.shouldProcessUrl(
                          this.rawUrlTree
                        )
                      ) {
                        const {
                            id: n,
                            extractedUrl: i,
                            source: s,
                            restoredState: r,
                            extras: o,
                          } = t,
                          a = new gv(n, this.serializeUrl(i), s, r)
                        e.next(a)
                        const l = bb(i, this.rootComponentType).snapshot
                        return mu(
                          Object.assign(Object.assign({}, t), {
                            targetSnapshot: l,
                            urlAfterRedirects: i,
                            extras: Object.assign(Object.assign({}, o), {
                              skipLocationChange: !1,
                              replaceUrl: !1,
                            }),
                          })
                        )
                      }
                      return (
                        (this.rawUrlTree = t.rawUrl),
                        (this.browserUrlTree = t.urlAfterRedirects),
                        t.resolve(null),
                        zu
                      )
                    }),
                    Ow((t) => {
                      const {
                        targetSnapshot: e,
                        id: n,
                        extractedUrl: i,
                        rawUrl: s,
                        extras: { skipLocationChange: r, replaceUrl: o },
                      } = t
                      return this.hooks.beforePreactivation(e, {
                        navigationId: n,
                        appliedUrlTree: i,
                        rawUrlTree: s,
                        skipLocationChange: !!r,
                        replaceUrl: !!o,
                      })
                    }),
                    xp((t) => {
                      const e = new wv(
                        t.id,
                        this.serializeUrl(t.extractedUrl),
                        this.serializeUrl(t.urlAfterRedirects),
                        t.targetSnapshot
                      )
                      this.triggerEvent(e)
                    }),
                    F((t) =>
                      Object.assign(Object.assign({}, t), {
                        guards: pw(
                          t.targetSnapshot,
                          t.currentSnapshot,
                          this.rootContexts
                        ),
                      })
                    ),
                    (function (t, e) {
                      return function (n) {
                        return n.pipe(
                          V((n) => {
                            const {
                              targetSnapshot: i,
                              currentSnapshot: s,
                              guards: {
                                canActivateChecks: r,
                                canDeactivateChecks: o,
                              },
                            } = n
                            return 0 === o.length && 0 === r.length
                              ? mu(
                                  Object.assign(Object.assign({}, n), {
                                    guardsResult: !0,
                                  })
                                )
                              : (function (t, e, n, i) {
                                  return B(t).pipe(
                                    V((t) =>
                                      (function (t, e, n, i, s) {
                                        const r =
                                          e && e.routeConfig
                                            ? e.routeConfig.canDeactivate
                                            : null
                                        return r && 0 !== r.length
                                          ? mu(
                                              r.map((r) => {
                                                const o = fw(r, e, s)
                                                let a
                                                if (
                                                  (function (t) {
                                                    return (
                                                      t && Wb(t.canDeactivate)
                                                    )
                                                  })(o)
                                                )
                                                  a = zv(
                                                    o.canDeactivate(t, e, n, i)
                                                  )
                                                else {
                                                  if (!Wb(o))
                                                    throw new Error(
                                                      'Invalid CanDeactivate guard'
                                                    )
                                                  a = zv(o(t, e, n, i))
                                                }
                                                return a.pipe(fv())
                                              })
                                            ).pipe(Qb())
                                          : mu(!0)
                                      })(t.component, t.route, n, e, i)
                                    ),
                                    fv((t) => !0 !== t, !0)
                                  )
                                })(o, i, s, t).pipe(
                                  V((n) =>
                                    n && 'boolean' == typeof n
                                      ? (function (t, e, n, i) {
                                          return B(e).pipe(
                                            d_((e) =>
                                              B([
                                                _w(e.route.parent, i),
                                                yw(e.route, i),
                                                bw(t, e.path, n),
                                                vw(t, e.route, n),
                                              ]).pipe(
                                                Mu(),
                                                fv((t) => !0 !== t, !0)
                                              )
                                            ),
                                            fv((t) => !0 !== t, !0)
                                          )
                                        })(i, r, t, e)
                                      : mu(n)
                                  ),
                                  F((t) =>
                                    Object.assign(Object.assign({}, n), {
                                      guardsResult: t,
                                    })
                                  )
                                )
                          })
                        )
                      }
                    })(this.ngModule.injector, (t) => this.triggerEvent(t)),
                    xp((t) => {
                      if (Kb(t.guardsResult)) {
                        const e = Fv(
                          `Redirecting to "${this.serializeUrl(
                            t.guardsResult
                          )}"`
                        )
                        throw ((e.url = t.guardsResult), e)
                      }
                    }),
                    xp((t) => {
                      const e = new Cv(
                        t.id,
                        this.serializeUrl(t.extractedUrl),
                        this.serializeUrl(t.urlAfterRedirects),
                        t.targetSnapshot,
                        !!t.guardsResult
                      )
                      this.triggerEvent(e)
                    }),
                    Iu((t) => {
                      if (!t.guardsResult) {
                        this.resetUrlToCurrentUrlTree()
                        const n = new _v(
                          t.id,
                          this.serializeUrl(t.extractedUrl),
                          ''
                        )
                        return e.next(n), t.resolve(!1), !1
                      }
                      return !0
                    }),
                    Ow((t) => {
                      if (t.guards.canActivateChecks.length)
                        return mu(t).pipe(
                          xp((t) => {
                            const e = new xv(
                              t.id,
                              this.serializeUrl(t.extractedUrl),
                              this.serializeUrl(t.urlAfterRedirects),
                              t.targetSnapshot
                            )
                            this.triggerEvent(e)
                          }),
                          Bu((t) => {
                            let n = !1
                            return mu(t).pipe(
                              ((i = this.paramsInheritanceStrategy),
                              (s = this.ngModule.injector),
                              function (t) {
                                return t.pipe(
                                  V((t) => {
                                    const {
                                      targetSnapshot: e,
                                      guards: { canActivateChecks: n },
                                    } = t
                                    if (!n.length) return mu(t)
                                    let r = 0
                                    return B(n).pipe(
                                      d_((t) =>
                                        (function (t, e, n, i) {
                                          return (function (t, e, n, i) {
                                            const s = Object.keys(t)
                                            if (0 === s.length) return mu({})
                                            const r = {}
                                            return B(s).pipe(
                                              V((s) =>
                                                (function (t, e, n, i) {
                                                  const s = fw(t, e, i)
                                                  return zv(
                                                    s.resolve
                                                      ? s.resolve(e, n)
                                                      : s(e, n)
                                                  )
                                                })(t[s], e, n, i).pipe(
                                                  xp((t) => {
                                                    r[s] = t
                                                  })
                                                )
                                              ),
                                              nv(1),
                                              V(() =>
                                                Object.keys(r).length ===
                                                s.length
                                                  ? mu(r)
                                                  : zu
                                              )
                                            )
                                          })(t._resolve, t, e, i).pipe(
                                            F(
                                              (e) => (
                                                (t._resolvedData = e),
                                                (t.data = Object.assign(
                                                  Object.assign({}, t.data),
                                                  Cb(t, n).resolve
                                                )),
                                                null
                                              )
                                            )
                                          )
                                        })(t.route, e, i, s)
                                      ),
                                      xp(() => r++),
                                      nv(1),
                                      V((e) => (r === n.length ? mu(t) : zu))
                                    )
                                  })
                                )
                              }),
                              xp({
                                next: () => (n = !0),
                                complete: () => {
                                  if (!n) {
                                    const n = new _v(
                                      t.id,
                                      this.serializeUrl(t.extractedUrl),
                                      "At least one route resolver didn't emit any value."
                                    )
                                    e.next(n), t.resolve(!1)
                                  }
                                },
                              })
                            )
                            var i, s
                          }),
                          xp((t) => {
                            const e = new Sv(
                              t.id,
                              this.serializeUrl(t.extractedUrl),
                              this.serializeUrl(t.urlAfterRedirects),
                              t.targetSnapshot
                            )
                            this.triggerEvent(e)
                          })
                        )
                    }),
                    Ow((t) => {
                      const {
                        targetSnapshot: e,
                        id: n,
                        extractedUrl: i,
                        rawUrl: s,
                        extras: { skipLocationChange: r, replaceUrl: o },
                      } = t
                      return this.hooks.afterPreactivation(e, {
                        navigationId: n,
                        appliedUrlTree: i,
                        rawUrlTree: s,
                        skipLocationChange: !!r,
                        replaceUrl: !!o,
                      })
                    }),
                    F((t) => {
                      const e = (function (t, e, n) {
                        const i = Ob(t, e._root, n ? n._root : void 0)
                        return new vb(i, e)
                      })(
                        this.routeReuseStrategy,
                        t.targetSnapshot,
                        t.currentRouterState
                      )
                      return Object.assign(Object.assign({}, t), {
                        targetRouterState: e,
                      })
                    }),
                    xp((t) => {
                      ;(this.currentUrlTree = t.urlAfterRedirects),
                        (this.rawUrlTree = this.urlHandlingStrategy.merge(
                          this.currentUrlTree,
                          t.rawUrl
                        )),
                        (this.routerState = t.targetRouterState),
                        'deferred' === this.urlUpdateStrategy &&
                          (t.extras.skipLocationChange ||
                            this.setBrowserUrl(
                              this.rawUrlTree,
                              !!t.extras.replaceUrl,
                              t.id,
                              t.extras.state
                            ),
                          (this.browserUrlTree = t.urlAfterRedirects))
                    }),
                    ((s = this.rootContexts),
                    (r = this.routeReuseStrategy),
                    (o = (t) => this.triggerEvent(t)),
                    F(
                      (t) => (
                        new Hb(
                          r,
                          t.targetRouterState,
                          t.currentRouterState,
                          o
                        ).activate(s),
                        t
                      )
                    )),
                    xp({
                      next() {
                        n = !0
                      },
                      complete() {
                        n = !0
                      },
                    }),
                    c_(() => {
                      if (!n && !i) {
                        this.resetUrlToCurrentUrlTree()
                        const n = new _v(
                          t.id,
                          this.serializeUrl(t.extractedUrl),
                          `Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`
                        )
                        e.next(n), t.resolve(!1)
                      }
                      this.currentNavigation = null
                    }),
                    o_((n) => {
                      if (((i = !0), (s = n) && s.ngNavigationCancelingError)) {
                        const i = Kb(n.url)
                        i ||
                          ((this.navigated = !0),
                          this.resetStateAndUrl(
                            t.currentRouterState,
                            t.currentUrlTree,
                            t.rawUrl
                          ))
                        const s = new _v(
                          t.id,
                          this.serializeUrl(t.extractedUrl),
                          n.message
                        )
                        e.next(s),
                          i
                            ? setTimeout(() => {
                                const e = this.urlHandlingStrategy.merge(
                                  n.url,
                                  this.rawUrlTree
                                )
                                return this.scheduleNavigation(
                                  e,
                                  'imperative',
                                  null,
                                  {
                                    skipLocationChange:
                                      t.extras.skipLocationChange,
                                    replaceUrl:
                                      'eager' === this.urlUpdateStrategy,
                                  },
                                  {
                                    resolve: t.resolve,
                                    reject: t.reject,
                                    promise: t.promise,
                                  }
                                )
                              }, 0)
                            : t.resolve(!1)
                      } else {
                        this.resetStateAndUrl(
                          t.currentRouterState,
                          t.currentUrlTree,
                          t.rawUrl
                        )
                        const i = new vv(
                          t.id,
                          this.serializeUrl(t.extractedUrl),
                          n
                        )
                        e.next(i)
                        try {
                          t.resolve(this.errorHandler(n))
                        } catch (r) {
                          t.reject(r)
                        }
                      }
                      var s
                      return zu
                    })
                  )
                  var s, r, o
                })
              )
            }
            resetRootComponentType(t) {
              ;(this.rootComponentType = t),
                (this.routerState.root.component = this.rootComponentType)
            }
            getTransition() {
              const t = this.transitions.value
              return (t.urlAfterRedirects = this.browserUrlTree), t
            }
            setTransition(t) {
              this.transitions.next(
                Object.assign(Object.assign({}, this.getTransition()), t)
              )
            }
            initialNavigation() {
              this.setUpLocationChangeListener(),
                0 === this.navigationId &&
                  this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 })
            }
            setUpLocationChangeListener() {
              this.locationSubscription ||
                (this.locationSubscription = this.location.subscribe((t) => {
                  const e = this.extractLocationChangeInfoFromEvent(t)
                  this.shouldScheduleNavigation(
                    this.lastLocationChangeInfo,
                    e
                  ) &&
                    setTimeout(() => {
                      const { source: t, state: n, urlTree: i } = e,
                        s = { replaceUrl: !0 }
                      if (n) {
                        const t = Object.assign({}, n)
                        delete t.navigationId,
                          0 !== Object.keys(t).length && (s.state = t)
                      }
                      this.scheduleNavigation(i, t, n, s)
                    }, 0),
                    (this.lastLocationChangeInfo = e)
                }))
            }
            extractLocationChangeInfoFromEvent(t) {
              var e
              return {
                source: 'popstate' === t.type ? 'popstate' : 'hashchange',
                urlTree: this.parseUrl(t.url),
                state: (
                  null === (e = t.state) || void 0 === e
                    ? void 0
                    : e.navigationId
                )
                  ? t.state
                  : null,
                transitionId: this.getTransition().id,
              }
            }
            shouldScheduleNavigation(t, e) {
              if (!t) return !0
              const n = e.urlTree.toString() === t.urlTree.toString()
              return !(
                e.transitionId === t.transitionId &&
                n &&
                (('hashchange' === e.source && 'popstate' === t.source) ||
                  ('popstate' === e.source && 'hashchange' === t.source))
              )
            }
            get url() {
              return this.serializeUrl(this.currentUrlTree)
            }
            getCurrentNavigation() {
              return this.currentNavigation
            }
            triggerEvent(t) {
              this.events.next(t)
            }
            resetConfig(t) {
              Yb(t),
                (this.config = t.map(tw)),
                (this.navigated = !1),
                (this.lastSuccessfulId = -1)
            }
            ngOnDestroy() {
              this.dispose()
            }
            dispose() {
              this.locationSubscription &&
                (this.locationSubscription.unsubscribe(),
                (this.locationSubscription = void 0))
            }
            createUrlTree(t, e = {}) {
              const {
                  relativeTo: n,
                  queryParams: i,
                  fragment: s,
                  queryParamsHandling: r,
                  preserveFragment: o,
                } = e,
                a = n || this.routerState.root,
                l = o ? this.currentUrlTree.fragment : s
              let c = null
              switch (r) {
                case 'merge':
                  c = Object.assign(
                    Object.assign({}, this.currentUrlTree.queryParams),
                    i
                  )
                  break
                case 'preserve':
                  c = this.currentUrlTree.queryParams
                  break
                default:
                  c = i || null
              }
              return (
                null !== c && (c = this.removeEmptyProps(c)),
                (function (t, e, n, i, s) {
                  if (0 === n.length) return Db(e.root, e.root, e, i, s)
                  const r = (function (t) {
                    if (
                      'string' == typeof t[0] &&
                      1 === t.length &&
                      '/' === t[0]
                    )
                      return new Fb(!0, 0, t)
                    let e = 0,
                      n = !1
                    const i = t.reduce((t, i, s) => {
                      if ('object' == typeof i && null != i) {
                        if (i.outlets) {
                          const e = {}
                          return (
                            Uv(i.outlets, (t, n) => {
                              e[n] = 'string' == typeof t ? t.split('/') : t
                            }),
                            [...t, { outlets: e }]
                          )
                        }
                        if (i.segmentPath) return [...t, i.segmentPath]
                      }
                      return 'string' != typeof i
                        ? [...t, i]
                        : 0 === s
                        ? (i.split('/').forEach((i, s) => {
                            ;(0 == s && '.' === i) ||
                              (0 == s && '' === i
                                ? (n = !0)
                                : '..' === i
                                ? e++
                                : '' != i && t.push(i))
                          }),
                          t)
                        : [...t, i]
                    }, [])
                    return new Fb(n, e, i)
                  })(n)
                  if (r.toRoot()) return Db(e.root, new Gv([], {}), e, i, s)
                  const o = (function (t, e, n) {
                      if (t.isAbsolute) return new Mb(e.root, !0, 0)
                      if (-1 === n.snapshot._lastPathIndex) {
                        const t = n.snapshot._urlSegment
                        return new Mb(t, t === e.root, 0)
                      }
                      const i = Rb(t.commands[0]) ? 0 : 1
                      return (function (t, e, n) {
                        let i = t,
                          s = e,
                          r = n
                        for (; r > s; ) {
                          if (((r -= s), (i = i.parent), !i))
                            throw new Error("Invalid number of '../'")
                          s = i.segments.length
                        }
                        return new Mb(i, !1, s - r)
                      })(
                        n.snapshot._urlSegment,
                        n.snapshot._lastPathIndex + i,
                        t.numberOfDoubleDots
                      )
                    })(r, e, t),
                    a = o.processChildren
                      ? jb(o.segmentGroup, o.index, r.commands)
                      : Lb(o.segmentGroup, o.index, r.commands)
                  return Db(o.segmentGroup, a, e, i, s)
                })(a, this.currentUrlTree, t, c, l)
              )
            }
            navigateByUrl(t, e = { skipLocationChange: !1 }) {
              const n = Kb(t) ? t : this.parseUrl(t),
                i = this.urlHandlingStrategy.merge(n, this.rawUrlTree)
              return this.scheduleNavigation(i, 'imperative', null, e)
            }
            navigate(t, e = { skipLocationChange: !1 }) {
              return (
                (function (t) {
                  for (let e = 0; e < t.length; e++) {
                    const n = t[e]
                    if (null == n)
                      throw new Error(
                        `The requested path contains ${n} segment at index ${e}`
                      )
                  }
                })(t),
                this.navigateByUrl(this.createUrlTree(t, e), e)
              )
            }
            serializeUrl(t) {
              return this.urlSerializer.serialize(t)
            }
            parseUrl(t) {
              let e
              try {
                e = this.urlSerializer.parse(t)
              } catch (n) {
                e = this.malformedUriErrorHandler(n, this.urlSerializer, t)
              }
              return e
            }
            isActive(t, e) {
              if (Kb(t)) return Hv(this.currentUrlTree, t, e)
              const n = this.parseUrl(t)
              return Hv(this.currentUrlTree, n, e)
            }
            removeEmptyProps(t) {
              return Object.keys(t).reduce((e, n) => {
                const i = t[n]
                return null != i && (e[n] = i), e
              }, {})
            }
            processNavigations() {
              this.navigations.subscribe(
                (t) => {
                  ;(this.navigated = !0),
                    (this.lastSuccessfulId = t.id),
                    this.events.next(
                      new yv(
                        t.id,
                        this.serializeUrl(t.extractedUrl),
                        this.serializeUrl(this.currentUrlTree)
                      )
                    ),
                    (this.lastSuccessfulNavigation = this.currentNavigation),
                    (this.currentNavigation = null),
                    t.resolve(!0)
                },
                (t) => {
                  this.console.warn('Unhandled Navigation Error: ')
                }
              )
            }
            scheduleNavigation(t, e, n, i, s) {
              const r = this.getTransition(),
                o =
                  'imperative' !== e &&
                  'imperative' === (null == r ? void 0 : r.source),
                a =
                  (this.lastSuccessfulId === r.id || this.currentNavigation
                    ? r.rawUrl
                    : r.urlAfterRedirects
                  ).toString() === t.toString()
              if (o && a) return Promise.resolve(!0)
              let l, c, h
              s
                ? ((l = s.resolve), (c = s.reject), (h = s.promise))
                : (h = new Promise((t, e) => {
                    ;(l = t), (c = e)
                  }))
              const u = ++this.navigationId
              return (
                this.setTransition({
                  id: u,
                  source: e,
                  restoredState: n,
                  currentUrlTree: this.currentUrlTree,
                  currentRawUrl: this.rawUrlTree,
                  rawUrl: t,
                  extras: i,
                  resolve: l,
                  reject: c,
                  promise: h,
                  currentSnapshot: this.routerState.snapshot,
                  currentRouterState: this.routerState,
                }),
                h.catch((t) => Promise.reject(t))
              )
            }
            setBrowserUrl(t, e, n, i) {
              const s = this.urlSerializer.serialize(t)
              ;(i = i || {}),
                this.location.isCurrentPathEqualTo(s) || e
                  ? this.location.replaceState(
                      s,
                      '',
                      Object.assign(Object.assign({}, i), { navigationId: n })
                    )
                  : this.location.go(
                      s,
                      '',
                      Object.assign(Object.assign({}, i), { navigationId: n })
                    )
            }
            resetStateAndUrl(t, e, n) {
              ;(this.routerState = t),
                (this.currentUrlTree = e),
                (this.rawUrlTree = this.urlHandlingStrategy.merge(
                  this.currentUrlTree,
                  n
                )),
                this.resetUrlToCurrentUrlTree()
            }
            resetUrlToCurrentUrlTree() {
              this.location.replaceState(
                this.urlSerializer.serialize(this.rawUrlTree),
                '',
                { navigationId: this.lastSuccessfulId }
              )
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                vi(Jn),
                vi(Xv),
                vi(Nw),
                vi(Ih),
                vi(ho),
                vi(Xc),
                vi(kc),
                vi(void 0)
              )
            }),
            (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        Vw = (() => {
          class t {
            constructor(t, e, n) {
              ;(this.router = t),
                (this.route = e),
                (this.locationStrategy = n),
                (this.commands = []),
                (this.onChanges = new x()),
                (this.subscription = t.events.subscribe((t) => {
                  t instanceof yv && this.updateTargetUrlAndHref()
                }))
            }
            set routerLink(t) {
              this.commands = null != t ? (Array.isArray(t) ? t : [t]) : []
            }
            ngOnChanges(t) {
              this.updateTargetUrlAndHref(), this.onChanges.next(this)
            }
            ngOnDestroy() {
              this.subscription.unsubscribe()
            }
            onClick(t, e, n, i, s) {
              if (0 !== t || e || n || i || s) return !0
              if ('string' == typeof this.target && '_self' != this.target)
                return !0
              const r = {
                skipLocationChange: Uw(this.skipLocationChange),
                replaceUrl: Uw(this.replaceUrl),
                state: this.state,
              }
              return this.router.navigateByUrl(this.urlTree, r), !1
            }
            updateTargetUrlAndHref() {
              this.href = this.locationStrategy.prepareExternalUrl(
                this.router.serializeUrl(this.urlTree)
              )
            }
            get urlTree() {
              return this.router.createUrlTree(this.commands, {
                relativeTo: this.route,
                queryParams: this.queryParams,
                fragment: this.fragment,
                queryParamsHandling: this.queryParamsHandling,
                preserveFragment: Uw(this.preserveFragment),
              })
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(Ao(Bw), Ao(wb), Ao(Eh))
            }),
            (t.ɵdir = Kt({
              type: t,
              selectors: [
                ['a', 'routerLink', ''],
                ['area', 'routerLink', ''],
              ],
              hostVars: 2,
              hostBindings: function (t, e) {
                1 & t &&
                  Bo('click', function (t) {
                    return e.onClick(
                      t.button,
                      t.ctrlKey,
                      t.shiftKey,
                      t.altKey,
                      t.metaKey
                    )
                  }),
                  2 & t && (ga('href', e.href, ns), Eo('target', e.target))
              },
              inputs: {
                routerLink: 'routerLink',
                target: 'target',
                queryParams: 'queryParams',
                fragment: 'fragment',
                queryParamsHandling: 'queryParamsHandling',
                preserveFragment: 'preserveFragment',
                skipLocationChange: 'skipLocationChange',
                replaceUrl: 'replaceUrl',
                state: 'state',
              },
              features: [ue],
            })),
            t
          )
        })()
      function Uw(t) {
        return '' === t || !!t
      }
      let zw = (() => {
        class t {
          constructor(t, e, n, i, s) {
            ;(this.parentContexts = t),
              (this.location = e),
              (this.resolver = n),
              (this.changeDetector = s),
              (this.activated = null),
              (this._activatedRoute = null),
              (this.activateEvents = new zl()),
              (this.deactivateEvents = new zl()),
              (this.name = i || Pv),
              t.onChildOutletCreated(this.name, this)
          }
          ngOnDestroy() {
            this.parentContexts.onChildOutletDestroyed(this.name)
          }
          ngOnInit() {
            if (!this.activated) {
              const t = this.parentContexts.getContext(this.name)
              t &&
                t.route &&
                (t.attachRef
                  ? this.attach(t.attachRef, t.route)
                  : this.activateWith(t.route, t.resolver || null))
            }
          }
          get isActivated() {
            return !!this.activated
          }
          get component() {
            if (!this.activated) throw new Error('Outlet is not activated')
            return this.activated.instance
          }
          get activatedRoute() {
            if (!this.activated) throw new Error('Outlet is not activated')
            return this._activatedRoute
          }
          get activatedRouteData() {
            return this._activatedRoute
              ? this._activatedRoute.snapshot.data
              : {}
          }
          detach() {
            if (!this.activated) throw new Error('Outlet is not activated')
            this.location.detach()
            const t = this.activated
            return (this.activated = null), (this._activatedRoute = null), t
          }
          attach(t, e) {
            ;(this.activated = t),
              (this._activatedRoute = e),
              this.location.insert(t.hostView)
          }
          deactivate() {
            if (this.activated) {
              const t = this.component
              this.activated.destroy(),
                (this.activated = null),
                (this._activatedRoute = null),
                this.deactivateEvents.emit(t)
            }
          }
          activateWith(t, e) {
            if (this.isActivated)
              throw new Error('Cannot activate an already activated outlet')
            this._activatedRoute = t
            const n = (e = e || this.resolver).resolveComponentFactory(
                t._futureSnapshot.routeConfig.component
              ),
              i = this.parentContexts.getOrCreateContext(this.name).children,
              s = new Hw(t, i, this.location.injector)
            ;(this.activated = this.location.createComponent(
              n,
              this.location.length,
              s
            )),
              this.changeDetector.markForCheck(),
              this.activateEvents.emit(this.activated.instance)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(Ao(Nw), Ao(Cl), Ao(Ma), Gn('name'), Ao(cl))
          }),
          (t.ɵdir = Kt({
            type: t,
            selectors: [['router-outlet']],
            outputs: {
              activateEvents: 'activate',
              deactivateEvents: 'deactivate',
            },
            exportAs: ['outlet'],
          })),
          t
        )
      })()
      class Hw {
        constructor(t, e, n) {
          ;(this.route = t), (this.childContexts = e), (this.parent = n)
        }
        get(t, e) {
          return t === wb
            ? this.route
            : t === Nw
            ? this.childContexts
            : this.parent.get(t, e)
        }
      }
      class qw {}
      class $w {
        preload(t, e) {
          return mu(null)
        }
      }
      let Ww = (() => {
          class t {
            constructor(t, e, n, i, s) {
              ;(this.router = t),
                (this.injector = i),
                (this.preloadingStrategy = s),
                (this.loader = new Pw(
                  e,
                  n,
                  (e) => t.triggerEvent(new Ev(e)),
                  (e) => t.triggerEvent(new kv(e))
                ))
            }
            setUpPreloading() {
              this.subscription = this.router.events
                .pipe(
                  Iu((t) => t instanceof yv),
                  d_(() => this.preload())
                )
                .subscribe(() => {})
            }
            preload() {
              const t = this.injector.get(vl)
              return this.processRoutes(t, this.router.config)
            }
            ngOnDestroy() {
              this.subscription && this.subscription.unsubscribe()
            }
            processRoutes(t, e) {
              const n = []
              for (const i of e)
                if (i.loadChildren && !i.canLoad && i._loadedConfig) {
                  const t = i._loadedConfig
                  n.push(this.processRoutes(t.module, t.routes))
                } else
                  i.loadChildren && !i.canLoad
                    ? n.push(this.preloadConfig(t, i))
                    : i.children && n.push(this.processRoutes(t, i.children))
              return B(n).pipe(
                H(),
                F((t) => {})
              )
            }
            preloadConfig(t, e) {
              return this.preloadingStrategy.preload(e, () =>
                this.loader
                  .load(t.injector, e)
                  .pipe(
                    V(
                      (t) => (
                        (e._loadedConfig = t),
                        this.processRoutes(t.module, t.routes)
                      )
                    )
                  )
              )
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(Bw), vi(Xc), vi(kc), vi(ho), vi(qw))
            }),
            (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        Kw = (() => {
          class t {
            constructor(t, e, n = {}) {
              ;(this.router = t),
                (this.viewportScroller = e),
                (this.options = n),
                (this.lastId = 0),
                (this.lastSource = 'imperative'),
                (this.restoredId = 0),
                (this.store = {}),
                (n.scrollPositionRestoration =
                  n.scrollPositionRestoration || 'disabled'),
                (n.anchorScrolling = n.anchorScrolling || 'disabled')
            }
            init() {
              'disabled' !== this.options.scrollPositionRestoration &&
                this.viewportScroller.setHistoryScrollRestoration('manual'),
                (this.routerEventsSubscription = this.createScrollEvents()),
                (this.scrollEventsSubscription = this.consumeScrollEvents())
            }
            createScrollEvents() {
              return this.router.events.subscribe((t) => {
                t instanceof gv
                  ? ((this.store[
                      this.lastId
                    ] = this.viewportScroller.getScrollPosition()),
                    (this.lastSource = t.navigationTrigger),
                    (this.restoredId = t.restoredState
                      ? t.restoredState.navigationId
                      : 0))
                  : t instanceof yv &&
                    ((this.lastId = t.id),
                    this.scheduleScrollEvent(
                      t,
                      this.router.parseUrl(t.urlAfterRedirects).fragment
                    ))
              })
            }
            consumeScrollEvents() {
              return this.router.events.subscribe((t) => {
                t instanceof Rv &&
                  (t.position
                    ? 'top' === this.options.scrollPositionRestoration
                      ? this.viewportScroller.scrollToPosition([0, 0])
                      : 'enabled' === this.options.scrollPositionRestoration &&
                        this.viewportScroller.scrollToPosition(t.position)
                    : t.anchor && 'enabled' === this.options.anchorScrolling
                    ? this.viewportScroller.scrollToAnchor(t.anchor)
                    : 'disabled' !== this.options.scrollPositionRestoration &&
                      this.viewportScroller.scrollToPosition([0, 0]))
              })
            }
            scheduleScrollEvent(t, e) {
              this.router.triggerEvent(
                new Rv(
                  t,
                  'popstate' === this.lastSource
                    ? this.store[this.restoredId]
                    : null,
                  e
                )
              )
            }
            ngOnDestroy() {
              this.routerEventsSubscription &&
                this.routerEventsSubscription.unsubscribe(),
                this.scrollEventsSubscription &&
                  this.scrollEventsSubscription.unsubscribe()
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(Bw), vi(Zh), vi(void 0))
            }),
            (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
            t
          )
        })()
      const Gw = new Yn('ROUTER_CONFIGURATION'),
        Qw = new Yn('ROUTER_FORROOT_GUARD'),
        Zw = [
          Ih,
          { provide: Xv, useClass: Jv },
          {
            provide: Bw,
            useFactory: function (t, e, n, i, s, r, o, a = {}, l, c) {
              const h = new Bw(null, t, e, n, i, s, r, Bv(o))
              if (
                (l && (h.urlHandlingStrategy = l),
                c && (h.routeReuseStrategy = c),
                (function (t, e) {
                  t.errorHandler && (e.errorHandler = t.errorHandler),
                    t.malformedUriErrorHandler &&
                      (e.malformedUriErrorHandler = t.malformedUriErrorHandler),
                    t.onSameUrlNavigation &&
                      (e.onSameUrlNavigation = t.onSameUrlNavigation),
                    t.paramsInheritanceStrategy &&
                      (e.paramsInheritanceStrategy =
                        t.paramsInheritanceStrategy),
                    t.relativeLinkResolution &&
                      (e.relativeLinkResolution = t.relativeLinkResolution),
                    t.urlUpdateStrategy &&
                      (e.urlUpdateStrategy = t.urlUpdateStrategy)
                })(a, h),
                a.enableTracing)
              ) {
                const t = fh()
                h.events.subscribe((e) => {
                  t.logGroup('Router Event: ' + e.constructor.name),
                    t.log(e.toString()),
                    t.log(e),
                    t.logGroupEnd()
                })
              }
              return h
            },
            deps: [
              Xv,
              Nw,
              Ih,
              ho,
              Xc,
              kc,
              Rw,
              Gw,
              [class {}, new ci()],
              [class {}, new ci()],
            ],
          },
          Nw,
          {
            provide: wb,
            useFactory: function (t) {
              return t.routerState.root
            },
            deps: [Bw],
          },
          { provide: Xc, useClass: eh },
          Ww,
          $w,
          class {
            preload(t, e) {
              return e().pipe(o_(() => mu(null)))
            }
          },
          { provide: Gw, useValue: { enableTracing: !1 } },
        ]
      function Yw() {
        return new $c('Router', Bw)
      }
      let Xw = (() => {
        class t {
          constructor(t, e) {}
          static forRoot(e, n) {
            return {
              ngModule: t,
              providers: [
                Zw,
                nC(e),
                {
                  provide: Qw,
                  useFactory: eC,
                  deps: [[Bw, new ci(), new ui()]],
                },
                { provide: Gw, useValue: n || {} },
                {
                  provide: Eh,
                  useFactory: tC,
                  deps: [gh, [new li(Th), new ci()], Gw],
                },
                { provide: Kw, useFactory: Jw, deps: [Bw, Zh, Gw] },
                {
                  provide: qw,
                  useExisting:
                    n && n.preloadingStrategy ? n.preloadingStrategy : $w,
                },
                { provide: $c, multi: !0, useFactory: Yw },
                [
                  iC,
                  { provide: lc, multi: !0, useFactory: sC, deps: [iC] },
                  { provide: oC, useFactory: rC, deps: [iC] },
                  { provide: mc, multi: !0, useExisting: oC },
                ],
              ],
            }
          }
          static forChild(e) {
            return { ngModule: t, providers: [nC(e)] }
          }
        }
        return (
          (t.ɵmod = $t({ type: t })),
          (t.ɵinj = ut({
            factory: function (e) {
              return new (e || t)(vi(Qw, 8), vi(Bw, 8))
            },
          })),
          t
        )
      })()
      function Jw(t, e, n) {
        return n.scrollOffset && e.setOffset(n.scrollOffset), new Kw(t, e, n)
      }
      function tC(t, e, n = {}) {
        return n.useHash ? new Oh(t, e) : new Ah(t, e)
      }
      function eC(t) {
        return 'guarded'
      }
      function nC(t) {
        return [
          { provide: Xn, multi: !0, useValue: t },
          { provide: Rw, multi: !0, useValue: t },
        ]
      }
      let iC = (() => {
        class t {
          constructor(t) {
            ;(this.injector = t),
              (this.initNavigation = !1),
              (this.resultOfPreactivationDone = new x())
          }
          appInitializer() {
            return this.injector.get(_h, Promise.resolve(null)).then(() => {
              let t = null
              const e = new Promise((e) => (t = e)),
                n = this.injector.get(Bw),
                i = this.injector.get(Gw)
              return (
                'disabled' === i.initialNavigation
                  ? (n.setUpLocationChangeListener(), t(!0))
                  : 'enabled' === i.initialNavigation ||
                    'enabledBlocking' === i.initialNavigation
                  ? ((n.hooks.afterPreactivation = () =>
                      this.initNavigation
                        ? mu(null)
                        : ((this.initNavigation = !0),
                          t(!0),
                          this.resultOfPreactivationDone)),
                    n.initialNavigation())
                  : t(!0),
                e
              )
            })
          }
          bootstrapListener(t) {
            const e = this.injector.get(Gw),
              n = this.injector.get(Ww),
              i = this.injector.get(Kw),
              s = this.injector.get(Bw),
              r = this.injector.get(Zc)
            t === r.components[0] &&
              (('enabledNonBlocking' !== e.initialNavigation &&
                void 0 !== e.initialNavigation) ||
                s.initialNavigation(),
              n.setUpPreloading(),
              i.init(),
              s.resetRootComponentType(r.componentTypes[0]),
              this.resultOfPreactivationDone.next(null),
              this.resultOfPreactivationDone.complete())
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(ho))
          }),
          (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      function sC(t) {
        return t.appInitializer.bind(t)
      }
      function rC(t) {
        return t.bootstrapListener.bind(t)
      }
      const oC = new Yn('Router Initializer')
      let aC = (() => {
        class t {}
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵcmp = Ut({
            type: t,
            selectors: [['app-footer']],
            decls: 8,
            vars: 0,
            consts: [
              [
                'rel',
                'external',
                'target',
                '_blank',
                'href',
                'https://github.com/guiseek/webrtc.community/blob/main/LICENSE',
                1,
                'docs-link',
              ],
              [
                'rel',
                'external',
                'target',
                '_blank',
                'href',
                'https://github.com/guiseek/webrtc.community',
                1,
                'docs-link',
              ],
              [
                'xmlns',
                'http://www.w3.org/2000/svg',
                'height',
                '32',
                'viewBox',
                '0 0 16 16',
                'version',
                '1.1',
                'width',
                '32',
                'aria-hidden',
                'true',
              ],
              [
                'fill-rule',
                'evenodd',
                'd',
                'M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z',
              ],
            ],
            template: function (t, e) {
              1 & t &&
                (Ro(0, 'mat-toolbar'),
                Ro(1, 'a', 0),
                pa(2, ' BSD 3-Clause License '),
                Po(),
                Ro(3, 'a', 1),
                hn(),
                Ro(4, 'svg', 2),
                Do(5, 'path', 3),
                Po(),
                Po(),
                (Pe.lFrame.currentNamespace = null),
                Ro(6, 'em'),
                pa(7, '(c) 2020, Guilherme Siquinelli'),
                Po(),
                Po())
            },
            directives: [Py],
            styles: [
              'app-footer{display:flex;flex-direction:column;align-items:center}app-footer .mat-toolbar{font-size:90%;justify-content:center;align-items:center}app-footer .mat-toolbar a{display:inline-flex}app-footer .mat-toolbar svg{display:inline-flex;width:24px;height:auto;margin:0 12px;fill:#fff}',
            ],
            encapsulation: 2,
          })),
          t
        )
      })()
      function lC(t, e) {
        if (
          (1 & t &&
            (Ro(0, 'div', 7),
            Ro(1, 'div', 8),
            Do(2, 'img', 9),
            Po(),
            pa(3),
            Po()),
          2 & t)
        ) {
          const t = e.$implicit
          Xs(2), Oo('alt', t.alt)('src', t.src, ns), Xs(1), ma(' ', t.alt, ' ')
        }
      }
      const cC = [
        {
          path: '',
          component: (() => {
            class t {
              constructor() {
                this.banners = [
                  {
                    src: 'assets/banners/peer-to-peer.svg',
                    alt: 'Ponto a ponto',
                    action: '',
                  },
                  {
                    src: 'assets/banners/live.svg',
                    alt: 'Tempo real',
                    action: '',
                  },
                  {
                    src: 'assets/banners/broadcast.svg',
                    alt: 'Difusor',
                    action: '',
                  },
                  {
                    src: 'assets/banners/multi-protocols.svg',
                    alt: 'Multi protocolo',
                    action: '',
                  },
                  {
                    src: 'assets/banners/security.svg',
                    alt: 'Seguro',
                    action: '',
                  },
                  {
                    src: 'assets/banners/easy.svg',
                    alt: 'Simples',
                    action: '',
                  },
                ]
              }
            }
            return (
              (t.ɵfac = function (e) {
                return new (e || t)()
              }),
              (t.ɵcmp = Ut({
                type: t,
                selectors: [['app-home']],
                decls: 47,
                vars: 3,
                consts: [
                  [1, 'docs-home-promo'],
                  [
                    1,
                    'docs-home-featured-components',
                    'docs-home-carousel-row',
                  ],
                  [3, 'itemWidth', 'aria-label'],
                  [
                    'carousel-item',
                    '',
                    'class',
                    'docs-featured-components-carousel-item',
                    4,
                    'ngFor',
                    'ngForOf',
                  ],
                  [1, 'docs-home-row', 'docs-introduction'],
                  [1, 'docs-home-row-column'],
                  ['routerLink', '', 1, 'docs-link'],
                  [
                    'carousel-item',
                    '',
                    1,
                    'docs-featured-components-carousel-item',
                  ],
                  [1, 'docs-home-img-container'],
                  ['role', 'presentation', 3, 'alt', 'src'],
                ],
                template: function (t, e) {
                  1 & t &&
                    (Ro(0, 'main', 0),
                    Ro(1, 'div', 1),
                    Ro(2, 'quertc-carousel', 2),
                    ko(3, lC, 4, 3, 'div', 3),
                    Po(),
                    Po(),
                    Do(4, 'mat-divider'),
                    Ro(5, 'div', 4),
                    Ro(6, 'div', 5),
                    Ro(7, 'h2'),
                    pa(8, 'C\xf3digo aberto'),
                    Po(),
                    Ro(9, 'p'),
                    pa(
                      10,
                      ' O projeto WebRTC \xe9 de c\xf3digo aberto e suportado pela Apple, Google, Microsoft e Mozilla, entre outros. '
                    ),
                    Po(),
                    Ro(11, 'p'),
                    pa(
                      12,
                      ' Todo conte\xfado do projeto s\xe3o/ser\xe3o mantidos pela comunidade. '
                    ),
                    Ro(13, 'a', 6),
                    pa(14, 'Gostaria de contribuir?'),
                    Po(),
                    Po(),
                    Po(),
                    Ro(15, 'div', 5),
                    Ro(16, 'h2'),
                    pa(17, 'Vers\xe1til'),
                    Po(),
                    Ro(18, 'p'),
                    pa(
                      19,
                      ' Projetado de forma que possa ser integrado aos sistemas de comunica\xe7\xe3o existentes: voz sobre IP (VOIP), v\xe1rios clientes SIP. '
                    ),
                    Po(),
                    Ro(20, 'p'),
                    pa(21, 'Inclusive rede telef\xf4nica p\xfablica comutada.'),
                    Po(),
                    Po(),
                    Ro(22, 'div', 5),
                    Ro(23, 'h2'),
                    pa(24, 'Simples'),
                    Po(),
                    Ro(25, 'p'),
                    pa(
                      26,
                      ' Aplica\xe7\xf5es de \xe1udio, v\xeddeo e troca de dados ponto a ponto com alta qualidade, requer muitas novas funcionalidades no navegador. '
                    ),
                    Po(),
                    Ro(27, 'p'),
                    pa(
                      28,
                      ' Felizmente, o navegador abstrai a essa complexidade com tr\xeas APIs principais. '
                    ),
                    Do(29, 'br'),
                    Po(),
                    Po(),
                    Po(),
                    Ro(30, 'div', 4),
                    Ro(31, 'div', 5),
                    Ro(32, 'h2'),
                    pa(33, 'MediaStream'),
                    Po(),
                    Ro(34, 'p'),
                    pa(
                      35,
                      'Aquisi\xe7\xe3o de streams para \xe1udio e v\xeddeo'
                    ),
                    Po(),
                    Po(),
                    Ro(36, 'div', 5),
                    Ro(37, 'h2'),
                    pa(38, 'RTCPeerConnection'),
                    Po(),
                    Ro(39, 'p'),
                    pa(
                      40,
                      'Comunica\xe7\xe3o de dados para \xe1udio e v\xeddeo'
                    ),
                    Po(),
                    Po(),
                    Ro(41, 'div', 5),
                    Ro(42, 'h2'),
                    pa(43, 'RTCDataChannel'),
                    Po(),
                    Ro(44, 'p'),
                    pa(45, 'Comunica\xe7\xe3o de dados para aplicativos'),
                    Po(),
                    Po(),
                    Po(),
                    Po(),
                    Do(46, 'app-footer')),
                    2 & t &&
                      (Xs(2),
                      Oo('itemWidth', 260)('aria-label', 'Featured components'),
                      Xs(1),
                      Oo('ngForOf', e.banners))
                },
                directives: [K_, jh, G_, Vw, aC, W_],
                styles: [
                  '[_nghost-%COMP%]{position:relative;display:flex;flex-direction:column;flex:1}.docs-header-background[_ngcontent-%COMP%]{overflow:hidden;position:relative;height:420px}.docs-header-background[_ngcontent-%COMP%]:before{content:"";position:absolute;background-size:600px;top:0;bottom:0;left:0;right:0;background-repeat:no-repeat;background-position:80% 20px;opacity:.2}.docs-header-section[_ngcontent-%COMP%]{width:90%;position:absolute;z-index:0;text-align:center;top:50%;left:50%;transform:translate(-50%,-50%)}.docs-header-headline[_ngcontent-%COMP%]   h1[_ngcontent-%COMP%]{font-size:56px;font-weight:700;line-height:56px;margin:15px 5px}.docs-header-headline[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{font-size:20px;font-weight:300;line-height:28px;margin:15px 0 25px}.docs-home-promo[_ngcontent-%COMP%]{flex:1;align-items:center;display:flex;flex-direction:column;padding:16px}.docs-home-promo[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{text-decoration:none}.docs-home-promo[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{font-size:25px;font-weight:400;margin:16px 0;padding:0}.docs-home-promo[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-size:16px;font-weight:400;line-height:28px;margin:0 0 24px;padding:0}.docs-home-promo[_ngcontent-%COMP%]   mat-divider[_ngcontent-%COMP%]{width:75%}.docs-home-promo[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{vertical-align:middle}.docs-home-row[_ngcontent-%COMP%]{width:75%;display:flex;flex-direction:row;margin:50px 0}.docs-home-carousel-row[_ngcontent-%COMP%]{margin:50px 0;width:75%;display:flex;flex-direction:column}.docs-home-carousel-row[_ngcontent-%COMP%]   a.docs-link[_ngcontent-%COMP%]{width:100%;text-align:right}.docs-home-carousel-row[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{margin-top:0}.docs-home-guides[_ngcontent-%COMP%]   .docs-home-guides-card-divider[_ngcontent-%COMP%]{width:30%;height:5px;margin:15px auto}.docs-home-guides[_ngcontent-%COMP%]   .docs-home-guides-carousel-item[_ngcontent-%COMP%]{padding:15px;display:flex;text-decoration:none}.docs-home-guides[_ngcontent-%COMP%]   .docs-home-guides-card.mat-card[_ngcontent-%COMP%]{text-align:center}.docs-home-guides[_ngcontent-%COMP%]   .docs-home-guides-card[_ngcontent-%COMP%]   .mat-card-title[_ngcontent-%COMP%]{height:35%;display:flex;align-items:center;justify-content:center;font-size:20px}.docs-home-featured-components[_ngcontent-%COMP%]   .docs-featured-components-carousel-item[_ngcontent-%COMP%]{padding:15px;text-align:center}.docs-home-featured-components[_ngcontent-%COMP%]   .docs-featured-components-carousel-item[_ngcontent-%COMP%]   .docs-home-img-container[_ngcontent-%COMP%]{overflow:hidden;width:259px;height:144px;margin-bottom:10px}.docs-home-featured-components[_ngcontent-%COMP%]   .docs-featured-components-carousel-item[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{transition:.3s ease-in-out;width:100%}.docs-home-row-column[_ngcontent-%COMP%]{display:flex;flex-direction:column;margin:0 auto;width:30%}.docs-header-start[_ngcontent-%COMP%]{text-align:center;margin:50px 0 0}.docs-header-start[_ngcontent-%COMP%]   .mat-raised-button[_ngcontent-%COMP%]{font-size:15px}@media (max-width:1200px){.docs-header-background[_ngcontent-%COMP%]{height:330px}.docs-header-background[_ngcontent-%COMP%]:before{background-image:none}}@media (max-width:850px){.docs-header-background[_ngcontent-%COMP%]:before{background-image:none}.docs-introduction[_ngcontent-%COMP%]{flex-direction:column}.docs-home-row-column[_ngcontent-%COMP%]{width:100%}}@media (max-width:720px){.docs-header-start[_ngcontent-%COMP%]{margin:15px 0 0}.docs-home-carousel-row[_ngcontent-%COMP%], .docs-home-row[_ngcontent-%COMP%]{margin:15px 0}}',
                ],
              })),
              t
            )
          })(),
        },
        { path: 'restart-ice', component: i_ },
        { path: 'peer-to-peer', component: cu },
        { path: 'perfect-negotiation', component: ou },
      ]
      let hC = (() => {
        class t {}
        return (
          (t.ɵmod = $t({ type: t })),
          (t.ɵinj = ut({
            factory: function (e) {
              return new (e || t)()
            },
            imports: [[Gh, cy, Rp], cy],
          })),
          t
        )
      })()
      function uC(t) {
        return null == t || 0 === t.length
      }
      function dC(t) {
        return null != t && 'number' == typeof t.length
      }
      const pC = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
      class fC {
        static min(t) {
          return (e) => {
            if (uC(e.value) || uC(t)) return null
            const n = parseFloat(e.value)
            return !isNaN(n) && n < t
              ? { min: { min: t, actual: e.value } }
              : null
          }
        }
        static max(t) {
          return (e) => {
            if (uC(e.value) || uC(t)) return null
            const n = parseFloat(e.value)
            return !isNaN(n) && n > t
              ? { max: { max: t, actual: e.value } }
              : null
          }
        }
        static required(t) {
          return uC(t.value) ? { required: !0 } : null
        }
        static requiredTrue(t) {
          return !0 === t.value ? null : { required: !0 }
        }
        static email(t) {
          return uC(t.value) || pC.test(t.value) ? null : { email: !0 }
        }
        static minLength(t) {
          return (e) =>
            uC(e.value) || !dC(e.value)
              ? null
              : e.value.length < t
              ? {
                  minlength: {
                    requiredLength: t,
                    actualLength: e.value.length,
                  },
                }
              : null
        }
        static maxLength(t) {
          return (e) =>
            dC(e.value) && e.value.length > t
              ? {
                  maxlength: {
                    requiredLength: t,
                    actualLength: e.value.length,
                  },
                }
              : null
        }
        static pattern(t) {
          if (!t) return fC.nullValidator
          let e, n
          return (
            'string' == typeof t
              ? ((n = ''),
                '^' !== t.charAt(0) && (n += '^'),
                (n += t),
                '$' !== t.charAt(t.length - 1) && (n += '$'),
                (e = new RegExp(n)))
              : ((n = t.toString()), (e = t)),
            (t) => {
              if (uC(t.value)) return null
              const i = t.value
              return e.test(i)
                ? null
                : { pattern: { requiredPattern: n, actualValue: i } }
            }
          )
        }
        static nullValidator(t) {
          return null
        }
        static compose(t) {
          if (!t) return null
          const e = t.filter(mC)
          return 0 == e.length
            ? null
            : function (t) {
                return yC(_C(t, e))
              }
        }
        static composeAsync(t) {
          if (!t) return null
          const e = t.filter(mC)
          return 0 == e.length
            ? null
            : function (t) {
                return s_(_C(t, e).map(gC)).pipe(F(yC))
              }
        }
      }
      function mC(t) {
        return null != t
      }
      function gC(t) {
        const e = Lo(t) ? B(t) : t
        return jo(e), e
      }
      function yC(t) {
        let e = {}
        return (
          t.forEach((t) => {
            e = null != t ? Object.assign(Object.assign({}, e), t) : e
          }),
          0 === Object.keys(e).length ? null : e
        )
      }
      function _C(t, e) {
        return e.map((e) => e(t))
      }
      function vC(t) {
        return t.map((t) =>
          (function (t) {
            return !t.validate
          })(t)
            ? t
            : (e) => t.validate(e)
        )
      }
      let bC = (() => {
        class t {
          constructor() {
            this._accessors = []
          }
          add(t, e) {
            this._accessors.push([t, e])
          }
          remove(t) {
            for (let e = this._accessors.length - 1; e >= 0; --e)
              if (this._accessors[e][1] === t)
                return void this._accessors.splice(e, 1)
          }
          select(t) {
            this._accessors.forEach((e) => {
              this._isSameGroup(e, t) && e[1] !== t && e[1].fireUncheck(t.value)
            })
          }
          _isSameGroup(t, e) {
            return (
              !!t[0].control &&
              t[0]._parent === e._control._parent &&
              t[1].name === e.name
            )
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      function wC(t, e) {
        const n = t.indexOf(e)
        n > -1 && t.splice(n, 1)
      }
      const CC = 'VALID',
        xC = 'INVALID',
        SC = 'PENDING',
        EC = 'DISABLED'
      function kC(t) {
        return (IC(t) ? t.validators : t) || null
      }
      function TC(t) {
        return Array.isArray(t)
          ? null != (e = t)
            ? fC.compose(vC(e))
            : null
          : t || null
        var e
      }
      function AC(t, e) {
        return (IC(e) ? e.asyncValidators : t) || null
      }
      function OC(t) {
        return Array.isArray(t)
          ? null != (e = t)
            ? fC.composeAsync(vC(e))
            : null
          : t || null
        var e
      }
      function IC(t) {
        return null != t && !Array.isArray(t) && 'object' == typeof t
      }
      class RC {
        constructor(t, e) {
          ;(this._hasOwnPendingAsyncValidator = !1),
            (this._onCollectionChange = () => {}),
            (this._parent = null),
            (this.pristine = !0),
            (this.touched = !1),
            (this._onDisabledChange = []),
            (this._rawValidators = t),
            (this._rawAsyncValidators = e),
            (this._composedValidatorFn = TC(this._rawValidators)),
            (this._composedAsyncValidatorFn = OC(this._rawAsyncValidators))
        }
        get validator() {
          return this._composedValidatorFn
        }
        set validator(t) {
          this._rawValidators = this._composedValidatorFn = t
        }
        get asyncValidator() {
          return this._composedAsyncValidatorFn
        }
        set asyncValidator(t) {
          this._rawAsyncValidators = this._composedAsyncValidatorFn = t
        }
        get parent() {
          return this._parent
        }
        get valid() {
          return this.status === CC
        }
        get invalid() {
          return this.status === xC
        }
        get pending() {
          return this.status == SC
        }
        get disabled() {
          return this.status === EC
        }
        get enabled() {
          return this.status !== EC
        }
        get dirty() {
          return !this.pristine
        }
        get untouched() {
          return !this.touched
        }
        get updateOn() {
          return this._updateOn
            ? this._updateOn
            : this.parent
            ? this.parent.updateOn
            : 'change'
        }
        setValidators(t) {
          ;(this._rawValidators = t), (this._composedValidatorFn = TC(t))
        }
        setAsyncValidators(t) {
          ;(this._rawAsyncValidators = t),
            (this._composedAsyncValidatorFn = OC(t))
        }
        clearValidators() {
          this.validator = null
        }
        clearAsyncValidators() {
          this.asyncValidator = null
        }
        markAsTouched(t = {}) {
          ;(this.touched = !0),
            this._parent && !t.onlySelf && this._parent.markAsTouched(t)
        }
        markAllAsTouched() {
          this.markAsTouched({ onlySelf: !0 }),
            this._forEachChild((t) => t.markAllAsTouched())
        }
        markAsUntouched(t = {}) {
          ;(this.touched = !1),
            (this._pendingTouched = !1),
            this._forEachChild((t) => {
              t.markAsUntouched({ onlySelf: !0 })
            }),
            this._parent && !t.onlySelf && this._parent._updateTouched(t)
        }
        markAsDirty(t = {}) {
          ;(this.pristine = !1),
            this._parent && !t.onlySelf && this._parent.markAsDirty(t)
        }
        markAsPristine(t = {}) {
          ;(this.pristine = !0),
            (this._pendingDirty = !1),
            this._forEachChild((t) => {
              t.markAsPristine({ onlySelf: !0 })
            }),
            this._parent && !t.onlySelf && this._parent._updatePristine(t)
        }
        markAsPending(t = {}) {
          ;(this.status = SC),
            !1 !== t.emitEvent && this.statusChanges.emit(this.status),
            this._parent && !t.onlySelf && this._parent.markAsPending(t)
        }
        disable(t = {}) {
          const e = this._parentMarkedDirty(t.onlySelf)
          ;(this.status = EC),
            (this.errors = null),
            this._forEachChild((e) => {
              e.disable(Object.assign(Object.assign({}, t), { onlySelf: !0 }))
            }),
            this._updateValue(),
            !1 !== t.emitEvent &&
              (this.valueChanges.emit(this.value),
              this.statusChanges.emit(this.status)),
            this._updateAncestors(
              Object.assign(Object.assign({}, t), { skipPristineCheck: e })
            ),
            this._onDisabledChange.forEach((t) => t(!0))
        }
        enable(t = {}) {
          const e = this._parentMarkedDirty(t.onlySelf)
          ;(this.status = CC),
            this._forEachChild((e) => {
              e.enable(Object.assign(Object.assign({}, t), { onlySelf: !0 }))
            }),
            this.updateValueAndValidity({
              onlySelf: !0,
              emitEvent: t.emitEvent,
            }),
            this._updateAncestors(
              Object.assign(Object.assign({}, t), { skipPristineCheck: e })
            ),
            this._onDisabledChange.forEach((t) => t(!1))
        }
        _updateAncestors(t) {
          this._parent &&
            !t.onlySelf &&
            (this._parent.updateValueAndValidity(t),
            t.skipPristineCheck || this._parent._updatePristine(),
            this._parent._updateTouched())
        }
        setParent(t) {
          this._parent = t
        }
        updateValueAndValidity(t = {}) {
          this._setInitialStatus(),
            this._updateValue(),
            this.enabled &&
              (this._cancelExistingSubscription(),
              (this.errors = this._runValidator()),
              (this.status = this._calculateStatus()),
              (this.status !== CC && this.status !== SC) ||
                this._runAsyncValidator(t.emitEvent)),
            !1 !== t.emitEvent &&
              (this.valueChanges.emit(this.value),
              this.statusChanges.emit(this.status)),
            this._parent &&
              !t.onlySelf &&
              this._parent.updateValueAndValidity(t)
        }
        _updateTreeValidity(t = { emitEvent: !0 }) {
          this._forEachChild((e) => e._updateTreeValidity(t)),
            this.updateValueAndValidity({
              onlySelf: !0,
              emitEvent: t.emitEvent,
            })
        }
        _setInitialStatus() {
          this.status = this._allControlsDisabled() ? EC : CC
        }
        _runValidator() {
          return this.validator ? this.validator(this) : null
        }
        _runAsyncValidator(t) {
          if (this.asyncValidator) {
            ;(this.status = SC), (this._hasOwnPendingAsyncValidator = !0)
            const e = gC(this.asyncValidator(this))
            this._asyncValidationSubscription = e.subscribe((e) => {
              ;(this._hasOwnPendingAsyncValidator = !1),
                this.setErrors(e, { emitEvent: t })
            })
          }
        }
        _cancelExistingSubscription() {
          this._asyncValidationSubscription &&
            (this._asyncValidationSubscription.unsubscribe(),
            (this._hasOwnPendingAsyncValidator = !1))
        }
        setErrors(t, e = {}) {
          ;(this.errors = t), this._updateControlsErrors(!1 !== e.emitEvent)
        }
        get(t) {
          return (function (t, e, n) {
            if (null == e) return null
            if (
              (Array.isArray(e) || (e = e.split('.')),
              Array.isArray(e) && 0 === e.length)
            )
              return null
            let i = t
            return (
              e.forEach((t) => {
                i =
                  i instanceof DC
                    ? i.controls.hasOwnProperty(t)
                      ? i.controls[t]
                      : null
                    : (i instanceof NC && i.at(t)) || null
              }),
              i
            )
          })(this, t)
        }
        getError(t, e) {
          const n = e ? this.get(e) : this
          return n && n.errors ? n.errors[t] : null
        }
        hasError(t, e) {
          return !!this.getError(t, e)
        }
        get root() {
          let t = this
          for (; t._parent; ) t = t._parent
          return t
        }
        _updateControlsErrors(t) {
          ;(this.status = this._calculateStatus()),
            t && this.statusChanges.emit(this.status),
            this._parent && this._parent._updateControlsErrors(t)
        }
        _initObservables() {
          ;(this.valueChanges = new zl()), (this.statusChanges = new zl())
        }
        _calculateStatus() {
          return this._allControlsDisabled()
            ? EC
            : this.errors
            ? xC
            : this._hasOwnPendingAsyncValidator ||
              this._anyControlsHaveStatus(SC)
            ? SC
            : this._anyControlsHaveStatus(xC)
            ? xC
            : CC
        }
        _anyControlsHaveStatus(t) {
          return this._anyControls((e) => e.status === t)
        }
        _anyControlsDirty() {
          return this._anyControls((t) => t.dirty)
        }
        _anyControlsTouched() {
          return this._anyControls((t) => t.touched)
        }
        _updatePristine(t = {}) {
          ;(this.pristine = !this._anyControlsDirty()),
            this._parent && !t.onlySelf && this._parent._updatePristine(t)
        }
        _updateTouched(t = {}) {
          ;(this.touched = this._anyControlsTouched()),
            this._parent && !t.onlySelf && this._parent._updateTouched(t)
        }
        _isBoxedValue(t) {
          return (
            'object' == typeof t &&
            null !== t &&
            2 === Object.keys(t).length &&
            'value' in t &&
            'disabled' in t
          )
        }
        _registerOnCollectionChange(t) {
          this._onCollectionChange = t
        }
        _setUpdateStrategy(t) {
          IC(t) && null != t.updateOn && (this._updateOn = t.updateOn)
        }
        _parentMarkedDirty(t) {
          return (
            !t &&
            !(!this._parent || !this._parent.dirty) &&
            !this._parent._anyControlsDirty()
          )
        }
      }
      class PC extends RC {
        constructor(t = null, e, n) {
          super(kC(e), AC(n, e)),
            (this._onChange = []),
            this._applyFormState(t),
            this._setUpdateStrategy(e),
            this._initObservables(),
            this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!n })
        }
        setValue(t, e = {}) {
          ;(this.value = this._pendingValue = t),
            this._onChange.length &&
              !1 !== e.emitModelToViewChange &&
              this._onChange.forEach((t) =>
                t(this.value, !1 !== e.emitViewToModelChange)
              ),
            this.updateValueAndValidity(e)
        }
        patchValue(t, e = {}) {
          this.setValue(t, e)
        }
        reset(t = null, e = {}) {
          this._applyFormState(t),
            this.markAsPristine(e),
            this.markAsUntouched(e),
            this.setValue(this.value, e),
            (this._pendingChange = !1)
        }
        _updateValue() {}
        _anyControls(t) {
          return !1
        }
        _allControlsDisabled() {
          return this.disabled
        }
        registerOnChange(t) {
          this._onChange.push(t)
        }
        _unregisterOnChange(t) {
          wC(this._onChange, t)
        }
        registerOnDisabledChange(t) {
          this._onDisabledChange.push(t)
        }
        _unregisterOnDisabledChange(t) {
          wC(this._onDisabledChange, t)
        }
        _forEachChild(t) {}
        _syncPendingControls() {
          return !(
            'submit' !== this.updateOn ||
            (this._pendingDirty && this.markAsDirty(),
            this._pendingTouched && this.markAsTouched(),
            !this._pendingChange) ||
            (this.setValue(this._pendingValue, {
              onlySelf: !0,
              emitModelToViewChange: !1,
            }),
            0)
          )
        }
        _applyFormState(t) {
          this._isBoxedValue(t)
            ? ((this.value = this._pendingValue = t.value),
              t.disabled
                ? this.disable({ onlySelf: !0, emitEvent: !1 })
                : this.enable({ onlySelf: !0, emitEvent: !1 }))
            : (this.value = this._pendingValue = t)
        }
      }
      class DC extends RC {
        constructor(t, e, n) {
          super(kC(e), AC(n, e)),
            (this.controls = t),
            this._initObservables(),
            this._setUpdateStrategy(e),
            this._setUpControls(),
            this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!n })
        }
        registerControl(t, e) {
          return this.controls[t]
            ? this.controls[t]
            : ((this.controls[t] = e),
              e.setParent(this),
              e._registerOnCollectionChange(this._onCollectionChange),
              e)
        }
        addControl(t, e) {
          this.registerControl(t, e),
            this.updateValueAndValidity(),
            this._onCollectionChange()
        }
        removeControl(t) {
          this.controls[t] &&
            this.controls[t]._registerOnCollectionChange(() => {}),
            delete this.controls[t],
            this.updateValueAndValidity(),
            this._onCollectionChange()
        }
        setControl(t, e) {
          this.controls[t] &&
            this.controls[t]._registerOnCollectionChange(() => {}),
            delete this.controls[t],
            e && this.registerControl(t, e),
            this.updateValueAndValidity(),
            this._onCollectionChange()
        }
        contains(t) {
          return this.controls.hasOwnProperty(t) && this.controls[t].enabled
        }
        setValue(t, e = {}) {
          this._checkAllValuesPresent(t),
            Object.keys(t).forEach((n) => {
              this._throwIfControlMissing(n),
                this.controls[n].setValue(t[n], {
                  onlySelf: !0,
                  emitEvent: e.emitEvent,
                })
            }),
            this.updateValueAndValidity(e)
        }
        patchValue(t, e = {}) {
          Object.keys(t).forEach((n) => {
            this.controls[n] &&
              this.controls[n].patchValue(t[n], {
                onlySelf: !0,
                emitEvent: e.emitEvent,
              })
          }),
            this.updateValueAndValidity(e)
        }
        reset(t = {}, e = {}) {
          this._forEachChild((n, i) => {
            n.reset(t[i], { onlySelf: !0, emitEvent: e.emitEvent })
          }),
            this._updatePristine(e),
            this._updateTouched(e),
            this.updateValueAndValidity(e)
        }
        getRawValue() {
          return this._reduceChildren(
            {},
            (t, e, n) => (
              (t[n] = e instanceof PC ? e.value : e.getRawValue()), t
            )
          )
        }
        _syncPendingControls() {
          let t = this._reduceChildren(
            !1,
            (t, e) => !!e._syncPendingControls() || t
          )
          return t && this.updateValueAndValidity({ onlySelf: !0 }), t
        }
        _throwIfControlMissing(t) {
          if (!Object.keys(this.controls).length)
            throw new Error(
              "\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "
            )
          if (!this.controls[t])
            throw new Error(`Cannot find form control with name: ${t}.`)
        }
        _forEachChild(t) {
          Object.keys(this.controls).forEach((e) => t(this.controls[e], e))
        }
        _setUpControls() {
          this._forEachChild((t) => {
            t.setParent(this),
              t._registerOnCollectionChange(this._onCollectionChange)
          })
        }
        _updateValue() {
          this.value = this._reduceValue()
        }
        _anyControls(t) {
          for (const e of Object.keys(this.controls)) {
            const n = this.controls[e]
            if (this.contains(e) && t(n)) return !0
          }
          return !1
        }
        _reduceValue() {
          return this._reduceChildren(
            {},
            (t, e, n) => ((e.enabled || this.disabled) && (t[n] = e.value), t)
          )
        }
        _reduceChildren(t, e) {
          let n = t
          return (
            this._forEachChild((t, i) => {
              n = e(n, t, i)
            }),
            n
          )
        }
        _allControlsDisabled() {
          for (const t of Object.keys(this.controls))
            if (this.controls[t].enabled) return !1
          return Object.keys(this.controls).length > 0 || this.disabled
        }
        _checkAllValuesPresent(t) {
          this._forEachChild((e, n) => {
            if (void 0 === t[n])
              throw new Error(
                `Must supply a value for form control with name: '${n}'.`
              )
          })
        }
      }
      class NC extends RC {
        constructor(t, e, n) {
          super(kC(e), AC(n, e)),
            (this.controls = t),
            this._initObservables(),
            this._setUpdateStrategy(e),
            this._setUpControls(),
            this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!n })
        }
        at(t) {
          return this.controls[t]
        }
        push(t) {
          this.controls.push(t),
            this._registerControl(t),
            this.updateValueAndValidity(),
            this._onCollectionChange()
        }
        insert(t, e) {
          this.controls.splice(t, 0, e),
            this._registerControl(e),
            this.updateValueAndValidity()
        }
        removeAt(t) {
          this.controls[t] &&
            this.controls[t]._registerOnCollectionChange(() => {}),
            this.controls.splice(t, 1),
            this.updateValueAndValidity()
        }
        setControl(t, e) {
          this.controls[t] &&
            this.controls[t]._registerOnCollectionChange(() => {}),
            this.controls.splice(t, 1),
            e && (this.controls.splice(t, 0, e), this._registerControl(e)),
            this.updateValueAndValidity(),
            this._onCollectionChange()
        }
        get length() {
          return this.controls.length
        }
        setValue(t, e = {}) {
          this._checkAllValuesPresent(t),
            t.forEach((t, n) => {
              this._throwIfControlMissing(n),
                this.at(n).setValue(t, { onlySelf: !0, emitEvent: e.emitEvent })
            }),
            this.updateValueAndValidity(e)
        }
        patchValue(t, e = {}) {
          t.forEach((t, n) => {
            this.at(n) &&
              this.at(n).patchValue(t, { onlySelf: !0, emitEvent: e.emitEvent })
          }),
            this.updateValueAndValidity(e)
        }
        reset(t = [], e = {}) {
          this._forEachChild((n, i) => {
            n.reset(t[i], { onlySelf: !0, emitEvent: e.emitEvent })
          }),
            this._updatePristine(e),
            this._updateTouched(e),
            this.updateValueAndValidity(e)
        }
        getRawValue() {
          return this.controls.map((t) =>
            t instanceof PC ? t.value : t.getRawValue()
          )
        }
        clear() {
          this.controls.length < 1 ||
            (this._forEachChild((t) => t._registerOnCollectionChange(() => {})),
            this.controls.splice(0),
            this.updateValueAndValidity())
        }
        _syncPendingControls() {
          let t = this.controls.reduce(
            (t, e) => !!e._syncPendingControls() || t,
            !1
          )
          return t && this.updateValueAndValidity({ onlySelf: !0 }), t
        }
        _throwIfControlMissing(t) {
          if (!this.controls.length)
            throw new Error(
              "\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "
            )
          if (!this.at(t))
            throw new Error('Cannot find form control at index ' + t)
        }
        _forEachChild(t) {
          this.controls.forEach((e, n) => {
            t(e, n)
          })
        }
        _updateValue() {
          this.value = this.controls
            .filter((t) => t.enabled || this.disabled)
            .map((t) => t.value)
        }
        _anyControls(t) {
          return this.controls.some((e) => e.enabled && t(e))
        }
        _setUpControls() {
          this._forEachChild((t) => this._registerControl(t))
        }
        _checkAllValuesPresent(t) {
          this._forEachChild((e, n) => {
            if (void 0 === t[n])
              throw new Error(
                `Must supply a value for form control at index: ${n}.`
              )
          })
        }
        _allControlsDisabled() {
          for (const t of this.controls) if (t.enabled) return !1
          return this.controls.length > 0 || this.disabled
        }
        _registerControl(t) {
          t.setParent(this),
            t._registerOnCollectionChange(this._onCollectionChange)
        }
      }
      const FC = new Yn('NgModelWithFormControlWarning')
      let MC = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
            })),
            t
          )
        })(),
        LC = (() => {
          class t {
            group(t, e = null) {
              const n = this._reduceControls(t)
              let i = null,
                s = null,
                r = void 0
              return (
                null != e &&
                  ((function (t) {
                    return (
                      void 0 !== t.asyncValidators ||
                      void 0 !== t.validators ||
                      void 0 !== t.updateOn
                    )
                  })(e)
                    ? ((i = null != e.validators ? e.validators : null),
                      (s =
                        null != e.asyncValidators ? e.asyncValidators : null),
                      (r = null != e.updateOn ? e.updateOn : void 0))
                    : ((i = null != e.validator ? e.validator : null),
                      (s =
                        null != e.asyncValidator ? e.asyncValidator : null))),
                new DC(n, { asyncValidators: s, updateOn: r, validators: i })
              )
            }
            control(t, e, n) {
              return new PC(t, e, n)
            }
            array(t, e, n) {
              const i = t.map((t) => this._createControl(t))
              return new NC(i, e, n)
            }
            _reduceControls(t) {
              const e = {}
              return (
                Object.keys(t).forEach((n) => {
                  e[n] = this._createControl(t[n])
                }),
                e
              )
            }
            _createControl(t) {
              return t instanceof PC || t instanceof DC || t instanceof NC
                ? t
                : Array.isArray(t)
                ? this.control(
                    t[0],
                    t.length > 1 ? t[1] : null,
                    t.length > 2 ? t[2] : null
                  )
                : this.control(t)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        jC = (() => {
          class t {
            static withConfig(e) {
              return {
                ngModule: t,
                providers: [
                  { provide: FC, useValue: e.warnOnNgModelWithFormControl },
                ],
              }
            }
          }
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
              providers: [LC, bC],
              imports: [MC],
            })),
            t
          )
        })()
      const BC = {
        provide: new Yn('mat-select-scroll-strategy'),
        deps: [Gd],
        useFactory: function (t) {
          return () => t.scrollStrategies.reposition()
        },
      }
      let VC = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
              providers: [BC],
              imports: [[Gh, Zd, ky, cy], ld, hC, ky, cy],
            })),
            t
          )
        })(),
        UC = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[Gh, U_, Qy, VC, hC, jC]],
            })),
            t
          )
        })(),
        zC = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[Gh, U_, Qy]],
            })),
            t
          )
        })()
      class HC {
        constructor(t) {
          this.total = t
        }
        call(t, e) {
          return e.subscribe(new qC(t, this.total))
        }
      }
      class qC extends f {
        constructor(t, e) {
          super(t), (this.total = e), (this.count = 0)
        }
        _next(t) {
          ++this.count > this.total && this.destination.next(t)
        }
      }
      let $C = (() => {
        class t {}
        return (
          (t.ɵmod = $t({ type: t })),
          (t.ɵinj = ut({
            factory: function (e) {
              return new (e || t)()
            },
          })),
          t
        )
      })()
      const WC = new Set()
      let KC,
        GC = (() => {
          class t {
            constructor(t) {
              ;(this._platform = t),
                (this._matchMedia =
                  this._platform.isBrowser && window.matchMedia
                    ? window.matchMedia.bind(window)
                    : QC)
            }
            matchMedia(t) {
              return (
                this._platform.WEBKIT &&
                  (function (t) {
                    if (!WC.has(t))
                      try {
                        KC ||
                          ((KC = document.createElement('style')),
                          KC.setAttribute('type', 'text/css'),
                          document.head.appendChild(KC)),
                          KC.sheet &&
                            (KC.sheet.insertRule(
                              `@media ${t} {.fx-query-test{ }}`,
                              0
                            ),
                            WC.add(t))
                      } catch (e) {
                        console.error(e)
                      }
                  })(t),
                this._matchMedia(t)
              )
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(Xu))
            }),
            (t.ɵprov = ht({
              factory: function () {
                return new t(vi(Xu))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })()
      function QC(t) {
        return {
          matches: 'all' === t || '' === t,
          media: t,
          addListener: () => {},
          removeListener: () => {},
        }
      }
      let ZC = (() => {
        class t {
          constructor(t, e) {
            ;(this._mediaMatcher = t),
              (this._zone = e),
              (this._queries = new Map()),
              (this._destroySubject = new x())
          }
          ngOnDestroy() {
            this._destroySubject.next(), this._destroySubject.complete()
          }
          isMatched(t) {
            return YC(du(t)).some((t) => this._registerQuery(t).mql.matches)
          }
          observe(t) {
            let e = Y_(YC(du(t)).map((t) => this._registerQuery(t).observable))
            return (
              (e = Lu(
                e.pipe(_d(1)),
                e.pipe((t) => t.lift(new HC(1)), kp(0))
              )),
              e.pipe(
                F((t) => {
                  const e = { matches: !1, breakpoints: {} }
                  return (
                    t.forEach(({ matches: t, query: n }) => {
                      ;(e.matches = e.matches || t), (e.breakpoints[n] = t)
                    }),
                    e
                  )
                })
              )
            )
          }
          _registerQuery(t) {
            if (this._queries.has(t)) return this._queries.get(t)
            const e = this._mediaMatcher.matchMedia(t),
              n = {
                observable: new _((t) => {
                  const n = (e) => this._zone.run(() => t.next(e))
                  return (
                    e.addListener(n),
                    () => {
                      e.removeListener(n)
                    }
                  )
                }).pipe(
                  ju(e),
                  F(({ matches: e }) => ({ query: t, matches: e })),
                  Du(this._destroySubject)
                ),
                mql: e,
              }
            return this._queries.set(t, n), n
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(vi(GC), vi(Oc))
          }),
          (t.ɵprov = ht({
            factory: function () {
              return new t(vi(GC), vi(Oc))
            },
            token: t,
            providedIn: 'root',
          })),
          t
        )
      })()
      function YC(t) {
        return t
          .map((t) => t.split(','))
          .reduce((t, e) => t.concat(e))
          .map((t) => t.trim())
      }
      let XC = (() => {
        class t {
          constructor() {}
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵcmp = Ut({
            type: t,
            selectors: [['app-navbar']],
            inputs: { snav: 'snav', title: 'title' },
<<<<<<< HEAD:docs/main.ac9691a87d3bc28484b9.js
            decls: 10,
=======
            decls: 11,
>>>>>>> feat: pwa:docs/main.4d6e4788e165e2c89322.js
            vars: 1,
            consts: [
              ['color', 'primary', 1, 'client-toolbar'],
              ['mat-icon-button', '', 3, 'click'],
<<<<<<< HEAD:docs/main.ac9691a87d3bc28484b9.js
              ['src', 'assets/message.svg', 'alt', ''],
              ['mat-icon-button', '', 'routerLink', '/'],
              [1, 'client-app-name'],
=======
              ['mat-icon-button', '', 'routerLink', '/'],
              [1, 'client-app-name'],
              [1, 'spacer'],
              ['src', 'assets/message.svg', 'alt', ''],
>>>>>>> feat: pwa:docs/main.4d6e4788e165e2c89322.js
            ],
            template: function (t, e) {
              1 & t &&
                (Ro(0, 'mat-toolbar', 0),
                Ro(1, 'button', 1),
                Bo('click', function () {
                  return e.snav.toggle()
                }),
                Ro(2, 'mat-icon'),
                pa(3, 'menu'),
                Po(),
                Po(),
<<<<<<< HEAD:docs/main.ac9691a87d3bc28484b9.js
                Do(4, 'img', 2),
                Ro(5, 'a', 3),
                Ro(6, 'mat-icon'),
                pa(7, 'home'),
                Po(),
                Po(),
                Ro(8, 'h1', 4),
                pa(9),
                Po(),
                Po()),
                2 & t && (Xs(9), fa(e.title))
=======
                Ro(4, 'a', 2),
                Ro(5, 'mat-icon'),
                pa(6, 'home'),
                Po(),
                Po(),
                Ro(7, 'h1', 3),
                pa(8),
                Po(),
                Do(9, 'span', 4),
                Do(10, 'img', 5),
                Po()),
                2 & t && (Xs(8), fa(e.title))
>>>>>>> feat: pwa:docs/main.4d6e4788e165e2c89322.js
            },
            directives: [Py, Ky, V_, Gy, Vw],
            styles: [''],
          })),
          t
        )
      })()
      function JC(t) {
        return (e) => e.lift(new tx(t))
      }
      class tx {
        constructor(t) {
          this.value = t
        }
        call(t, e) {
          return e.subscribe(new ex(t, this.value))
        }
      }
      class ex extends f {
        constructor(t, e) {
          super(t), (this.value = e)
        }
        _next(t) {
          this.destination.next(this.value)
        }
      }
      const nx = ['*']
      function ix(t, e) {
        if (1 & t) {
          const t = Mo()
          Ro(0, 'div', 2),
            Bo('click', function () {
              return Me(t), qo()._onBackdropClicked()
            }),
            Po()
        }
        2 & t && na('mat-drawer-shown', qo()._isShowingBackdrop())
      }
      function sx(t, e) {
        1 & t && (Ro(0, 'mat-drawer-content'), Ko(1, 2), Po())
      }
      const rx = [[['mat-drawer']], [['mat-drawer-content']], '*'],
        ox = ['mat-drawer', 'mat-drawer-content', '*']
      function ax(t, e) {
        if (1 & t) {
          const t = Mo()
          Ro(0, 'div', 2),
            Bo('click', function () {
              return Me(t), qo()._onBackdropClicked()
            }),
            Po()
        }
        2 & t && na('mat-drawer-shown', qo()._isShowingBackdrop())
      }
      function lx(t, e) {
        1 & t && (Ro(0, 'mat-sidenav-content', 3), Ko(1, 2), Po())
      }
      const cx = [[['mat-sidenav']], [['mat-sidenav-content']], '*'],
        hx = ['mat-sidenav', 'mat-sidenav-content', '*'],
        ux =
          '.mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\n',
        dx = {
          transformDrawer: Jd('transform', [
            ip(
              'open, open-instant',
              np({ transform: 'none', visibility: 'visible' })
            ),
            ip('void', np({ 'box-shadow': 'none', visibility: 'hidden' })),
            rp('void => open-instant', tp('0ms')),
            rp(
              'void <=> open, open-instant => void',
              tp('400ms cubic-bezier(0.25, 0.8, 0.25, 1)')
            ),
          ]),
        },
        px = new Yn('MAT_DRAWER_DEFAULT_AUTOSIZE', {
          providedIn: 'root',
          factory: function () {
            return !1
          },
        }),
        fx = new Yn('MAT_DRAWER_CONTAINER')
      let mx = (() => {
          class t extends od {
            constructor(t, e, n, i, s) {
              super(n, i, s),
                (this._changeDetectorRef = t),
                (this._container = e)
            }
            ngAfterContentInit() {
              this._container._contentMarginChanges.subscribe(() => {
                this._changeDetectorRef.markForCheck()
              })
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                Ao(cl),
                Ao(at(() => yx)),
                Ao(Va),
                Ao(rd),
                Ao(Oc)
              )
            }),
            (t.ɵcmp = Ut({
              type: t,
              selectors: [['mat-drawer-content']],
              hostAttrs: [1, 'mat-drawer-content'],
              hostVars: 4,
              hostBindings: function (t, e) {
                2 & t &&
                  ea('margin-left', e._container._contentMargins.left, 'px')(
                    'margin-right',
                    e._container._contentMargins.right,
                    'px'
                  )
              },
              features: [po],
              ngContentSelectors: nx,
              decls: 1,
              vars: 0,
              template: function (t, e) {
                1 & t && (Wo(), Ko(0))
              },
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        gx = (() => {
          class t {
            constructor(t, e, n, i, s, r, o) {
              ;(this._elementRef = t),
                (this._focusTrapFactory = e),
                (this._focusMonitor = n),
                (this._platform = i),
                (this._ngZone = s),
                (this._doc = r),
                (this._container = o),
                (this._elementFocusedBeforeDrawerWasOpened = null),
                (this._enableAnimations = !1),
                (this._position = 'start'),
                (this._mode = 'over'),
                (this._disableClose = !1),
                (this._opened = !1),
                (this._animationStarted = new x()),
                (this._animationEnd = new x()),
                (this._animationState = 'void'),
                (this.openedChange = new zl(!0)),
                (this._openedStream = this.openedChange.pipe(
                  Iu((t) => t),
                  F(() => {})
                )),
                (this.openedStart = this._animationStarted.pipe(
                  Iu(
                    (t) =>
                      t.fromState !== t.toState &&
                      0 === t.toState.indexOf('open')
                  ),
                  JC(void 0)
                )),
                (this._closedStream = this.openedChange.pipe(
                  Iu((t) => !t),
                  F(() => {})
                )),
                (this.closedStart = this._animationStarted.pipe(
                  Iu((t) => t.fromState !== t.toState && 'void' === t.toState),
                  JC(void 0)
                )),
                (this._destroyed = new x()),
                (this.onPositionChanged = new zl()),
                (this._modeChanged = new x()),
                this.openedChange.subscribe((t) => {
                  t
                    ? (this._doc &&
                        (this._elementFocusedBeforeDrawerWasOpened = this._doc.activeElement),
                      this._takeFocus())
                    : this._isFocusWithinDrawer() && this._restoreFocus()
                }),
                this._ngZone.runOutsideAngular(() => {
                  gu(this._elementRef.nativeElement, 'keydown')
                    .pipe(
                      Iu(
                        (t) => 27 === t.keyCode && !this.disableClose && !wd(t)
                      ),
                      Du(this._destroyed)
                    )
                    .subscribe((t) =>
                      this._ngZone.run(() => {
                        this.close(), t.stopPropagation(), t.preventDefault()
                      })
                    )
                }),
                this._animationEnd
                  .pipe(
                    (function (t, e) {
                      return (e) => e.lift(new Cu(t, undefined))
                    })(
                      (t, e) =>
                        t.fromState === e.fromState && t.toState === e.toState
                    )
                  )
                  .subscribe((t) => {
                    const { fromState: e, toState: n } = t
                    ;((0 === n.indexOf('open') && 'void' === e) ||
                      ('void' === n && 0 === e.indexOf('open'))) &&
                      this.openedChange.emit(this._opened)
                  })
            }
            get position() {
              return this._position
            }
            set position(t) {
              ;(t = 'end' === t ? 'end' : 'start') != this._position &&
                ((this._position = t), this.onPositionChanged.emit())
            }
            get mode() {
              return this._mode
            }
            set mode(t) {
              ;(this._mode = t),
                this._updateFocusTrapState(),
                this._modeChanged.next()
            }
            get disableClose() {
              return this._disableClose
            }
            set disableClose(t) {
              this._disableClose = hu(t)
            }
            get autoFocus() {
              const t = this._autoFocus
              return null == t ? 'side' !== this.mode : t
            }
            set autoFocus(t) {
              this._autoFocus = hu(t)
            }
            get opened() {
              return this._opened
            }
            set opened(t) {
              this.toggle(hu(t))
            }
            _takeFocus() {
              this.autoFocus &&
                this._focusTrap &&
                this._focusTrap.focusInitialElementWhenReady().then((t) => {
                  t ||
                    'function' != typeof this._elementRef.nativeElement.focus ||
                    this._elementRef.nativeElement.focus()
                })
            }
            _restoreFocus() {
              this.autoFocus &&
                (this._elementFocusedBeforeDrawerWasOpened
                  ? this._focusMonitor.focusVia(
                      this._elementFocusedBeforeDrawerWasOpened,
                      this._openedVia
                    )
                  : this._elementRef.nativeElement.blur(),
                (this._elementFocusedBeforeDrawerWasOpened = null),
                (this._openedVia = null))
            }
            _isFocusWithinDrawer() {
              var t
              const e =
                null === (t = this._doc) || void 0 === t
                  ? void 0
                  : t.activeElement
              return !!e && this._elementRef.nativeElement.contains(e)
            }
            ngAfterContentInit() {
              ;(this._focusTrap = this._focusTrapFactory.create(
                this._elementRef.nativeElement
              )),
                this._updateFocusTrapState()
            }
            ngAfterContentChecked() {
              this._platform.isBrowser && (this._enableAnimations = !0)
            }
            ngOnDestroy() {
              this._focusTrap && this._focusTrap.destroy(),
                this._animationStarted.complete(),
                this._animationEnd.complete(),
                this._modeChanged.complete(),
                this._destroyed.next(),
                this._destroyed.complete()
            }
            open(t) {
              return this.toggle(!0, t)
            }
            close() {
              return this.toggle(!1)
            }
            _closeViaBackdropClick() {
              return this._setOpen(!1, !0)
            }
            toggle(t = !this.opened, e) {
              return this._setOpen(t, !t && this._isFocusWithinDrawer(), e)
            }
            _setOpen(t, e, n = 'program') {
              return (
                (this._opened = t),
                t
                  ? ((this._animationState = this._enableAnimations
                      ? 'open'
                      : 'open-instant'),
                    (this._openedVia = n))
                  : ((this._animationState = 'void'),
                    e && this._restoreFocus()),
                this._updateFocusTrapState(),
                new Promise((t) => {
                  this.openedChange
                    .pipe(_d(1))
                    .subscribe((e) => t(e ? 'open' : 'close'))
                })
              )
            }
            _getWidth() {
              return (
                (this._elementRef.nativeElement &&
                  this._elementRef.nativeElement.offsetWidth) ||
                0
              )
            }
            _updateFocusTrapState() {
              this._focusTrap &&
                (this._focusTrap.enabled = this.opened && 'side' !== this.mode)
            }
            _animationStartListener(t) {
              this._animationStarted.next(t)
            }
            _animationDoneListener(t) {
              this._animationEnd.next(t)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                Ao(Va),
                Ao(qp),
                Ao(Gp),
                Ao(Xu),
                Ao(Oc),
                Ao(mh, 8),
                Ao(fx, 8)
              )
            }),
            (t.ɵcmp = Ut({
              type: t,
              selectors: [['mat-drawer']],
              hostAttrs: ['tabIndex', '-1', 1, 'mat-drawer'],
              hostVars: 12,
              hostBindings: function (t, e) {
                1 & t &&
                  Vo('@transform.start', function (t) {
                    return e._animationStartListener(t)
                  })('@transform.done', function (t) {
                    return e._animationDoneListener(t)
                  }),
                  2 & t &&
                    (Eo('align', null),
                    ya('@transform', e._animationState),
                    na('mat-drawer-end', 'end' === e.position)(
                      'mat-drawer-over',
                      'over' === e.mode
                    )('mat-drawer-push', 'push' === e.mode)(
                      'mat-drawer-side',
                      'side' === e.mode
                    )('mat-drawer-opened', e.opened))
              },
              inputs: {
                position: 'position',
                mode: 'mode',
                disableClose: 'disableClose',
                autoFocus: 'autoFocus',
                opened: 'opened',
              },
              outputs: {
                openedChange: 'openedChange',
                _openedStream: 'opened',
                openedStart: 'openedStart',
                _closedStream: 'closed',
                closedStart: 'closedStart',
                onPositionChanged: 'positionChanged',
              },
              exportAs: ['matDrawer'],
              ngContentSelectors: nx,
              decls: 2,
              vars: 0,
              consts: [[1, 'mat-drawer-inner-container']],
              template: function (t, e) {
                1 & t && (Wo(), Ro(0, 'div', 0), Ko(1), Po())
              },
              encapsulation: 2,
              data: { animation: [dx.transformDrawer] },
              changeDetection: 0,
            })),
            t
          )
        })(),
        yx = (() => {
          class t {
            constructor(t, e, n, i, s, r = !1, o) {
              ;(this._dir = t),
                (this._element = e),
                (this._ngZone = n),
                (this._changeDetectorRef = i),
                (this._animationMode = o),
                (this._drawers = new ql()),
                (this.backdropClick = new zl()),
                (this._destroyed = new x()),
                (this._doCheckSubject = new x()),
                (this._contentMargins = { left: null, right: null }),
                (this._contentMarginChanges = new x()),
                t &&
                  t.change.pipe(Du(this._destroyed)).subscribe(() => {
                    this._validateDrawers(), this.updateContentMargins()
                  }),
                s
                  .change()
                  .pipe(Du(this._destroyed))
                  .subscribe(() => this.updateContentMargins()),
                (this._autosize = r)
            }
            get start() {
              return this._start
            }
            get end() {
              return this._end
            }
            get autosize() {
              return this._autosize
            }
            set autosize(t) {
              this._autosize = hu(t)
            }
            get hasBackdrop() {
              return null == this._backdropOverride
                ? !this._start ||
                    'side' !== this._start.mode ||
                    !this._end ||
                    'side' !== this._end.mode
                : this._backdropOverride
            }
            set hasBackdrop(t) {
              this._backdropOverride = null == t ? null : hu(t)
            }
            get scrollable() {
              return this._userContent || this._content
            }
            ngAfterContentInit() {
              this._allDrawers.changes
                .pipe(ju(this._allDrawers), Du(this._destroyed))
                .subscribe((t) => {
                  this._drawers.reset(
                    t.filter((t) => !t._container || t._container === this)
                  ),
                    this._drawers.notifyOnChanges()
                }),
                this._drawers.changes.pipe(ju(null)).subscribe(() => {
                  this._validateDrawers(),
                    this._drawers.forEach((t) => {
                      this._watchDrawerToggle(t),
                        this._watchDrawerPosition(t),
                        this._watchDrawerMode(t)
                    }),
                    (!this._drawers.length ||
                      this._isDrawerOpen(this._start) ||
                      this._isDrawerOpen(this._end)) &&
                      this.updateContentMargins(),
                    this._changeDetectorRef.markForCheck()
                }),
                this._ngZone.runOutsideAngular(() => {
                  this._doCheckSubject
                    .pipe(kp(10), Du(this._destroyed))
                    .subscribe(() => this.updateContentMargins())
                })
            }
            ngOnDestroy() {
              this._contentMarginChanges.complete(),
                this._doCheckSubject.complete(),
                this._drawers.destroy(),
                this._destroyed.next(),
                this._destroyed.complete()
            }
            open() {
              this._drawers.forEach((t) => t.open())
            }
            close() {
              this._drawers.forEach((t) => t.close())
            }
            updateContentMargins() {
              let t = 0,
                e = 0
              if (this._left && this._left.opened)
                if ('side' == this._left.mode) t += this._left._getWidth()
                else if ('push' == this._left.mode) {
                  const n = this._left._getWidth()
                  ;(t += n), (e -= n)
                }
              if (this._right && this._right.opened)
                if ('side' == this._right.mode) e += this._right._getWidth()
                else if ('push' == this._right.mode) {
                  const n = this._right._getWidth()
                  ;(e += n), (t -= n)
                }
              ;(t = t || null),
                (e = e || null),
                (t === this._contentMargins.left &&
                  e === this._contentMargins.right) ||
                  ((this._contentMargins = { left: t, right: e }),
                  this._ngZone.run(() =>
                    this._contentMarginChanges.next(this._contentMargins)
                  ))
            }
            ngDoCheck() {
              this._autosize &&
                this._isPushed() &&
                this._ngZone.runOutsideAngular(() =>
                  this._doCheckSubject.next()
                )
            }
            _watchDrawerToggle(t) {
              t._animationStarted
                .pipe(
                  Iu((t) => t.fromState !== t.toState),
                  Du(this._drawers.changes)
                )
                .subscribe((t) => {
                  'open-instant' !== t.toState &&
                    'NoopAnimations' !== this._animationMode &&
                    this._element.nativeElement.classList.add(
                      'mat-drawer-transition'
                    ),
                    this.updateContentMargins(),
                    this._changeDetectorRef.markForCheck()
                }),
                'side' !== t.mode &&
                  t.openedChange
                    .pipe(Du(this._drawers.changes))
                    .subscribe(() => this._setContainerClass(t.opened))
            }
            _watchDrawerPosition(t) {
              t &&
                t.onPositionChanged
                  .pipe(Du(this._drawers.changes))
                  .subscribe(() => {
                    this._ngZone.onMicrotaskEmpty.pipe(_d(1)).subscribe(() => {
                      this._validateDrawers()
                    })
                  })
            }
            _watchDrawerMode(t) {
              t &&
                t._modeChanged
                  .pipe(Du($(this._drawers.changes, this._destroyed)))
                  .subscribe(() => {
                    this.updateContentMargins(),
                      this._changeDetectorRef.markForCheck()
                  })
            }
            _setContainerClass(t) {
              const e = this._element.nativeElement.classList,
                n = 'mat-drawer-container-has-open'
              t ? e.add(n) : e.remove(n)
            }
            _validateDrawers() {
              ;(this._start = this._end = null),
                this._drawers.forEach((t) => {
                  'end' == t.position ? (this._end = t) : (this._start = t)
                }),
                (this._right = this._left = null),
                this._dir && 'rtl' === this._dir.value
                  ? ((this._left = this._end), (this._right = this._start))
                  : ((this._left = this._start), (this._right = this._end))
            }
            _isPushed() {
              return (
                (this._isDrawerOpen(this._start) &&
                  'over' != this._start.mode) ||
                (this._isDrawerOpen(this._end) && 'over' != this._end.mode)
              )
            }
            _onBackdropClicked() {
              this.backdropClick.emit(), this._closeModalDrawersViaBackdrop()
            }
            _closeModalDrawersViaBackdrop() {
              ;[this._start, this._end]
                .filter((t) => t && !t.disableClose && this._canHaveBackdrop(t))
                .forEach((t) => t._closeViaBackdropClick())
            }
            _isShowingBackdrop() {
              return (
                (this._isDrawerOpen(this._start) &&
                  this._canHaveBackdrop(this._start)) ||
                (this._isDrawerOpen(this._end) &&
                  this._canHaveBackdrop(this._end))
              )
            }
            _canHaveBackdrop(t) {
              return 'side' !== t.mode || !!this._backdropOverride
            }
            _isDrawerOpen(t) {
              return null != t && t.opened
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                Ao(id, 8),
                Ao(Va),
                Ao(Oc),
                Ao(cl),
                Ao(ad),
                Ao(px),
                Ao(iy, 8)
              )
            }),
            (t.ɵcmp = Ut({
              type: t,
              selectors: [['mat-drawer-container']],
              contentQueries: function (t, e, n) {
                if ((1 & t && (nc(n, mx, !0), nc(n, gx, !0)), 2 & t)) {
                  let t
                  tc((t = ic())) && (e._content = t.first),
                    tc((t = ic())) && (e._allDrawers = t)
                }
              },
              viewQuery: function (t, e) {
                if ((1 & t && ec(mx, !0), 2 & t)) {
                  let t
                  tc((t = ic())) && (e._userContent = t.first)
                }
              },
              hostAttrs: [1, 'mat-drawer-container'],
              hostVars: 2,
              hostBindings: function (t, e) {
                2 & t &&
                  na(
                    'mat-drawer-container-explicit-backdrop',
                    e._backdropOverride
                  )
              },
              inputs: { autosize: 'autosize', hasBackdrop: 'hasBackdrop' },
              outputs: { backdropClick: 'backdropClick' },
              exportAs: ['matDrawerContainer'],
              features: [Da([{ provide: fx, useExisting: t }])],
              ngContentSelectors: ox,
              decls: 4,
              vars: 2,
              consts: [
                [
                  'class',
                  'mat-drawer-backdrop',
                  3,
                  'mat-drawer-shown',
                  'click',
                  4,
                  'ngIf',
                ],
                [4, 'ngIf'],
                [1, 'mat-drawer-backdrop', 3, 'click'],
              ],
              template: function (t, e) {
                1 & t &&
                  (Wo(rx),
                  ko(0, ix, 1, 2, 'div', 0),
                  Ko(1),
                  Ko(2, 1),
                  ko(3, sx, 2, 0, 'mat-drawer-content', 1)),
                  2 & t &&
                    (Oo('ngIf', e.hasBackdrop), Xs(3), Oo('ngIf', !e._content))
              },
              directives: [Vh, mx],
              styles: [ux],
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        _x = (() => {
          class t extends mx {
            constructor(t, e, n, i, s) {
              super(t, e, n, i, s)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                Ao(cl),
                Ao(at(() => wx)),
                Ao(Va),
                Ao(rd),
                Ao(Oc)
              )
            }),
            (t.ɵcmp = Ut({
              type: t,
              selectors: [['mat-sidenav-content']],
              hostAttrs: [1, 'mat-drawer-content', 'mat-sidenav-content'],
              hostVars: 4,
              hostBindings: function (t, e) {
                2 & t &&
                  ea('margin-left', e._container._contentMargins.left, 'px')(
                    'margin-right',
                    e._container._contentMargins.right,
                    'px'
                  )
              },
              features: [po],
              ngContentSelectors: nx,
              decls: 1,
              vars: 0,
              template: function (t, e) {
                1 & t && (Wo(), Ko(0))
              },
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        vx = (() => {
          class t extends gx {
            constructor() {
              super(...arguments),
                (this._fixedInViewport = !1),
                (this._fixedTopGap = 0),
                (this._fixedBottomGap = 0)
            }
            get fixedInViewport() {
              return this._fixedInViewport
            }
            set fixedInViewport(t) {
              this._fixedInViewport = hu(t)
            }
            get fixedTopGap() {
              return this._fixedTopGap
            }
            set fixedTopGap(t) {
              this._fixedTopGap = uu(t)
            }
            get fixedBottomGap() {
              return this._fixedBottomGap
            }
            set fixedBottomGap(t) {
              this._fixedBottomGap = uu(t)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return bx(e || t)
            }),
            (t.ɵcmp = Ut({
              type: t,
              selectors: [['mat-sidenav']],
              hostAttrs: ['tabIndex', '-1', 1, 'mat-drawer', 'mat-sidenav'],
              hostVars: 17,
              hostBindings: function (t, e) {
                2 & t &&
                  (Eo('align', null),
                  ea('top', e.fixedInViewport ? e.fixedTopGap : null, 'px')(
                    'bottom',
                    e.fixedInViewport ? e.fixedBottomGap : null,
                    'px'
                  ),
                  na('mat-drawer-end', 'end' === e.position)(
                    'mat-drawer-over',
                    'over' === e.mode
                  )('mat-drawer-push', 'push' === e.mode)(
                    'mat-drawer-side',
                    'side' === e.mode
                  )('mat-drawer-opened', e.opened)(
                    'mat-sidenav-fixed',
                    e.fixedInViewport
                  ))
              },
              inputs: {
                fixedInViewport: 'fixedInViewport',
                fixedTopGap: 'fixedTopGap',
                fixedBottomGap: 'fixedBottomGap',
              },
              exportAs: ['matSidenav'],
              features: [po],
              ngContentSelectors: nx,
              decls: 2,
              vars: 0,
              consts: [[1, 'mat-drawer-inner-container']],
              template: function (t, e) {
                1 & t && (Wo(), Ro(0, 'div', 0), Ko(1), Po())
              },
              encapsulation: 2,
              data: { animation: [dx.transformDrawer] },
              changeDetection: 0,
            })),
            t
          )
        })()
      const bx = Kn(vx)
      let wx = (() => {
        class t extends yx {}
        return (
          (t.ɵfac = function (e) {
            return Cx(e || t)
          }),
          (t.ɵcmp = Ut({
            type: t,
            selectors: [['mat-sidenav-container']],
            contentQueries: function (t, e, n) {
              if ((1 & t && (nc(n, _x, !0), nc(n, vx, !0)), 2 & t)) {
                let t
                tc((t = ic())) && (e._content = t.first),
                  tc((t = ic())) && (e._allDrawers = t)
              }
            },
            hostAttrs: [1, 'mat-drawer-container', 'mat-sidenav-container'],
            hostVars: 2,
            hostBindings: function (t, e) {
              2 & t &&
                na(
                  'mat-drawer-container-explicit-backdrop',
                  e._backdropOverride
                )
            },
            exportAs: ['matSidenavContainer'],
            features: [Da([{ provide: fx, useExisting: t }]), po],
            ngContentSelectors: hx,
            decls: 4,
            vars: 2,
            consts: [
              [
                'class',
                'mat-drawer-backdrop',
                3,
                'mat-drawer-shown',
                'click',
                4,
                'ngIf',
              ],
              ['cdkScrollable', '', 4, 'ngIf'],
              [1, 'mat-drawer-backdrop', 3, 'click'],
              ['cdkScrollable', ''],
            ],
            template: function (t, e) {
              1 & t &&
                (Wo(cx),
                ko(0, ax, 1, 2, 'div', 0),
                Ko(1),
                Ko(2, 1),
                ko(3, lx, 2, 0, 'mat-sidenav-content', 1)),
                2 & t &&
                  (Oo('ngIf', e.hasBackdrop), Xs(3), Oo('ngIf', !e._content))
            },
            directives: [Vh, _x, od],
            styles: [ux],
            encapsulation: 2,
            changeDetection: 0,
          })),
          t
        )
      })()
      const Cx = Kn(wx)
      let xx = (() => {
        class t {}
        return (
          (t.ɵmod = $t({ type: t })),
          (t.ɵinj = ut({
            factory: function (e) {
              return new (e || t)()
            },
            imports: [[Gh, cy, Ju, ld], ld, cy],
          })),
          t
        )
      })()
      const Sx = ['*'],
        Ex = [
          [
            ['', 'mat-list-avatar', ''],
            ['', 'mat-list-icon', ''],
            ['', 'matListAvatar', ''],
            ['', 'matListIcon', ''],
          ],
          [
            ['', 'mat-line', ''],
            ['', 'matLine', ''],
          ],
          '*',
        ],
        kx = [
          '[mat-list-avatar], [mat-list-icon], [matListAvatar], [matListIcon]',
          '[mat-line], [matLine]',
          '*',
        ]
      class Tx {}
      const Ax = hy(dy(Tx))
      class Ox {}
      const Ix = dy(Ox),
        Rx = new Yn('MatList'),
        Px = new Yn('MatNavList')
      let Dx = (() => {
        class t extends Ax {
          constructor() {
            super(...arguments), (this._stateChanges = new x())
          }
          ngOnChanges() {
            this._stateChanges.next()
          }
          ngOnDestroy() {
            this._stateChanges.complete()
          }
        }
        return (
          (t.ɵfac = function (e) {
            return Nx(e || t)
          }),
          (t.ɵcmp = Ut({
            type: t,
            selectors: [['mat-nav-list']],
            hostAttrs: [
              'role',
              'navigation',
              1,
              'mat-nav-list',
              'mat-list-base',
            ],
            inputs: { disableRipple: 'disableRipple', disabled: 'disabled' },
            exportAs: ['matNavList'],
            features: [Da([{ provide: Px, useExisting: t }]), po, ue],
            ngContentSelectors: Sx,
            decls: 1,
            vars: 0,
            template: function (t, e) {
              1 & t && (Wo(), Ko(0))
            },
            styles: [
              '.mat-subheader{display:flex;box-sizing:border-box;padding:16px;align-items:center}.mat-list-base .mat-subheader{margin:0}.mat-list-base{padding-top:8px;display:block;-webkit-tap-highlight-color:transparent}.mat-list-base .mat-subheader{height:48px;line-height:16px}.mat-list-base .mat-subheader:first-child{margin-top:-8px}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{display:block;height:48px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base .mat-list-item .mat-list-item-content,.mat-list-base .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base .mat-list-item .mat-list-item-content-reverse,.mat-list-base .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base .mat-list-item .mat-list-item-ripple,.mat-list-base .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar,.mat-list-base .mat-list-option.mat-list-item-with-avatar{height:56px}.mat-list-base .mat-list-item.mat-2-line,.mat-list-base .mat-list-option.mat-2-line{height:72px}.mat-list-base .mat-list-item.mat-3-line,.mat-list-base .mat-list-option.mat-3-line{height:88px}.mat-list-base .mat-list-item.mat-multi-line,.mat-list-base .mat-list-option.mat-multi-line{height:auto}.mat-list-base .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base .mat-list-item .mat-list-text,.mat-list-base .mat-list-option .mat-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base .mat-list-item .mat-list-text>*,.mat-list-base .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-list-base .mat-list-item .mat-list-text:empty,.mat-list-base .mat-list-option .mat-list-text:empty{display:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base .mat-list-item .mat-list-avatar,.mat-list-base .mat-list-option .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%;object-fit:cover}.mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:72px;width:calc(100% - 72px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:72px}.mat-list-base .mat-list-item .mat-list-icon,.mat-list-base .mat-list-option .mat-list-icon{flex-shrink:0;width:24px;height:24px;font-size:24px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:64px;width:calc(100% - 64px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:64px}.mat-list-base .mat-list-item .mat-divider,.mat-list-base .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base .mat-list-item .mat-divider,[dir=rtl] .mat-list-base .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-list-base[dense]{padding-top:4px;display:block}.mat-list-base[dense] .mat-subheader{height:40px;line-height:8px}.mat-list-base[dense] .mat-subheader:first-child{margin-top:-4px}.mat-list-base[dense] .mat-list-item,.mat-list-base[dense] .mat-list-option{display:block;height:40px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-item-content,.mat-list-base[dense] .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base[dense] .mat-list-item .mat-list-item-content-reverse,.mat-list-base[dense] .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base[dense] .mat-list-item .mat-list-item-ripple,.mat-list-base[dense] .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar{height:48px}.mat-list-base[dense] .mat-list-item.mat-2-line,.mat-list-base[dense] .mat-list-option.mat-2-line{height:60px}.mat-list-base[dense] .mat-list-item.mat-3-line,.mat-list-base[dense] .mat-list-option.mat-3-line{height:76px}.mat-list-base[dense] .mat-list-item.mat-multi-line,.mat-list-base[dense] .mat-list-option.mat-multi-line{height:auto}.mat-list-base[dense] .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base[dense] .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base[dense] .mat-list-item .mat-list-text,.mat-list-base[dense] .mat-list-option .mat-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-text>*,.mat-list-base[dense] .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-list-base[dense] .mat-list-item .mat-list-text:empty,.mat-list-base[dense] .mat-list-option .mat-list-text:empty{display:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base[dense] .mat-list-item .mat-list-avatar,.mat-list-base[dense] .mat-list-option .mat-list-avatar{flex-shrink:0;width:36px;height:36px;border-radius:50%;object-fit:cover}.mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:68px;width:calc(100% - 68px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:68px}.mat-list-base[dense] .mat-list-item .mat-list-icon,.mat-list-base[dense] .mat-list-option .mat-list-icon{flex-shrink:0;width:20px;height:20px;font-size:20px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:60px;width:calc(100% - 60px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:60px}.mat-list-base[dense] .mat-list-item .mat-divider,.mat-list-base[dense] .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-divider,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base[dense] .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-nav-list a{text-decoration:none;color:inherit}.mat-nav-list .mat-list-item{cursor:pointer;outline:none}mat-action-list button{background:none;color:inherit;border:none;font:inherit;outline:inherit;-webkit-tap-highlight-color:transparent;text-align:left}[dir=rtl] mat-action-list button{text-align:right}mat-action-list button::-moz-focus-inner{border:0}mat-action-list .mat-list-item{cursor:pointer;outline:inherit}.mat-list-option:not(.mat-list-item-disabled){cursor:pointer;outline:none}.mat-list-item-disabled{pointer-events:none}.cdk-high-contrast-active .mat-list-item-disabled{opacity:.5}.cdk-high-contrast-active :host .mat-list-item-disabled{opacity:.5}.cdk-high-contrast-active .mat-selection-list:focus{outline-style:dotted}.cdk-high-contrast-active .mat-list-option:hover,.cdk-high-contrast-active .mat-list-option:focus,.cdk-high-contrast-active .mat-nav-list .mat-list-item:hover,.cdk-high-contrast-active .mat-nav-list .mat-list-item:focus,.cdk-high-contrast-active mat-action-list .mat-list-item:hover,.cdk-high-contrast-active mat-action-list .mat-list-item:focus{outline:dotted 1px}.cdk-high-contrast-active .mat-list-single-selected-option::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}.cdk-high-contrast-active [dir=rtl] .mat-list-single-selected-option::after{right:auto;left:16px}@media(hover: none){.mat-list-option:not(.mat-list-single-selected-option):not(.mat-list-item-disabled):hover,.mat-nav-list .mat-list-item:not(.mat-list-item-disabled):hover,.mat-action-list .mat-list-item:not(.mat-list-item-disabled):hover{background:none}}\n',
            ],
            encapsulation: 2,
            changeDetection: 0,
          })),
          t
        )
      })()
      const Nx = Kn(Dx)
      let Fx = (() => {
          class t {}
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵdir = Kt({
              type: t,
              selectors: [
                ['', 'mat-list-avatar', ''],
                ['', 'matListAvatar', ''],
              ],
              hostAttrs: [1, 'mat-list-avatar'],
            })),
            t
          )
        })(),
        Mx = (() => {
          class t {}
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵdir = Kt({
              type: t,
              selectors: [
                ['', 'mat-list-icon', ''],
                ['', 'matListIcon', ''],
              ],
              hostAttrs: [1, 'mat-list-icon'],
            })),
            t
          )
        })(),
        Lx = (() => {
          class t extends Ix {
            constructor(t, e, n, i) {
              super(),
                (this._element = t),
                (this._isInteractiveList = !1),
                (this._destroyed = new x()),
                (this._disabled = !1),
                (this._isInteractiveList = !!(
                  n ||
                  (i && 'action-list' === i._getListType())
                )),
                (this._list = n || i)
              const s = this._getHostElement()
              'button' !== s.nodeName.toLowerCase() ||
                s.hasAttribute('type') ||
                s.setAttribute('type', 'button'),
                this._list &&
                  this._list._stateChanges
                    .pipe(Du(this._destroyed))
                    .subscribe(() => {
                      e.markForCheck()
                    })
            }
            get disabled() {
              return this._disabled || !(!this._list || !this._list.disabled)
            }
            set disabled(t) {
              this._disabled = hu(t)
            }
            ngAfterContentInit() {
              !(function (t, e, n = 'mat') {
                t.changes.pipe(ju(t)).subscribe(({ length: t }) => {
                  fy(e, n + '-2-line', !1),
                    fy(e, n + '-3-line', !1),
                    fy(e, n + '-multi-line', !1),
                    2 === t || 3 === t
                      ? fy(e, `${n}-${t}-line`, !0)
                      : t > 3 && fy(e, n + '-multi-line', !0)
                })
              })(this._lines, this._element)
            }
            ngOnDestroy() {
              this._destroyed.next(), this._destroyed.complete()
            }
            _isRippleDisabled() {
              return (
                !this._isInteractiveList ||
                this.disableRipple ||
                !(!this._list || !this._list.disableRipple)
              )
            }
            _getHostElement() {
              return this._element.nativeElement
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(Ao(Va), Ao(cl), Ao(Px, 8), Ao(Rx, 8))
            }),
            (t.ɵcmp = Ut({
              type: t,
              selectors: [
                ['mat-list-item'],
                ['a', 'mat-list-item', ''],
                ['button', 'mat-list-item', ''],
              ],
              contentQueries: function (t, e, n) {
                if (
                  (1 & t && (nc(n, Fx, !0), nc(n, Mx, !0), nc(n, py, !0)),
                  2 & t)
                ) {
                  let t
                  tc((t = ic())) && (e._avatar = t.first),
                    tc((t = ic())) && (e._icon = t.first),
                    tc((t = ic())) && (e._lines = t)
                }
              },
              hostAttrs: [1, 'mat-list-item', 'mat-focus-indicator'],
              hostVars: 6,
              hostBindings: function (t, e) {
                2 & t &&
                  na('mat-list-item-disabled', e.disabled)(
                    'mat-list-item-avatar',
                    e._avatar || e._icon
                  )('mat-list-item-with-avatar', e._avatar || e._icon)
              },
              inputs: { disableRipple: 'disableRipple', disabled: 'disabled' },
              exportAs: ['matListItem'],
              features: [po],
              ngContentSelectors: kx,
              decls: 6,
              vars: 2,
              consts: [
                [1, 'mat-list-item-content'],
                [
                  'mat-ripple',
                  '',
                  1,
                  'mat-list-item-ripple',
                  3,
                  'matRippleTrigger',
                  'matRippleDisabled',
                ],
                [1, 'mat-list-text'],
              ],
              template: function (t, e) {
                1 & t &&
                  (Wo(Ex),
                  Ro(0, 'div', 0),
                  Do(1, 'div', 1),
                  Ko(2),
                  Ro(3, 'div', 2),
                  Ko(4, 1),
                  Po(),
                  Ko(5, 2),
                  Po()),
                  2 & t &&
                    (Xs(1),
                    Oo('matRippleTrigger', e._getHostElement())(
                      'matRippleDisabled',
                      e._isRippleDisabled()
                    ))
              },
              directives: [xy],
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        jx = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[my, Sy, cy, Ey, Gh], my, cy, Ey, Q_],
            })),
            t
          )
        })(),
        Bx = (() => {
          class t {
            constructor() {
              this.githubCorner = !0
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵcmp = Ut({
              type: t,
              selectors: [
                ['app-github-corner'],
                ['a', 'app-github-corner', ''],
              ],
              hostVars: 2,
              hostBindings: function (t, e) {
                2 & t && na('github-corner', e.githubCorner)
              },
              decls: 4,
              vars: 0,
              consts: [
                ['width', '80', 'height', '80', 'viewBox', '0 0 250 250'],
                ['d', 'M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z'],
                [
                  'd',
                  'M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2',
                  1,
                  'octo-arm',
                  2,
                  'transform-origin',
                  '130px 106px',
                ],
                [
                  'd',
                  'M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z',
                  1,
                  'octo-body',
                ],
              ],
              template: function (t, e) {
                1 & t &&
                  (hn(),
                  Ro(0, 'svg', 0),
                  Do(1, 'path', 1),
                  Do(2, 'path', 2),
                  Do(3, 'path', 3),
                  Po())
              },
              styles: [
                '[_nghost-%COMP%]{display:flex;position:absolute;top:0;border:0;right:0;z-index:10}.github-corner[_nghost-%COMP%]:hover   .octo-arm[_ngcontent-%COMP%]{animation:octocat-wave .56s ease-in-out}@keyframes octocat-wave{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner[_ngcontent-%COMP%]:hover   .octo-arm[_ngcontent-%COMP%]{animation:none}.github-corner[_ngcontent-%COMP%]   .octo-arm[_ngcontent-%COMP%]{animation:octocat-wave .56s ease-in-out}}',
              ],
            })),
            t
          )
        })()
      const Vx = {
          tooltipState: Jd('state', [
            ip(
              'initial, void, hidden',
              np({ opacity: 0, transform: 'scale(0)' })
            ),
            ip('visible', np({ transform: 'scale(1)' })),
            rp(
              '* => visible',
              tp(
                '200ms cubic-bezier(0, 0, 0.2, 1)',
                sp([
                  np({ opacity: 0, transform: 'scale(0)', offset: 0 }),
                  np({ opacity: 0.5, transform: 'scale(0.99)', offset: 0.5 }),
                  np({ opacity: 1, transform: 'scale(1)', offset: 1 }),
                ])
              )
            ),
            rp(
              '* => hidden',
              tp('100ms cubic-bezier(0, 0, 0.2, 1)', np({ opacity: 0 }))
            ),
          ]),
        },
        Ux = td({ passive: !0 }),
        zx = new Yn('mat-tooltip-scroll-strategy'),
        Hx = {
          provide: zx,
          deps: [Gd],
          useFactory: function (t) {
            return () => t.scrollStrategies.reposition({ scrollThrottle: 20 })
          },
        },
        qx = new Yn('mat-tooltip-default-options', {
          providedIn: 'root',
          factory: function () {
            return { showDelay: 0, hideDelay: 0, touchendHideDelay: 1500 }
          },
        })
      let $x = (() => {
          class t {
            constructor(t, e, n, i, s, r, o, a, l, c, h) {
              ;(this._overlay = t),
                (this._elementRef = e),
                (this._scrollDispatcher = n),
                (this._viewContainerRef = i),
                (this._ngZone = s),
                (this._platform = r),
                (this._ariaDescriber = o),
                (this._focusMonitor = a),
                (this._dir = c),
                (this._defaultOptions = h),
                (this._position = 'below'),
                (this._disabled = !1),
                (this._viewInitialized = !1),
                (this._pointerExitEventsInitialized = !1),
                (this.showDelay = this._defaultOptions.showDelay),
                (this.hideDelay = this._defaultOptions.hideDelay),
                (this.touchGestures = 'auto'),
                (this._message = ''),
                (this._passiveListeners = []),
                (this._destroyed = new x()),
                (this._handleKeydown = (t) => {
                  this._isTooltipVisible() &&
                    27 === t.keyCode &&
                    !wd(t) &&
                    (t.preventDefault(),
                    t.stopPropagation(),
                    this._ngZone.run(() => this.hide(0)))
                }),
                (this._scrollStrategy = l),
                h &&
                  (h.position && (this.position = h.position),
                  h.touchGestures && (this.touchGestures = h.touchGestures)),
                s.runOutsideAngular(() => {
                  e.nativeElement.addEventListener(
                    'keydown',
                    this._handleKeydown
                  )
                })
            }
            get position() {
              return this._position
            }
            set position(t) {
              t !== this._position &&
                ((this._position = t),
                this._overlayRef &&
                  (this._updatePosition(),
                  this._tooltipInstance && this._tooltipInstance.show(0),
                  this._overlayRef.updatePosition()))
            }
            get disabled() {
              return this._disabled
            }
            set disabled(t) {
              ;(this._disabled = hu(t)),
                this._disabled
                  ? this.hide(0)
                  : this._setupPointerEnterEventsIfNeeded()
            }
            get message() {
              return this._message
            }
            set message(t) {
              this._ariaDescriber.removeDescription(
                this._elementRef.nativeElement,
                this._message
              ),
                (this._message = null != t ? String(t).trim() : ''),
                !this._message && this._isTooltipVisible()
                  ? this.hide(0)
                  : (this._setupPointerEnterEventsIfNeeded(),
                    this._updateTooltipMessage(),
                    this._ngZone.runOutsideAngular(() => {
                      Promise.resolve().then(() => {
                        this._ariaDescriber.describe(
                          this._elementRef.nativeElement,
                          this.message
                        )
                      })
                    }))
            }
            get tooltipClass() {
              return this._tooltipClass
            }
            set tooltipClass(t) {
              ;(this._tooltipClass = t),
                this._tooltipInstance &&
                  this._setTooltipClass(this._tooltipClass)
            }
            ngAfterViewInit() {
              ;(this._viewInitialized = !0),
                this._setupPointerEnterEventsIfNeeded(),
                this._focusMonitor
                  .monitor(this._elementRef)
                  .pipe(Du(this._destroyed))
                  .subscribe((t) => {
                    t
                      ? 'keyboard' === t && this._ngZone.run(() => this.show())
                      : this._ngZone.run(() => this.hide(0))
                  })
            }
            ngOnDestroy() {
              const t = this._elementRef.nativeElement
              clearTimeout(this._touchstartTimeout),
                this._overlayRef &&
                  (this._overlayRef.dispose(), (this._tooltipInstance = null)),
                t.removeEventListener('keydown', this._handleKeydown),
                this._passiveListeners.forEach(([e, n]) => {
                  t.removeEventListener(e, n, Ux)
                }),
                (this._passiveListeners.length = 0),
                this._destroyed.next(),
                this._destroyed.complete(),
                this._ariaDescriber.removeDescription(t, this.message),
                this._focusMonitor.stopMonitoring(t)
            }
            show(t = this.showDelay) {
              if (
                this.disabled ||
                !this.message ||
                (this._isTooltipVisible() &&
                  !this._tooltipInstance._showTimeoutId &&
                  !this._tooltipInstance._hideTimeoutId)
              )
                return
              const e = this._createOverlay()
              this._detach(),
                (this._portal =
                  this._portal || new ud(Wx, this._viewContainerRef)),
                (this._tooltipInstance = e.attach(this._portal).instance),
                this._tooltipInstance
                  .afterHidden()
                  .pipe(Du(this._destroyed))
                  .subscribe(() => this._detach()),
                this._setTooltipClass(this._tooltipClass),
                this._updateTooltipMessage(),
                this._tooltipInstance.show(t)
            }
            hide(t = this.hideDelay) {
              this._tooltipInstance && this._tooltipInstance.hide(t)
            }
            toggle() {
              this._isTooltipVisible() ? this.hide() : this.show()
            }
            _isTooltipVisible() {
              return (
                !!this._tooltipInstance && this._tooltipInstance.isVisible()
              )
            }
            _createOverlay() {
              if (this._overlayRef) return this._overlayRef
              const t = this._scrollDispatcher.getAncestorScrollContainers(
                  this._elementRef
                ),
                e = this._overlay
                  .position()
                  .flexibleConnectedTo(this._elementRef)
                  .withTransformOriginOn('.mat-tooltip')
                  .withFlexibleDimensions(!1)
                  .withViewportMargin(8)
                  .withScrollableContainers(t)
              return (
                e.positionChanges.pipe(Du(this._destroyed)).subscribe((t) => {
                  this._tooltipInstance &&
                    t.scrollableViewProperties.isOverlayClipped &&
                    this._tooltipInstance.isVisible() &&
                    this._ngZone.run(() => this.hide(0))
                }),
                (this._overlayRef = this._overlay.create({
                  direction: this._dir,
                  positionStrategy: e,
                  panelClass: 'mat-tooltip-panel',
                  scrollStrategy: this._scrollStrategy(),
                })),
                this._updatePosition(),
                this._overlayRef
                  .detachments()
                  .pipe(Du(this._destroyed))
                  .subscribe(() => this._detach()),
                this._overlayRef
              )
            }
            _detach() {
              this._overlayRef &&
                this._overlayRef.hasAttached() &&
                this._overlayRef.detach(),
                (this._tooltipInstance = null)
            }
            _updatePosition() {
              const t = this._overlayRef.getConfig().positionStrategy,
                e = this._getOrigin(),
                n = this._getOverlayPosition()
              t.withPositions([
                Object.assign(Object.assign({}, e.main), n.main),
                Object.assign(Object.assign({}, e.fallback), n.fallback),
              ])
            }
            _getOrigin() {
              const t = !this._dir || 'ltr' == this._dir.value,
                e = this.position
              let n
              'above' == e || 'below' == e
                ? (n = {
                    originX: 'center',
                    originY: 'above' == e ? 'top' : 'bottom',
                  })
                : 'before' == e || ('left' == e && t) || ('right' == e && !t)
                ? (n = { originX: 'start', originY: 'center' })
                : ('after' == e ||
                    ('right' == e && t) ||
                    ('left' == e && !t)) &&
                  (n = { originX: 'end', originY: 'center' })
              const { x: i, y: s } = this._invertPosition(n.originX, n.originY)
              return { main: n, fallback: { originX: i, originY: s } }
            }
            _getOverlayPosition() {
              const t = !this._dir || 'ltr' == this._dir.value,
                e = this.position
              let n
              'above' == e
                ? (n = { overlayX: 'center', overlayY: 'bottom' })
                : 'below' == e
                ? (n = { overlayX: 'center', overlayY: 'top' })
                : 'before' == e || ('left' == e && t) || ('right' == e && !t)
                ? (n = { overlayX: 'end', overlayY: 'center' })
                : ('after' == e ||
                    ('right' == e && t) ||
                    ('left' == e && !t)) &&
                  (n = { overlayX: 'start', overlayY: 'center' })
              const { x: i, y: s } = this._invertPosition(
                n.overlayX,
                n.overlayY
              )
              return { main: n, fallback: { overlayX: i, overlayY: s } }
            }
            _updateTooltipMessage() {
              this._tooltipInstance &&
                ((this._tooltipInstance.message = this.message),
                this._tooltipInstance._markForCheck(),
                this._ngZone.onMicrotaskEmpty
                  .pipe(_d(1), Du(this._destroyed))
                  .subscribe(() => {
                    this._tooltipInstance && this._overlayRef.updatePosition()
                  }))
            }
            _setTooltipClass(t) {
              this._tooltipInstance &&
                ((this._tooltipInstance.tooltipClass = t),
                this._tooltipInstance._markForCheck())
            }
            _invertPosition(t, e) {
              return (
                'above' === this.position || 'below' === this.position
                  ? 'top' === e
                    ? (e = 'bottom')
                    : 'bottom' === e && (e = 'top')
                  : 'end' === t
                  ? (t = 'start')
                  : 'start' === t && (t = 'end'),
                { x: t, y: e }
              )
            }
            _setupPointerEnterEventsIfNeeded() {
              !this._disabled &&
                this.message &&
                this._viewInitialized &&
                !this._passiveListeners.length &&
                (this._platformSupportsMouseEvents()
                  ? this._passiveListeners.push([
                      'mouseenter',
                      () => {
                        this._setupPointerExitEventsIfNeeded(), this.show()
                      },
                    ])
                  : 'off' !== this.touchGestures &&
                    (this._disableNativeGesturesIfNecessary(),
                    this._passiveListeners.push([
                      'touchstart',
                      () => {
                        this._setupPointerExitEventsIfNeeded(),
                          clearTimeout(this._touchstartTimeout),
                          (this._touchstartTimeout = setTimeout(
                            () => this.show(),
                            500
                          ))
                      },
                    ])),
                this._addListeners(this._passiveListeners))
            }
            _setupPointerExitEventsIfNeeded() {
              if (this._pointerExitEventsInitialized) return
              this._pointerExitEventsInitialized = !0
              const t = []
              if (this._platformSupportsMouseEvents())
                t.push(['mouseleave', () => this.hide()])
              else if ('off' !== this.touchGestures) {
                this._disableNativeGesturesIfNecessary()
                const e = () => {
                  clearTimeout(this._touchstartTimeout),
                    this.hide(this._defaultOptions.touchendHideDelay)
                }
                t.push(['touchend', e], ['touchcancel', e])
              }
              this._addListeners(t), this._passiveListeners.push(...t)
            }
            _addListeners(t) {
              t.forEach(([t, e]) => {
                this._elementRef.nativeElement.addEventListener(t, e, Ux)
              })
            }
            _platformSupportsMouseEvents() {
              return !this._platform.IOS && !this._platform.ANDROID
            }
            _disableNativeGesturesIfNecessary() {
              const t = this.touchGestures
              if ('off' !== t) {
                const e = this._elementRef.nativeElement,
                  n = e.style
                ;('on' === t ||
                  ('INPUT' !== e.nodeName && 'TEXTAREA' !== e.nodeName)) &&
                  (n.userSelect = n.msUserSelect = n.webkitUserSelect = n.MozUserSelect =
                    'none'),
                  ('on' !== t && e.draggable) || (n.webkitUserDrag = 'none'),
                  (n.touchAction = 'none'),
                  (n.webkitTapHighlightColor = 'transparent')
              }
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                Ao(Gd),
                Ao(Va),
                Ao(rd),
                Ao(Cl),
                Ao(Oc),
                Ao(Xu),
                Ao(jp),
                Ao(Gp),
                Ao(zx),
                Ao(id, 8),
                Ao(qx, 8)
              )
            }),
            (t.ɵdir = Kt({
              type: t,
              selectors: [['', 'matTooltip', '']],
              hostAttrs: [1, 'mat-tooltip-trigger'],
              inputs: {
                showDelay: ['matTooltipShowDelay', 'showDelay'],
                hideDelay: ['matTooltipHideDelay', 'hideDelay'],
                touchGestures: ['matTooltipTouchGestures', 'touchGestures'],
                position: ['matTooltipPosition', 'position'],
                disabled: ['matTooltipDisabled', 'disabled'],
                message: ['matTooltip', 'message'],
                tooltipClass: ['matTooltipClass', 'tooltipClass'],
              },
              exportAs: ['matTooltip'],
            })),
            t
          )
        })(),
        Wx = (() => {
          class t {
            constructor(t, e) {
              ;(this._changeDetectorRef = t),
                (this._breakpointObserver = e),
                (this._visibility = 'initial'),
                (this._closeOnInteraction = !1),
                (this._onHide = new x()),
                (this._isHandset = this._breakpointObserver.observe(
                  '(max-width: 599.98px) and (orientation: portrait), (max-width: 959.98px) and (orientation: landscape)'
                ))
            }
            show(t) {
              this._hideTimeoutId &&
                (clearTimeout(this._hideTimeoutId),
                (this._hideTimeoutId = null)),
                (this._closeOnInteraction = !0),
                (this._showTimeoutId = setTimeout(() => {
                  ;(this._visibility = 'visible'),
                    (this._showTimeoutId = null),
                    this._markForCheck()
                }, t))
            }
            hide(t) {
              this._showTimeoutId &&
                (clearTimeout(this._showTimeoutId),
                (this._showTimeoutId = null)),
                (this._hideTimeoutId = setTimeout(() => {
                  ;(this._visibility = 'hidden'),
                    (this._hideTimeoutId = null),
                    this._markForCheck()
                }, t))
            }
            afterHidden() {
              return this._onHide
            }
            isVisible() {
              return 'visible' === this._visibility
            }
            ngOnDestroy() {
              this._onHide.complete()
            }
            _animationStart() {
              this._closeOnInteraction = !1
            }
            _animationDone(t) {
              const e = t.toState
              'hidden' !== e || this.isVisible() || this._onHide.next(),
                ('visible' !== e && 'hidden' !== e) ||
                  (this._closeOnInteraction = !0)
            }
            _handleBodyInteraction() {
              this._closeOnInteraction && this.hide(0)
            }
            _markForCheck() {
              this._changeDetectorRef.markForCheck()
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(Ao(cl), Ao(ZC))
            }),
            (t.ɵcmp = Ut({
              type: t,
              selectors: [['mat-tooltip-component']],
              hostAttrs: ['aria-hidden', 'true'],
              hostVars: 2,
              hostBindings: function (t, e) {
                1 & t &&
                  Bo(
                    'click',
                    function () {
                      return e._handleBodyInteraction()
                    },
                    !1,
                    hs
                  ),
                  2 & t && ea('zoom', 'visible' === e._visibility ? 1 : null)
              },
              decls: 3,
              vars: 7,
              consts: [[1, 'mat-tooltip', 3, 'ngClass']],
              template: function (t, e) {
                if (
                  (1 & t &&
                    (Ro(0, 'div', 0),
                    Bo('@state.start', function () {
                      return e._animationStart()
                    })('@state.done', function (t) {
                      return e._animationDone(t)
                    }),
                    Vl(1, 'async'),
                    pa(2),
                    Po()),
                  2 & t)
                ) {
                  let t = null
                  na(
                    'mat-tooltip-handset',
                    null == (t = Ul(1, 5, e._isHandset)) ? null : t.matches
                  ),
                    Oo('ngClass', e.tooltipClass)('@state', e._visibility),
                    Xs(2),
                    fa(e.message)
                }
              },
              directives: [Mh],
              pipes: [Kh],
              styles: [
                '.mat-tooltip-panel{pointer-events:none !important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}.cdk-high-contrast-active .mat-tooltip{outline:solid 1px}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}\n',
              ],
              encapsulation: 2,
              data: { animation: [Vx.tooltipState] },
              changeDetection: 0,
            })),
            t
          )
        })(),
        Kx = (() => {
          class t {}
          return (
            (t.ɵmod = $t({ type: t })),
            (t.ɵinj = ut({
              factory: function (e) {
                return new (e || t)()
              },
              providers: [Hx],
              imports: [[tf, Gh, Zd, cy], cy, ld],
            })),
            t
          )
        })()
      const Gx = ['snav']
      function Qx(t, e) {
        if (
          (1 & t &&
            (Ro(0, 'a', 9),
            Ro(1, 'mat-icon', 10),
            pa(2),
            Po(),
            Ro(3, 'span'),
            pa(4),
            Po(),
            Po()),
          2 & t)
        ) {
          const t = e.$implicit
          Oo('routerLink', t.route), Xs(2), fa(t.icon), Xs(2), fa(t.label)
        }
      }
      let Zx = (() => {
        class t {
          constructor(t, e, n, i) {
            ;(this.media = t),
              (this.title = 'WebRTC.Community'),
              (this.navLinks = [
                { route: '/', icon: 'home', label: 'Home' },
                {
                  route: '/restart-ice',
                  icon: 'cached',
                  label: 'Reiniciar candidato',
                },
                {
                  route: '/peer-to-peer',
                  icon: 'alt_route',
                  label: 'Ponto a ponto',
                },
                {
                  route: '/perfect-negotiation',
                  icon: 'swap_calls',
                  label: 'Negocia\xe7\xe3o perfeita',
                },
              ]),
              (this.mobileQuery = e.matchMedia('(max-width: 600px)')),
              (this._mobileQueryListener = () => n.detectChanges()),
              this.mobileQuery.addEventListener(
                'change',
                this._mobileQueryListener
              ),
              (this.subscription = i.events
                .pipe(Iu((t) => t instanceof gv))
                .subscribe(() => this.onRouteChange()))
          }
          onRouteChange() {
            var t
            this.snav.opened && this.snav.close(),
              (null === (t = this.media.currentStream) || void 0 === t
                ? void 0
                : t.active) &&
                this.media.currentStream.getTracks().forEach((t) => t.stop())
          }
          ngOnDestroy() {
            this.subscription.unsubscribe(),
              this.mobileQuery.removeEventListener(
                'change',
                this._mobileQueryListener
              )
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(Ao(dh), Ao(GC), Ao(cl), Ao(Bw))
          }),
          (t.ɵcmp = Ut({
            type: t,
            selectors: [['app-root']],
            viewQuery: function (t, e) {
              if ((1 & t && ec(Gx, !0), 2 & t)) {
                let t
                tc((t = ic())) && (e.snav = t.first)
              }
            },
            decls: 10,
            vars: 9,
            consts: [
              [1, 'client-container'],
              [3, 'snav', 'title'],
              [1, 'client-sidenav-container'],
              ['fixedTopGap', '56', 3, 'mode', 'fixedInViewport'],
              ['snav', ''],
              [1, 'client-nav-list'],
              ['mat-list-item', '', 3, 'routerLink', 4, 'ngFor', 'ngForOf'],
              [1, 'client-sidenav-content'],
              [
                'rel',
                'external',
                'target',
                '_blank',
                'app-github-corner',
                '',
                'matTooltip',
                'Contribua com o projeto',
                'matTooltipPosition',
                'before',
                'href',
                'https://github.com/guiseek/webrtc.community',
              ],
              ['mat-list-item', '', 3, 'routerLink'],
              ['color', 'accent', 1, 'mat-18'],
            ],
            template: function (t, e) {
              if (
                (1 & t &&
                  (Ro(0, 'div', 0),
                  Do(1, 'app-navbar', 1),
                  Ro(2, 'mat-sidenav-container', 2),
                  Ro(3, 'mat-sidenav', 3, 4),
                  Ro(5, 'mat-nav-list', 5),
                  ko(6, Qx, 5, 3, 'a', 6),
                  Po(),
                  Po(),
                  Ro(7, 'mat-sidenav-content', 7),
                  Do(8, 'a', 8),
                  Do(9, 'router-outlet'),
                  Po(),
                  Po(),
                  Po()),
                2 & t)
              ) {
                const t = To(4)
                na('client-is-mobile', e.mobileQuery.matches),
                  Xs(1),
                  Oo('snav', t)('title', e.title),
                  Xs(1),
                  ea('margin-top', e.mobileQuery.matches ? 56 : 0, 'px'),
                  Xs(1),
                  Oo('mode', 'over')('fixedInViewport', e.mobileQuery.matches),
                  Xs(3),
                  Oo('ngForOf', e.navLinks)
              }
            },
            directives: [XC, wx, vx, Dx, jh, _x, Bx, $x, zw, Lx, Vw, V_],
            styles: [
              '[_nghost-%COMP%]{flex:1;display:flex;flex-direction:column;height:100%;font-family:sans-serif}.client-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;position:absolute;top:0;bottom:0;left:0;right:0}.client-is-mobile[_ngcontent-%COMP%]   .client-toolbar[_ngcontent-%COMP%]{position:fixed;z-index:2}h1.client-app-name[_ngcontent-%COMP%]{margin-left:8px}.client-nav-list[_ngcontent-%COMP%]   .mat-icon[_ngcontent-%COMP%]{margin-right:8px}.client-sidenav-container[_ngcontent-%COMP%]{flex:1}.client-sidenav-content[_ngcontent-%COMP%]{display:flex;flex-direction:column}.client-is-mobile[_ngcontent-%COMP%]   .client-sidenav-container[_ngcontent-%COMP%]{flex:1 0 auto}',
            ],
            changeDetection: 0,
          })),
          t
        )
      })()
      const Yx = new _(Cp)
      class Xx {
        constructor(t, e) {
          ;(this.delay = t), (this.scheduler = e)
        }
        call(t, e) {
          return e.subscribe(new Jx(t, this.delay, this.scheduler))
        }
      }
      class Jx extends f {
        constructor(t, e, n) {
          super(t),
            (this.delay = e),
            (this.scheduler = n),
            (this.queue = []),
            (this.active = !1),
            (this.errored = !1)
        }
        static dispatch(t) {
          const e = t.source,
            n = e.queue,
            i = t.scheduler,
            s = t.destination
          for (; n.length > 0 && n[0].time - i.now() <= 0; )
            n.shift().notification.observe(s)
          if (n.length > 0) {
            const e = Math.max(0, n[0].time - i.now())
            this.schedule(t, e)
          } else this.unsubscribe(), (e.active = !1)
        }
        _schedule(t) {
          ;(this.active = !0),
            this.destination.add(
              t.schedule(Jx.dispatch, this.delay, {
                source: this,
                destination: this.destination,
                scheduler: t,
              })
            )
        }
        scheduleNotification(t) {
          if (!0 === this.errored) return
          const e = this.scheduler,
            n = new tS(e.now() + this.delay, t)
          this.queue.push(n), !1 === this.active && this._schedule(e)
        }
        _next(t) {
          this.scheduleNotification(Ku.createNext(t))
        }
        _error(t) {
          ;(this.errored = !0),
            (this.queue = []),
            this.destination.error(t),
            this.unsubscribe()
        }
        _complete() {
          this.scheduleNotification(Ku.createComplete()), this.unsubscribe()
        }
      }
      class tS {
        constructor(t, e) {
          ;(this.time = t), (this.notification = e)
        }
      }
      const eS = 'Service workers are disabled or not supported by this browser'
      class nS {
        constructor(t) {
          if (((this.serviceWorker = t), t)) {
            const e = gu(t, 'controllerchange').pipe(F(() => t.controller)),
              n = Lu(
                ev(() => mu(t.controller)),
                e
              )
            ;(this.worker = n.pipe(Iu((t) => !!t))),
              (this.registration = this.worker.pipe(
                Bu(() => t.getRegistration())
              ))
            const i = gu(t, 'message')
              .pipe(F((t) => t.data))
              .pipe(Iu((t) => t && t.type))
              .pipe(X(new x()))
            i.connect(), (this.events = i)
          } else
            this.worker = this.events = this.registration = ev(() =>
              qu(
                new Error(
                  'Service workers are disabled or not supported by this browser'
                )
              )
            )
        }
        postMessage(t, e) {
          return this.worker
            .pipe(
              _d(1),
              xp((n) => {
                n.postMessage(Object.assign({ action: t }, e))
              })
            )
            .toPromise()
            .then(() => {})
        }
        postMessageWithStatus(t, e, n) {
          const i = this.waitForStatus(n),
            s = this.postMessage(t, e)
          return Promise.all([i, s]).then(() => {})
        }
        generateNonce() {
          return Math.round(1e7 * Math.random())
        }
        eventsOfType(t) {
          return this.events.pipe(Iu((e) => e.type === t))
        }
        nextEventOfType(t) {
          return this.eventsOfType(t).pipe(_d(1))
        }
        waitForStatus(t) {
          return this.eventsOfType('STATUS')
            .pipe(
              Iu((e) => e.nonce === t),
              _d(1),
              F((t) => {
                if (!t.status) throw new Error(t.error)
              })
            )
            .toPromise()
        }
        get isEnabled() {
          return !!this.serviceWorker
        }
      }
      let iS = (() => {
          class t {
            constructor(t) {
              if (
                ((this.sw = t),
                (this.subscriptionChanges = new x()),
                !t.isEnabled)
              )
                return (
                  (this.messages = Yx),
                  (this.notificationClicks = Yx),
                  void (this.subscription = Yx)
                )
              ;(this.messages = this.sw
                .eventsOfType('PUSH')
                .pipe(F((t) => t.data))),
                (this.notificationClicks = this.sw
                  .eventsOfType('NOTIFICATION_CLICK')
                  .pipe(F((t) => t.data))),
                (this.pushManager = this.sw.registration.pipe(
                  F((t) => t.pushManager)
                ))
              const e = this.pushManager.pipe(Bu((t) => t.getSubscription()))
              this.subscription = $(e, this.subscriptionChanges)
            }
            get isEnabled() {
              return this.sw.isEnabled
            }
            requestSubscription(t) {
              if (!this.sw.isEnabled) return Promise.reject(new Error(eS))
              const e = { userVisibleOnly: !0 }
              let n = this.decodeBase64(
                  t.serverPublicKey.replace(/_/g, '/').replace(/-/g, '+')
                ),
                i = new Uint8Array(new ArrayBuffer(n.length))
              for (let s = 0; s < n.length; s++) i[s] = n.charCodeAt(s)
              return (
                (e.applicationServerKey = i),
                this.pushManager
                  .pipe(
                    Bu((t) => t.subscribe(e)),
                    _d(1)
                  )
                  .toPromise()
                  .then((t) => (this.subscriptionChanges.next(t), t))
              )
            }
            unsubscribe() {
              return this.sw.isEnabled
                ? this.subscription
                    .pipe(
                      _d(1),
                      Bu((t) => {
                        if (null === t)
                          throw new Error(
                            'Not subscribed to push notifications.'
                          )
                        return t.unsubscribe().then((t) => {
                          if (!t) throw new Error('Unsubscribe failed!')
                          this.subscriptionChanges.next(null)
                        })
                      })
                    )
                    .toPromise()
                : Promise.reject(new Error(eS))
            }
            decodeBase64(t) {
              return atob(t)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(nS))
            }),
            (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        sS = (() => {
          class t {
            constructor(t) {
              if (((this.sw = t), !t.isEnabled))
                return (
                  (this.available = Yx),
                  (this.activated = Yx),
                  void (this.unrecoverable = Yx)
                )
              ;(this.available = this.sw.eventsOfType('UPDATE_AVAILABLE')),
                (this.activated = this.sw.eventsOfType('UPDATE_ACTIVATED')),
                (this.unrecoverable = this.sw.eventsOfType(
                  'UNRECOVERABLE_STATE'
                ))
            }
            get isEnabled() {
              return this.sw.isEnabled
            }
            checkForUpdate() {
              if (!this.sw.isEnabled) return Promise.reject(new Error(eS))
              const t = this.sw.generateNonce()
              return this.sw.postMessageWithStatus(
                'CHECK_FOR_UPDATES',
                { statusNonce: t },
                t
              )
            }
            activateUpdate() {
              if (!this.sw.isEnabled) return Promise.reject(new Error(eS))
              const t = this.sw.generateNonce()
              return this.sw.postMessageWithStatus(
                'ACTIVATE_UPDATE',
                { statusNonce: t },
                t
              )
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(vi(nS))
            }),
            (t.ɵprov = ht({ token: t, factory: t.ɵfac })),
            t
          )
        })()
      class rS {}
      const oS = new Yn('NGSW_REGISTER_SCRIPT')
      function aS(t, e, n, i) {
        return () => {
          if (!Qh(i) || !('serviceWorker' in navigator) || !1 === n.enabled)
            return
          let s
          if (
            (navigator.serviceWorker.addEventListener(
              'controllerchange',
              () => {
                null !== navigator.serviceWorker.controller &&
                  navigator.serviceWorker.controller.postMessage({
                    action: 'INITIALIZE',
                  })
              }
            ),
            'function' == typeof n.registrationStrategy)
          )
            s = n.registrationStrategy()
          else {
            const [e, ...i] = (
              n.registrationStrategy || 'registerWhenStable:30000'
            ).split(':')
            switch (e) {
              case 'registerImmediately':
                s = mu(null)
                break
              case 'registerWithDelay':
                s = lS(+i[0] || 0)
                break
              case 'registerWhenStable':
                s = i[0] ? $(cS(t), lS(+i[0])) : cS(t)
                break
              default:
                throw new Error(
                  'Unknown ServiceWorker registration strategy: ' +
                    n.registrationStrategy
                )
            }
          }
          t.get(Oc).runOutsideAngular(() =>
            s.pipe(_d(1)).subscribe(() =>
              navigator.serviceWorker
                .register(e, { scope: n.scope })
                .catch((e) => {
                  t.get(os).handleError(e)
                })
            )
          )
        }
      }
      function lS(t) {
        return mu(null).pipe(
          (function (t, e = Su) {
            var n
            const i =
              (n = t) instanceof Date && !isNaN(+n) ? +t - e.now() : Math.abs(t)
            return (t) => t.lift(new Xx(i, e))
          })(t)
        )
      }
      function cS(t) {
        return t.get(Zc).isStable.pipe(Iu((t) => t))
      }
      function hS(t, e) {
        return new nS(
          Qh(e) && !1 !== t.enabled ? navigator.serviceWorker : void 0
        )
      }
      let uS = (() => {
        class t {
          static register(e, n = {}) {
            return {
              ngModule: t,
              providers: [
                { provide: oS, useValue: e },
                { provide: rS, useValue: n },
                { provide: nS, useFactory: hS, deps: [rS, fc] },
                {
                  provide: lc,
                  useFactory: aS,
                  deps: [ho, oS, rS, fc],
                  multi: !0,
                },
              ],
            }
          }
        }
        return (
          (t.ɵmod = $t({ type: t })),
          (t.ɵinj = ut({
            factory: function (e) {
              return new (e || t)()
            },
            providers: [iS, sS],
          })),
          t
        )
      })()
      function dS(t) {
        return new lh(t)
      }
      const pS = new Yn('SignalingChannel')
      let fS = (() => {
        class t {}
        return (
          (t.ɵmod = $t({ type: t, bootstrap: [Zx] })),
          (t.ɵinj = ut({
            factory: function (e) {
              return new (e || t)()
            },
            providers: [
              dh,
              {
                provide: pS,
                useValue: 'https://webrtc-community.herokuapp.com',
              },
              { provide: lh, useFactory: dS, deps: [pS] },
            ],
            imports: [
              [
                $C,
                Pf,
                U_,
                jx,
                Vy,
                Qy,
                Dy,
                Q_,
                xx,
                hC,
                Kx,
                UC,
                zC,
                jC,
                bp.forRoot(),
                Xw.forRoot(cC, { initialNavigation: 'enabled', useHash: !0 }),
                ry,
                uS.register('ngsw-worker.js', { enabled: !0 }),
              ],
            ],
          })),
          t
        )
      })()
      ;(function () {
        if (zc) throw new Error('Cannot enable prod mode after platform setup.')
        Uc = !1
      })(),
        If()
          .bootstrapModule(fS)
          .catch((t) => console.error(t))
    },
    akSB: function (t, e, n) {
      var i = n('AdPF'),
        s = n('0z79'),
        r = n('Cl5A'),
        o = n('CIKq')
      ;(e.polling = function (t) {
        var e = !1,
          n = !1,
          o = !1 !== t.jsonp
        if ('undefined' != typeof location) {
          var a = 'https:' === location.protocol,
            l = location.port
          l || (l = a ? 443 : 80),
            (e = t.hostname !== location.hostname || l !== t.port),
            (n = t.secure !== a)
        }
        if (
          ((t.xdomain = e),
          (t.xscheme = n),
          'open' in new i(t) && !t.forceJSONP)
        )
          return new s(t)
        if (!o) throw new Error('JSONP disabled')
        return new r(t)
      }),
        (e.websocket = o)
    },
    cpc2: function (t, e, n) {
      function i(t) {
        if (t)
          return (function (t) {
            for (var e in i.prototype) t[e] = i.prototype[e]
            return t
          })(t)
      }
      ;(t.exports = i),
        (i.prototype.on = i.prototype.addEventListener = function (t, e) {
          return (
            (this._callbacks = this._callbacks || {}),
            (this._callbacks['$' + t] = this._callbacks['$' + t] || []).push(e),
            this
          )
        }),
        (i.prototype.once = function (t, e) {
          function n() {
            this.off(t, n), e.apply(this, arguments)
          }
          return (n.fn = e), this.on(t, n), this
        }),
        (i.prototype.off = i.prototype.removeListener = i.prototype.removeAllListeners = i.prototype.removeEventListener = function (
          t,
          e
        ) {
          if (
            ((this._callbacks = this._callbacks || {}), 0 == arguments.length)
          )
            return (this._callbacks = {}), this
          var n,
            i = this._callbacks['$' + t]
          if (!i) return this
          if (1 == arguments.length)
            return delete this._callbacks['$' + t], this
          for (var s = 0; s < i.length; s++)
            if ((n = i[s]) === e || n.fn === e) {
              i.splice(s, 1)
              break
            }
          return 0 === i.length && delete this._callbacks['$' + t], this
        }),
        (i.prototype.emit = function (t) {
          this._callbacks = this._callbacks || {}
          for (
            var e = new Array(arguments.length - 1),
              n = this._callbacks['$' + t],
              i = 1;
            i < arguments.length;
            i++
          )
            e[i - 1] = arguments[i]
          if (n) {
            i = 0
            for (var s = (n = n.slice(0)).length; i < s; ++i)
              n[i].apply(this, e)
          }
          return this
        }),
        (i.prototype.listeners = function (t) {
          return (
            (this._callbacks = this._callbacks || {}),
            this._callbacks['$' + t] || []
          )
        }),
        (i.prototype.hasListeners = function (t) {
          return !!this.listeners(t).length
        })
    },
    'dkv/': function (t, e) {
      t.exports =
        Object.keys ||
        function (t) {
          var e = [],
            n = Object.prototype.hasOwnProperty
          for (var i in t) n.call(t, i) && e.push(i)
          return e
        }
    },
    eOtv: function (t, e, n) {
      var i = n('lKxJ'),
        s = n('KFGy'),
        r = n('cpc2'),
        o = n('Uwu7'),
        a = n('2Dig'),
        l = n('QN7Q'),
        c = n('NOtv')('socket.io-client:manager'),
        h = n('7jRU'),
        u = n('C2QD'),
        d = Object.prototype.hasOwnProperty
      function p(t, e) {
        if (!(this instanceof p)) return new p(t, e)
        t && 'object' == typeof t && ((e = t), (t = void 0)),
          ((e = e || {}).path = e.path || '/socket.io'),
          (this.nsps = {}),
          (this.subs = []),
          (this.opts = e),
          this.reconnection(!1 !== e.reconnection),
          this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0),
          this.reconnectionDelay(e.reconnectionDelay || 1e3),
          this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3),
          this.randomizationFactor(e.randomizationFactor || 0.5),
          (this.backoff = new u({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor(),
          })),
          this.timeout(null == e.timeout ? 2e4 : e.timeout),
          (this.readyState = 'closed'),
          (this.uri = t),
          (this.connecting = []),
          (this.lastPing = null),
          (this.encoding = !1),
          (this.packetBuffer = [])
        var n = e.parser || o
        ;(this.encoder = new n.Encoder()),
          (this.decoder = new n.Decoder()),
          (this.autoConnect = !1 !== e.autoConnect),
          this.autoConnect && this.open()
      }
      ;(t.exports = p),
        (p.prototype.emitAll = function () {
          for (var t in (this.emit.apply(this, arguments), this.nsps))
            d.call(this.nsps, t) &&
              this.nsps[t].emit.apply(this.nsps[t], arguments)
        }),
        (p.prototype.updateSocketIds = function () {
          for (var t in this.nsps)
            d.call(this.nsps, t) && (this.nsps[t].id = this.generateId(t))
        }),
        (p.prototype.generateId = function (t) {
          return ('/' === t ? '' : t + '#') + this.engine.id
        }),
        r(p.prototype),
        (p.prototype.reconnection = function (t) {
          return arguments.length
            ? ((this._reconnection = !!t), this)
            : this._reconnection
        }),
        (p.prototype.reconnectionAttempts = function (t) {
          return arguments.length
            ? ((this._reconnectionAttempts = t), this)
            : this._reconnectionAttempts
        }),
        (p.prototype.reconnectionDelay = function (t) {
          return arguments.length
            ? ((this._reconnectionDelay = t),
              this.backoff && this.backoff.setMin(t),
              this)
            : this._reconnectionDelay
        }),
        (p.prototype.randomizationFactor = function (t) {
          return arguments.length
            ? ((this._randomizationFactor = t),
              this.backoff && this.backoff.setJitter(t),
              this)
            : this._randomizationFactor
        }),
        (p.prototype.reconnectionDelayMax = function (t) {
          return arguments.length
            ? ((this._reconnectionDelayMax = t),
              this.backoff && this.backoff.setMax(t),
              this)
            : this._reconnectionDelayMax
        }),
        (p.prototype.timeout = function (t) {
          return arguments.length ? ((this._timeout = t), this) : this._timeout
        }),
        (p.prototype.maybeReconnectOnOpen = function () {
          !this.reconnecting &&
            this._reconnection &&
            0 === this.backoff.attempts &&
            this.reconnect()
        }),
        (p.prototype.open = p.prototype.connect = function (t, e) {
          if (
            (c('readyState %s', this.readyState),
            ~this.readyState.indexOf('open'))
          )
            return this
          c('opening %s', this.uri), (this.engine = i(this.uri, this.opts))
          var n = this.engine,
            s = this
          ;(this.readyState = 'opening'), (this.skipReconnect = !1)
          var r = a(n, 'open', function () {
              s.onopen(), t && t()
            }),
            o = a(n, 'error', function (e) {
              if (
                (c('connect_error'),
                s.cleanup(),
                (s.readyState = 'closed'),
                s.emitAll('connect_error', e),
                t)
              ) {
                var n = new Error('Connection error')
                ;(n.data = e), t(n)
              } else s.maybeReconnectOnOpen()
            })
          if (!1 !== this._timeout) {
            var l = this._timeout
            c('connect attempt will timeout after %d', l),
              0 === l && r.destroy()
            var h = setTimeout(function () {
              c('connect attempt timed out after %d', l),
                r.destroy(),
                n.close(),
                n.emit('error', 'timeout'),
                s.emitAll('connect_timeout', l)
            }, l)
            this.subs.push({
              destroy: function () {
                clearTimeout(h)
              },
            })
          }
          return this.subs.push(r), this.subs.push(o), this
        }),
        (p.prototype.onopen = function () {
          c('open'),
            this.cleanup(),
            (this.readyState = 'open'),
            this.emit('open')
          var t = this.engine
          this.subs.push(a(t, 'data', l(this, 'ondata'))),
            this.subs.push(a(t, 'ping', l(this, 'onping'))),
            this.subs.push(a(t, 'pong', l(this, 'onpong'))),
            this.subs.push(a(t, 'error', l(this, 'onerror'))),
            this.subs.push(a(t, 'close', l(this, 'onclose'))),
            this.subs.push(a(this.decoder, 'decoded', l(this, 'ondecoded')))
        }),
        (p.prototype.onping = function () {
          ;(this.lastPing = new Date()), this.emitAll('ping')
        }),
        (p.prototype.onpong = function () {
          this.emitAll('pong', new Date() - this.lastPing)
        }),
        (p.prototype.ondata = function (t) {
          this.decoder.add(t)
        }),
        (p.prototype.ondecoded = function (t) {
          this.emit('packet', t)
        }),
        (p.prototype.onerror = function (t) {
          c('error', t), this.emitAll('error', t)
        }),
        (p.prototype.socket = function (t, e) {
          var n = this.nsps[t]
          if (!n) {
            ;(n = new s(this, t, e)), (this.nsps[t] = n)
            var i = this
            n.on('connecting', r),
              n.on('connect', function () {
                n.id = i.generateId(t)
              }),
              this.autoConnect && r()
          }
          function r() {
            ~h(i.connecting, n) || i.connecting.push(n)
          }
          return n
        }),
        (p.prototype.destroy = function (t) {
          var e = h(this.connecting, t)
          ~e && this.connecting.splice(e, 1),
            this.connecting.length || this.close()
        }),
        (p.prototype.packet = function (t) {
          c('writing packet %j', t)
          var e = this
          t.query && 0 === t.type && (t.nsp += '?' + t.query),
            e.encoding
              ? e.packetBuffer.push(t)
              : ((e.encoding = !0),
                this.encoder.encode(t, function (n) {
                  for (var i = 0; i < n.length; i++)
                    e.engine.write(n[i], t.options)
                  ;(e.encoding = !1), e.processPacketQueue()
                }))
        }),
        (p.prototype.processPacketQueue = function () {
          if (this.packetBuffer.length > 0 && !this.encoding) {
            var t = this.packetBuffer.shift()
            this.packet(t)
          }
        }),
        (p.prototype.cleanup = function () {
          c('cleanup')
          for (var t = this.subs.length, e = 0; e < t; e++)
            this.subs.shift().destroy()
          ;(this.packetBuffer = []),
            (this.encoding = !1),
            (this.lastPing = null),
            this.decoder.destroy()
        }),
        (p.prototype.close = p.prototype.disconnect = function () {
          c('disconnect'),
            (this.skipReconnect = !0),
            (this.reconnecting = !1),
            'opening' === this.readyState && this.cleanup(),
            this.backoff.reset(),
            (this.readyState = 'closed'),
            this.engine && this.engine.close()
        }),
        (p.prototype.onclose = function (t) {
          c('onclose'),
            this.cleanup(),
            this.backoff.reset(),
            (this.readyState = 'closed'),
            this.emit('close', t),
            this._reconnection && !this.skipReconnect && this.reconnect()
        }),
        (p.prototype.reconnect = function () {
          if (this.reconnecting || this.skipReconnect) return this
          var t = this
          if (this.backoff.attempts >= this._reconnectionAttempts)
            c('reconnect failed'),
              this.backoff.reset(),
              this.emitAll('reconnect_failed'),
              (this.reconnecting = !1)
          else {
            var e = this.backoff.duration()
            c('will wait %dms before reconnect attempt', e),
              (this.reconnecting = !0)
            var n = setTimeout(function () {
              t.skipReconnect ||
                (c('attempting reconnect'),
                t.emitAll('reconnect_attempt', t.backoff.attempts),
                t.emitAll('reconnecting', t.backoff.attempts),
                t.skipReconnect ||
                  t.open(function (e) {
                    e
                      ? (c('reconnect attempt error'),
                        (t.reconnecting = !1),
                        t.reconnect(),
                        t.emitAll('reconnect_error', e.data))
                      : (c('reconnect success'), t.onreconnect())
                  }))
            }, e)
            this.subs.push({
              destroy: function () {
                clearTimeout(n)
              },
            })
          }
        }),
        (p.prototype.onreconnect = function () {
          var t = this.backoff.attempts
          ;(this.reconnecting = !1),
            this.backoff.reset(),
            this.updateSocketIds(),
            this.emitAll('reconnect', t)
        })
    },
    g5Dd: function (t, e) {
      !(function (t) {
        'use strict'
        ;(e.encode = function (e) {
          var n,
            i = new Uint8Array(e),
            s = i.length,
            r = ''
          for (n = 0; n < s; n += 3)
            (r += t[i[n] >> 2]),
              (r += t[((3 & i[n]) << 4) | (i[n + 1] >> 4)]),
              (r += t[((15 & i[n + 1]) << 2) | (i[n + 2] >> 6)]),
              (r += t[63 & i[n + 2]])
          return (
            s % 3 == 2
              ? (r = r.substring(0, r.length - 1) + '=')
              : s % 3 == 1 && (r = r.substring(0, r.length - 2) + '=='),
            r
          )
        }),
          (e.decode = function (e) {
            var n,
              i,
              s,
              r,
              o,
              a = 0.75 * e.length,
              l = e.length,
              c = 0
            '=' === e[e.length - 1] && (a--, '=' === e[e.length - 2] && a--)
            var h = new ArrayBuffer(a),
              u = new Uint8Array(h)
            for (n = 0; n < l; n += 4)
              (i = t.indexOf(e[n])),
                (s = t.indexOf(e[n + 1])),
                (r = t.indexOf(e[n + 2])),
                (o = t.indexOf(e[n + 3])),
                (u[c++] = (i << 2) | (s >> 4)),
                (u[c++] = ((15 & s) << 4) | (r >> 2)),
                (u[c++] = ((3 & r) << 6) | (63 & o))
            return h
          })
      })('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/')
    },
    gFX4: function (t, e, n) {
      var i = n('zJ60'),
        s = n('Uwu7'),
        r = n('eOtv'),
        o = n('NOtv')('socket.io-client')
      t.exports = e = l
      var a = (e.managers = {})
      function l(t, e) {
        'object' == typeof t && ((e = t), (t = void 0)), (e = e || {})
        var n,
          s = i(t),
          l = s.source,
          c = s.id
        return (
          e.forceNew ||
          e['force new connection'] ||
          !1 === e.multiplex ||
          (a[c] && s.path in a[c].nsps)
            ? (o('ignoring socket cache for %s', l), (n = r(l, e)))
            : (a[c] || (o('new io instance for %s', l), (a[c] = r(l, e))),
              (n = a[c])),
          s.query && !e.query && (e.query = s.query),
          n.socket(s.path, e)
        )
      }
      ;(e.protocol = s.protocol),
        (e.connect = l),
        (e.Manager = n('eOtv')),
        (e.Socket = n('KFGy'))
    },
    kSER: function (t, e) {
      t.exports = function (t, e) {
        for (var n = [], i = (e = e || 0) || 0; i < t.length; i++)
          n[i - e] = t[i]
        return n
      }
    },
    lKxJ: function (t, e, n) {
      ;(t.exports = n('2pII')), (t.exports.parser = n('Wm4p'))
    },
    luTP: function (t, e) {
      var n = {}.toString
      t.exports =
        Array.isArray ||
        function (t) {
          return '[object Array]' == n.call(t)
        }
    },
    lv48: function (t, e, n) {
      function i(t) {
        var n
        function i() {
          if (i.enabled) {
            var t = i,
              s = +new Date(),
              r = s - (n || s)
            ;(t.diff = r), (t.prev = n), (t.curr = s), (n = s)
            for (var o = new Array(arguments.length), a = 0; a < o.length; a++)
              o[a] = arguments[a]
            ;(o[0] = e.coerce(o[0])), 'string' != typeof o[0] && o.unshift('%O')
            var l = 0
            ;(o[0] = o[0].replace(/%([a-zA-Z%])/g, function (n, i) {
              if ('%%' === n) return n
              l++
              var s = e.formatters[i]
              return (
                'function' == typeof s &&
                  ((n = s.call(t, o[l])), o.splice(l, 1), l--),
                n
              )
            })),
              e.formatArgs.call(t, o)
            var c = i.log || e.log || console.log.bind(console)
            c.apply(t, o)
          }
        }
        return (
          (i.namespace = t),
          (i.enabled = e.enabled(t)),
          (i.useColors = e.useColors()),
          (i.color = (function (t) {
            var n,
              i = 0
            for (n in t) (i = (i << 5) - i + t.charCodeAt(n)), (i |= 0)
            return e.colors[Math.abs(i) % e.colors.length]
          })(t)),
          (i.destroy = s),
          'function' == typeof e.init && e.init(i),
          e.instances.push(i),
          i
        )
      }
      function s() {
        var t = e.instances.indexOf(this)
        return -1 !== t && (e.instances.splice(t, 1), !0)
      }
      ;((e = t.exports = i.debug = i.default = i).coerce = function (t) {
        return t instanceof Error ? t.stack || t.message : t
      }),
        (e.disable = function () {
          e.enable('')
        }),
        (e.enable = function (t) {
          var n
          e.save(t), (e.names = []), (e.skips = [])
          var i = ('string' == typeof t ? t : '').split(/[\s,]+/),
            s = i.length
          for (n = 0; n < s; n++)
            i[n] &&
              ('-' === (t = i[n].replace(/\*/g, '.*?'))[0]
                ? e.skips.push(new RegExp('^' + t.substr(1) + '$'))
                : e.names.push(new RegExp('^' + t + '$')))
          for (n = 0; n < e.instances.length; n++) {
            var r = e.instances[n]
            r.enabled = e.enabled(r.namespace)
          }
        }),
        (e.enabled = function (t) {
          if ('*' === t[t.length - 1]) return !0
          var n, i
          for (n = 0, i = e.skips.length; n < i; n++)
            if (e.skips[n].test(t)) return !1
          for (n = 0, i = e.names.length; n < i; n++)
            if (e.names[n].test(t)) return !0
          return !1
        }),
        (e.humanize = n('FGiv')),
        (e.instances = []),
        (e.names = []),
        (e.skips = []),
        (e.formatters = {})
    },
    'oIG/': function (t, e) {
      var n,
        i,
        s,
        r = String.fromCharCode
      function o(t) {
        for (var e, n, i = [], s = 0, r = t.length; s < r; )
          (e = t.charCodeAt(s++)) >= 55296 && e <= 56319 && s < r
            ? 56320 == (64512 & (n = t.charCodeAt(s++)))
              ? i.push(((1023 & e) << 10) + (1023 & n) + 65536)
              : (i.push(e), s--)
            : i.push(e)
        return i
      }
      function a(t, e) {
        if (t >= 55296 && t <= 57343) {
          if (e)
            throw Error(
              'Lone surrogate U+' +
                t.toString(16).toUpperCase() +
                ' is not a scalar value'
            )
          return !1
        }
        return !0
      }
      function l(t, e) {
        return r(((t >> e) & 63) | 128)
      }
      function c(t, e) {
        if (0 == (4294967168 & t)) return r(t)
        var n = ''
        return (
          0 == (4294965248 & t)
            ? (n = r(((t >> 6) & 31) | 192))
            : 0 == (4294901760 & t)
            ? (a(t, e) || (t = 65533),
              (n = r(((t >> 12) & 15) | 224)),
              (n += l(t, 6)))
            : 0 == (4292870144 & t) &&
              ((n = r(((t >> 18) & 7) | 240)), (n += l(t, 12)), (n += l(t, 6))),
          n + r((63 & t) | 128)
        )
      }
      function h() {
        if (s >= i) throw Error('Invalid byte index')
        var t = 255 & n[s]
        if ((s++, 128 == (192 & t))) return 63 & t
        throw Error('Invalid continuation byte')
      }
      function u(t) {
        var e, r
        if (s > i) throw Error('Invalid byte index')
        if (s == i) return !1
        if (((e = 255 & n[s]), s++, 0 == (128 & e))) return e
        if (192 == (224 & e)) {
          if ((r = ((31 & e) << 6) | h()) >= 128) return r
          throw Error('Invalid continuation byte')
        }
        if (224 == (240 & e)) {
          if ((r = ((15 & e) << 12) | (h() << 6) | h()) >= 2048)
            return a(r, t) ? r : 65533
          throw Error('Invalid continuation byte')
        }
        if (
          240 == (248 & e) &&
          (r = ((7 & e) << 18) | (h() << 12) | (h() << 6) | h()) >= 65536 &&
          r <= 1114111
        )
          return r
        throw Error('Invalid UTF-8 detected')
      }
      t.exports = {
        version: '2.1.2',
        encode: function (t, e) {
          for (
            var n = !1 !== (e = e || {}).strict,
              i = o(t),
              s = i.length,
              r = -1,
              a = '';
            ++r < s;

          )
            a += c(i[r], n)
          return a
        },
        decode: function (t, e) {
          var a = !1 !== (e = e || {}).strict
          ;(n = o(t)), (i = n.length), (s = 0)
          for (var l, c = []; !1 !== (l = u(a)); ) c.push(l)
          return (function (t) {
            for (var e, n = t.length, i = -1, s = ''; ++i < n; )
              (e = t[i]) > 65535 &&
                ((s += r((((e -= 65536) >>> 10) & 1023) | 55296)),
                (e = 56320 | (1023 & e))),
                (s += r(e))
            return s
          })(c)
        },
      }
    },
    qGlh: function (t, e) {
      t.exports = function (t) {
        return (
          (n && Buffer.isBuffer(t)) ||
          (i &&
            (t instanceof ArrayBuffer ||
              (function (t) {
                return 'function' == typeof ArrayBuffer.isView
                  ? ArrayBuffer.isView(t)
                  : t.buffer instanceof ArrayBuffer
              })(t)))
        )
      }
      var n =
          'function' == typeof Buffer && 'function' == typeof Buffer.isBuffer,
        i = 'function' == typeof ArrayBuffer
    },
    yeub: function (t, e) {
      try {
        t.exports =
          'undefined' != typeof XMLHttpRequest &&
          'withCredentials' in new XMLHttpRequest()
      } catch (n) {
        t.exports = !1
      }
    },
    ypnn: function (t, e) {
      t.exports = function (t, e, n) {
        var i = t.byteLength
        if (((e = e || 0), (n = n || i), t.slice)) return t.slice(e, n)
        if (
          (e < 0 && (e += i),
          n < 0 && (n += i),
          n > i && (n = i),
          e >= i || e >= n || 0 === i)
        )
          return new ArrayBuffer(0)
        for (
          var s = new Uint8Array(t), r = new Uint8Array(n - e), o = e, a = 0;
          o < n;
          o++, a++
        )
          r[a] = s[o]
        return r.buffer
      }
    },
    zJ60: function (t, e, n) {
      var i = n('Uxeu'),
        s = n('NOtv')('socket.io-client:url')
      t.exports = function (t, e) {
        var n = t
        ;(e = e || ('undefined' != typeof location && location)),
          null == t && (t = e.protocol + '//' + e.host),
          'string' == typeof t &&
            ('/' === t.charAt(0) &&
              (t = '/' === t.charAt(1) ? e.protocol + t : e.host + t),
            /^(https?|wss?):\/\//.test(t) ||
              (s('protocol-less url %s', t),
              (t = void 0 !== e ? e.protocol + '//' + t : 'https://' + t)),
            s('parse %s', t),
            (n = i(t))),
          n.port ||
            (/^(http|ws)$/.test(n.protocol)
              ? (n.port = '80')
              : /^(http|ws)s$/.test(n.protocol) && (n.port = '443')),
          (n.path = n.path || '/')
        var r = -1 !== n.host.indexOf(':') ? '[' + n.host + ']' : n.host
        return (
          (n.id = n.protocol + '://' + r + ':' + n.port),
          (n.href =
            n.protocol +
            '://' +
            r +
            (e && e.port === n.port ? '' : ':' + n.port)),
          n
        )
      }
    },
    zMFY: function (t, e) {
      function n() {}
      t.exports = function (t, e, i) {
        var s = !1
        return (i = i || n), (r.count = t), 0 === t ? e() : r
        function r(t, n) {
          if (r.count <= 0) throw new Error('after called too many times')
          --r.count,
            t ? ((s = !0), e(t), (e = i)) : 0 !== r.count || s || e(null, n)
        }
      }
    },
  },
  [[0, 0]],
])
