;(window.webpackJsonp = window.webpackJsonp || []).push([
  [1],
  {
    '+rOU': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return s
      }),
        n.d(e, 'b', function () {
          return l
        }),
        n.d(e, 'c', function () {
          return u
        }),
        n.d(e, 'd', function () {
          return c
        }),
        n.d(e, 'e', function () {
          return o
        })
      var i = n('fXoL')
      n('ofXK')
      class r {
        attach(t) {
          return (this._attachedHost = t), t.attach(this)
        }
        detach() {
          let t = this._attachedHost
          null != t && ((this._attachedHost = null), t.detach())
        }
        get isAttached() {
          return null != this._attachedHost
        }
        setAttachedHost(t) {
          this._attachedHost = t
        }
      }
      class s extends r {
        constructor(t, e, n, i) {
          super(),
            (this.component = t),
            (this.viewContainerRef = e),
            (this.injector = n),
            (this.componentFactoryResolver = i)
        }
      }
      class o extends r {
        constructor(t, e, n) {
          super(),
            (this.templateRef = t),
            (this.viewContainerRef = e),
            (this.context = n)
        }
        get origin() {
          return this.templateRef.elementRef
        }
        attach(t, e = this.context) {
          return (this.context = e), super.attach(t)
        }
        detach() {
          return (this.context = void 0), super.detach()
        }
      }
      class a extends r {
        constructor(t) {
          super(), (this.element = t instanceof i.l ? t.nativeElement : t)
        }
      }
      class l extends class {
        constructor() {
          ;(this._isDisposed = !1), (this.attachDomPortal = null)
        }
        hasAttached() {
          return !!this._attachedPortal
        }
        attach(t) {
          return t instanceof s
            ? ((this._attachedPortal = t), this.attachComponentPortal(t))
            : t instanceof o
            ? ((this._attachedPortal = t), this.attachTemplatePortal(t))
            : this.attachDomPortal && t instanceof a
            ? ((this._attachedPortal = t), this.attachDomPortal(t))
            : void 0
        }
        detach() {
          this._attachedPortal &&
            (this._attachedPortal.setAttachedHost(null),
            (this._attachedPortal = null)),
            this._invokeDisposeFn()
        }
        dispose() {
          this.hasAttached() && this.detach(),
            this._invokeDisposeFn(),
            (this._isDisposed = !0)
        }
        setDisposeFn(t) {
          this._disposeFn = t
        }
        _invokeDisposeFn() {
          this._disposeFn && (this._disposeFn(), (this._disposeFn = null))
        }
      } {
        constructor(t, e, n, i, r) {
          super(),
            (this.outletElement = t),
            (this._componentFactoryResolver = e),
            (this._appRef = n),
            (this._defaultInjector = i),
            (this.attachDomPortal = (t) => {
              const e = t.element,
                n = this._document.createComment('dom-portal')
              e.parentNode.insertBefore(n, e),
                this.outletElement.appendChild(e),
                super.setDisposeFn(() => {
                  n.parentNode && n.parentNode.replaceChild(e, n)
                })
            }),
            (this._document = r)
        }
        attachComponentPortal(t) {
          const e = (
            t.componentFactoryResolver || this._componentFactoryResolver
          ).resolveComponentFactory(t.component)
          let n
          return (
            t.viewContainerRef
              ? ((n = t.viewContainerRef.createComponent(
                  e,
                  t.viewContainerRef.length,
                  t.injector || t.viewContainerRef.injector
                )),
                this.setDisposeFn(() => n.destroy()))
              : ((n = e.create(t.injector || this._defaultInjector)),
                this._appRef.attachView(n.hostView),
                this.setDisposeFn(() => {
                  this._appRef.detachView(n.hostView), n.destroy()
                })),
            this.outletElement.appendChild(this._getComponentRootNode(n)),
            n
          )
        }
        attachTemplatePortal(t) {
          let e = t.viewContainerRef,
            n = e.createEmbeddedView(t.templateRef, t.context)
          return (
            n.rootNodes.forEach((t) => this.outletElement.appendChild(t)),
            n.detectChanges(),
            this.setDisposeFn(() => {
              let t = e.indexOf(n)
              ;-1 !== t && e.remove(t)
            }),
            n
          )
        }
        dispose() {
          super.dispose(),
            null != this.outletElement.parentNode &&
              this.outletElement.parentNode.removeChild(this.outletElement)
        }
        _getComponentRootNode(t) {
          return t.hostView.rootNodes[0]
        }
      }
      let c = (() => {
        class t {}
        return (
          (t.ɵmod = i.Jb({ type: t })),
          (t.ɵinj = i.Ib({
            factory: function (e) {
              return new (e || t)()
            },
          })),
          t
        )
      })()
      class u {
        constructor(t, e) {
          ;(this._parentInjector = t), (this._customTokens = e)
        }
        get(t, e) {
          const n = this._customTokens.get(t)
          return void 0 !== n ? n : this._parentInjector.get(t, e)
        }
      }
    },
    '/t3+': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return d
      }),
        n.d(e, 'b', function () {
          return p
        })
      var i = n('FKr1'),
        r = n('ofXK'),
        s = n('fXoL'),
        o = n('nLfN')
      const a = ['*', [['mat-toolbar-row']]],
        l = ['*', 'mat-toolbar-row']
      class c {
        constructor(t) {
          this._elementRef = t
        }
      }
      const u = Object(i.o)(c)
      let h = (() => {
          class t {}
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵdir = s.Gb({
              type: t,
              selectors: [['mat-toolbar-row']],
              hostAttrs: [1, 'mat-toolbar-row'],
              exportAs: ['matToolbarRow'],
            })),
            t
          )
        })(),
        d = (() => {
          class t extends u {
            constructor(t, e, n) {
              super(t), (this._platform = e), (this._document = n)
            }
            ngAfterViewInit() {
              this._platform.isBrowser &&
                (this._checkToolbarMixedModes(),
                this._toolbarRows.changes.subscribe(() =>
                  this._checkToolbarMixedModes()
                ))
            }
            _checkToolbarMixedModes() {}
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(s.Lb(s.l), s.Lb(o.a), s.Lb(r.d))
            }),
            (t.ɵcmp = s.Fb({
              type: t,
              selectors: [['mat-toolbar']],
              contentQueries: function (t, e, n) {
                if ((1 & t && s.Eb(n, h, !0), 2 & t)) {
                  let t
                  s.jc((t = s.Yb())) && (e._toolbarRows = t)
                }
              },
              hostAttrs: [1, 'mat-toolbar'],
              hostVars: 4,
              hostBindings: function (t, e) {
                2 & t &&
                  s.Db('mat-toolbar-multiple-rows', e._toolbarRows.length > 0)(
                    'mat-toolbar-single-row',
                    0 === e._toolbarRows.length
                  )
              },
              inputs: { color: 'color' },
              exportAs: ['matToolbar'],
              features: [s.wb],
              ngContentSelectors: l,
              decls: 2,
              vars: 0,
              template: function (t, e) {
                1 & t && (s.fc(a), s.ec(0), s.ec(1, 1))
              },
              styles: [
                '.cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}\n',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        p = (() => {
          class t {}
          return (
            (t.ɵmod = s.Jb({ type: t })),
            (t.ɵinj = s.Ib({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[i.d], i.d],
            })),
            t
          )
        })()
    },
    '/uUt': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return r
      })
      var i = n('7o/Q')
      function r(t, e) {
        return (n) => n.lift(new s(t, e))
      }
      class s {
        constructor(t, e) {
          ;(this.compare = t), (this.keySelector = e)
        }
        call(t, e) {
          return e.subscribe(new o(t, this.compare, this.keySelector))
        }
      }
      class o extends i.a {
        constructor(t, e, n) {
          super(t),
            (this.keySelector = n),
            (this.hasKey = !1),
            'function' == typeof e && (this.compare = e)
        }
        compare(t, e) {
          return t === e
        }
        _next(t) {
          let e
          try {
            const { keySelector: n } = this
            e = n ? n(t) : t
          } catch (i) {
            return this.destination.error(i)
          }
          let n = !1
          if (this.hasKey)
            try {
              const { compare: t } = this
              n = t(this.key, e)
            } catch (i) {
              return this.destination.error(i)
            }
          else this.hasKey = !0
          n || ((this.key = e), this.destination.next(t))
        }
      }
    },
    0: function (t, e, n) {
      t.exports = n('Zr4m')
    },
    '0EQZ': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return l
      }),
        n.d(e, 'b', function () {
          return u
        }),
        n.d(e, 'c', function () {
          return c
        }),
        n.d(e, 'd', function () {
          return h
        }),
        n.d(e, 'e', function () {
          return a
        })
      var i = n('7+OI'),
        r = n('LRne'),
        s = n('XNiG'),
        o = n('fXoL')
      function a(t) {
        return t && 'function' == typeof t.connect
      }
      class l extends class {} {
        constructor(t) {
          super(), (this._data = t)
        }
        connect() {
          return Object(i.a)(this._data) ? this._data : Object(r.a)(this._data)
        }
        disconnect() {}
      }
      class c {
        constructor() {
          ;(this.viewCacheSize = 20), (this._viewCache = [])
        }
        applyChanges(t, e, n, i, r) {
          t.forEachOperation((t, s, o) => {
            let a, l
            null == t.previousIndex
              ? ((a = this._insertView(() => n(t, s, o), o, e, i(t))),
                (l = a ? 1 : 0))
              : null == o
              ? (this._detachAndCacheView(s, e), (l = 3))
              : ((a = this._moveView(s, o, e, i(t))), (l = 2)),
              r &&
                r({
                  context: null == a ? void 0 : a.context,
                  operation: l,
                  record: t,
                })
          })
        }
        detach() {
          for (const t of this._viewCache) t.destroy()
        }
        _insertView(t, e, n, i) {
          let r = this._insertViewFromCache(e, n)
          if (r) return void (r.context.$implicit = i)
          const s = t()
          return n.createEmbeddedView(s.templateRef, s.context, s.index)
        }
        _detachAndCacheView(t, e) {
          const n = this._detachView(t, e)
          this._maybeCacheView(n, e)
        }
        _moveView(t, e, n, i) {
          const r = n.get(t)
          return n.move(r, e), (r.context.$implicit = i), r
        }
        _maybeCacheView(t, e) {
          if (this._viewCache.length < this.viewCacheSize)
            this._viewCache.push(t)
          else {
            const n = e.indexOf(t)
            ;-1 === n ? t.destroy() : e.remove(n)
          }
        }
        _insertViewFromCache(t, e) {
          const n = this._viewCache.pop()
          return n && e.insert(n, t), n || null
        }
        _detachView(t, e) {
          return e.detach(t)
        }
      }
      class u {
        constructor(t = !1, e, n = !0) {
          ;(this._multiple = t),
            (this._emitChanges = n),
            (this._selection = new Set()),
            (this._deselectedToEmit = []),
            (this._selectedToEmit = []),
            (this.changed = new s.a()),
            e &&
              e.length &&
              (t
                ? e.forEach((t) => this._markSelected(t))
                : this._markSelected(e[0]),
              (this._selectedToEmit.length = 0))
        }
        get selected() {
          return (
            this._selected ||
              (this._selected = Array.from(this._selection.values())),
            this._selected
          )
        }
        select(...t) {
          this._verifyValueAssignment(t),
            t.forEach((t) => this._markSelected(t)),
            this._emitChangeEvent()
        }
        deselect(...t) {
          this._verifyValueAssignment(t),
            t.forEach((t) => this._unmarkSelected(t)),
            this._emitChangeEvent()
        }
        toggle(t) {
          this.isSelected(t) ? this.deselect(t) : this.select(t)
        }
        clear() {
          this._unmarkAll(), this._emitChangeEvent()
        }
        isSelected(t) {
          return this._selection.has(t)
        }
        isEmpty() {
          return 0 === this._selection.size
        }
        hasValue() {
          return !this.isEmpty()
        }
        sort(t) {
          this._multiple && this.selected && this._selected.sort(t)
        }
        isMultipleSelection() {
          return this._multiple
        }
        _emitChangeEvent() {
          ;(this._selected = null),
            (this._selectedToEmit.length || this._deselectedToEmit.length) &&
              (this.changed.next({
                source: this,
                added: this._selectedToEmit,
                removed: this._deselectedToEmit,
              }),
              (this._deselectedToEmit = []),
              (this._selectedToEmit = []))
        }
        _markSelected(t) {
          this.isSelected(t) ||
            (this._multiple || this._unmarkAll(),
            this._selection.add(t),
            this._emitChanges && this._selectedToEmit.push(t))
        }
        _unmarkSelected(t) {
          this.isSelected(t) &&
            (this._selection.delete(t),
            this._emitChanges && this._deselectedToEmit.push(t))
        }
        _unmarkAll() {
          this.isEmpty() ||
            this._selection.forEach((t) => this._unmarkSelected(t))
        }
        _verifyValueAssignment(t) {}
      }
      const h = new o.q('_ViewRepeater')
    },
    '0EUg': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return r
      })
      var i = n('bHdf')
      function r() {
        return Object(i.a)(1)
      }
    },
    '0ujj': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return l
      })
      var i = n('ofXK'),
        r = n('rDax'),
        s = n('iBb4'),
        o = n('cPJY'),
        a = n('fXoL')
      let l = (() => {
        class t {
          static forRoot(e = o.c) {
            return {
              ngModule: t,
              providers: [
                {
                  provide: o.a,
                  useValue: Object.assign(Object.assign({}, o.c), e),
                },
              ],
            }
          }
        }
        return (
          (t.ɵmod = a.Jb({ type: t })),
          (t.ɵinj = a.Ib({
            factory: function (e) {
              return new (e || t)()
            },
            providers: [s.a],
            imports: [[i.c, r.d]],
          })),
          t
        )
      })()
    },
    '0z79': function (t, e, n) {
      var i = n('AdPF'),
        r = n('CUme'),
        s = n('cpc2'),
        o = n('Yvos'),
        a = n('NOtv')('engine.io-client:polling-xhr'),
        l = n('2UHX')
      function c() {}
      function u(t) {
        if (
          (r.call(this, t),
          (this.requestTimeout = t.requestTimeout),
          (this.extraHeaders = t.extraHeaders),
          'undefined' != typeof location)
        ) {
          var e = 'https:' === location.protocol,
            n = location.port
          n || (n = e ? 443 : 80),
            (this.xd =
              ('undefined' != typeof location &&
                t.hostname !== location.hostname) ||
              n !== t.port),
            (this.xs = t.secure !== e)
        }
      }
      function h(t) {
        ;(this.method = t.method || 'GET'),
          (this.uri = t.uri),
          (this.xd = !!t.xd),
          (this.xs = !!t.xs),
          (this.async = !1 !== t.async),
          (this.data = void 0 !== t.data ? t.data : null),
          (this.agent = t.agent),
          (this.isBinary = t.isBinary),
          (this.supportsBinary = t.supportsBinary),
          (this.enablesXDR = t.enablesXDR),
          (this.withCredentials = t.withCredentials),
          (this.requestTimeout = t.requestTimeout),
          (this.pfx = t.pfx),
          (this.key = t.key),
          (this.passphrase = t.passphrase),
          (this.cert = t.cert),
          (this.ca = t.ca),
          (this.ciphers = t.ciphers),
          (this.rejectUnauthorized = t.rejectUnauthorized),
          (this.extraHeaders = t.extraHeaders),
          this.create()
      }
      function d() {
        for (var t in h.requests)
          h.requests.hasOwnProperty(t) && h.requests[t].abort()
      }
      ;(t.exports = u),
        (t.exports.Request = h),
        o(u, r),
        (u.prototype.supportsBinary = !0),
        (u.prototype.request = function (t) {
          return (
            ((t = t || {}).uri = this.uri()),
            (t.xd = this.xd),
            (t.xs = this.xs),
            (t.agent = this.agent || !1),
            (t.supportsBinary = this.supportsBinary),
            (t.enablesXDR = this.enablesXDR),
            (t.withCredentials = this.withCredentials),
            (t.pfx = this.pfx),
            (t.key = this.key),
            (t.passphrase = this.passphrase),
            (t.cert = this.cert),
            (t.ca = this.ca),
            (t.ciphers = this.ciphers),
            (t.rejectUnauthorized = this.rejectUnauthorized),
            (t.requestTimeout = this.requestTimeout),
            (t.extraHeaders = this.extraHeaders),
            new h(t)
          )
        }),
        (u.prototype.doWrite = function (t, e) {
          var n = this.request({
              method: 'POST',
              data: t,
              isBinary: 'string' != typeof t && void 0 !== t,
            }),
            i = this
          n.on('success', e),
            n.on('error', function (t) {
              i.onError('xhr post error', t)
            }),
            (this.sendXhr = n)
        }),
        (u.prototype.doPoll = function () {
          a('xhr poll')
          var t = this.request(),
            e = this
          t.on('data', function (t) {
            e.onData(t)
          }),
            t.on('error', function (t) {
              e.onError('xhr poll error', t)
            }),
            (this.pollXhr = t)
        }),
        s(h.prototype),
        (h.prototype.create = function () {
          var t = {
            agent: this.agent,
            xdomain: this.xd,
            xscheme: this.xs,
            enablesXDR: this.enablesXDR,
          }
          ;(t.pfx = this.pfx),
            (t.key = this.key),
            (t.passphrase = this.passphrase),
            (t.cert = this.cert),
            (t.ca = this.ca),
            (t.ciphers = this.ciphers),
            (t.rejectUnauthorized = this.rejectUnauthorized)
          var e = (this.xhr = new i(t)),
            n = this
          try {
            a('xhr open %s: %s', this.method, this.uri),
              e.open(this.method, this.uri, this.async)
            try {
              if (this.extraHeaders)
                for (var r in (e.setDisableHeaderCheck &&
                  e.setDisableHeaderCheck(!0),
                this.extraHeaders))
                  this.extraHeaders.hasOwnProperty(r) &&
                    e.setRequestHeader(r, this.extraHeaders[r])
            } catch (s) {}
            if ('POST' === this.method)
              try {
                e.setRequestHeader(
                  'Content-type',
                  this.isBinary
                    ? 'application/octet-stream'
                    : 'text/plain;charset=UTF-8'
                )
              } catch (s) {}
            try {
              e.setRequestHeader('Accept', '*/*')
            } catch (s) {}
            'withCredentials' in e &&
              (e.withCredentials = this.withCredentials),
              this.requestTimeout && (e.timeout = this.requestTimeout),
              this.hasXDR()
                ? ((e.onload = function () {
                    n.onLoad()
                  }),
                  (e.onerror = function () {
                    n.onError(e.responseText)
                  }))
                : (e.onreadystatechange = function () {
                    if (2 === e.readyState)
                      try {
                        var t = e.getResponseHeader('Content-Type')
                        ;((n.supportsBinary &&
                          'application/octet-stream' === t) ||
                          'application/octet-stream; charset=UTF-8' === t) &&
                          (e.responseType = 'arraybuffer')
                      } catch (s) {}
                    4 === e.readyState &&
                      (200 === e.status || 1223 === e.status
                        ? n.onLoad()
                        : setTimeout(function () {
                            n.onError(
                              'number' == typeof e.status ? e.status : 0
                            )
                          }, 0))
                  }),
              a('xhr data %s', this.data),
              e.send(this.data)
          } catch (s) {
            return void setTimeout(function () {
              n.onError(s)
            }, 0)
          }
          'undefined' != typeof document &&
            ((this.index = h.requestsCount++), (h.requests[this.index] = this))
        }),
        (h.prototype.onSuccess = function () {
          this.emit('success'), this.cleanup()
        }),
        (h.prototype.onData = function (t) {
          this.emit('data', t), this.onSuccess()
        }),
        (h.prototype.onError = function (t) {
          this.emit('error', t), this.cleanup(!0)
        }),
        (h.prototype.cleanup = function (t) {
          if (null != this.xhr) {
            if (
              (this.hasXDR()
                ? (this.xhr.onload = this.xhr.onerror = c)
                : (this.xhr.onreadystatechange = c),
              t)
            )
              try {
                this.xhr.abort()
              } catch (e) {}
            'undefined' != typeof document && delete h.requests[this.index],
              (this.xhr = null)
          }
        }),
        (h.prototype.onLoad = function () {
          var t
          try {
            var e
            try {
              e = this.xhr.getResponseHeader('Content-Type')
            } catch (n) {}
            t =
              (('application/octet-stream' === e ||
                'application/octet-stream; charset=UTF-8' === e) &&
                this.xhr.response) ||
              this.xhr.responseText
          } catch (n) {
            this.onError(n)
          }
          null != t && this.onData(t)
        }),
        (h.prototype.hasXDR = function () {
          return (
            'undefined' != typeof XDomainRequest && !this.xs && this.enablesXDR
          )
        }),
        (h.prototype.abort = function () {
          this.cleanup()
        }),
        (h.requestsCount = 0),
        (h.requests = {}),
        'undefined' != typeof document &&
          ('function' == typeof attachEvent
            ? attachEvent('onunload', d)
            : 'function' == typeof addEventListener &&
              addEventListener(
                'onpagehide' in l ? 'pagehide' : 'unload',
                d,
                !1
              ))
    },
    1: function (t, e) {},
    '14A5': function (t, e) {
      var n =
          void 0 !== n
            ? n
            : 'undefined' != typeof WebKitBlobBuilder
            ? WebKitBlobBuilder
            : 'undefined' != typeof MSBlobBuilder
            ? MSBlobBuilder
            : 'undefined' != typeof MozBlobBuilder && MozBlobBuilder,
        i = (function () {
          try {
            return 2 === new Blob(['hi']).size
          } catch (t) {
            return !1
          }
        })(),
        r =
          i &&
          (function () {
            try {
              return 2 === new Blob([new Uint8Array([1, 2])]).size
            } catch (t) {
              return !1
            }
          })(),
        s = n && n.prototype.append && n.prototype.getBlob
      function o(t) {
        return t.map(function (t) {
          if (t.buffer instanceof ArrayBuffer) {
            var e = t.buffer
            if (t.byteLength !== e.byteLength) {
              var n = new Uint8Array(t.byteLength)
              n.set(new Uint8Array(e, t.byteOffset, t.byteLength)),
                (e = n.buffer)
            }
            return e
          }
          return t
        })
      }
      function a(t, e) {
        e = e || {}
        var i = new n()
        return (
          o(t).forEach(function (t) {
            i.append(t)
          }),
          e.type ? i.getBlob(e.type) : i.getBlob()
        )
      }
      function l(t, e) {
        return new Blob(o(t), e || {})
      }
      'undefined' != typeof Blob &&
        ((a.prototype = Blob.prototype), (l.prototype = Blob.prototype)),
        (t.exports = i ? (r ? Blob : l) : s ? a : void 0)
    },
    '1G5W': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return s
      })
      var i = n('l7GE'),
        r = n('ZUHj')
      function s(t) {
        return (e) => e.lift(new o(t))
      }
      class o {
        constructor(t) {
          this.notifier = t
        }
        call(t, e) {
          const n = new a(t),
            i = Object(r.a)(n, this.notifier)
          return i && !n.seenValue ? (n.add(i), e.subscribe(n)) : n
        }
      }
      class a extends i.a {
        constructor(t) {
          super(t), (this.seenValue = !1)
        }
        notifyNext(t, e, n, i, r) {
          ;(this.seenValue = !0), this.complete()
        }
        notifyComplete() {}
      }
    },
    '2Dig': function (t, e) {
      t.exports = function (t, e, n) {
        return (
          t.on(e, n),
          {
            destroy: function () {
              t.removeListener(e, n)
            },
          }
        )
      }
    },
    '2Mw2': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return s
      }),
        n.d(e, 'b', function () {
          return o
        }),
        n.d(e, 'c', function () {
          return l
        })
      var i = n('mrSG'),
        r = n('fXoL')
      let s = (() => {
        class t {
          constructor() {
            this.constraints = {
              audio: { echoCancellation: !0 },
              video: {
                facingMode: 'user',
                frameRate: 30,
                width: { max: 1280, ideal: 800 },
              },
            }
          }
          getUserMedia(t) {
            return navigator.mediaDevices.getUserMedia(t || this.constraints)
          }
          getDevices(t) {
            return Object(i.a)(this, void 0, void 0, function* () {
              const e = yield navigator.mediaDevices.enumerateDevices()
              return t ? e.filter(({ kind: e }) => e === t) : e
            })
          }
          getDisplayMedia() {
            const t = { video: !0 },
              e = navigator.mediaDevices
            return 'getDisplayMedia' in navigator
              ? navigator.getDisplayMedia(t)
              : 'getDisplayMedia' in e
              ? e.getDisplayMedia(t)
              : e.getUserMedia({ video: { mediaSourcee: 'screen' } })
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵprov = r.Hb({ token: t, factory: t.ɵfac, providedIn: 'root' })),
          t
        )
      })()
      n('WX4o')
      const o = new r.q('RTCConfiguration')
      var a = n('ofXK')
      let l = (() => {
        class t {}
        return (
          (t.ɵmod = r.Jb({ type: t })),
          (t.ɵinj = r.Ib({
            factory: function (e) {
              return new (e || t)()
            },
            providers: [s],
            imports: [[a.c]],
          })),
          t
        )
      })()
    },
    '2QA8': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return i
      })
      const i = (() =>
        'function' == typeof Symbol
          ? Symbol('rxSubscriber')
          : '@@rxSubscriber_' + Math.random())()
    },
    '2UHX': function (t, e) {
      t.exports =
        'undefined' != typeof self
          ? self
          : 'undefined' != typeof window
          ? window
          : Function('return this')()
    },
    '2Vo4': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return s
      })
      var i = n('XNiG'),
        r = n('9ppp')
      class s extends i.a {
        constructor(t) {
          super(), (this._value = t)
        }
        get value() {
          return this.getValue()
        }
        _subscribe(t) {
          const e = super._subscribe(t)
          return e && !e.closed && t.next(this._value), e
        }
        getValue() {
          if (this.hasError) throw this.thrownError
          if (this.closed) throw new r.a()
          return this._value
        }
        next(t) {
          super.next((this._value = t))
        }
      }
    },
    '2fFW': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return r
      })
      let i = !1
      const r = {
        Promise: void 0,
        set useDeprecatedSynchronousErrorHandling(t) {
          if (t) {
            const t = new Error()
            console.warn(
              'DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' +
                t.stack
            )
          } else
            i &&
              console.log(
                'RxJS: Back to a better error behavior. Thank you. <3'
              )
          i = t
        },
        get useDeprecatedSynchronousErrorHandling() {
          return i
        },
      }
    },
    '2pII': function (t, e, n) {
      var i = n('akSB'),
        r = n('cpc2'),
        s = n('NOtv')('engine.io-client:socket'),
        o = n('7jRU'),
        a = n('Wm4p'),
        l = n('Uxeu'),
        c = n('TypT')
      function u(t, e) {
        if (!(this instanceof u)) return new u(t, e)
        ;(e = e || {}),
          t && 'object' == typeof t && ((e = t), (t = null)),
          t
            ? ((t = l(t)),
              (e.hostname = t.host),
              (e.secure = 'https' === t.protocol || 'wss' === t.protocol),
              (e.port = t.port),
              t.query && (e.query = t.query))
            : e.host && (e.hostname = l(e.host).host),
          (this.secure =
            null != e.secure
              ? e.secure
              : 'undefined' != typeof location &&
                'https:' === location.protocol),
          e.hostname && !e.port && (e.port = this.secure ? '443' : '80'),
          (this.agent = e.agent || !1),
          (this.hostname =
            e.hostname ||
            ('undefined' != typeof location ? location.hostname : 'localhost')),
          (this.port =
            e.port ||
            ('undefined' != typeof location && location.port
              ? location.port
              : this.secure
              ? 443
              : 80)),
          (this.query = e.query || {}),
          'string' == typeof this.query && (this.query = c.decode(this.query)),
          (this.upgrade = !1 !== e.upgrade),
          (this.path = (e.path || '/engine.io').replace(/\/$/, '') + '/'),
          (this.forceJSONP = !!e.forceJSONP),
          (this.jsonp = !1 !== e.jsonp),
          (this.forceBase64 = !!e.forceBase64),
          (this.enablesXDR = !!e.enablesXDR),
          (this.withCredentials = !1 !== e.withCredentials),
          (this.timestampParam = e.timestampParam || 't'),
          (this.timestampRequests = e.timestampRequests),
          (this.transports = e.transports || ['polling', 'websocket']),
          (this.transportOptions = e.transportOptions || {}),
          (this.readyState = ''),
          (this.writeBuffer = []),
          (this.prevBufferLen = 0),
          (this.policyPort = e.policyPort || 843),
          (this.rememberUpgrade = e.rememberUpgrade || !1),
          (this.binaryType = null),
          (this.onlyBinaryUpgrades = e.onlyBinaryUpgrades),
          (this.perMessageDeflate =
            !1 !== e.perMessageDeflate && (e.perMessageDeflate || {})),
          !0 === this.perMessageDeflate && (this.perMessageDeflate = {}),
          this.perMessageDeflate &&
            null == this.perMessageDeflate.threshold &&
            (this.perMessageDeflate.threshold = 1024),
          (this.pfx = e.pfx || null),
          (this.key = e.key || null),
          (this.passphrase = e.passphrase || null),
          (this.cert = e.cert || null),
          (this.ca = e.ca || null),
          (this.ciphers = e.ciphers || null),
          (this.rejectUnauthorized =
            void 0 === e.rejectUnauthorized || e.rejectUnauthorized),
          (this.forceNode = !!e.forceNode),
          (this.isReactNative =
            'undefined' != typeof navigator &&
            'string' == typeof navigator.product &&
            'reactnative' === navigator.product.toLowerCase()),
          ('undefined' == typeof self || this.isReactNative) &&
            (e.extraHeaders &&
              Object.keys(e.extraHeaders).length > 0 &&
              (this.extraHeaders = e.extraHeaders),
            e.localAddress && (this.localAddress = e.localAddress)),
          (this.id = null),
          (this.upgrades = null),
          (this.pingInterval = null),
          (this.pingTimeout = null),
          (this.pingIntervalTimer = null),
          (this.pingTimeoutTimer = null),
          this.open()
      }
      ;(t.exports = u),
        (u.priorWebsocketSuccess = !1),
        r(u.prototype),
        (u.protocol = a.protocol),
        (u.Socket = u),
        (u.Transport = n('Gbct')),
        (u.transports = n('akSB')),
        (u.parser = n('Wm4p')),
        (u.prototype.createTransport = function (t) {
          s('creating transport "%s"', t)
          var e = (function (t) {
            var e = {}
            for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
            return e
          })(this.query)
          ;(e.EIO = a.protocol), (e.transport = t)
          var n = this.transportOptions[t] || {}
          return (
            this.id && (e.sid = this.id),
            new i[t]({
              query: e,
              socket: this,
              agent: n.agent || this.agent,
              hostname: n.hostname || this.hostname,
              port: n.port || this.port,
              secure: n.secure || this.secure,
              path: n.path || this.path,
              forceJSONP: n.forceJSONP || this.forceJSONP,
              jsonp: n.jsonp || this.jsonp,
              forceBase64: n.forceBase64 || this.forceBase64,
              enablesXDR: n.enablesXDR || this.enablesXDR,
              withCredentials: n.withCredentials || this.withCredentials,
              timestampRequests: n.timestampRequests || this.timestampRequests,
              timestampParam: n.timestampParam || this.timestampParam,
              policyPort: n.policyPort || this.policyPort,
              pfx: n.pfx || this.pfx,
              key: n.key || this.key,
              passphrase: n.passphrase || this.passphrase,
              cert: n.cert || this.cert,
              ca: n.ca || this.ca,
              ciphers: n.ciphers || this.ciphers,
              rejectUnauthorized:
                n.rejectUnauthorized || this.rejectUnauthorized,
              perMessageDeflate: n.perMessageDeflate || this.perMessageDeflate,
              extraHeaders: n.extraHeaders || this.extraHeaders,
              forceNode: n.forceNode || this.forceNode,
              localAddress: n.localAddress || this.localAddress,
              requestTimeout: n.requestTimeout || this.requestTimeout,
              protocols: n.protocols || void 0,
              isReactNative: this.isReactNative,
            })
          )
        }),
        (u.prototype.open = function () {
          var t
          if (
            this.rememberUpgrade &&
            u.priorWebsocketSuccess &&
            -1 !== this.transports.indexOf('websocket')
          )
            t = 'websocket'
          else {
            if (0 === this.transports.length) {
              var e = this
              return void setTimeout(function () {
                e.emit('error', 'No transports available')
              }, 0)
            }
            t = this.transports[0]
          }
          this.readyState = 'opening'
          try {
            t = this.createTransport(t)
          } catch (n) {
            return this.transports.shift(), void this.open()
          }
          t.open(), this.setTransport(t)
        }),
        (u.prototype.setTransport = function (t) {
          s('setting transport %s', t.name)
          var e = this
          this.transport &&
            (s('clearing existing transport %s', this.transport.name),
            this.transport.removeAllListeners()),
            (this.transport = t),
            t
              .on('drain', function () {
                e.onDrain()
              })
              .on('packet', function (t) {
                e.onPacket(t)
              })
              .on('error', function (t) {
                e.onError(t)
              })
              .on('close', function () {
                e.onClose('transport close')
              })
        }),
        (u.prototype.probe = function (t) {
          s('probing transport "%s"', t)
          var e = this.createTransport(t, { probe: 1 }),
            n = !1,
            i = this
          function r() {
            i.onlyBinaryUpgrades &&
              (n = n || (!this.supportsBinary && i.transport.supportsBinary)),
              n ||
                (s('probe transport "%s" opened', t),
                e.send([{ type: 'ping', data: 'probe' }]),
                e.once('packet', function (r) {
                  if (!n)
                    if ('pong' === r.type && 'probe' === r.data) {
                      if (
                        (s('probe transport "%s" pong', t),
                        (i.upgrading = !0),
                        i.emit('upgrading', e),
                        !e)
                      )
                        return
                      ;(u.priorWebsocketSuccess = 'websocket' === e.name),
                        s('pausing current transport "%s"', i.transport.name),
                        i.transport.pause(function () {
                          n ||
                            ('closed' !== i.readyState &&
                              (s(
                                'changing transport and sending upgrade packet'
                              ),
                              d(),
                              i.setTransport(e),
                              e.send([{ type: 'upgrade' }]),
                              i.emit('upgrade', e),
                              (e = null),
                              (i.upgrading = !1),
                              i.flush()))
                        })
                    } else {
                      s('probe transport "%s" failed', t)
                      var o = new Error('probe error')
                      ;(o.transport = e.name), i.emit('upgradeError', o)
                    }
                }))
          }
          function o() {
            n || ((n = !0), d(), e.close(), (e = null))
          }
          function a(n) {
            var r = new Error('probe error: ' + n)
            ;(r.transport = e.name),
              o(),
              s('probe transport "%s" failed because of error: %s', t, n),
              i.emit('upgradeError', r)
          }
          function l() {
            a('transport closed')
          }
          function c() {
            a('socket closed')
          }
          function h(t) {
            e &&
              t.name !== e.name &&
              (s('"%s" works - aborting "%s"', t.name, e.name), o())
          }
          function d() {
            e.removeListener('open', r),
              e.removeListener('error', a),
              e.removeListener('close', l),
              i.removeListener('close', c),
              i.removeListener('upgrading', h)
          }
          ;(u.priorWebsocketSuccess = !1),
            e.once('open', r),
            e.once('error', a),
            e.once('close', l),
            this.once('close', c),
            this.once('upgrading', h),
            e.open()
        }),
        (u.prototype.onOpen = function () {
          if (
            (s('socket open'),
            (this.readyState = 'open'),
            (u.priorWebsocketSuccess = 'websocket' === this.transport.name),
            this.emit('open'),
            this.flush(),
            'open' === this.readyState && this.upgrade && this.transport.pause)
          ) {
            s('starting upgrade probes')
            for (var t = 0, e = this.upgrades.length; t < e; t++)
              this.probe(this.upgrades[t])
          }
        }),
        (u.prototype.onPacket = function (t) {
          if (
            'opening' === this.readyState ||
            'open' === this.readyState ||
            'closing' === this.readyState
          )
            switch (
              (s('socket receive: type "%s", data "%s"', t.type, t.data),
              this.emit('packet', t),
              this.emit('heartbeat'),
              t.type)
            ) {
              case 'open':
                this.onHandshake(JSON.parse(t.data))
                break
              case 'pong':
                this.setPing(), this.emit('pong')
                break
              case 'error':
                var e = new Error('server error')
                ;(e.code = t.data), this.onError(e)
                break
              case 'message':
                this.emit('data', t.data), this.emit('message', t.data)
            }
          else s('packet received with socket readyState "%s"', this.readyState)
        }),
        (u.prototype.onHandshake = function (t) {
          this.emit('handshake', t),
            (this.id = t.sid),
            (this.transport.query.sid = t.sid),
            (this.upgrades = this.filterUpgrades(t.upgrades)),
            (this.pingInterval = t.pingInterval),
            (this.pingTimeout = t.pingTimeout),
            this.onOpen(),
            'closed' !== this.readyState &&
              (this.setPing(),
              this.removeListener('heartbeat', this.onHeartbeat),
              this.on('heartbeat', this.onHeartbeat))
        }),
        (u.prototype.onHeartbeat = function (t) {
          clearTimeout(this.pingTimeoutTimer)
          var e = this
          e.pingTimeoutTimer = setTimeout(function () {
            'closed' !== e.readyState && e.onClose('ping timeout')
          }, t || e.pingInterval + e.pingTimeout)
        }),
        (u.prototype.setPing = function () {
          var t = this
          clearTimeout(t.pingIntervalTimer),
            (t.pingIntervalTimer = setTimeout(function () {
              s(
                'writing ping packet - expecting pong within %sms',
                t.pingTimeout
              ),
                t.ping(),
                t.onHeartbeat(t.pingTimeout)
            }, t.pingInterval))
        }),
        (u.prototype.ping = function () {
          var t = this
          this.sendPacket('ping', function () {
            t.emit('ping')
          })
        }),
        (u.prototype.onDrain = function () {
          this.writeBuffer.splice(0, this.prevBufferLen),
            (this.prevBufferLen = 0),
            0 === this.writeBuffer.length ? this.emit('drain') : this.flush()
        }),
        (u.prototype.flush = function () {
          'closed' !== this.readyState &&
            this.transport.writable &&
            !this.upgrading &&
            this.writeBuffer.length &&
            (s('flushing %d packets in socket', this.writeBuffer.length),
            this.transport.send(this.writeBuffer),
            (this.prevBufferLen = this.writeBuffer.length),
            this.emit('flush'))
        }),
        (u.prototype.write = u.prototype.send = function (t, e, n) {
          return this.sendPacket('message', t, e, n), this
        }),
        (u.prototype.sendPacket = function (t, e, n, i) {
          if (
            ('function' == typeof e && ((i = e), (e = void 0)),
            'function' == typeof n && ((i = n), (n = null)),
            'closing' !== this.readyState && 'closed' !== this.readyState)
          ) {
            ;(n = n || {}).compress = !1 !== n.compress
            var r = { type: t, data: e, options: n }
            this.emit('packetCreate', r),
              this.writeBuffer.push(r),
              i && this.once('flush', i),
              this.flush()
          }
        }),
        (u.prototype.close = function () {
          if ('opening' === this.readyState || 'open' === this.readyState) {
            this.readyState = 'closing'
            var t = this
            this.writeBuffer.length
              ? this.once('drain', function () {
                  this.upgrading ? i() : e()
                })
              : this.upgrading
              ? i()
              : e()
          }
          function e() {
            t.onClose('forced close'),
              s('socket closing - telling transport to close'),
              t.transport.close()
          }
          function n() {
            t.removeListener('upgrade', n),
              t.removeListener('upgradeError', n),
              e()
          }
          function i() {
            t.once('upgrade', n), t.once('upgradeError', n)
          }
          return this
        }),
        (u.prototype.onError = function (t) {
          s('socket error %j', t),
            (u.priorWebsocketSuccess = !1),
            this.emit('error', t),
            this.onClose('transport error', t)
        }),
        (u.prototype.onClose = function (t, e) {
          ;('opening' !== this.readyState &&
            'open' !== this.readyState &&
            'closing' !== this.readyState) ||
            (s('socket close with reason: "%s"', t),
            clearTimeout(this.pingIntervalTimer),
            clearTimeout(this.pingTimeoutTimer),
            this.transport.removeAllListeners('close'),
            this.transport.close(),
            this.transport.removeAllListeners(),
            (this.readyState = 'closed'),
            (this.id = null),
            this.emit('close', t, e),
            (this.writeBuffer = []),
            (this.prevBufferLen = 0))
        }),
        (u.prototype.filterUpgrades = function (t) {
          for (var e = [], n = 0, i = t.length; n < i; n++)
            ~o(this.transports, t[n]) && e.push(t[n])
          return e
        })
    },
    '3N8a': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return s
      })
      var i = n('quSY')
      class r extends i.a {
        constructor(t, e) {
          super()
        }
        schedule(t, e = 0) {
          return this
        }
      }
      class s extends r {
        constructor(t, e) {
          super(t, e),
            (this.scheduler = t),
            (this.work = e),
            (this.pending = !1)
        }
        schedule(t, e = 0) {
          if (this.closed) return this
          this.state = t
          const n = this.id,
            i = this.scheduler
          return (
            null != n && (this.id = this.recycleAsyncId(i, n, e)),
            (this.pending = !0),
            (this.delay = e),
            (this.id = this.id || this.requestAsyncId(i, this.id, e)),
            this
          )
        }
        requestAsyncId(t, e, n = 0) {
          return setInterval(t.flush.bind(t, this), n)
        }
        recycleAsyncId(t, e, n = 0) {
          if (null !== n && this.delay === n && !1 === this.pending) return e
          clearInterval(e)
        }
        execute(t, e) {
          if (this.closed) return new Error('executing a cancelled action')
          this.pending = !1
          const n = this._execute(t, e)
          if (n) return n
          !1 === this.pending &&
            null != this.id &&
            (this.id = this.recycleAsyncId(this.scheduler, this.id, null))
        }
        _execute(t, e) {
          let n = !1,
            i = void 0
          try {
            this.work(t)
          } catch (r) {
            ;(n = !0), (i = (!!r && r) || new Error(r))
          }
          if (n) return this.unsubscribe(), i
        }
        _unsubscribe() {
          const t = this.id,
            e = this.scheduler,
            n = e.actions,
            i = n.indexOf(this)
          ;(this.work = null),
            (this.state = null),
            (this.pending = !1),
            (this.scheduler = null),
            -1 !== i && n.splice(i, 1),
            null != t && (this.id = this.recycleAsyncId(e, t, null)),
            (this.delay = null)
        }
      }
    },
    '3Pt+': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return p
      }),
        n.d(e, 'b', function () {
          return It
        }),
        n.d(e, 'c', function () {
          return xt
        }),
        n.d(e, 'd', function () {
          return Et
        }),
        n.d(e, 'e', function () {
          return Ot
        }),
        n.d(e, 'f', function () {
          return Tt
        }),
        n.d(e, 'g', function () {
          return l
        }),
        n.d(e, 'h', function () {
          return R
        }),
        n.d(e, 'i', function () {
          return L
        }),
        n.d(e, 'j', function () {
          return F
        }),
        n.d(e, 'k', function () {
          return vt
        }),
        n.d(e, 'l', function () {
          return Pt
        }),
        n.d(e, 'm', function () {
          return y
        })
      var i = n('fXoL'),
        r = n('ofXK'),
        s = n('cp0P'),
        o = n('Cfvw'),
        a = n('lJxs')
      const l = new i.q('NgValueAccessor'),
        c = { provide: l, useExisting: Object(i.T)(() => u), multi: !0 }
      let u = (() => {
        class t {
          constructor(t, e) {
            ;(this._renderer = t),
              (this._elementRef = e),
              (this.onChange = (t) => {}),
              (this.onTouched = () => {})
          }
          writeValue(t) {
            this._renderer.setProperty(
              this._elementRef.nativeElement,
              'checked',
              t
            )
          }
          registerOnChange(t) {
            this.onChange = t
          }
          registerOnTouched(t) {
            this.onTouched = t
          }
          setDisabledState(t) {
            this._renderer.setProperty(
              this._elementRef.nativeElement,
              'disabled',
              t
            )
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Lb(i.E), i.Lb(i.l))
          }),
          (t.ɵdir = i.Gb({
            type: t,
            selectors: [
              ['input', 'type', 'checkbox', 'formControlName', ''],
              ['input', 'type', 'checkbox', 'formControl', ''],
              ['input', 'type', 'checkbox', 'ngModel', ''],
            ],
            hostBindings: function (t, e) {
              1 & t &&
                i.Xb('change', function (t) {
                  return e.onChange(t.target.checked)
                })('blur', function () {
                  return e.onTouched()
                })
            },
            features: [i.yb([c])],
          })),
          t
        )
      })()
      const h = { provide: l, useExisting: Object(i.T)(() => p), multi: !0 },
        d = new i.q('CompositionEventMode')
      let p = (() => {
        class t {
          constructor(t, e, n) {
            ;(this._renderer = t),
              (this._elementRef = e),
              (this._compositionMode = n),
              (this.onChange = (t) => {}),
              (this.onTouched = () => {}),
              (this._composing = !1),
              null == this._compositionMode &&
                (this._compositionMode = !(function () {
                  const t = Object(r.u)() ? Object(r.u)().getUserAgent() : ''
                  return /android (\d+)/.test(t.toLowerCase())
                })())
          }
          writeValue(t) {
            this._renderer.setProperty(
              this._elementRef.nativeElement,
              'value',
              null == t ? '' : t
            )
          }
          registerOnChange(t) {
            this.onChange = t
          }
          registerOnTouched(t) {
            this.onTouched = t
          }
          setDisabledState(t) {
            this._renderer.setProperty(
              this._elementRef.nativeElement,
              'disabled',
              t
            )
          }
          _handleInput(t) {
            ;(!this._compositionMode ||
              (this._compositionMode && !this._composing)) &&
              this.onChange(t)
          }
          _compositionStart() {
            this._composing = !0
          }
          _compositionEnd(t) {
            ;(this._composing = !1), this._compositionMode && this.onChange(t)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Lb(i.E), i.Lb(i.l), i.Lb(d, 8))
          }),
          (t.ɵdir = i.Gb({
            type: t,
            selectors: [
              ['input', 'formControlName', '', 3, 'type', 'checkbox'],
              ['textarea', 'formControlName', ''],
              ['input', 'formControl', '', 3, 'type', 'checkbox'],
              ['textarea', 'formControl', ''],
              ['input', 'ngModel', '', 3, 'type', 'checkbox'],
              ['textarea', 'ngModel', ''],
              ['', 'ngDefaultControl', ''],
            ],
            hostBindings: function (t, e) {
              1 & t &&
                i.Xb('input', function (t) {
                  return e._handleInput(t.target.value)
                })('blur', function () {
                  return e.onTouched()
                })('compositionstart', function () {
                  return e._compositionStart()
                })('compositionend', function (t) {
                  return e._compositionEnd(t.target.value)
                })
            },
            features: [i.yb([h])],
          })),
          t
        )
      })()
      function f(t) {
        return null == t || 0 === t.length
      }
      function m(t) {
        return null != t && 'number' == typeof t.length
      }
      const g = new i.q('NgValidators'),
        b = new i.q('NgAsyncValidators'),
        _ = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
      class y {
        static min(t) {
          return (e) => {
            if (f(e.value) || f(t)) return null
            const n = parseFloat(e.value)
            return !isNaN(n) && n < t
              ? { min: { min: t, actual: e.value } }
              : null
          }
        }
        static max(t) {
          return (e) => {
            if (f(e.value) || f(t)) return null
            const n = parseFloat(e.value)
            return !isNaN(n) && n > t
              ? { max: { max: t, actual: e.value } }
              : null
          }
        }
        static required(t) {
          return f(t.value) ? { required: !0 } : null
        }
        static requiredTrue(t) {
          return !0 === t.value ? null : { required: !0 }
        }
        static email(t) {
          return f(t.value) || _.test(t.value) ? null : { email: !0 }
        }
        static minLength(t) {
          return (e) =>
            f(e.value) || !m(e.value)
              ? null
              : e.value.length < t
              ? {
                  minlength: {
                    requiredLength: t,
                    actualLength: e.value.length,
                  },
                }
              : null
        }
        static maxLength(t) {
          return (e) =>
            m(e.value) && e.value.length > t
              ? {
                  maxlength: {
                    requiredLength: t,
                    actualLength: e.value.length,
                  },
                }
              : null
        }
        static pattern(t) {
          if (!t) return y.nullValidator
          let e, n
          return (
            'string' == typeof t
              ? ((n = ''),
                '^' !== t.charAt(0) && (n += '^'),
                (n += t),
                '$' !== t.charAt(t.length - 1) && (n += '$'),
                (e = new RegExp(n)))
              : ((n = t.toString()), (e = t)),
            (t) => {
              if (f(t.value)) return null
              const i = t.value
              return e.test(i)
                ? null
                : { pattern: { requiredPattern: n, actualValue: i } }
            }
          )
        }
        static nullValidator(t) {
          return null
        }
        static compose(t) {
          if (!t) return null
          const e = t.filter(v)
          return 0 == e.length
            ? null
            : function (t) {
                return C(x(t, e))
              }
        }
        static composeAsync(t) {
          if (!t) return null
          const e = t.filter(v)
          return 0 == e.length
            ? null
            : function (t) {
                const n = x(t, e).map(w)
                return Object(s.a)(n).pipe(Object(a.a)(C))
              }
        }
      }
      function v(t) {
        return null != t
      }
      function w(t) {
        const e = Object(i.rb)(t) ? Object(o.a)(t) : t
        return Object(i.qb)(e), e
      }
      function C(t) {
        let e = {}
        return (
          t.forEach((t) => {
            e = null != t ? Object.assign(Object.assign({}, e), t) : e
          }),
          0 === Object.keys(e).length ? null : e
        )
      }
      function x(t, e) {
        return e.map((e) => e(t))
      }
      function S(t) {
        return t.map((t) =>
          (function (t) {
            return !t.validate
          })(t)
            ? t
            : (e) => t.validate(e)
        )
      }
      function O(t) {
        return null != t ? y.compose(S(t)) : null
      }
      function k(t) {
        return null != t ? y.composeAsync(S(t)) : null
      }
      function E(t, e) {
        return null === t ? [e] : Array.isArray(t) ? [...t, e] : [t, e]
      }
      function A(t) {
        return t._rawValidators
      }
      function T(t) {
        return t._rawAsyncValidators
      }
      let j = (() => {
          class t {
            constructor() {
              ;(this._rawValidators = []),
                (this._rawAsyncValidators = []),
                (this._onDestroyCallbacks = [])
            }
            get value() {
              return this.control ? this.control.value : null
            }
            get valid() {
              return this.control ? this.control.valid : null
            }
            get invalid() {
              return this.control ? this.control.invalid : null
            }
            get pending() {
              return this.control ? this.control.pending : null
            }
            get disabled() {
              return this.control ? this.control.disabled : null
            }
            get enabled() {
              return this.control ? this.control.enabled : null
            }
            get errors() {
              return this.control ? this.control.errors : null
            }
            get pristine() {
              return this.control ? this.control.pristine : null
            }
            get dirty() {
              return this.control ? this.control.dirty : null
            }
            get touched() {
              return this.control ? this.control.touched : null
            }
            get status() {
              return this.control ? this.control.status : null
            }
            get untouched() {
              return this.control ? this.control.untouched : null
            }
            get statusChanges() {
              return this.control ? this.control.statusChanges : null
            }
            get valueChanges() {
              return this.control ? this.control.valueChanges : null
            }
            get path() {
              return null
            }
            _setValidators(t) {
              ;(this._rawValidators = t || []),
                (this._composedValidatorFn = O(this._rawValidators))
            }
            _setAsyncValidators(t) {
              ;(this._rawAsyncValidators = t || []),
                (this._composedAsyncValidatorFn = k(this._rawAsyncValidators))
            }
            get validator() {
              return this._composedValidatorFn || null
            }
            get asyncValidator() {
              return this._composedAsyncValidatorFn || null
            }
            _registerOnDestroy(t) {
              this._onDestroyCallbacks.push(t)
            }
            _invokeOnDestroyCallbacks() {
              this._onDestroyCallbacks.forEach((t) => t()),
                (this._onDestroyCallbacks = [])
            }
            reset(t) {
              this.control && this.control.reset(t)
            }
            hasError(t, e) {
              return !!this.control && this.control.hasError(t, e)
            }
            getError(t, e) {
              return this.control ? this.control.getError(t, e) : null
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵdir = i.Gb({ type: t })),
            t
          )
        })(),
        I = (() => {
          class t extends j {
            get formDirective() {
              return null
            }
            get path() {
              return null
            }
          }
          return (
            (t.ɵfac = function (e) {
              return P(e || t)
            }),
            (t.ɵdir = i.Gb({ type: t, features: [i.wb] })),
            t
          )
        })()
      const P = i.Sb(I)
      class R extends j {
        constructor() {
          super(...arguments),
            (this._parent = null),
            (this.name = null),
            (this.valueAccessor = null)
        }
      }
      class D {
        constructor(t) {
          this._cd = t
        }
        get ngClassUntouched() {
          return !!this._cd.control && this._cd.control.untouched
        }
        get ngClassTouched() {
          return !!this._cd.control && this._cd.control.touched
        }
        get ngClassPristine() {
          return !!this._cd.control && this._cd.control.pristine
        }
        get ngClassDirty() {
          return !!this._cd.control && this._cd.control.dirty
        }
        get ngClassValid() {
          return !!this._cd.control && this._cd.control.valid
        }
        get ngClassInvalid() {
          return !!this._cd.control && this._cd.control.invalid
        }
        get ngClassPending() {
          return !!this._cd.control && this._cd.control.pending
        }
      }
      let L = (() => {
          class t extends D {
            constructor(t) {
              super(t)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Lb(R, 2))
            }),
            (t.ɵdir = i.Gb({
              type: t,
              selectors: [
                ['', 'formControlName', ''],
                ['', 'ngModel', ''],
                ['', 'formControl', ''],
              ],
              hostVars: 14,
              hostBindings: function (t, e) {
                2 & t &&
                  i.Db('ng-untouched', e.ngClassUntouched)(
                    'ng-touched',
                    e.ngClassTouched
                  )('ng-pristine', e.ngClassPristine)(
                    'ng-dirty',
                    e.ngClassDirty
                  )('ng-valid', e.ngClassValid)('ng-invalid', e.ngClassInvalid)(
                    'ng-pending',
                    e.ngClassPending
                  )
              },
              features: [i.wb],
            })),
            t
          )
        })(),
        F = (() => {
          class t extends D {
            constructor(t) {
              super(t)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Lb(I, 2))
            }),
            (t.ɵdir = i.Gb({
              type: t,
              selectors: [
                ['', 'formGroupName', ''],
                ['', 'formArrayName', ''],
                ['', 'ngModelGroup', ''],
                ['', 'formGroup', ''],
                ['form', 3, 'ngNoForm', ''],
                ['', 'ngForm', ''],
              ],
              hostVars: 14,
              hostBindings: function (t, e) {
                2 & t &&
                  i.Db('ng-untouched', e.ngClassUntouched)(
                    'ng-touched',
                    e.ngClassTouched
                  )('ng-pristine', e.ngClassPristine)(
                    'ng-dirty',
                    e.ngClassDirty
                  )('ng-valid', e.ngClassValid)('ng-invalid', e.ngClassInvalid)(
                    'ng-pending',
                    e.ngClassPending
                  )
              },
              features: [i.wb],
            })),
            t
          )
        })()
      const N = { provide: l, useExisting: Object(i.T)(() => M), multi: !0 }
      let M = (() => {
        class t {
          constructor(t, e) {
            ;(this._renderer = t),
              (this._elementRef = e),
              (this.onChange = (t) => {}),
              (this.onTouched = () => {})
          }
          writeValue(t) {
            this._renderer.setProperty(
              this._elementRef.nativeElement,
              'value',
              null == t ? '' : t
            )
          }
          registerOnChange(t) {
            this.onChange = (e) => {
              t('' == e ? null : parseFloat(e))
            }
          }
          registerOnTouched(t) {
            this.onTouched = t
          }
          setDisabledState(t) {
            this._renderer.setProperty(
              this._elementRef.nativeElement,
              'disabled',
              t
            )
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Lb(i.E), i.Lb(i.l))
          }),
          (t.ɵdir = i.Gb({
            type: t,
            selectors: [
              ['input', 'type', 'number', 'formControlName', ''],
              ['input', 'type', 'number', 'formControl', ''],
              ['input', 'type', 'number', 'ngModel', ''],
            ],
            hostBindings: function (t, e) {
              1 & t &&
                i.Xb('input', function (t) {
                  return e.onChange(t.target.value)
                })('blur', function () {
                  return e.onTouched()
                })
            },
            features: [i.yb([N])],
          })),
          t
        )
      })()
      const V = { provide: l, useExisting: Object(i.T)(() => B), multi: !0 }
      let U = (() => {
          class t {
            constructor() {
              this._accessors = []
            }
            add(t, e) {
              this._accessors.push([t, e])
            }
            remove(t) {
              for (let e = this._accessors.length - 1; e >= 0; --e)
                if (this._accessors[e][1] === t)
                  return void this._accessors.splice(e, 1)
            }
            select(t) {
              this._accessors.forEach((e) => {
                this._isSameGroup(e, t) &&
                  e[1] !== t &&
                  e[1].fireUncheck(t.value)
              })
            }
            _isSameGroup(t, e) {
              return (
                !!t[0].control &&
                t[0]._parent === e._control._parent &&
                t[1].name === e.name
              )
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵprov = i.Hb({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        B = (() => {
          class t {
            constructor(t, e, n, i) {
              ;(this._renderer = t),
                (this._elementRef = e),
                (this._registry = n),
                (this._injector = i),
                (this.onChange = () => {}),
                (this.onTouched = () => {})
            }
            ngOnInit() {
              ;(this._control = this._injector.get(R)),
                this._checkName(),
                this._registry.add(this._control, this)
            }
            ngOnDestroy() {
              this._registry.remove(this)
            }
            writeValue(t) {
              ;(this._state = t === this.value),
                this._renderer.setProperty(
                  this._elementRef.nativeElement,
                  'checked',
                  this._state
                )
            }
            registerOnChange(t) {
              ;(this._fn = t),
                (this.onChange = () => {
                  t(this.value), this._registry.select(this)
                })
            }
            fireUncheck(t) {
              this.writeValue(t)
            }
            registerOnTouched(t) {
              this.onTouched = t
            }
            setDisabledState(t) {
              this._renderer.setProperty(
                this._elementRef.nativeElement,
                'disabled',
                t
              )
            }
            _checkName() {
              !this.name &&
                this.formControlName &&
                (this.name = this.formControlName)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Lb(i.E), i.Lb(i.l), i.Lb(U), i.Lb(i.r))
            }),
            (t.ɵdir = i.Gb({
              type: t,
              selectors: [
                ['input', 'type', 'radio', 'formControlName', ''],
                ['input', 'type', 'radio', 'formControl', ''],
                ['input', 'type', 'radio', 'ngModel', ''],
              ],
              hostBindings: function (t, e) {
                1 & t &&
                  i.Xb('change', function () {
                    return e.onChange()
                  })('blur', function () {
                    return e.onTouched()
                  })
              },
              inputs: {
                name: 'name',
                formControlName: 'formControlName',
                value: 'value',
              },
              features: [i.yb([V])],
            })),
            t
          )
        })()
      const z = { provide: l, useExisting: Object(i.T)(() => H), multi: !0 }
      let H = (() => {
        class t {
          constructor(t, e) {
            ;(this._renderer = t),
              (this._elementRef = e),
              (this.onChange = (t) => {}),
              (this.onTouched = () => {})
          }
          writeValue(t) {
            this._renderer.setProperty(
              this._elementRef.nativeElement,
              'value',
              parseFloat(t)
            )
          }
          registerOnChange(t) {
            this.onChange = (e) => {
              t('' == e ? null : parseFloat(e))
            }
          }
          registerOnTouched(t) {
            this.onTouched = t
          }
          setDisabledState(t) {
            this._renderer.setProperty(
              this._elementRef.nativeElement,
              'disabled',
              t
            )
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Lb(i.E), i.Lb(i.l))
          }),
          (t.ɵdir = i.Gb({
            type: t,
            selectors: [
              ['input', 'type', 'range', 'formControlName', ''],
              ['input', 'type', 'range', 'formControl', ''],
              ['input', 'type', 'range', 'ngModel', ''],
            ],
            hostBindings: function (t, e) {
              1 & t &&
                i.Xb('change', function (t) {
                  return e.onChange(t.target.value)
                })('input', function (t) {
                  return e.onChange(t.target.value)
                })('blur', function () {
                  return e.onTouched()
                })
            },
            features: [i.yb([z])],
          })),
          t
        )
      })()
      const q = { provide: l, useExisting: Object(i.T)(() => W), multi: !0 }
      let W = (() => {
        class t {
          constructor(t, e) {
            ;(this._renderer = t),
              (this._elementRef = e),
              (this._optionMap = new Map()),
              (this._idCounter = 0),
              (this.onChange = (t) => {}),
              (this.onTouched = () => {}),
              (this._compareWith = Object.is)
          }
          set compareWith(t) {
            this._compareWith = t
          }
          writeValue(t) {
            this.value = t
            const e = this._getOptionId(t)
            null == e &&
              this._renderer.setProperty(
                this._elementRef.nativeElement,
                'selectedIndex',
                -1
              )
            const n = (function (t, e) {
              return null == t
                ? '' + e
                : (e && 'object' == typeof e && (e = 'Object'),
                  `${t}: ${e}`.slice(0, 50))
            })(e, t)
            this._renderer.setProperty(
              this._elementRef.nativeElement,
              'value',
              n
            )
          }
          registerOnChange(t) {
            this.onChange = (e) => {
              ;(this.value = this._getOptionValue(e)), t(this.value)
            }
          }
          registerOnTouched(t) {
            this.onTouched = t
          }
          setDisabledState(t) {
            this._renderer.setProperty(
              this._elementRef.nativeElement,
              'disabled',
              t
            )
          }
          _registerOption() {
            return (this._idCounter++).toString()
          }
          _getOptionId(t) {
            for (const e of Array.from(this._optionMap.keys()))
              if (this._compareWith(this._optionMap.get(e), t)) return e
            return null
          }
          _getOptionValue(t) {
            const e = (function (t) {
              return t.split(':')[0]
            })(t)
            return this._optionMap.has(e) ? this._optionMap.get(e) : t
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Lb(i.E), i.Lb(i.l))
          }),
          (t.ɵdir = i.Gb({
            type: t,
            selectors: [
              ['select', 'formControlName', '', 3, 'multiple', ''],
              ['select', 'formControl', '', 3, 'multiple', ''],
              ['select', 'ngModel', '', 3, 'multiple', ''],
            ],
            hostBindings: function (t, e) {
              1 & t &&
                i.Xb('change', function (t) {
                  return e.onChange(t.target.value)
                })('blur', function () {
                  return e.onTouched()
                })
            },
            inputs: { compareWith: 'compareWith' },
            features: [i.yb([q])],
          })),
          t
        )
      })()
      const $ = { provide: l, useExisting: Object(i.T)(() => G), multi: !0 }
      let G = (() => {
        class t {
          constructor(t, e) {
            ;(this._renderer = t),
              (this._elementRef = e),
              (this._optionMap = new Map()),
              (this._idCounter = 0),
              (this.onChange = (t) => {}),
              (this.onTouched = () => {}),
              (this._compareWith = Object.is)
          }
          set compareWith(t) {
            this._compareWith = t
          }
          writeValue(t) {
            let e
            if (((this.value = t), Array.isArray(t))) {
              const n = t.map((t) => this._getOptionId(t))
              e = (t, e) => {
                t._setSelected(n.indexOf(e.toString()) > -1)
              }
            } else
              e = (t, e) => {
                t._setSelected(!1)
              }
            this._optionMap.forEach(e)
          }
          registerOnChange(t) {
            this.onChange = (e) => {
              const n = []
              if (void 0 !== e.selectedOptions) {
                const t = e.selectedOptions
                for (let e = 0; e < t.length; e++) {
                  const i = t.item(e),
                    r = this._getOptionValue(i.value)
                  n.push(r)
                }
              } else {
                const t = e.options
                for (let e = 0; e < t.length; e++) {
                  const i = t.item(e)
                  if (i.selected) {
                    const t = this._getOptionValue(i.value)
                    n.push(t)
                  }
                }
              }
              ;(this.value = n), t(n)
            }
          }
          registerOnTouched(t) {
            this.onTouched = t
          }
          setDisabledState(t) {
            this._renderer.setProperty(
              this._elementRef.nativeElement,
              'disabled',
              t
            )
          }
          _registerOption(t) {
            const e = (this._idCounter++).toString()
            return this._optionMap.set(e, t), e
          }
          _getOptionId(t) {
            for (const e of Array.from(this._optionMap.keys()))
              if (this._compareWith(this._optionMap.get(e)._value, t)) return e
            return null
          }
          _getOptionValue(t) {
            const e = (function (t) {
              return t.split(':')[0]
            })(t)
            return this._optionMap.has(e) ? this._optionMap.get(e)._value : t
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Lb(i.E), i.Lb(i.l))
          }),
          (t.ɵdir = i.Gb({
            type: t,
            selectors: [
              ['select', 'multiple', '', 'formControlName', ''],
              ['select', 'multiple', '', 'formControl', ''],
              ['select', 'multiple', '', 'ngModel', ''],
            ],
            hostBindings: function (t, e) {
              1 & t &&
                i.Xb('change', function (t) {
                  return e.onChange(t.target)
                })('blur', function () {
                  return e.onTouched()
                })
            },
            inputs: { compareWith: 'compareWith' },
            features: [i.yb([$])],
          })),
          t
        )
      })()
      function Q(t, e) {
        K(t, e, !0),
          e.valueAccessor.writeValue(t.value),
          (function (t, e) {
            e.valueAccessor.registerOnChange((n) => {
              ;(t._pendingValue = n),
                (t._pendingChange = !0),
                (t._pendingDirty = !0),
                'change' === t.updateOn && Z(t, e)
            })
          })(t, e),
          (function (t, e) {
            const n = (t, n) => {
              e.valueAccessor.writeValue(t), n && e.viewToModelUpdate(t)
            }
            t.registerOnChange(n),
              e._registerOnDestroy(() => {
                t._unregisterOnChange(n)
              })
          })(t, e),
          (function (t, e) {
            e.valueAccessor.registerOnTouched(() => {
              ;(t._pendingTouched = !0),
                'blur' === t.updateOn && t._pendingChange && Z(t, e),
                'submit' !== t.updateOn && t.markAsTouched()
            })
          })(t, e),
          (function (t, e) {
            if (e.valueAccessor.setDisabledState) {
              const n = (t) => {
                e.valueAccessor.setDisabledState(t)
              }
              t.registerOnDisabledChange(n),
                e._registerOnDestroy(() => {
                  t._unregisterOnDisabledChange(n)
                })
            }
          })(t, e)
      }
      function X(t, e) {
        t.forEach((t) => {
          t.registerOnValidatorChange && t.registerOnValidatorChange(e)
        })
      }
      function K(t, e, n) {
        const i = A(t)
        null !== e.validator
          ? t.setValidators(E(i, e.validator))
          : 'function' == typeof i && t.setValidators([i])
        const r = T(t)
        if (
          (null !== e.asyncValidator
            ? t.setAsyncValidators(E(r, e.asyncValidator))
            : 'function' == typeof r && t.setAsyncValidators([r]),
          n)
        ) {
          const n = () => t.updateValueAndValidity()
          X(e._rawValidators, n), X(e._rawAsyncValidators, n)
        }
      }
      function Y(t, e, n) {
        if (null !== t) {
          if (null !== e.validator) {
            const n = A(t)
            Array.isArray(n) &&
              n.length > 0 &&
              t.setValidators(n.filter((t) => t !== e.validator))
          }
          if (null !== e.asyncValidator) {
            const n = T(t)
            Array.isArray(n) &&
              n.length > 0 &&
              t.setAsyncValidators(n.filter((t) => t !== e.asyncValidator))
          }
        }
        if (n) {
          const t = () => {}
          X(e._rawValidators, t), X(e._rawAsyncValidators, t)
        }
      }
      function Z(t, e) {
        t._pendingDirty && t.markAsDirty(),
          t.setValue(t._pendingValue, { emitModelToViewChange: !1 }),
          e.viewToModelUpdate(t._pendingValue),
          (t._pendingChange = !1)
      }
      function J(t, e) {
        K(t, e, !1)
      }
      function tt(t, e) {
        if (!t.hasOwnProperty('model')) return !1
        const n = t.model
        return !!n.isFirstChange() || !Object.is(e, n.currentValue)
      }
      const et = [u, H, M, W, G, B]
      function nt(t, e) {
        t._syncPendingControls(),
          e.forEach((t) => {
            const e = t.control
            'submit' === e.updateOn &&
              e._pendingChange &&
              (t.viewToModelUpdate(e._pendingValue), (e._pendingChange = !1))
          })
      }
      function it(t, e) {
        if (!e) return null
        Array.isArray(e)
        let n = void 0,
          i = void 0,
          r = void 0
        return (
          e.forEach((t) => {
            var e
            t.constructor === p
              ? (n = t)
              : ((e = t),
                et.some((t) => e.constructor === t) ? (i = t) : (r = t))
          }),
          r || i || n || null
        )
      }
      function rt(t, e) {
        const n = t.indexOf(e)
        n > -1 && t.splice(n, 1)
      }
      const st = 'VALID',
        ot = 'INVALID',
        at = 'PENDING',
        lt = 'DISABLED'
      function ct(t) {
        return (pt(t) ? t.validators : t) || null
      }
      function ut(t) {
        return Array.isArray(t) ? O(t) : t || null
      }
      function ht(t, e) {
        return (pt(e) ? e.asyncValidators : t) || null
      }
      function dt(t) {
        return Array.isArray(t) ? k(t) : t || null
      }
      function pt(t) {
        return null != t && !Array.isArray(t) && 'object' == typeof t
      }
      class ft {
        constructor(t, e) {
          ;(this._hasOwnPendingAsyncValidator = !1),
            (this._onCollectionChange = () => {}),
            (this._parent = null),
            (this.pristine = !0),
            (this.touched = !1),
            (this._onDisabledChange = []),
            (this._rawValidators = t),
            (this._rawAsyncValidators = e),
            (this._composedValidatorFn = ut(this._rawValidators)),
            (this._composedAsyncValidatorFn = dt(this._rawAsyncValidators))
        }
        get validator() {
          return this._composedValidatorFn
        }
        set validator(t) {
          this._rawValidators = this._composedValidatorFn = t
        }
        get asyncValidator() {
          return this._composedAsyncValidatorFn
        }
        set asyncValidator(t) {
          this._rawAsyncValidators = this._composedAsyncValidatorFn = t
        }
        get parent() {
          return this._parent
        }
        get valid() {
          return this.status === st
        }
        get invalid() {
          return this.status === ot
        }
        get pending() {
          return this.status == at
        }
        get disabled() {
          return this.status === lt
        }
        get enabled() {
          return this.status !== lt
        }
        get dirty() {
          return !this.pristine
        }
        get untouched() {
          return !this.touched
        }
        get updateOn() {
          return this._updateOn
            ? this._updateOn
            : this.parent
            ? this.parent.updateOn
            : 'change'
        }
        setValidators(t) {
          ;(this._rawValidators = t), (this._composedValidatorFn = ut(t))
        }
        setAsyncValidators(t) {
          ;(this._rawAsyncValidators = t),
            (this._composedAsyncValidatorFn = dt(t))
        }
        clearValidators() {
          this.validator = null
        }
        clearAsyncValidators() {
          this.asyncValidator = null
        }
        markAsTouched(t = {}) {
          ;(this.touched = !0),
            this._parent && !t.onlySelf && this._parent.markAsTouched(t)
        }
        markAllAsTouched() {
          this.markAsTouched({ onlySelf: !0 }),
            this._forEachChild((t) => t.markAllAsTouched())
        }
        markAsUntouched(t = {}) {
          ;(this.touched = !1),
            (this._pendingTouched = !1),
            this._forEachChild((t) => {
              t.markAsUntouched({ onlySelf: !0 })
            }),
            this._parent && !t.onlySelf && this._parent._updateTouched(t)
        }
        markAsDirty(t = {}) {
          ;(this.pristine = !1),
            this._parent && !t.onlySelf && this._parent.markAsDirty(t)
        }
        markAsPristine(t = {}) {
          ;(this.pristine = !0),
            (this._pendingDirty = !1),
            this._forEachChild((t) => {
              t.markAsPristine({ onlySelf: !0 })
            }),
            this._parent && !t.onlySelf && this._parent._updatePristine(t)
        }
        markAsPending(t = {}) {
          ;(this.status = at),
            !1 !== t.emitEvent && this.statusChanges.emit(this.status),
            this._parent && !t.onlySelf && this._parent.markAsPending(t)
        }
        disable(t = {}) {
          const e = this._parentMarkedDirty(t.onlySelf)
          ;(this.status = lt),
            (this.errors = null),
            this._forEachChild((e) => {
              e.disable(Object.assign(Object.assign({}, t), { onlySelf: !0 }))
            }),
            this._updateValue(),
            !1 !== t.emitEvent &&
              (this.valueChanges.emit(this.value),
              this.statusChanges.emit(this.status)),
            this._updateAncestors(
              Object.assign(Object.assign({}, t), { skipPristineCheck: e })
            ),
            this._onDisabledChange.forEach((t) => t(!0))
        }
        enable(t = {}) {
          const e = this._parentMarkedDirty(t.onlySelf)
          ;(this.status = st),
            this._forEachChild((e) => {
              e.enable(Object.assign(Object.assign({}, t), { onlySelf: !0 }))
            }),
            this.updateValueAndValidity({
              onlySelf: !0,
              emitEvent: t.emitEvent,
            }),
            this._updateAncestors(
              Object.assign(Object.assign({}, t), { skipPristineCheck: e })
            ),
            this._onDisabledChange.forEach((t) => t(!1))
        }
        _updateAncestors(t) {
          this._parent &&
            !t.onlySelf &&
            (this._parent.updateValueAndValidity(t),
            t.skipPristineCheck || this._parent._updatePristine(),
            this._parent._updateTouched())
        }
        setParent(t) {
          this._parent = t
        }
        updateValueAndValidity(t = {}) {
          this._setInitialStatus(),
            this._updateValue(),
            this.enabled &&
              (this._cancelExistingSubscription(),
              (this.errors = this._runValidator()),
              (this.status = this._calculateStatus()),
              (this.status !== st && this.status !== at) ||
                this._runAsyncValidator(t.emitEvent)),
            !1 !== t.emitEvent &&
              (this.valueChanges.emit(this.value),
              this.statusChanges.emit(this.status)),
            this._parent &&
              !t.onlySelf &&
              this._parent.updateValueAndValidity(t)
        }
        _updateTreeValidity(t = { emitEvent: !0 }) {
          this._forEachChild((e) => e._updateTreeValidity(t)),
            this.updateValueAndValidity({
              onlySelf: !0,
              emitEvent: t.emitEvent,
            })
        }
        _setInitialStatus() {
          this.status = this._allControlsDisabled() ? lt : st
        }
        _runValidator() {
          return this.validator ? this.validator(this) : null
        }
        _runAsyncValidator(t) {
          if (this.asyncValidator) {
            ;(this.status = at), (this._hasOwnPendingAsyncValidator = !0)
            const e = w(this.asyncValidator(this))
            this._asyncValidationSubscription = e.subscribe((e) => {
              ;(this._hasOwnPendingAsyncValidator = !1),
                this.setErrors(e, { emitEvent: t })
            })
          }
        }
        _cancelExistingSubscription() {
          this._asyncValidationSubscription &&
            (this._asyncValidationSubscription.unsubscribe(),
            (this._hasOwnPendingAsyncValidator = !1))
        }
        setErrors(t, e = {}) {
          ;(this.errors = t), this._updateControlsErrors(!1 !== e.emitEvent)
        }
        get(t) {
          return (function (t, e, n) {
            if (null == e) return null
            if (
              (Array.isArray(e) || (e = e.split('.')),
              Array.isArray(e) && 0 === e.length)
            )
              return null
            let i = t
            return (
              e.forEach((t) => {
                i =
                  i instanceof gt
                    ? i.controls.hasOwnProperty(t)
                      ? i.controls[t]
                      : null
                    : (i instanceof bt && i.at(t)) || null
              }),
              i
            )
          })(this, t)
        }
        getError(t, e) {
          const n = e ? this.get(e) : this
          return n && n.errors ? n.errors[t] : null
        }
        hasError(t, e) {
          return !!this.getError(t, e)
        }
        get root() {
          let t = this
          for (; t._parent; ) t = t._parent
          return t
        }
        _updateControlsErrors(t) {
          ;(this.status = this._calculateStatus()),
            t && this.statusChanges.emit(this.status),
            this._parent && this._parent._updateControlsErrors(t)
        }
        _initObservables() {
          ;(this.valueChanges = new i.n()), (this.statusChanges = new i.n())
        }
        _calculateStatus() {
          return this._allControlsDisabled()
            ? lt
            : this.errors
            ? ot
            : this._hasOwnPendingAsyncValidator ||
              this._anyControlsHaveStatus(at)
            ? at
            : this._anyControlsHaveStatus(ot)
            ? ot
            : st
        }
        _anyControlsHaveStatus(t) {
          return this._anyControls((e) => e.status === t)
        }
        _anyControlsDirty() {
          return this._anyControls((t) => t.dirty)
        }
        _anyControlsTouched() {
          return this._anyControls((t) => t.touched)
        }
        _updatePristine(t = {}) {
          ;(this.pristine = !this._anyControlsDirty()),
            this._parent && !t.onlySelf && this._parent._updatePristine(t)
        }
        _updateTouched(t = {}) {
          ;(this.touched = this._anyControlsTouched()),
            this._parent && !t.onlySelf && this._parent._updateTouched(t)
        }
        _isBoxedValue(t) {
          return (
            'object' == typeof t &&
            null !== t &&
            2 === Object.keys(t).length &&
            'value' in t &&
            'disabled' in t
          )
        }
        _registerOnCollectionChange(t) {
          this._onCollectionChange = t
        }
        _setUpdateStrategy(t) {
          pt(t) && null != t.updateOn && (this._updateOn = t.updateOn)
        }
        _parentMarkedDirty(t) {
          return (
            !t &&
            !(!this._parent || !this._parent.dirty) &&
            !this._parent._anyControlsDirty()
          )
        }
      }
      class mt extends ft {
        constructor(t = null, e, n) {
          super(ct(e), ht(n, e)),
            (this._onChange = []),
            this._applyFormState(t),
            this._setUpdateStrategy(e),
            this._initObservables(),
            this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!n })
        }
        setValue(t, e = {}) {
          ;(this.value = this._pendingValue = t),
            this._onChange.length &&
              !1 !== e.emitModelToViewChange &&
              this._onChange.forEach((t) =>
                t(this.value, !1 !== e.emitViewToModelChange)
              ),
            this.updateValueAndValidity(e)
        }
        patchValue(t, e = {}) {
          this.setValue(t, e)
        }
        reset(t = null, e = {}) {
          this._applyFormState(t),
            this.markAsPristine(e),
            this.markAsUntouched(e),
            this.setValue(this.value, e),
            (this._pendingChange = !1)
        }
        _updateValue() {}
        _anyControls(t) {
          return !1
        }
        _allControlsDisabled() {
          return this.disabled
        }
        registerOnChange(t) {
          this._onChange.push(t)
        }
        _unregisterOnChange(t) {
          rt(this._onChange, t)
        }
        registerOnDisabledChange(t) {
          this._onDisabledChange.push(t)
        }
        _unregisterOnDisabledChange(t) {
          rt(this._onDisabledChange, t)
        }
        _forEachChild(t) {}
        _syncPendingControls() {
          return !(
            'submit' !== this.updateOn ||
            (this._pendingDirty && this.markAsDirty(),
            this._pendingTouched && this.markAsTouched(),
            !this._pendingChange) ||
            (this.setValue(this._pendingValue, {
              onlySelf: !0,
              emitModelToViewChange: !1,
            }),
            0)
          )
        }
        _applyFormState(t) {
          this._isBoxedValue(t)
            ? ((this.value = this._pendingValue = t.value),
              t.disabled
                ? this.disable({ onlySelf: !0, emitEvent: !1 })
                : this.enable({ onlySelf: !0, emitEvent: !1 }))
            : (this.value = this._pendingValue = t)
        }
      }
      class gt extends ft {
        constructor(t, e, n) {
          super(ct(e), ht(n, e)),
            (this.controls = t),
            this._initObservables(),
            this._setUpdateStrategy(e),
            this._setUpControls(),
            this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!n })
        }
        registerControl(t, e) {
          return this.controls[t]
            ? this.controls[t]
            : ((this.controls[t] = e),
              e.setParent(this),
              e._registerOnCollectionChange(this._onCollectionChange),
              e)
        }
        addControl(t, e) {
          this.registerControl(t, e),
            this.updateValueAndValidity(),
            this._onCollectionChange()
        }
        removeControl(t) {
          this.controls[t] &&
            this.controls[t]._registerOnCollectionChange(() => {}),
            delete this.controls[t],
            this.updateValueAndValidity(),
            this._onCollectionChange()
        }
        setControl(t, e) {
          this.controls[t] &&
            this.controls[t]._registerOnCollectionChange(() => {}),
            delete this.controls[t],
            e && this.registerControl(t, e),
            this.updateValueAndValidity(),
            this._onCollectionChange()
        }
        contains(t) {
          return this.controls.hasOwnProperty(t) && this.controls[t].enabled
        }
        setValue(t, e = {}) {
          this._checkAllValuesPresent(t),
            Object.keys(t).forEach((n) => {
              this._throwIfControlMissing(n),
                this.controls[n].setValue(t[n], {
                  onlySelf: !0,
                  emitEvent: e.emitEvent,
                })
            }),
            this.updateValueAndValidity(e)
        }
        patchValue(t, e = {}) {
          Object.keys(t).forEach((n) => {
            this.controls[n] &&
              this.controls[n].patchValue(t[n], {
                onlySelf: !0,
                emitEvent: e.emitEvent,
              })
          }),
            this.updateValueAndValidity(e)
        }
        reset(t = {}, e = {}) {
          this._forEachChild((n, i) => {
            n.reset(t[i], { onlySelf: !0, emitEvent: e.emitEvent })
          }),
            this._updatePristine(e),
            this._updateTouched(e),
            this.updateValueAndValidity(e)
        }
        getRawValue() {
          return this._reduceChildren(
            {},
            (t, e, n) => (
              (t[n] = e instanceof mt ? e.value : e.getRawValue()), t
            )
          )
        }
        _syncPendingControls() {
          let t = this._reduceChildren(
            !1,
            (t, e) => !!e._syncPendingControls() || t
          )
          return t && this.updateValueAndValidity({ onlySelf: !0 }), t
        }
        _throwIfControlMissing(t) {
          if (!Object.keys(this.controls).length)
            throw new Error(
              "\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "
            )
          if (!this.controls[t])
            throw new Error(`Cannot find form control with name: ${t}.`)
        }
        _forEachChild(t) {
          Object.keys(this.controls).forEach((e) => t(this.controls[e], e))
        }
        _setUpControls() {
          this._forEachChild((t) => {
            t.setParent(this),
              t._registerOnCollectionChange(this._onCollectionChange)
          })
        }
        _updateValue() {
          this.value = this._reduceValue()
        }
        _anyControls(t) {
          for (const e of Object.keys(this.controls)) {
            const n = this.controls[e]
            if (this.contains(e) && t(n)) return !0
          }
          return !1
        }
        _reduceValue() {
          return this._reduceChildren(
            {},
            (t, e, n) => ((e.enabled || this.disabled) && (t[n] = e.value), t)
          )
        }
        _reduceChildren(t, e) {
          let n = t
          return (
            this._forEachChild((t, i) => {
              n = e(n, t, i)
            }),
            n
          )
        }
        _allControlsDisabled() {
          for (const t of Object.keys(this.controls))
            if (this.controls[t].enabled) return !1
          return Object.keys(this.controls).length > 0 || this.disabled
        }
        _checkAllValuesPresent(t) {
          this._forEachChild((e, n) => {
            if (void 0 === t[n])
              throw new Error(
                `Must supply a value for form control with name: '${n}'.`
              )
          })
        }
      }
      class bt extends ft {
        constructor(t, e, n) {
          super(ct(e), ht(n, e)),
            (this.controls = t),
            this._initObservables(),
            this._setUpdateStrategy(e),
            this._setUpControls(),
            this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!n })
        }
        at(t) {
          return this.controls[t]
        }
        push(t) {
          this.controls.push(t),
            this._registerControl(t),
            this.updateValueAndValidity(),
            this._onCollectionChange()
        }
        insert(t, e) {
          this.controls.splice(t, 0, e),
            this._registerControl(e),
            this.updateValueAndValidity()
        }
        removeAt(t) {
          this.controls[t] &&
            this.controls[t]._registerOnCollectionChange(() => {}),
            this.controls.splice(t, 1),
            this.updateValueAndValidity()
        }
        setControl(t, e) {
          this.controls[t] &&
            this.controls[t]._registerOnCollectionChange(() => {}),
            this.controls.splice(t, 1),
            e && (this.controls.splice(t, 0, e), this._registerControl(e)),
            this.updateValueAndValidity(),
            this._onCollectionChange()
        }
        get length() {
          return this.controls.length
        }
        setValue(t, e = {}) {
          this._checkAllValuesPresent(t),
            t.forEach((t, n) => {
              this._throwIfControlMissing(n),
                this.at(n).setValue(t, { onlySelf: !0, emitEvent: e.emitEvent })
            }),
            this.updateValueAndValidity(e)
        }
        patchValue(t, e = {}) {
          t.forEach((t, n) => {
            this.at(n) &&
              this.at(n).patchValue(t, { onlySelf: !0, emitEvent: e.emitEvent })
          }),
            this.updateValueAndValidity(e)
        }
        reset(t = [], e = {}) {
          this._forEachChild((n, i) => {
            n.reset(t[i], { onlySelf: !0, emitEvent: e.emitEvent })
          }),
            this._updatePristine(e),
            this._updateTouched(e),
            this.updateValueAndValidity(e)
        }
        getRawValue() {
          return this.controls.map((t) =>
            t instanceof mt ? t.value : t.getRawValue()
          )
        }
        clear() {
          this.controls.length < 1 ||
            (this._forEachChild((t) => t._registerOnCollectionChange(() => {})),
            this.controls.splice(0),
            this.updateValueAndValidity())
        }
        _syncPendingControls() {
          let t = this.controls.reduce(
            (t, e) => !!e._syncPendingControls() || t,
            !1
          )
          return t && this.updateValueAndValidity({ onlySelf: !0 }), t
        }
        _throwIfControlMissing(t) {
          if (!this.controls.length)
            throw new Error(
              "\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "
            )
          if (!this.at(t))
            throw new Error('Cannot find form control at index ' + t)
        }
        _forEachChild(t) {
          this.controls.forEach((e, n) => {
            t(e, n)
          })
        }
        _updateValue() {
          this.value = this.controls
            .filter((t) => t.enabled || this.disabled)
            .map((t) => t.value)
        }
        _anyControls(t) {
          return this.controls.some((e) => e.enabled && t(e))
        }
        _setUpControls() {
          this._forEachChild((t) => this._registerControl(t))
        }
        _checkAllValuesPresent(t) {
          this._forEachChild((e, n) => {
            if (void 0 === t[n])
              throw new Error(
                `Must supply a value for form control at index: ${n}.`
              )
          })
        }
        _allControlsDisabled() {
          for (const t of this.controls) if (t.enabled) return !1
          return this.controls.length > 0 || this.disabled
        }
        _registerControl(t) {
          t.setParent(this),
            t._registerOnCollectionChange(this._onCollectionChange)
        }
      }
      const _t = { provide: I, useExisting: Object(i.T)(() => vt) },
        yt = (() => Promise.resolve(null))()
      let vt = (() => {
        class t extends I {
          constructor(t, e) {
            super(),
              (this.submitted = !1),
              (this._directives = []),
              (this.ngSubmit = new i.n()),
              (this.form = new gt({}, O(t), k(e)))
          }
          ngAfterViewInit() {
            this._setUpdateStrategy()
          }
          get formDirective() {
            return this
          }
          get control() {
            return this.form
          }
          get path() {
            return []
          }
          get controls() {
            return this.form.controls
          }
          addControl(t) {
            yt.then(() => {
              const e = this._findContainer(t.path)
              ;(t.control = e.registerControl(t.name, t.control)),
                Q(t.control, t),
                t.control.updateValueAndValidity({ emitEvent: !1 }),
                this._directives.push(t)
            })
          }
          getControl(t) {
            return this.form.get(t.path)
          }
          removeControl(t) {
            yt.then(() => {
              const e = this._findContainer(t.path)
              e && e.removeControl(t.name), rt(this._directives, t)
            })
          }
          addFormGroup(t) {
            yt.then(() => {
              const e = this._findContainer(t.path),
                n = new gt({})
              J(n, t),
                e.registerControl(t.name, n),
                n.updateValueAndValidity({ emitEvent: !1 })
            })
          }
          removeFormGroup(t) {
            yt.then(() => {
              const e = this._findContainer(t.path)
              e && e.removeControl(t.name)
            })
          }
          getFormGroup(t) {
            return this.form.get(t.path)
          }
          updateModel(t, e) {
            yt.then(() => {
              this.form.get(t.path).setValue(e)
            })
          }
          setValue(t) {
            this.control.setValue(t)
          }
          onSubmit(t) {
            return (
              (this.submitted = !0),
              nt(this.form, this._directives),
              this.ngSubmit.emit(t),
              !1
            )
          }
          onReset() {
            this.resetForm()
          }
          resetForm(t) {
            this.form.reset(t), (this.submitted = !1)
          }
          _setUpdateStrategy() {
            this.options &&
              null != this.options.updateOn &&
              (this.form._updateOn = this.options.updateOn)
          }
          _findContainer(t) {
            return t.pop(), t.length ? this.form.get(t) : this.form
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Lb(g, 10), i.Lb(b, 10))
          }),
          (t.ɵdir = i.Gb({
            type: t,
            selectors: [
              ['form', 3, 'ngNoForm', '', 3, 'formGroup', ''],
              ['ng-form'],
              ['', 'ngForm', ''],
            ],
            hostBindings: function (t, e) {
              1 & t &&
                i.Xb('submit', function (t) {
                  return e.onSubmit(t)
                })('reset', function () {
                  return e.onReset()
                })
            },
            inputs: { options: ['ngFormOptions', 'options'] },
            outputs: { ngSubmit: 'ngSubmit' },
            exportAs: ['ngForm'],
            features: [i.yb([_t]), i.wb],
          })),
          t
        )
      })()
      const wt = new i.q('NgModelWithFormControlWarning'),
        Ct = { provide: R, useExisting: Object(i.T)(() => xt) }
      let xt = (() => {
        class t extends R {
          constructor(t, e, n, r) {
            super(),
              (this._ngModelWarningConfig = r),
              (this.update = new i.n()),
              (this._ngModelWarningSent = !1),
              this._setValidators(t),
              this._setAsyncValidators(e),
              (this.valueAccessor = it(0, n))
          }
          set isDisabled(t) {}
          ngOnChanges(t) {
            this._isControlChanged(t) &&
              (Q(this.form, this),
              this.control.disabled &&
                this.valueAccessor.setDisabledState &&
                this.valueAccessor.setDisabledState(!0),
              this.form.updateValueAndValidity({ emitEvent: !1 })),
              tt(t, this.viewModel) &&
                (this.form.setValue(this.model), (this.viewModel = this.model))
          }
          get path() {
            return []
          }
          get control() {
            return this.form
          }
          viewToModelUpdate(t) {
            ;(this.viewModel = t), this.update.emit(t)
          }
          _isControlChanged(t) {
            return t.hasOwnProperty('form')
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(
              i.Lb(g, 10),
              i.Lb(b, 10),
              i.Lb(l, 10),
              i.Lb(wt, 8)
            )
          }),
          (t.ɵdir = i.Gb({
            type: t,
            selectors: [['', 'formControl', '']],
            inputs: {
              isDisabled: ['disabled', 'isDisabled'],
              form: ['formControl', 'form'],
              model: ['ngModel', 'model'],
            },
            outputs: { update: 'ngModelChange' },
            exportAs: ['ngForm'],
            features: [i.yb([Ct]), i.wb, i.xb],
          })),
          (t._ngModelWarningSentOnce = !1),
          t
        )
      })()
      const St = { provide: I, useExisting: Object(i.T)(() => Ot) }
      let Ot = (() => {
        class t extends I {
          constructor(t, e) {
            super(),
              (this.validators = t),
              (this.asyncValidators = e),
              (this.submitted = !1),
              (this.directives = []),
              (this.form = null),
              (this.ngSubmit = new i.n()),
              this._setValidators(t),
              this._setAsyncValidators(e)
          }
          ngOnChanges(t) {
            this._checkFormPresent(),
              t.hasOwnProperty('form') &&
                (this._updateValidators(),
                this._updateDomValue(),
                this._updateRegistrations(),
                (this._oldForm = this.form))
          }
          get formDirective() {
            return this
          }
          get control() {
            return this.form
          }
          get path() {
            return []
          }
          addControl(t) {
            const e = this.form.get(t.path)
            return (
              Q(e, t),
              e.updateValueAndValidity({ emitEvent: !1 }),
              this.directives.push(t),
              e
            )
          }
          getControl(t) {
            return this.form.get(t.path)
          }
          removeControl(t) {
            rt(this.directives, t)
          }
          addFormGroup(t) {
            const e = this.form.get(t.path)
            J(e, t), e.updateValueAndValidity({ emitEvent: !1 })
          }
          removeFormGroup(t) {}
          getFormGroup(t) {
            return this.form.get(t.path)
          }
          addFormArray(t) {
            const e = this.form.get(t.path)
            J(e, t), e.updateValueAndValidity({ emitEvent: !1 })
          }
          removeFormArray(t) {}
          getFormArray(t) {
            return this.form.get(t.path)
          }
          updateModel(t, e) {
            this.form.get(t.path).setValue(e)
          }
          onSubmit(t) {
            return (
              (this.submitted = !0),
              nt(this.form, this.directives),
              this.ngSubmit.emit(t),
              !1
            )
          }
          onReset() {
            this.resetForm()
          }
          resetForm(t) {
            this.form.reset(t), (this.submitted = !1)
          }
          _updateDomValue() {
            this.directives.forEach((t) => {
              const e = this.form.get(t.path)
              t.control !== e &&
                ((function (t, e) {
                  const n = () => {}
                  e.valueAccessor.registerOnChange(n),
                    e.valueAccessor.registerOnTouched(n),
                    Y(t, e, !0),
                    t &&
                      (e._invokeOnDestroyCallbacks(),
                      t._registerOnCollectionChange(() => {}))
                })(t.control || null, t),
                e && Q(e, t),
                (t.control = e))
            }),
              this.form._updateTreeValidity({ emitEvent: !1 })
          }
          _updateRegistrations() {
            this.form._registerOnCollectionChange(() => this._updateDomValue()),
              this._oldForm &&
                this._oldForm._registerOnCollectionChange(() => {})
          }
          _updateValidators() {
            K(this.form, this, !1), this._oldForm && Y(this._oldForm, this, !1)
          }
          _checkFormPresent() {}
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Lb(g, 10), i.Lb(b, 10))
          }),
          (t.ɵdir = i.Gb({
            type: t,
            selectors: [['', 'formGroup', '']],
            hostBindings: function (t, e) {
              1 & t &&
                i.Xb('submit', function (t) {
                  return e.onSubmit(t)
                })('reset', function () {
                  return e.onReset()
                })
            },
            inputs: { form: ['formGroup', 'form'] },
            outputs: { ngSubmit: 'ngSubmit' },
            exportAs: ['ngForm'],
            features: [i.yb([St]), i.wb, i.xb],
          })),
          t
        )
      })()
      const kt = { provide: R, useExisting: Object(i.T)(() => Et) }
      let Et = (() => {
        class t extends R {
          constructor(t, e, n, r, s) {
            super(),
              (this._ngModelWarningConfig = s),
              (this._added = !1),
              (this.update = new i.n()),
              (this._ngModelWarningSent = !1),
              (this._parent = t),
              this._setValidators(e),
              this._setAsyncValidators(n),
              (this.valueAccessor = it(0, r))
          }
          set isDisabled(t) {}
          ngOnChanges(t) {
            this._added || this._setUpControl(),
              tt(t, this.viewModel) &&
                ((this.viewModel = this.model),
                this.formDirective.updateModel(this, this.model))
          }
          ngOnDestroy() {
            this.formDirective && this.formDirective.removeControl(this)
          }
          viewToModelUpdate(t) {
            ;(this.viewModel = t), this.update.emit(t)
          }
          get path() {
            return (
              (t = null == this.name ? this.name : this.name.toString()),
              [...this._parent.path, t]
            )
            var t
          }
          get formDirective() {
            return this._parent ? this._parent.formDirective : null
          }
          _checkParentType() {}
          _setUpControl() {
            this._checkParentType(),
              (this.control = this.formDirective.addControl(this)),
              this.control.disabled &&
                this.valueAccessor.setDisabledState &&
                this.valueAccessor.setDisabledState(!0),
              (this._added = !0)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(
              i.Lb(I, 13),
              i.Lb(g, 10),
              i.Lb(b, 10),
              i.Lb(l, 10),
              i.Lb(wt, 8)
            )
          }),
          (t.ɵdir = i.Gb({
            type: t,
            selectors: [['', 'formControlName', '']],
            inputs: {
              isDisabled: ['disabled', 'isDisabled'],
              name: ['formControlName', 'name'],
              model: ['ngModel', 'model'],
            },
            outputs: { update: 'ngModelChange' },
            features: [i.yb([kt]), i.wb, i.xb],
          })),
          (t._ngModelWarningSentOnce = !1),
          t
        )
      })()
      const At = { provide: g, useExisting: Object(i.T)(() => Tt), multi: !0 }
      let Tt = (() => {
          class t {
            constructor() {
              this._validator = y.nullValidator
            }
            ngOnChanges(t) {
              'maxlength' in t &&
                (this._createValidator(), this._onChange && this._onChange())
            }
            validate(t) {
              return null != this.maxlength ? this._validator(t) : null
            }
            registerOnValidatorChange(t) {
              this._onChange = t
            }
            _createValidator() {
              this._validator = y.maxLength(
                'number' == typeof this.maxlength
                  ? this.maxlength
                  : parseInt(this.maxlength, 10)
              )
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵdir = i.Gb({
              type: t,
              selectors: [
                ['', 'maxlength', '', 'formControlName', ''],
                ['', 'maxlength', '', 'formControl', ''],
                ['', 'maxlength', '', 'ngModel', ''],
              ],
              hostVars: 1,
              hostBindings: function (t, e) {
                2 & t && i.Ab('maxlength', e.maxlength ? e.maxlength : null)
              },
              inputs: { maxlength: 'maxlength' },
              features: [i.yb([At]), i.xb],
            })),
            t
          )
        })(),
        jt = (() => {
          class t {}
          return (
            (t.ɵmod = i.Jb({ type: t })),
            (t.ɵinj = i.Ib({
              factory: function (e) {
                return new (e || t)()
              },
            })),
            t
          )
        })(),
        It = (() => {
          class t {
            group(t, e = null) {
              const n = this._reduceControls(t)
              let i = null,
                r = null,
                s = void 0
              return (
                null != e &&
                  ((function (t) {
                    return (
                      void 0 !== t.asyncValidators ||
                      void 0 !== t.validators ||
                      void 0 !== t.updateOn
                    )
                  })(e)
                    ? ((i = null != e.validators ? e.validators : null),
                      (r =
                        null != e.asyncValidators ? e.asyncValidators : null),
                      (s = null != e.updateOn ? e.updateOn : void 0))
                    : ((i = null != e.validator ? e.validator : null),
                      (r =
                        null != e.asyncValidator ? e.asyncValidator : null))),
                new gt(n, { asyncValidators: r, updateOn: s, validators: i })
              )
            }
            control(t, e, n) {
              return new mt(t, e, n)
            }
            array(t, e, n) {
              const i = t.map((t) => this._createControl(t))
              return new bt(i, e, n)
            }
            _reduceControls(t) {
              const e = {}
              return (
                Object.keys(t).forEach((n) => {
                  e[n] = this._createControl(t[n])
                }),
                e
              )
            }
            _createControl(t) {
              return t instanceof mt || t instanceof gt || t instanceof bt
                ? t
                : Array.isArray(t)
                ? this.control(
                    t[0],
                    t.length > 1 ? t[1] : null,
                    t.length > 2 ? t[2] : null
                  )
                : this.control(t)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵprov = i.Hb({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        Pt = (() => {
          class t {
            static withConfig(e) {
              return {
                ngModule: t,
                providers: [
                  { provide: wt, useValue: e.warnOnNgModelWithFormControl },
                ],
              }
            }
          }
          return (
            (t.ɵmod = i.Jb({ type: t })),
            (t.ɵinj = i.Ib({
              factory: function (e) {
                return new (e || t)()
              },
              providers: [It, U],
              imports: [jt],
            })),
            t
          )
        })()
    },
    '4I5i': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return i
      })
      const i = (() => {
        function t() {
          return (
            Error.call(this),
            (this.message = 'argument out of range'),
            (this.name = 'ArgumentOutOfRangeError'),
            this
          )
        }
        return (t.prototype = Object.create(Error.prototype)), t
      })()
    },
    '5+tZ': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return l
      })
      var i = n('ZUHj'),
        r = n('l7GE'),
        s = n('51Dv'),
        o = n('lJxs'),
        a = n('Cfvw')
      function l(t, e, n = Number.POSITIVE_INFINITY) {
        return 'function' == typeof e
          ? (i) =>
              i.pipe(
                l(
                  (n, i) =>
                    Object(a.a)(t(n, i)).pipe(
                      Object(o.a)((t, r) => e(n, t, i, r))
                    ),
                  n
                )
              )
          : ('number' == typeof e && (n = e), (e) => e.lift(new c(t, n)))
      }
      class c {
        constructor(t, e = Number.POSITIVE_INFINITY) {
          ;(this.project = t), (this.concurrent = e)
        }
        call(t, e) {
          return e.subscribe(new u(t, this.project, this.concurrent))
        }
      }
      class u extends r.a {
        constructor(t, e, n = Number.POSITIVE_INFINITY) {
          super(t),
            (this.project = e),
            (this.concurrent = n),
            (this.hasCompleted = !1),
            (this.buffer = []),
            (this.active = 0),
            (this.index = 0)
        }
        _next(t) {
          this.active < this.concurrent ? this._tryNext(t) : this.buffer.push(t)
        }
        _tryNext(t) {
          let e
          const n = this.index++
          try {
            e = this.project(t, n)
          } catch (i) {
            return void this.destination.error(i)
          }
          this.active++, this._innerSub(e, t, n)
        }
        _innerSub(t, e, n) {
          const r = new s.a(this, e, n),
            o = this.destination
          o.add(r)
          const a = Object(i.a)(this, t, void 0, void 0, r)
          a !== r && o.add(a)
        }
        _complete() {
          ;(this.hasCompleted = !0),
            0 === this.active &&
              0 === this.buffer.length &&
              this.destination.complete(),
            this.unsubscribe()
        }
        notifyNext(t, e, n, i, r) {
          this.destination.next(e)
        }
        notifyComplete(t) {
          const e = this.buffer
          this.remove(t),
            this.active--,
            e.length > 0
              ? this._next(e.shift())
              : 0 === this.active &&
                this.hasCompleted &&
                this.destination.complete()
        }
      }
    },
    '51Dv': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return r
      })
      var i = n('7o/Q')
      class r extends i.a {
        constructor(t, e, n) {
          super(),
            (this.parent = t),
            (this.outerValue = e),
            (this.outerIndex = n),
            (this.index = 0)
        }
        _next(t) {
          this.parent.notifyNext(
            this.outerValue,
            t,
            this.outerIndex,
            this.index++,
            this
          )
        }
        _error(t) {
          this.parent.notifyError(t, this), this.unsubscribe()
        }
        _complete() {
          this.parent.notifyComplete(this), this.unsubscribe()
        }
      }
    },
    '7+OI': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return r
      })
      var i = n('HDdC')
      function r(t) {
        return (
          !!t &&
          (t instanceof i.a ||
            ('function' == typeof t.lift && 'function' == typeof t.subscribe))
        )
      }
    },
    '7jRU': function (t, e) {
      var n = [].indexOf
      t.exports = function (t, e) {
        if (n) return t.indexOf(e)
        for (var i = 0; i < t.length; ++i) if (t[i] === e) return i
        return -1
      }
    },
    '7o/Q': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return c
      })
      var i = n('n6bG'),
        r = n('gRHU'),
        s = n('quSY'),
        o = n('2QA8'),
        a = n('2fFW'),
        l = n('NJ4a')
      class c extends s.a {
        constructor(t, e, n) {
          switch (
            (super(),
            (this.syncErrorValue = null),
            (this.syncErrorThrown = !1),
            (this.syncErrorThrowable = !1),
            (this.isStopped = !1),
            arguments.length)
          ) {
            case 0:
              this.destination = r.a
              break
            case 1:
              if (!t) {
                this.destination = r.a
                break
              }
              if ('object' == typeof t) {
                t instanceof c
                  ? ((this.syncErrorThrowable = t.syncErrorThrowable),
                    (this.destination = t),
                    t.add(this))
                  : ((this.syncErrorThrowable = !0),
                    (this.destination = new u(this, t)))
                break
              }
            default:
              ;(this.syncErrorThrowable = !0),
                (this.destination = new u(this, t, e, n))
          }
        }
        [o.a]() {
          return this
        }
        static create(t, e, n) {
          const i = new c(t, e, n)
          return (i.syncErrorThrowable = !1), i
        }
        next(t) {
          this.isStopped || this._next(t)
        }
        error(t) {
          this.isStopped || ((this.isStopped = !0), this._error(t))
        }
        complete() {
          this.isStopped || ((this.isStopped = !0), this._complete())
        }
        unsubscribe() {
          this.closed || ((this.isStopped = !0), super.unsubscribe())
        }
        _next(t) {
          this.destination.next(t)
        }
        _error(t) {
          this.destination.error(t), this.unsubscribe()
        }
        _complete() {
          this.destination.complete(), this.unsubscribe()
        }
        _unsubscribeAndRecycle() {
          const { _parentOrParents: t } = this
          return (
            (this._parentOrParents = null),
            this.unsubscribe(),
            (this.closed = !1),
            (this.isStopped = !1),
            (this._parentOrParents = t),
            this
          )
        }
      }
      class u extends c {
        constructor(t, e, n, s) {
          let o
          super(), (this._parentSubscriber = t)
          let a = this
          Object(i.a)(e)
            ? (o = e)
            : e &&
              ((o = e.next),
              (n = e.error),
              (s = e.complete),
              e !== r.a &&
                ((a = Object.create(e)),
                Object(i.a)(a.unsubscribe) && this.add(a.unsubscribe.bind(a)),
                (a.unsubscribe = this.unsubscribe.bind(this)))),
            (this._context = a),
            (this._next = o),
            (this._error = n),
            (this._complete = s)
        }
        next(t) {
          if (!this.isStopped && this._next) {
            const { _parentSubscriber: e } = this
            a.a.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable
              ? this.__tryOrSetError(e, this._next, t) && this.unsubscribe()
              : this.__tryOrUnsub(this._next, t)
          }
        }
        error(t) {
          if (!this.isStopped) {
            const { _parentSubscriber: e } = this,
              { useDeprecatedSynchronousErrorHandling: n } = a.a
            if (this._error)
              n && e.syncErrorThrowable
                ? (this.__tryOrSetError(e, this._error, t), this.unsubscribe())
                : (this.__tryOrUnsub(this._error, t), this.unsubscribe())
            else if (e.syncErrorThrowable)
              n
                ? ((e.syncErrorValue = t), (e.syncErrorThrown = !0))
                : Object(l.a)(t),
                this.unsubscribe()
            else {
              if ((this.unsubscribe(), n)) throw t
              Object(l.a)(t)
            }
          }
        }
        complete() {
          if (!this.isStopped) {
            const { _parentSubscriber: t } = this
            if (this._complete) {
              const e = () => this._complete.call(this._context)
              a.a.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable
                ? (this.__tryOrSetError(t, e), this.unsubscribe())
                : (this.__tryOrUnsub(e), this.unsubscribe())
            } else this.unsubscribe()
          }
        }
        __tryOrUnsub(t, e) {
          try {
            t.call(this._context, e)
          } catch (n) {
            if ((this.unsubscribe(), a.a.useDeprecatedSynchronousErrorHandling))
              throw n
            Object(l.a)(n)
          }
        }
        __tryOrSetError(t, e, n) {
          if (!a.a.useDeprecatedSynchronousErrorHandling)
            throw new Error('bad call')
          try {
            e.call(this._context, n)
          } catch (i) {
            return a.a.useDeprecatedSynchronousErrorHandling
              ? ((t.syncErrorValue = i), (t.syncErrorThrown = !0), !0)
              : (Object(l.a)(i), !0)
          }
          return !1
        }
        _unsubscribe() {
          const { _parentSubscriber: t } = this
          ;(this._context = null),
            (this._parentSubscriber = null),
            t.unsubscribe()
        }
      }
    },
    '8LU1': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return o
      }),
        n.d(e, 'b', function () {
          return r
        }),
        n.d(e, 'c', function () {
          return a
        }),
        n.d(e, 'd', function () {
          return l
        }),
        n.d(e, 'e', function () {
          return s
        })
      var i = n('fXoL')
      function r(t) {
        return null != t && '' + t != 'false'
      }
      function s(t, e = 0) {
        return (function (t) {
          return !isNaN(parseFloat(t)) && !isNaN(Number(t))
        })(t)
          ? Number(t)
          : e
      }
      function o(t) {
        return Array.isArray(t) ? t : [t]
      }
      function a(t) {
        return null == t ? '' : 'string' == typeof t ? t : t + 'px'
      }
      function l(t) {
        return t instanceof i.l ? t.nativeElement : t
      }
    },
    '9ppp': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return i
      })
      const i = (() => {
        function t() {
          return (
            Error.call(this),
            (this.message = 'object unsubscribed'),
            (this.name = 'ObjectUnsubscribedError'),
            this
          )
        }
        return (t.prototype = Object.create(Error.prototype)), t
      })()
    },
    AdPF: function (t, e, n) {
      var i = n('yeub'),
        r = n('2UHX')
      t.exports = function (t) {
        var e = t.xdomain,
          n = t.xscheme,
          s = t.enablesXDR
        try {
          if ('undefined' != typeof XMLHttpRequest && (!e || i))
            return new XMLHttpRequest()
        } catch (o) {}
        try {
          if ('undefined' != typeof XDomainRequest && !n && s)
            return new XDomainRequest()
        } catch (o) {}
        if (!e)
          try {
            return new r[['Active'].concat('Object').join('X')](
              'Microsoft.XMLHTTP'
            )
          } catch (o) {}
      }
    },
    Aplp: function (t, e, n) {
      'use strict'
      var i,
        r = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(
          ''
        ),
        s = {},
        o = 0,
        a = 0
      function l(t) {
        var e = ''
        do {
          ;(e = r[t % 64] + e), (t = Math.floor(t / 64))
        } while (t > 0)
        return e
      }
      function c() {
        var t = l(+new Date())
        return t !== i ? ((o = 0), (i = t)) : t + '.' + l(o++)
      }
      for (; a < 64; a++) s[r[a]] = a
      ;(c.encode = l),
        (c.decode = function (t) {
          var e = 0
          for (a = 0; a < t.length; a++) e = 64 * e + s[t.charAt(a)]
          return e
        }),
        (t.exports = c)
    },
    C2QD: function (t, e) {
      function n(t) {
        ;(this.ms = (t = t || {}).min || 100),
          (this.max = t.max || 1e4),
          (this.factor = t.factor || 2),
          (this.jitter = t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0),
          (this.attempts = 0)
      }
      ;(t.exports = n),
        (n.prototype.duration = function () {
          var t = this.ms * Math.pow(this.factor, this.attempts++)
          if (this.jitter) {
            var e = Math.random(),
              n = Math.floor(e * this.jitter * t)
            t = 0 == (1 & Math.floor(10 * e)) ? t - n : t + n
          }
          return 0 | Math.min(t, this.max)
        }),
        (n.prototype.reset = function () {
          this.attempts = 0
        }),
        (n.prototype.setMin = function (t) {
          this.ms = t
        }),
        (n.prototype.setMax = function (t) {
          this.max = t
        }),
        (n.prototype.setJitter = function (t) {
          this.jitter = t
        })
    },
    CIKq: function (t, e, n) {
      var i,
        r,
        s = n('Gbct'),
        o = n('Wm4p'),
        a = n('TypT'),
        l = n('Yvos'),
        c = n('Aplp'),
        u = n('NOtv')('engine.io-client:websocket')
      if (
        ('undefined' != typeof WebSocket
          ? (i = WebSocket)
          : 'undefined' != typeof self &&
            (i = self.WebSocket || self.MozWebSocket),
        'undefined' == typeof window)
      )
        try {
          r = n(1)
        } catch (p) {}
      var h = i || r
      function d(t) {
        t && t.forceBase64 && (this.supportsBinary = !1),
          (this.perMessageDeflate = t.perMessageDeflate),
          (this.usingBrowserWebSocket = i && !t.forceNode),
          (this.protocols = t.protocols),
          this.usingBrowserWebSocket || (h = r),
          s.call(this, t)
      }
      ;(t.exports = d),
        l(d, s),
        (d.prototype.name = 'websocket'),
        (d.prototype.supportsBinary = !0),
        (d.prototype.doOpen = function () {
          if (this.check()) {
            var t = this.uri(),
              e = this.protocols,
              n = {}
            this.isReactNative ||
              ((n.agent = this.agent),
              (n.perMessageDeflate = this.perMessageDeflate),
              (n.pfx = this.pfx),
              (n.key = this.key),
              (n.passphrase = this.passphrase),
              (n.cert = this.cert),
              (n.ca = this.ca),
              (n.ciphers = this.ciphers),
              (n.rejectUnauthorized = this.rejectUnauthorized)),
              this.extraHeaders && (n.headers = this.extraHeaders),
              this.localAddress && (n.localAddress = this.localAddress)
            try {
              this.ws =
                this.usingBrowserWebSocket && !this.isReactNative
                  ? e
                    ? new h(t, e)
                    : new h(t)
                  : new h(t, e, n)
            } catch (i) {
              return this.emit('error', i)
            }
            void 0 === this.ws.binaryType && (this.supportsBinary = !1),
              this.ws.supports && this.ws.supports.binary
                ? ((this.supportsBinary = !0),
                  (this.ws.binaryType = 'nodebuffer'))
                : (this.ws.binaryType = 'arraybuffer'),
              this.addEventListeners()
          }
        }),
        (d.prototype.addEventListeners = function () {
          var t = this
          ;(this.ws.onopen = function () {
            t.onOpen()
          }),
            (this.ws.onclose = function () {
              t.onClose()
            }),
            (this.ws.onmessage = function (e) {
              t.onData(e.data)
            }),
            (this.ws.onerror = function (e) {
              t.onError('websocket error', e)
            })
        }),
        (d.prototype.write = function (t) {
          var e = this
          this.writable = !1
          for (var n = t.length, i = 0, r = n; i < r; i++)
            !(function (t) {
              o.encodePacket(t, e.supportsBinary, function (i) {
                if (!e.usingBrowserWebSocket) {
                  var r = {}
                  t.options && (r.compress = t.options.compress),
                    e.perMessageDeflate &&
                      ('string' == typeof i ? Buffer.byteLength(i) : i.length) <
                        e.perMessageDeflate.threshold &&
                      (r.compress = !1)
                }
                try {
                  e.usingBrowserWebSocket ? e.ws.send(i) : e.ws.send(i, r)
                } catch (p) {
                  u('websocket closed before onclose event')
                }
                --n ||
                  (e.emit('flush'),
                  setTimeout(function () {
                    ;(e.writable = !0), e.emit('drain')
                  }, 0))
              })
            })(t[i])
        }),
        (d.prototype.onClose = function () {
          s.prototype.onClose.call(this)
        }),
        (d.prototype.doClose = function () {
          void 0 !== this.ws && this.ws.close()
        }),
        (d.prototype.uri = function () {
          var t = this.query || {},
            e = this.secure ? 'wss' : 'ws',
            n = ''
          return (
            this.port &&
              (('wss' === e && 443 !== Number(this.port)) ||
                ('ws' === e && 80 !== Number(this.port))) &&
              (n = ':' + this.port),
            this.timestampRequests && (t[this.timestampParam] = c()),
            this.supportsBinary || (t.b64 = 1),
            (t = a.encode(t)).length && (t = '?' + t),
            e +
              '://' +
              (-1 !== this.hostname.indexOf(':')
                ? '[' + this.hostname + ']'
                : this.hostname) +
              n +
              this.path +
              t
          )
        }),
        (d.prototype.check = function () {
          return !(
            !h ||
            ('__initialize' in h && this.name === d.prototype.name)
          )
        })
    },
    CUme: function (t, e, n) {
      var i = n('Gbct'),
        r = n('TypT'),
        s = n('Wm4p'),
        o = n('Yvos'),
        a = n('Aplp'),
        l = n('NOtv')('engine.io-client:polling')
      t.exports = u
      var c = null != new (n('AdPF'))({ xdomain: !1 }).responseType
      function u(t) {
        ;(c && !(t && t.forceBase64)) || (this.supportsBinary = !1),
          i.call(this, t)
      }
      o(u, i),
        (u.prototype.name = 'polling'),
        (u.prototype.doOpen = function () {
          this.poll()
        }),
        (u.prototype.pause = function (t) {
          var e = this
          function n() {
            l('paused'), (e.readyState = 'paused'), t()
          }
          if (((this.readyState = 'pausing'), this.polling || !this.writable)) {
            var i = 0
            this.polling &&
              (l('we are currently polling - waiting to pause'),
              i++,
              this.once('pollComplete', function () {
                l('pre-pause polling complete'), --i || n()
              })),
              this.writable ||
                (l('we are currently writing - waiting to pause'),
                i++,
                this.once('drain', function () {
                  l('pre-pause writing complete'), --i || n()
                }))
          } else n()
        }),
        (u.prototype.poll = function () {
          l('polling'), (this.polling = !0), this.doPoll(), this.emit('poll')
        }),
        (u.prototype.onData = function (t) {
          var e = this
          l('polling got data %s', t),
            s.decodePayload(t, this.socket.binaryType, function (t, n, i) {
              if (
                ('opening' === e.readyState && e.onOpen(), 'close' === t.type)
              )
                return e.onClose(), !1
              e.onPacket(t)
            }),
            'closed' !== this.readyState &&
              ((this.polling = !1),
              this.emit('pollComplete'),
              'open' === this.readyState
                ? this.poll()
                : l('ignoring poll - transport state "%s"', this.readyState))
        }),
        (u.prototype.doClose = function () {
          var t = this
          function e() {
            l('writing close packet'), t.write([{ type: 'close' }])
          }
          'open' === this.readyState
            ? (l('transport open - closing'), e())
            : (l('transport not open - deferring close'), this.once('open', e))
        }),
        (u.prototype.write = function (t) {
          var e = this
          this.writable = !1
          var n = function () {
            ;(e.writable = !0), e.emit('drain')
          }
          s.encodePayload(t, this.supportsBinary, function (t) {
            e.doWrite(t, n)
          })
        }),
        (u.prototype.uri = function () {
          var t = this.query || {},
            e = this.secure ? 'https' : 'http',
            n = ''
          return (
            !1 !== this.timestampRequests && (t[this.timestampParam] = a()),
            this.supportsBinary || t.sid || (t.b64 = 1),
            (t = r.encode(t)),
            this.port &&
              (('https' === e && 443 !== Number(this.port)) ||
                ('http' === e && 80 !== Number(this.port))) &&
              (n = ':' + this.port),
            t.length && (t = '?' + t),
            e +
              '://' +
              (-1 !== this.hostname.indexOf(':')
                ? '[' + this.hostname + ']'
                : this.hostname) +
              n +
              this.path +
              t
          )
        })
    },
    Cfvw: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return h
      })
      var i = n('HDdC'),
        r = n('SeVD'),
        s = n('quSY'),
        o = n('kJWO'),
        a = n('jZKg'),
        l = n('Lhse'),
        c = n('c2HN'),
        u = n('I55L')
      function h(t, e) {
        return e
          ? (function (t, e) {
              if (null != t) {
                if (
                  (function (t) {
                    return t && 'function' == typeof t[o.a]
                  })(t)
                )
                  return (function (t, e) {
                    return new i.a((n) => {
                      const i = new s.a()
                      return (
                        i.add(
                          e.schedule(() => {
                            const r = t[o.a]()
                            i.add(
                              r.subscribe({
                                next(t) {
                                  i.add(e.schedule(() => n.next(t)))
                                },
                                error(t) {
                                  i.add(e.schedule(() => n.error(t)))
                                },
                                complete() {
                                  i.add(e.schedule(() => n.complete()))
                                },
                              })
                            )
                          })
                        ),
                        i
                      )
                    })
                  })(t, e)
                if (Object(c.a)(t))
                  return (function (t, e) {
                    return new i.a((n) => {
                      const i = new s.a()
                      return (
                        i.add(
                          e.schedule(() =>
                            t.then(
                              (t) => {
                                i.add(
                                  e.schedule(() => {
                                    n.next(t),
                                      i.add(e.schedule(() => n.complete()))
                                  })
                                )
                              },
                              (t) => {
                                i.add(e.schedule(() => n.error(t)))
                              }
                            )
                          )
                        ),
                        i
                      )
                    })
                  })(t, e)
                if (Object(u.a)(t)) return Object(a.a)(t, e)
                if (
                  (function (t) {
                    return t && 'function' == typeof t[l.a]
                  })(t) ||
                  'string' == typeof t
                )
                  return (function (t, e) {
                    if (!t) throw new Error('Iterable cannot be null')
                    return new i.a((n) => {
                      const i = new s.a()
                      let r
                      return (
                        i.add(() => {
                          r && 'function' == typeof r.return && r.return()
                        }),
                        i.add(
                          e.schedule(() => {
                            ;(r = t[l.a]()),
                              i.add(
                                e.schedule(function () {
                                  if (n.closed) return
                                  let t, e
                                  try {
                                    const n = r.next()
                                    ;(t = n.value), (e = n.done)
                                  } catch (i) {
                                    return void n.error(i)
                                  }
                                  e
                                    ? n.complete()
                                    : (n.next(t), this.schedule())
                                })
                              )
                          })
                        ),
                        i
                      )
                    })
                  })(t, e)
              }
              throw new TypeError(
                ((null !== t && typeof t) || t) + ' is not observable'
              )
            })(t, e)
          : t instanceof i.a
          ? t
          : new i.a(Object(r.a)(t))
      }
    },
    Cl5A: function (t, e, n) {
      var i = n('CUme'),
        r = n('Yvos'),
        s = n('2UHX')
      t.exports = u
      var o,
        a = /\n/g,
        l = /\\n/g
      function c() {}
      function u(t) {
        i.call(this, t),
          (this.query = this.query || {}),
          o || (o = s.___eio = s.___eio || []),
          (this.index = o.length)
        var e = this
        o.push(function (t) {
          e.onData(t)
        }),
          (this.query.j = this.index),
          'function' == typeof addEventListener &&
            addEventListener(
              'beforeunload',
              function () {
                e.script && (e.script.onerror = c)
              },
              !1
            )
      }
      r(u, i),
        (u.prototype.supportsBinary = !1),
        (u.prototype.doClose = function () {
          this.script &&
            (this.script.parentNode.removeChild(this.script),
            (this.script = null)),
            this.form &&
              (this.form.parentNode.removeChild(this.form),
              (this.form = null),
              (this.iframe = null)),
            i.prototype.doClose.call(this)
        }),
        (u.prototype.doPoll = function () {
          var t = this,
            e = document.createElement('script')
          this.script &&
            (this.script.parentNode.removeChild(this.script),
            (this.script = null)),
            (e.async = !0),
            (e.src = this.uri()),
            (e.onerror = function (e) {
              t.onError('jsonp poll error', e)
            })
          var n = document.getElementsByTagName('script')[0]
          n
            ? n.parentNode.insertBefore(e, n)
            : (document.head || document.body).appendChild(e),
            (this.script = e),
            'undefined' != typeof navigator &&
              /gecko/i.test(navigator.userAgent) &&
              setTimeout(function () {
                var t = document.createElement('iframe')
                document.body.appendChild(t), document.body.removeChild(t)
              }, 100)
        }),
        (u.prototype.doWrite = function (t, e) {
          var n = this
          if (!this.form) {
            var i,
              r = document.createElement('form'),
              s = document.createElement('textarea'),
              o = (this.iframeId = 'eio_iframe_' + this.index)
            ;(r.className = 'socketio'),
              (r.style.position = 'absolute'),
              (r.style.top = '-1000px'),
              (r.style.left = '-1000px'),
              (r.target = o),
              (r.method = 'POST'),
              r.setAttribute('accept-charset', 'utf-8'),
              (s.name = 'd'),
              r.appendChild(s),
              document.body.appendChild(r),
              (this.form = r),
              (this.area = s)
          }
          function c() {
            u(), e()
          }
          function u() {
            if (n.iframe)
              try {
                n.form.removeChild(n.iframe)
              } catch (t) {
                n.onError('jsonp polling iframe removal error', t)
              }
            try {
              i = document.createElement(
                '<iframe src="javascript:0" name="' + n.iframeId + '">'
              )
            } catch (t) {
              ;((i = document.createElement('iframe')).name = n.iframeId),
                (i.src = 'javascript:0')
            }
            ;(i.id = n.iframeId), n.form.appendChild(i), (n.iframe = i)
          }
          ;(this.form.action = this.uri()),
            u(),
            (t = t.replace(l, '\\\n')),
            (this.area.value = t.replace(a, '\\n'))
          try {
            this.form.submit()
          } catch (h) {}
          this.iframe.attachEvent
            ? (this.iframe.onreadystatechange = function () {
                'complete' === n.iframe.readyState && c()
              })
            : (this.iframe.onload = c)
        })
    },
    D0XW: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return r
      })
      var i = n('3N8a')
      const r = new (n('IjjT').a)(i.a)
    },
    DH7j: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return i
      })
      const i = (() =>
        Array.isArray || ((t) => t && 'number' == typeof t.length))()
    },
    EY2u: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return r
      }),
        n.d(e, 'b', function () {
          return s
        })
      var i = n('HDdC')
      const r = new i.a((t) => t.complete())
      function s(t) {
        return t
          ? (function (t) {
              return new i.a((e) => t.schedule(() => e.complete()))
            })(t)
          : r
      }
    },
    F1In: function (t, e) {
      function n(t) {
        return Promise.resolve().then(function () {
          var e = new Error("Cannot find module '" + t + "'")
          throw ((e.code = 'MODULE_NOT_FOUND'), e)
        })
      }
      ;(n.keys = function () {
        return []
      }),
        (n.resolve = n),
        (t.exports = n),
        (n.id = 'F1In')
    },
    FGiv: function (t, e) {
      var n = 1e3,
        i = 60 * n,
        r = 60 * i,
        s = 24 * r
      function o(t, e, n) {
        if (!(t < e))
          return t < 1.5 * e
            ? Math.floor(t / e) + ' ' + n
            : Math.ceil(t / e) + ' ' + n + 's'
      }
      t.exports = function (t, e) {
        e = e || {}
        var a,
          l = typeof t
        if ('string' === l && t.length > 0)
          return (function (t) {
            if (!((t = String(t)).length > 100)) {
              var e = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
                t
              )
              if (e) {
                var o = parseFloat(e[1])
                switch ((e[2] || 'ms').toLowerCase()) {
                  case 'years':
                  case 'year':
                  case 'yrs':
                  case 'yr':
                  case 'y':
                    return 315576e5 * o
                  case 'days':
                  case 'day':
                  case 'd':
                    return o * s
                  case 'hours':
                  case 'hour':
                  case 'hrs':
                  case 'hr':
                  case 'h':
                    return o * r
                  case 'minutes':
                  case 'minute':
                  case 'mins':
                  case 'min':
                  case 'm':
                    return o * i
                  case 'seconds':
                  case 'second':
                  case 'secs':
                  case 'sec':
                  case 's':
                    return o * n
                  case 'milliseconds':
                  case 'millisecond':
                  case 'msecs':
                  case 'msec':
                  case 'ms':
                    return o
                  default:
                    return
                }
              }
            }
          })(t)
        if ('number' === l && !1 === isNaN(t))
          return e.long
            ? o((a = t), s, 'day') ||
                o(a, r, 'hour') ||
                o(a, i, 'minute') ||
                o(a, n, 'second') ||
                a + ' ms'
            : (function (t) {
                return t >= s
                  ? Math.round(t / s) + 'd'
                  : t >= r
                  ? Math.round(t / r) + 'h'
                  : t >= i
                  ? Math.round(t / i) + 'm'
                  : t >= n
                  ? Math.round(t / n) + 's'
                  : t + 'ms'
              })(t)
        throw new Error(
          'val is not a non-empty string or a valid number. val=' +
            JSON.stringify(t)
        )
      }
    },
    FKr1: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return O
      }),
        n.d(e, 'b', function () {
          return $
        }),
        n.d(e, 'c', function () {
          return X
        }),
        n.d(e, 'd', function () {
          return y
        }),
        n.d(e, 'e', function () {
          return k
        }),
        n.d(e, 'f', function () {
          return T
        }),
        n.d(e, 'g', function () {
          return Y
        }),
        n.d(e, 'h', function () {
          return tt
        }),
        n.d(e, 'i', function () {
          return V
        }),
        n.d(e, 'j', function () {
          return U
        }),
        n.d(e, 'k', function () {
          return N
        }),
        n.d(e, 'l', function () {
          return M
        }),
        n.d(e, 'm', function () {
          return Z
        }),
        n.d(e, 'n', function () {
          return J
        }),
        n.d(e, 'o', function () {
          return w
        }),
        n.d(e, 'p', function () {
          return C
        }),
        n.d(e, 'q', function () {
          return v
        }),
        n.d(e, 'r', function () {
          return S
        }),
        n.d(e, 's', function () {
          return x
        }),
        n.d(e, 't', function () {
          return E
        })
      var i = n('fXoL'),
        r = n('u47x'),
        s = n('cH1L')
      const o = new i.O('11.0.3')
      var a = n('ofXK'),
        l = n('8LU1'),
        c = n('XNiG'),
        u = (n('HDdC'), n('nLfN')),
        h = n('JX91'),
        d = n('R1ws'),
        p = n('FtGj')
      function f(t, e) {
        if ((1 & t && i.Mb(0, 'mat-pseudo-checkbox', 3), 2 & t)) {
          const t = i.bc()
          i.gc('state', t.selected ? 'checked' : 'unchecked')(
            'disabled',
            t.disabled
          )
        }
      }
      const m = ['*'],
        g = new i.O('11.0.3'),
        b = new i.q('mat-sanity-checks', {
          providedIn: 'root',
          factory: function () {
            return !0
          },
        })
      let _,
        y = (() => {
          class t {
            constructor(t, e, n) {
              ;(this._hasDoneGlobalChecks = !1),
                (this._document = n),
                t._applyBodyHighContrastModeCssClasses(),
                (this._sanityChecks = e),
                this._hasDoneGlobalChecks ||
                  (this._checkDoctypeIsDefined(),
                  this._checkThemeIsPresent(),
                  this._checkCdkVersionMatch(),
                  (this._hasDoneGlobalChecks = !0))
            }
            _getWindow() {
              const t = this._document.defaultView || window
              return 'object' == typeof t && t ? t : null
            }
            _checksAreEnabled() {
              return Object(i.V)() && !this._isTestEnv()
            }
            _isTestEnv() {
              const t = this._getWindow()
              return t && (t.__karma__ || t.jasmine)
            }
            _checkDoctypeIsDefined() {
              this._checksAreEnabled() &&
                (!0 === this._sanityChecks || this._sanityChecks.doctype) &&
                !this._document.doctype &&
                console.warn(
                  'Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.'
                )
            }
            _checkThemeIsPresent() {
              if (
                !this._checksAreEnabled() ||
                !1 === this._sanityChecks ||
                !this._sanityChecks.theme ||
                !this._document.body ||
                'function' != typeof getComputedStyle
              )
                return
              const t = this._document.createElement('div')
              t.classList.add('mat-theme-loaded-marker'),
                this._document.body.appendChild(t)
              const e = getComputedStyle(t)
              e &&
                'none' !== e.display &&
                console.warn(
                  'Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming'
                ),
                this._document.body.removeChild(t)
            }
            _checkCdkVersionMatch() {
              this._checksAreEnabled() &&
                (!0 === this._sanityChecks || this._sanityChecks.version) &&
                g.full !== o.full &&
                console.warn(
                  'The Angular Material version (' +
                    g.full +
                    ') does not match the Angular CDK version (' +
                    o.full +
                    ').\nPlease ensure the versions of these two packages exactly match.'
                )
            }
          }
          return (
            (t.ɵmod = i.Jb({ type: t })),
            (t.ɵinj = i.Ib({
              factory: function (e) {
                return new (e || t)(i.Ub(r.g), i.Ub(b, 8), i.Ub(a.d))
              },
              imports: [[s.a], s.a],
            })),
            t
          )
        })()
      function v(t) {
        return class extends t {
          constructor(...t) {
            super(...t), (this._disabled = !1)
          }
          get disabled() {
            return this._disabled
          }
          set disabled(t) {
            this._disabled = Object(l.b)(t)
          }
        }
      }
      function w(t, e) {
        return class extends t {
          constructor(...t) {
            super(...t), (this.defaultColor = e), (this.color = e)
          }
          get color() {
            return this._color
          }
          set color(t) {
            const e = t || this.defaultColor
            e !== this._color &&
              (this._color &&
                this._elementRef.nativeElement.classList.remove(
                  'mat-' + this._color
                ),
              e && this._elementRef.nativeElement.classList.add('mat-' + e),
              (this._color = e))
          }
        }
      }
      function C(t) {
        return class extends t {
          constructor(...t) {
            super(...t), (this._disableRipple = !1)
          }
          get disableRipple() {
            return this._disableRipple
          }
          set disableRipple(t) {
            this._disableRipple = Object(l.b)(t)
          }
        }
      }
      function x(t, e = 0) {
        return class extends t {
          constructor(...t) {
            super(...t), (this._tabIndex = e), (this.defaultTabIndex = e)
          }
          get tabIndex() {
            return this.disabled ? -1 : this._tabIndex
          }
          set tabIndex(t) {
            this._tabIndex = null != t ? Object(l.e)(t) : this.defaultTabIndex
          }
        }
      }
      function S(t) {
        return class extends t {
          constructor(...t) {
            super(...t), (this.errorState = !1), (this.stateChanges = new c.a())
          }
          updateErrorState() {
            const t = this.errorState,
              e = (
                this.errorStateMatcher || this._defaultErrorStateMatcher
              ).isErrorState(
                this.ngControl ? this.ngControl.control : null,
                this._parentFormGroup || this._parentForm
              )
            e !== t && ((this.errorState = e), this.stateChanges.next())
          }
        }
      }
      try {
        _ = 'undefined' != typeof Intl
      } catch (et) {
        _ = !1
      }
      let O = (() => {
          class t {
            isErrorState(t, e) {
              return !!(t && t.invalid && (t.touched || (e && e.submitted)))
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵprov = Object(i.Hb)({
              factory: function () {
                return new t()
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        k = (() => {
          class t {}
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵdir = i.Gb({
              type: t,
              selectors: [
                ['', 'mat-line', ''],
                ['', 'matLine', ''],
              ],
              hostAttrs: [1, 'mat-line'],
            })),
            t
          )
        })()
      function E(t, e, n = 'mat') {
        t.changes.pipe(Object(h.a)(t)).subscribe(({ length: t }) => {
          A(e, n + '-2-line', !1),
            A(e, n + '-3-line', !1),
            A(e, n + '-multi-line', !1),
            2 === t || 3 === t
              ? A(e, `${n}-${t}-line`, !0)
              : t > 3 && A(e, n + '-multi-line', !0)
        })
      }
      function A(t, e, n) {
        const i = t.nativeElement.classList
        n ? i.add(e) : i.remove(e)
      }
      let T = (() => {
        class t {}
        return (
          (t.ɵmod = i.Jb({ type: t })),
          (t.ɵinj = i.Ib({
            factory: function (e) {
              return new (e || t)()
            },
            imports: [[y], y],
          })),
          t
        )
      })()
      class j {
        constructor(t, e, n) {
          ;(this._renderer = t),
            (this.element = e),
            (this.config = n),
            (this.state = 3)
        }
        fadeOut() {
          this._renderer.fadeOutRipple(this)
        }
      }
      const I = { enterDuration: 450, exitDuration: 400 },
        P = Object(u.e)({ passive: !0 }),
        R = ['mousedown', 'touchstart'],
        D = ['mouseup', 'mouseleave', 'touchend', 'touchcancel']
      class L {
        constructor(t, e, n, i) {
          ;(this._target = t),
            (this._ngZone = e),
            (this._isPointerDown = !1),
            (this._activeRipples = new Set()),
            (this._pointerUpEventsRegistered = !1),
            i.isBrowser && (this._containerElement = Object(l.d)(n))
        }
        fadeInRipple(t, e, n = {}) {
          const i = (this._containerRect =
              this._containerRect ||
              this._containerElement.getBoundingClientRect()),
            r = Object.assign(Object.assign({}, I), n.animation)
          n.centered && ((t = i.left + i.width / 2), (e = i.top + i.height / 2))
          const s =
              n.radius ||
              (function (t, e, n) {
                const i = Math.max(Math.abs(t - n.left), Math.abs(t - n.right)),
                  r = Math.max(Math.abs(e - n.top), Math.abs(e - n.bottom))
                return Math.sqrt(i * i + r * r)
              })(t, e, i),
            o = t - i.left,
            a = e - i.top,
            l = r.enterDuration,
            c = document.createElement('div')
          c.classList.add('mat-ripple-element'),
            (c.style.left = o - s + 'px'),
            (c.style.top = a - s + 'px'),
            (c.style.height = 2 * s + 'px'),
            (c.style.width = 2 * s + 'px'),
            null != n.color && (c.style.backgroundColor = n.color),
            (c.style.transitionDuration = l + 'ms'),
            this._containerElement.appendChild(c),
            window.getComputedStyle(c).getPropertyValue('opacity'),
            (c.style.transform = 'scale(1)')
          const u = new j(this, c, n)
          return (
            (u.state = 0),
            this._activeRipples.add(u),
            n.persistent || (this._mostRecentTransientRipple = u),
            this._runTimeoutOutsideZone(() => {
              const t = u === this._mostRecentTransientRipple
              ;(u.state = 1),
                n.persistent || (t && this._isPointerDown) || u.fadeOut()
            }, l),
            u
          )
        }
        fadeOutRipple(t) {
          const e = this._activeRipples.delete(t)
          if (
            (t === this._mostRecentTransientRipple &&
              (this._mostRecentTransientRipple = null),
            this._activeRipples.size || (this._containerRect = null),
            !e)
          )
            return
          const n = t.element,
            i = Object.assign(Object.assign({}, I), t.config.animation)
          ;(n.style.transitionDuration = i.exitDuration + 'ms'),
            (n.style.opacity = '0'),
            (t.state = 2),
            this._runTimeoutOutsideZone(() => {
              ;(t.state = 3), n.parentNode.removeChild(n)
            }, i.exitDuration)
        }
        fadeOutAll() {
          this._activeRipples.forEach((t) => t.fadeOut())
        }
        setupTriggerEvents(t) {
          const e = Object(l.d)(t)
          e &&
            e !== this._triggerElement &&
            (this._removeTriggerEvents(),
            (this._triggerElement = e),
            this._registerEvents(R))
        }
        handleEvent(t) {
          'mousedown' === t.type
            ? this._onMousedown(t)
            : 'touchstart' === t.type
            ? this._onTouchStart(t)
            : this._onPointerUp(),
            this._pointerUpEventsRegistered ||
              (this._registerEvents(D), (this._pointerUpEventsRegistered = !0))
        }
        _onMousedown(t) {
          const e = Object(r.i)(t),
            n =
              this._lastTouchStartEvent &&
              Date.now() < this._lastTouchStartEvent + 800
          this._target.rippleDisabled ||
            e ||
            n ||
            ((this._isPointerDown = !0),
            this.fadeInRipple(t.clientX, t.clientY, this._target.rippleConfig))
        }
        _onTouchStart(t) {
          if (!this._target.rippleDisabled) {
            ;(this._lastTouchStartEvent = Date.now()),
              (this._isPointerDown = !0)
            const e = t.changedTouches
            for (let t = 0; t < e.length; t++)
              this.fadeInRipple(
                e[t].clientX,
                e[t].clientY,
                this._target.rippleConfig
              )
          }
        }
        _onPointerUp() {
          this._isPointerDown &&
            ((this._isPointerDown = !1),
            this._activeRipples.forEach((t) => {
              !t.config.persistent &&
                (1 === t.state ||
                  (t.config.terminateOnPointerUp && 0 === t.state)) &&
                t.fadeOut()
            }))
        }
        _runTimeoutOutsideZone(t, e = 0) {
          this._ngZone.runOutsideAngular(() => setTimeout(t, e))
        }
        _registerEvents(t) {
          this._ngZone.runOutsideAngular(() => {
            t.forEach((t) => {
              this._triggerElement.addEventListener(t, this, P)
            })
          })
        }
        _removeTriggerEvents() {
          this._triggerElement &&
            (R.forEach((t) => {
              this._triggerElement.removeEventListener(t, this, P)
            }),
            this._pointerUpEventsRegistered &&
              D.forEach((t) => {
                this._triggerElement.removeEventListener(t, this, P)
              }))
        }
      }
      const F = new i.q('mat-ripple-global-options')
      let N = (() => {
          class t {
            constructor(t, e, n, i, r) {
              ;(this._elementRef = t),
                (this._animationMode = r),
                (this.radius = 0),
                (this._disabled = !1),
                (this._isInitialized = !1),
                (this._globalOptions = i || {}),
                (this._rippleRenderer = new L(this, e, t, n))
            }
            get disabled() {
              return this._disabled
            }
            set disabled(t) {
              ;(this._disabled = t), this._setupTriggerEventsIfEnabled()
            }
            get trigger() {
              return this._trigger || this._elementRef.nativeElement
            }
            set trigger(t) {
              ;(this._trigger = t), this._setupTriggerEventsIfEnabled()
            }
            ngOnInit() {
              ;(this._isInitialized = !0), this._setupTriggerEventsIfEnabled()
            }
            ngOnDestroy() {
              this._rippleRenderer._removeTriggerEvents()
            }
            fadeOutAll() {
              this._rippleRenderer.fadeOutAll()
            }
            get rippleConfig() {
              return {
                centered: this.centered,
                radius: this.radius,
                color: this.color,
                animation: Object.assign(
                  Object.assign(
                    Object.assign({}, this._globalOptions.animation),
                    'NoopAnimations' === this._animationMode
                      ? { enterDuration: 0, exitDuration: 0 }
                      : {}
                  ),
                  this.animation
                ),
                terminateOnPointerUp: this._globalOptions.terminateOnPointerUp,
              }
            }
            get rippleDisabled() {
              return this.disabled || !!this._globalOptions.disabled
            }
            _setupTriggerEventsIfEnabled() {
              !this.disabled &&
                this._isInitialized &&
                this._rippleRenderer.setupTriggerEvents(this.trigger)
            }
            launch(t, e = 0, n) {
              return 'number' == typeof t
                ? this._rippleRenderer.fadeInRipple(
                    t,
                    e,
                    Object.assign(Object.assign({}, this.rippleConfig), n)
                  )
                : this._rippleRenderer.fadeInRipple(
                    0,
                    0,
                    Object.assign(Object.assign({}, this.rippleConfig), t)
                  )
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                i.Lb(i.l),
                i.Lb(i.z),
                i.Lb(u.a),
                i.Lb(F, 8),
                i.Lb(d.a, 8)
              )
            }),
            (t.ɵdir = i.Gb({
              type: t,
              selectors: [
                ['', 'mat-ripple', ''],
                ['', 'matRipple', ''],
              ],
              hostAttrs: [1, 'mat-ripple'],
              hostVars: 2,
              hostBindings: function (t, e) {
                2 & t && i.Db('mat-ripple-unbounded', e.unbounded)
              },
              inputs: {
                radius: ['matRippleRadius', 'radius'],
                disabled: ['matRippleDisabled', 'disabled'],
                trigger: ['matRippleTrigger', 'trigger'],
                color: ['matRippleColor', 'color'],
                unbounded: ['matRippleUnbounded', 'unbounded'],
                centered: ['matRippleCentered', 'centered'],
                animation: ['matRippleAnimation', 'animation'],
              },
              exportAs: ['matRipple'],
            })),
            t
          )
        })(),
        M = (() => {
          class t {}
          return (
            (t.ɵmod = i.Jb({ type: t })),
            (t.ɵinj = i.Ib({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[y, u.b], y],
            })),
            t
          )
        })(),
        V = (() => {
          class t {
            constructor(t) {
              ;(this._animationMode = t),
                (this.state = 'unchecked'),
                (this.disabled = !1)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Lb(d.a, 8))
            }),
            (t.ɵcmp = i.Fb({
              type: t,
              selectors: [['mat-pseudo-checkbox']],
              hostAttrs: [1, 'mat-pseudo-checkbox'],
              hostVars: 8,
              hostBindings: function (t, e) {
                2 & t &&
                  i.Db(
                    'mat-pseudo-checkbox-indeterminate',
                    'indeterminate' === e.state
                  )('mat-pseudo-checkbox-checked', 'checked' === e.state)(
                    'mat-pseudo-checkbox-disabled',
                    e.disabled
                  )(
                    '_mat-animation-noopable',
                    'NoopAnimations' === e._animationMode
                  )
              },
              inputs: { state: 'state', disabled: 'disabled' },
              decls: 0,
              vars: 0,
              template: function (t, e) {},
              styles: [
                '.mat-pseudo-checkbox{width:16px;height:16px;border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:"";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox.mat-pseudo-checkbox-indeterminate{border-color:transparent}._mat-animation-noopable.mat-pseudo-checkbox{transition:none;animation:none}._mat-animation-noopable.mat-pseudo-checkbox::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{top:5px;left:1px;width:10px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{top:2.4px;left:1px;width:8px;height:3px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}\n',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        U = (() => {
          class t {}
          return (
            (t.ɵmod = i.Jb({ type: t })),
            (t.ɵinj = i.Ib({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[y]],
            })),
            t
          )
        })()
      class B {}
      const z = v(B)
      let H = 0,
        q = (() => {
          class t extends z {
            constructor() {
              super(...arguments), (this._labelId = 'mat-optgroup-label-' + H++)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return W(e || t)
            }),
            (t.ɵdir = i.Gb({
              type: t,
              inputs: { label: 'label' },
              features: [i.wb],
            })),
            t
          )
        })()
      const W = i.Sb(q),
        $ = new i.q('MatOptgroup')
      let G = 0
      class Q {
        constructor(t, e = !1) {
          ;(this.source = t), (this.isUserInput = e)
        }
      }
      const X = new i.q('MAT_OPTION_PARENT_COMPONENT')
      let K = (() => {
          class t {
            constructor(t, e, n, r) {
              ;(this._element = t),
                (this._changeDetectorRef = e),
                (this._parent = n),
                (this.group = r),
                (this._selected = !1),
                (this._active = !1),
                (this._disabled = !1),
                (this._mostRecentViewValue = ''),
                (this.id = 'mat-option-' + G++),
                (this.onSelectionChange = new i.n()),
                (this._stateChanges = new c.a())
            }
            get multiple() {
              return this._parent && this._parent.multiple
            }
            get selected() {
              return this._selected
            }
            get disabled() {
              return (this.group && this.group.disabled) || this._disabled
            }
            set disabled(t) {
              this._disabled = Object(l.b)(t)
            }
            get disableRipple() {
              return this._parent && this._parent.disableRipple
            }
            get active() {
              return this._active
            }
            get viewValue() {
              return (this._getHostElement().textContent || '').trim()
            }
            select() {
              this._selected ||
                ((this._selected = !0),
                this._changeDetectorRef.markForCheck(),
                this._emitSelectionChangeEvent())
            }
            deselect() {
              this._selected &&
                ((this._selected = !1),
                this._changeDetectorRef.markForCheck(),
                this._emitSelectionChangeEvent())
            }
            focus(t, e) {
              const n = this._getHostElement()
              'function' == typeof n.focus && n.focus(e)
            }
            setActiveStyles() {
              this._active ||
                ((this._active = !0), this._changeDetectorRef.markForCheck())
            }
            setInactiveStyles() {
              this._active &&
                ((this._active = !1), this._changeDetectorRef.markForCheck())
            }
            getLabel() {
              return this.viewValue
            }
            _handleKeydown(t) {
              ;(t.keyCode !== p.d && t.keyCode !== p.j) ||
                Object(p.o)(t) ||
                (this._selectViaInteraction(), t.preventDefault())
            }
            _selectViaInteraction() {
              this.disabled ||
                ((this._selected = !this.multiple || !this._selected),
                this._changeDetectorRef.markForCheck(),
                this._emitSelectionChangeEvent(!0))
            }
            _getAriaSelected() {
              return this.selected || (!this.multiple && null)
            }
            _getTabIndex() {
              return this.disabled ? '-1' : '0'
            }
            _getHostElement() {
              return this._element.nativeElement
            }
            ngAfterViewChecked() {
              if (this._selected) {
                const t = this.viewValue
                t !== this._mostRecentViewValue &&
                  ((this._mostRecentViewValue = t), this._stateChanges.next())
              }
            }
            ngOnDestroy() {
              this._stateChanges.complete()
            }
            _emitSelectionChangeEvent(t = !1) {
              this.onSelectionChange.emit(new Q(this, t))
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Lb(i.l), i.Lb(i.h), i.Lb(void 0), i.Lb(q))
            }),
            (t.ɵdir = i.Gb({
              type: t,
              inputs: { id: 'id', disabled: 'disabled', value: 'value' },
              outputs: { onSelectionChange: 'onSelectionChange' },
            })),
            t
          )
        })(),
        Y = (() => {
          class t extends K {
            constructor(t, e, n, i) {
              super(t, e, n, i)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Lb(i.l), i.Lb(i.h), i.Lb(X, 8), i.Lb($, 8))
            }),
            (t.ɵcmp = i.Fb({
              type: t,
              selectors: [['mat-option']],
              hostAttrs: [
                'role',
                'option',
                1,
                'mat-option',
                'mat-focus-indicator',
              ],
              hostVars: 12,
              hostBindings: function (t, e) {
                1 & t &&
                  i.Xb('click', function () {
                    return e._selectViaInteraction()
                  })('keydown', function (t) {
                    return e._handleKeydown(t)
                  }),
                  2 & t &&
                    (i.Tb('id', e.id),
                    i.Ab('tabindex', e._getTabIndex())(
                      'aria-selected',
                      e._getAriaSelected()
                    )('aria-disabled', e.disabled.toString()),
                    i.Db('mat-selected', e.selected)(
                      'mat-option-multiple',
                      e.multiple
                    )('mat-active', e.active)(
                      'mat-option-disabled',
                      e.disabled
                    ))
              },
              exportAs: ['matOption'],
              features: [i.wb],
              ngContentSelectors: m,
              decls: 4,
              vars: 3,
              consts: [
                [
                  'class',
                  'mat-option-pseudo-checkbox',
                  3,
                  'state',
                  'disabled',
                  4,
                  'ngIf',
                ],
                [1, 'mat-option-text'],
                [
                  'mat-ripple',
                  '',
                  1,
                  'mat-option-ripple',
                  3,
                  'matRippleTrigger',
                  'matRippleDisabled',
                ],
                [1, 'mat-option-pseudo-checkbox', 3, 'state', 'disabled'],
              ],
              template: function (t, e) {
                1 & t &&
                  (i.fc(),
                  i.vc(0, f, 1, 2, 'mat-pseudo-checkbox', 0),
                  i.Qb(1, 'span', 1),
                  i.ec(2),
                  i.Pb(),
                  i.Mb(3, 'div', 2)),
                  2 & t &&
                    (i.gc('ngIf', e.multiple),
                    i.zb(3),
                    i.gc('matRippleTrigger', e._getHostElement())(
                      'matRippleDisabled',
                      e.disabled || e.disableRipple
                    ))
              },
              directives: [a.k, N, V],
              styles: [
                '.mat-option{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative;cursor:pointer;outline:none;display:flex;flex-direction:row;max-width:100%;box-sizing:border-box;align-items:center;-webkit-tap-highlight-color:transparent}.mat-option[disabled]{cursor:default}[dir=rtl] .mat-option{text-align:right}.mat-option .mat-icon{margin-right:16px;vertical-align:middle}.mat-option .mat-icon svg{vertical-align:top}[dir=rtl] .mat-option .mat-icon{margin-left:16px;margin-right:0}.mat-option[aria-disabled=true]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:32px}[dir=rtl] .mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:16px;padding-right:32px}.cdk-high-contrast-active .mat-option{margin:0 1px}.cdk-high-contrast-active .mat-option.mat-active{border:solid 1px currentColor;margin:0}.mat-option-text{display:inline-block;flex-grow:1;overflow:hidden;text-overflow:ellipsis}.mat-option .mat-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.cdk-high-contrast-active .mat-option .mat-option-ripple{opacity:.5}.mat-option-pseudo-checkbox{margin-right:8px}[dir=rtl] .mat-option-pseudo-checkbox{margin-left:8px;margin-right:0}\n',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })()
      function Z(t, e, n) {
        if (n.length) {
          let i = e.toArray(),
            r = n.toArray(),
            s = 0
          for (let e = 0; e < t + 1; e++)
            i[e].group && i[e].group === r[s] && s++
          return s
        }
        return 0
      }
      function J(t, e, n, i) {
        return t < n ? t : t + e > n + i ? Math.max(0, t - i + e) : n
      }
      let tt = (() => {
        class t {}
        return (
          (t.ɵmod = i.Jb({ type: t })),
          (t.ɵinj = i.Ib({
            factory: function (e) {
              return new (e || t)()
            },
            imports: [[M, a.c, y, U]],
          })),
          t
        )
      })()
    },
    FtGj: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return m
      }),
        n.d(e, 'b', function () {
          return d
        }),
        n.d(e, 'c', function () {
          return a
        }),
        n.d(e, 'd', function () {
          return r
        }),
        n.d(e, 'e', function () {
          return s
        }),
        n.d(e, 'f', function () {
          return l
        }),
        n.d(e, 'g', function () {
          return c
        }),
        n.d(e, 'h', function () {
          return f
        }),
        n.d(e, 'i', function () {
          return h
        }),
        n.d(e, 'j', function () {
          return o
        }),
        n.d(e, 'k', function () {
          return i
        }),
        n.d(e, 'l', function () {
          return u
        }),
        n.d(e, 'm', function () {
          return g
        }),
        n.d(e, 'n', function () {
          return p
        }),
        n.d(e, 'o', function () {
          return b
        })
      const i = 9,
        r = 13,
        s = 27,
        o = 32,
        a = 35,
        l = 36,
        c = 37,
        u = 38,
        h = 39,
        d = 40,
        p = 48,
        f = 57,
        m = 65,
        g = 90
      function b(t, ...e) {
        return e.length
          ? e.some((e) => t[e])
          : t.altKey || t.shiftKey || t.ctrlKey || t.metaKey
      }
    },
    GU7r: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return u
      }),
        n.d(e, 'b', function () {
          return c
        }),
        n.d(e, 'c', function () {
          return h
        })
      var i = n('8LU1'),
        r = n('fXoL'),
        s = n('HDdC'),
        o = n('XNiG'),
        a = n('Kj3r')
      let l = (() => {
          class t {
            create(t) {
              return 'undefined' == typeof MutationObserver
                ? null
                : new MutationObserver(t)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵprov = Object(r.Hb)({
              factory: function () {
                return new t()
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        c = (() => {
          class t {
            constructor(t) {
              ;(this._mutationObserverFactory = t),
                (this._observedElements = new Map())
            }
            ngOnDestroy() {
              this._observedElements.forEach((t, e) => this._cleanupObserver(e))
            }
            observe(t) {
              const e = Object(i.d)(t)
              return new s.a((t) => {
                const n = this._observeElement(e).subscribe(t)
                return () => {
                  n.unsubscribe(), this._unobserveElement(e)
                }
              })
            }
            _observeElement(t) {
              if (this._observedElements.has(t))
                this._observedElements.get(t).count++
              else {
                const e = new o.a(),
                  n = this._mutationObserverFactory.create((t) => e.next(t))
                n &&
                  n.observe(t, {
                    characterData: !0,
                    childList: !0,
                    subtree: !0,
                  }),
                  this._observedElements.set(t, {
                    observer: n,
                    stream: e,
                    count: 1,
                  })
              }
              return this._observedElements.get(t).stream
            }
            _unobserveElement(t) {
              this._observedElements.has(t) &&
                (this._observedElements.get(t).count--,
                this._observedElements.get(t).count || this._cleanupObserver(t))
            }
            _cleanupObserver(t) {
              if (this._observedElements.has(t)) {
                const { observer: e, stream: n } = this._observedElements.get(t)
                e && e.disconnect(),
                  n.complete(),
                  this._observedElements.delete(t)
              }
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(r.Ub(l))
            }),
            (t.ɵprov = Object(r.Hb)({
              factory: function () {
                return new t(Object(r.Ub)(l))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        u = (() => {
          class t {
            constructor(t, e, n) {
              ;(this._contentObserver = t),
                (this._elementRef = e),
                (this._ngZone = n),
                (this.event = new r.n()),
                (this._disabled = !1),
                (this._currentSubscription = null)
            }
            get disabled() {
              return this._disabled
            }
            set disabled(t) {
              ;(this._disabled = Object(i.b)(t)),
                this._disabled ? this._unsubscribe() : this._subscribe()
            }
            get debounce() {
              return this._debounce
            }
            set debounce(t) {
              ;(this._debounce = Object(i.e)(t)), this._subscribe()
            }
            ngAfterContentInit() {
              this._currentSubscription || this.disabled || this._subscribe()
            }
            ngOnDestroy() {
              this._unsubscribe()
            }
            _subscribe() {
              this._unsubscribe()
              const t = this._contentObserver.observe(this._elementRef)
              this._ngZone.runOutsideAngular(() => {
                this._currentSubscription = (this.debounce
                  ? t.pipe(Object(a.a)(this.debounce))
                  : t
                ).subscribe(this.event)
              })
            }
            _unsubscribe() {
              var t
              null === (t = this._currentSubscription) ||
                void 0 === t ||
                t.unsubscribe()
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(r.Lb(c), r.Lb(r.l), r.Lb(r.z))
            }),
            (t.ɵdir = r.Gb({
              type: t,
              selectors: [['', 'cdkObserveContent', '']],
              inputs: {
                disabled: ['cdkObserveContentDisabled', 'disabled'],
                debounce: 'debounce',
              },
              outputs: { event: 'cdkObserveContent' },
              exportAs: ['cdkObserveContent'],
            })),
            t
          )
        })(),
        h = (() => {
          class t {}
          return (
            (t.ɵmod = r.Jb({ type: t })),
            (t.ɵinj = r.Ib({
              factory: function (e) {
                return new (e || t)()
              },
              providers: [l],
            })),
            t
          )
        })()
    },
    Gbct: function (t, e, n) {
      var i = n('Wm4p'),
        r = n('cpc2')
      function s(t) {
        ;(this.path = t.path),
          (this.hostname = t.hostname),
          (this.port = t.port),
          (this.secure = t.secure),
          (this.query = t.query),
          (this.timestampParam = t.timestampParam),
          (this.timestampRequests = t.timestampRequests),
          (this.readyState = ''),
          (this.agent = t.agent || !1),
          (this.socket = t.socket),
          (this.enablesXDR = t.enablesXDR),
          (this.withCredentials = t.withCredentials),
          (this.pfx = t.pfx),
          (this.key = t.key),
          (this.passphrase = t.passphrase),
          (this.cert = t.cert),
          (this.ca = t.ca),
          (this.ciphers = t.ciphers),
          (this.rejectUnauthorized = t.rejectUnauthorized),
          (this.forceNode = t.forceNode),
          (this.isReactNative = t.isReactNative),
          (this.extraHeaders = t.extraHeaders),
          (this.localAddress = t.localAddress)
      }
      ;(t.exports = s),
        r(s.prototype),
        (s.prototype.onError = function (t, e) {
          var n = new Error(t)
          return (
            (n.type = 'TransportError'),
            (n.description = e),
            this.emit('error', n),
            this
          )
        }),
        (s.prototype.open = function () {
          return (
            ('closed' !== this.readyState && '' !== this.readyState) ||
              ((this.readyState = 'opening'), this.doOpen()),
            this
          )
        }),
        (s.prototype.close = function () {
          return (
            ('opening' !== this.readyState && 'open' !== this.readyState) ||
              (this.doClose(), this.onClose()),
            this
          )
        }),
        (s.prototype.send = function (t) {
          if ('open' !== this.readyState) throw new Error('Transport not open')
          this.write(t)
        }),
        (s.prototype.onOpen = function () {
          ;(this.readyState = 'open'), (this.writable = !0), this.emit('open')
        }),
        (s.prototype.onData = function (t) {
          var e = i.decodePacket(t, this.socket.binaryType)
          this.onPacket(e)
        }),
        (s.prototype.onPacket = function (t) {
          this.emit('packet', t)
        }),
        (s.prototype.onClose = function () {
          ;(this.readyState = 'closed'), this.emit('close')
        })
    },
    GyhO: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return s
      })
      var i = n('LRne'),
        r = n('0EUg')
      function s(...t) {
        return Object(r.a)()(Object(i.a)(...t))
      }
    },
    HDdC: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return c
      })
      var i = n('7o/Q'),
        r = n('2QA8'),
        s = n('gRHU'),
        o = n('kJWO'),
        a = n('SpAZ'),
        l = n('2fFW')
      let c = (() => {
        class t {
          constructor(t) {
            ;(this._isScalar = !1), t && (this._subscribe = t)
          }
          lift(e) {
            const n = new t()
            return (n.source = this), (n.operator = e), n
          }
          subscribe(t, e, n) {
            const { operator: o } = this,
              a = (function (t, e, n) {
                if (t) {
                  if (t instanceof i.a) return t
                  if (t[r.a]) return t[r.a]()
                }
                return t || e || n ? new i.a(t, e, n) : new i.a(s.a)
              })(t, e, n)
            if (
              (a.add(
                o
                  ? o.call(a, this.source)
                  : this.source ||
                    (l.a.useDeprecatedSynchronousErrorHandling &&
                      !a.syncErrorThrowable)
                  ? this._subscribe(a)
                  : this._trySubscribe(a)
              ),
              l.a.useDeprecatedSynchronousErrorHandling &&
                a.syncErrorThrowable &&
                ((a.syncErrorThrowable = !1), a.syncErrorThrown))
            )
              throw a.syncErrorValue
            return a
          }
          _trySubscribe(t) {
            try {
              return this._subscribe(t)
            } catch (e) {
              l.a.useDeprecatedSynchronousErrorHandling &&
                ((t.syncErrorThrown = !0), (t.syncErrorValue = e)),
                (function (t) {
                  for (; t; ) {
                    const { closed: e, destination: n, isStopped: r } = t
                    if (e || r) return !1
                    t = n && n instanceof i.a ? n : null
                  }
                  return !0
                })(t)
                  ? t.error(e)
                  : console.warn(e)
            }
          }
          forEach(t, e) {
            return new (e = u(e))((e, n) => {
              let i
              i = this.subscribe(
                (e) => {
                  try {
                    t(e)
                  } catch (r) {
                    n(r), i && i.unsubscribe()
                  }
                },
                n,
                e
              )
            })
          }
          _subscribe(t) {
            const { source: e } = this
            return e && e.subscribe(t)
          }
          [o.a]() {
            return this
          }
          pipe(...t) {
            return 0 === t.length
              ? this
              : (0 === (e = t).length
                  ? a.a
                  : 1 === e.length
                  ? e[0]
                  : function (t) {
                      return e.reduce((t, e) => e(t), t)
                    })(this)
            var e
          }
          toPromise(t) {
            return new (t = u(t))((t, e) => {
              let n
              this.subscribe(
                (t) => (n = t),
                (t) => e(t),
                () => t(n)
              )
            })
          }
        }
        return (t.create = (e) => new t(e)), t
      })()
      function u(t) {
        if ((t || (t = l.a.Promise || Promise), !t))
          throw new Error('no Promise impl found')
        return t
      }
    },
    Huv7: function (t, e, n) {
      'use strict'
      n.d(e, 'd', function () {
        return s
      }),
        n.d(e, 'a', function () {
          return o
        }),
        n.d(e, 'b', function () {
          return a
        }),
        n.d(e, 'c', function () {
          return l
        })
      var i = n('gFX4'),
        r = n('XNiG')
      class s {
        constructor(t) {
          ;(this.message = new r.a()),
            (this.message$ = this.message.asObservable()),
            console.log({ uri: t }),
            t &&
              ((this.io = i.connect(t)),
              this.io.on('message', (t) => this.message.next(t)))
        }
        send(t) {
          this.io.send(t)
        }
      }
      let o = (() => {
        class t {
          static log(e, n = t.logColor) {
            console.log('%c' + e, 'color:' + n)
          }
          static info(e, n = t.infoColor) {
            console.info('%c' + e, 'color:' + n)
          }
          static warn(e, n = t.warnColor) {
            console.warn('%c' + e, 'color:' + n)
          }
          static error(e, n = t.errorColor) {
            console.error('%c' + e, 'color:' + n)
          }
        }
        return (
          (t.logColor = '#2196F3'),
          (t.infoColor = 'purple'),
          (t.warnColor = 'orange'),
          (t.errorColor = 'red'),
          t
        )
      })()
      var a = (function (t) {
          return (
            (t.Connect = 'connect'),
            (t.Disconnect = 'disconnect'),
            (t.Connected = 'connected'),
            (t.Completed = 'completed'),
            (t.Offer = 'offer'),
            (t.Answer = 'answer'),
            t
          )
        })({}),
        l = (function (t) {
          return (
            (t.Connected = 'connected'),
            (t.Completed = 'completed'),
            (t.Stable = 'stable'),
            t
          )
        })({})
    },
    I55L: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return i
      })
      const i = (t) =>
        t && 'number' == typeof t.length && 'function' != typeof t
    },
    IjjT: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return r
      })
      let i = (() => {
        class t {
          constructor(e, n = t.now) {
            ;(this.SchedulerAction = e), (this.now = n)
          }
          schedule(t, e = 0, n) {
            return new this.SchedulerAction(this, t).schedule(n, e)
          }
        }
        return (t.now = () => Date.now()), t
      })()
      class r extends i {
        constructor(t, e = i.now) {
          super(t, () =>
            r.delegate && r.delegate !== this ? r.delegate.now() : e()
          ),
            (this.actions = []),
            (this.active = !1),
            (this.scheduled = void 0)
        }
        schedule(t, e = 0, n) {
          return r.delegate && r.delegate !== this
            ? r.delegate.schedule(t, e, n)
            : super.schedule(t, e, n)
        }
        flush(t) {
          const { actions: e } = this
          if (this.active) return void e.push(t)
          let n
          this.active = !0
          do {
            if ((n = t.execute(t.state, t.delay))) break
          } while ((t = e.shift()))
          if (((this.active = !1), n)) {
            for (; (t = e.shift()); ) t.unsubscribe()
            throw n
          }
        }
      }
    },
    IzEk: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return o
      })
      var i = n('7o/Q'),
        r = n('4I5i'),
        s = n('EY2u')
      function o(t) {
        return (e) => (0 === t ? Object(s.b)() : e.lift(new a(t)))
      }
      class a {
        constructor(t) {
          if (((this.total = t), this.total < 0)) throw new r.a()
        }
        call(t, e) {
          return e.subscribe(new l(t, this.total))
        }
      }
      class l extends i.a {
        constructor(t, e) {
          super(t), (this.total = e), (this.count = 0)
        }
        _next(t) {
          const e = this.total,
            n = ++this.count
          n <= e &&
            (this.destination.next(t),
            n === e && (this.destination.complete(), this.unsubscribe()))
        }
      }
    },
    JIr8: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return o
      })
      var i = n('l7GE'),
        r = n('51Dv'),
        s = n('ZUHj')
      function o(t) {
        return function (e) {
          const n = new a(t),
            i = e.lift(n)
          return (n.caught = i)
        }
      }
      class a {
        constructor(t) {
          this.selector = t
        }
        call(t, e) {
          return e.subscribe(new l(t, this.selector, this.caught))
        }
      }
      class l extends i.a {
        constructor(t, e, n) {
          super(t), (this.selector = e), (this.caught = n)
        }
        error(t) {
          if (!this.isStopped) {
            let n
            try {
              n = this.selector(t, this.caught)
            } catch (e) {
              return void super.error(e)
            }
            this._unsubscribeAndRecycle()
            const i = new r.a(this, void 0, void 0)
            this.add(i)
            const o = Object(s.a)(this, n, void 0, void 0, i)
            o !== i && this.add(o)
          }
        }
      }
    },
    JX91: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return s
      })
      var i = n('GyhO'),
        r = n('z+Ro')
      function s(...t) {
        const e = t[t.length - 1]
        return Object(r.a)(e)
          ? (t.pop(), (n) => Object(i.a)(t, n, e))
          : (e) => Object(i.a)(t, e)
      }
    },
    KFGy: function (t, e, n) {
      var i = n('Uwu7'),
        r = n('cpc2'),
        s = n('kSER'),
        o = n('2Dig'),
        a = n('QN7Q'),
        l = n('NOtv')('socket.io-client:socket'),
        c = n('TypT'),
        u = n('WLGk')
      t.exports = p
      var h = {
          connect: 1,
          connect_error: 1,
          connect_timeout: 1,
          connecting: 1,
          disconnect: 1,
          error: 1,
          reconnect: 1,
          reconnect_attempt: 1,
          reconnect_failed: 1,
          reconnect_error: 1,
          reconnecting: 1,
          ping: 1,
          pong: 1,
        },
        d = r.prototype.emit
      function p(t, e, n) {
        ;(this.io = t),
          (this.nsp = e),
          (this.json = this),
          (this.ids = 0),
          (this.acks = {}),
          (this.receiveBuffer = []),
          (this.sendBuffer = []),
          (this.connected = !1),
          (this.disconnected = !0),
          (this.flags = {}),
          n && n.query && (this.query = n.query),
          this.io.autoConnect && this.open()
      }
      r(p.prototype),
        (p.prototype.subEvents = function () {
          if (!this.subs) {
            var t = this.io
            this.subs = [
              o(t, 'open', a(this, 'onopen')),
              o(t, 'packet', a(this, 'onpacket')),
              o(t, 'close', a(this, 'onclose')),
            ]
          }
        }),
        (p.prototype.open = p.prototype.connect = function () {
          return (
            this.connected ||
              (this.subEvents(),
              this.io.reconnecting || this.io.open(),
              'open' === this.io.readyState && this.onopen(),
              this.emit('connecting')),
            this
          )
        }),
        (p.prototype.send = function () {
          var t = s(arguments)
          return t.unshift('message'), this.emit.apply(this, t), this
        }),
        (p.prototype.emit = function (t) {
          if (h.hasOwnProperty(t)) return d.apply(this, arguments), this
          var e = s(arguments),
            n = {
              type: (void 0 !== this.flags.binary ? this.flags.binary : u(e))
                ? i.BINARY_EVENT
                : i.EVENT,
              data: e,
              options: {},
            }
          return (
            (n.options.compress = !this.flags || !1 !== this.flags.compress),
            'function' == typeof e[e.length - 1] &&
              (l('emitting packet with ack id %d', this.ids),
              (this.acks[this.ids] = e.pop()),
              (n.id = this.ids++)),
            this.connected ? this.packet(n) : this.sendBuffer.push(n),
            (this.flags = {}),
            this
          )
        }),
        (p.prototype.packet = function (t) {
          ;(t.nsp = this.nsp), this.io.packet(t)
        }),
        (p.prototype.onopen = function () {
          if ((l('transport is open - connecting'), '/' !== this.nsp))
            if (this.query) {
              var t =
                'object' == typeof this.query
                  ? c.encode(this.query)
                  : this.query
              l('sending connect packet with query %s', t),
                this.packet({ type: i.CONNECT, query: t })
            } else this.packet({ type: i.CONNECT })
        }),
        (p.prototype.onclose = function (t) {
          l('close (%s)', t),
            (this.connected = !1),
            (this.disconnected = !0),
            delete this.id,
            this.emit('disconnect', t)
        }),
        (p.prototype.onpacket = function (t) {
          if (t.nsp === this.nsp || (t.type === i.ERROR && '/' === t.nsp))
            switch (t.type) {
              case i.CONNECT:
                this.onconnect()
                break
              case i.EVENT:
              case i.BINARY_EVENT:
                this.onevent(t)
                break
              case i.ACK:
              case i.BINARY_ACK:
                this.onack(t)
                break
              case i.DISCONNECT:
                this.ondisconnect()
                break
              case i.ERROR:
                this.emit('error', t.data)
            }
        }),
        (p.prototype.onevent = function (t) {
          var e = t.data || []
          l('emitting event %j', e),
            null != t.id &&
              (l('attaching ack callback to event'), e.push(this.ack(t.id))),
            this.connected ? d.apply(this, e) : this.receiveBuffer.push(e)
        }),
        (p.prototype.ack = function (t) {
          var e = this,
            n = !1
          return function () {
            if (!n) {
              n = !0
              var r = s(arguments)
              l('sending ack %j', r),
                e.packet({ type: u(r) ? i.BINARY_ACK : i.ACK, id: t, data: r })
            }
          }
        }),
        (p.prototype.onack = function (t) {
          var e = this.acks[t.id]
          'function' == typeof e
            ? (l('calling ack %s with %j', t.id, t.data),
              e.apply(this, t.data),
              delete this.acks[t.id])
            : l('bad ack %s', t.id)
        }),
        (p.prototype.onconnect = function () {
          ;(this.connected = !0),
            (this.disconnected = !1),
            this.emit('connect'),
            this.emitBuffered()
        }),
        (p.prototype.emitBuffered = function () {
          var t
          for (t = 0; t < this.receiveBuffer.length; t++)
            d.apply(this, this.receiveBuffer[t])
          for (this.receiveBuffer = [], t = 0; t < this.sendBuffer.length; t++)
            this.packet(this.sendBuffer[t])
          this.sendBuffer = []
        }),
        (p.prototype.ondisconnect = function () {
          l('server disconnect (%s)', this.nsp),
            this.destroy(),
            this.onclose('io server disconnect')
        }),
        (p.prototype.destroy = function () {
          if (this.subs) {
            for (var t = 0; t < this.subs.length; t++) this.subs[t].destroy()
            this.subs = null
          }
          this.io.destroy(this)
        }),
        (p.prototype.close = p.prototype.disconnect = function () {
          return (
            this.connected &&
              (l('performing disconnect (%s)', this.nsp),
              this.packet({ type: i.DISCONNECT })),
            this.destroy(),
            this.connected && this.onclose('io client disconnect'),
            this
          )
        }),
        (p.prototype.compress = function (t) {
          return (this.flags.compress = t), this
        }),
        (p.prototype.binary = function (t) {
          return (this.flags.binary = t), this
        })
    },
    Kj3r: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return s
      })
      var i = n('7o/Q'),
        r = n('D0XW')
      function s(t, e = r.a) {
        return (n) => n.lift(new o(t, e))
      }
      class o {
        constructor(t, e) {
          ;(this.dueTime = t), (this.scheduler = e)
        }
        call(t, e) {
          return e.subscribe(new a(t, this.dueTime, this.scheduler))
        }
      }
      class a extends i.a {
        constructor(t, e, n) {
          super(t),
            (this.dueTime = e),
            (this.scheduler = n),
            (this.debouncedSubscription = null),
            (this.lastValue = null),
            (this.hasValue = !1)
        }
        _next(t) {
          this.clearDebounce(),
            (this.lastValue = t),
            (this.hasValue = !0),
            this.add(
              (this.debouncedSubscription = this.scheduler.schedule(
                l,
                this.dueTime,
                this
              ))
            )
        }
        _complete() {
          this.debouncedNext(), this.destination.complete()
        }
        debouncedNext() {
          if ((this.clearDebounce(), this.hasValue)) {
            const { lastValue: t } = this
            ;(this.lastValue = null),
              (this.hasValue = !1),
              this.destination.next(t)
          }
        }
        clearDebounce() {
          const t = this.debouncedSubscription
          null !== t &&
            (this.remove(t),
            t.unsubscribe(),
            (this.debouncedSubscription = null))
        }
      }
      function l(t) {
        t.debouncedNext()
      }
    },
    KqfI: function (t, e, n) {
      'use strict'
      function i() {}
      n.d(e, 'a', function () {
        return i
      })
    },
    LRne: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return o
      })
      var i = n('z+Ro'),
        r = n('yCtX'),
        s = n('jZKg')
      function o(...t) {
        let e = t[t.length - 1]
        return Object(i.a)(e) ? (t.pop(), Object(s.a)(t, e)) : Object(r.a)(t)
      }
    },
    Lhse: function (t, e, n) {
      'use strict'
      function i() {
        return 'function' == typeof Symbol && Symbol.iterator
          ? Symbol.iterator
          : '@@iterator'
      }
      n.d(e, 'a', function () {
        return r
      })
      const r = i()
    },
    MAu8: function (t, e, n) {
      'use strict'
      n.d(e, 'b', function () {
        return f
      }),
        n.d(e, 'a', function () {
          return b
        }),
        n('8LU1')
      var i = n('3Pt+'),
        r = n('kmnG'),
        s = (n('XNiG'), n('fXoL'))
      n('u47x')
      var o = n('2Mw2')
      let a = (() => {
        class t {
          constructor() {
            ;(this.onChange = () => {}), (this.onTouched = () => {})
          }
          get value() {
            return this._value
          }
          set value(t) {
            console.log('value: ', t), (this._value = t)
          }
          writeValue(t) {
            this.value = t
          }
          registerOnChange(t) {
            this.onChange = t
          }
          registerOnTouched(t) {
            this.onTouched = t
          }
          setDisabledState(t) {
            this._disabled = t
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵprov = s.Hb({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      n('2Vo4')
      var l = n('rDax'),
        c = n('ofXK'),
        u = n('FKr1'),
        h = n('vxfF')
      n('0EQZ'),
        n('FtGj'),
        n('NXyV'),
        n('VRyK'),
        n('JX91'),
        n('eIep'),
        n('IzEk'),
        n('pLZG'),
        n('lJxs'),
        n('/uUt'),
        n('1G5W'),
        n('R0Ic'),
        n('cH1L')
      const d = {
        provide: new s.q('mat-select-scroll-strategy'),
        deps: [l.c],
        useFactory: function (t) {
          return () => t.scrollStrategies.reposition()
        },
      }
      let p = (() => {
        class t {}
        return (
          (t.ɵmod = s.Jb({ type: t })),
          (t.ɵinj = s.Ib({
            factory: function (e) {
              return new (e || t)()
            },
            providers: [d],
            imports: [[c.c, l.d, u.h, u.d], h.b, r.e, u.h, u.d],
          })),
          t
        )
      })()
      function f() {
        function t() {
          return Math.floor(65536 * (1 + Math.random()))
            .toString(16)
            .substring(1)
        }
        return `${t()}${t()}-${t()}-${t()}-${t()}-${t()}${t()}${t()}`
      }
      Object(s.T)(() => a)
      var m = n('NFeN'),
        g = n('bTqV')
      let b = (() => {
        class t {}
        return (
          (t.ɵmod = s.Jb({ type: t })),
          (t.ɵinj = s.Ib({
            factory: function (e) {
              return new (e || t)()
            },
            imports: [[c.c, o.c, m.b, g.c, p, r.e, i.l]],
          })),
          t
        )
      })()
    },
    NFeN: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return G
      }),
        n.d(e, 'b', function () {
          return Q
        })
      var i = n('fXoL'),
        r = n('FKr1'),
        s = n('8LU1'),
        o = n('ofXK'),
        a = n('LRne'),
        l = n('z6cu'),
        c = n('cp0P'),
        u = n('quSY'),
        h = n('vkgz'),
        d = n('lJxs'),
        p = n('JIr8'),
        f = n('nYR2'),
        m = n('w1tV'),
        g = n('IzEk'),
        b = (n('HDdC'), n('bOdf')),
        _ = n('pLZG')
      class y {}
      class v {
        constructor(t) {
          ;(this.normalizedNames = new Map()),
            (this.lazyUpdate = null),
            t
              ? (this.lazyInit =
                  'string' == typeof t
                    ? () => {
                        ;(this.headers = new Map()),
                          t.split('\n').forEach((t) => {
                            const e = t.indexOf(':')
                            if (e > 0) {
                              const n = t.slice(0, e),
                                i = n.toLowerCase(),
                                r = t.slice(e + 1).trim()
                              this.maybeSetNormalizedName(n, i),
                                this.headers.has(i)
                                  ? this.headers.get(i).push(r)
                                  : this.headers.set(i, [r])
                            }
                          })
                      }
                    : () => {
                        ;(this.headers = new Map()),
                          Object.keys(t).forEach((e) => {
                            let n = t[e]
                            const i = e.toLowerCase()
                            'string' == typeof n && (n = [n]),
                              n.length > 0 &&
                                (this.headers.set(i, n),
                                this.maybeSetNormalizedName(e, i))
                          })
                      })
              : (this.headers = new Map())
        }
        has(t) {
          return this.init(), this.headers.has(t.toLowerCase())
        }
        get(t) {
          this.init()
          const e = this.headers.get(t.toLowerCase())
          return e && e.length > 0 ? e[0] : null
        }
        keys() {
          return this.init(), Array.from(this.normalizedNames.values())
        }
        getAll(t) {
          return this.init(), this.headers.get(t.toLowerCase()) || null
        }
        append(t, e) {
          return this.clone({ name: t, value: e, op: 'a' })
        }
        set(t, e) {
          return this.clone({ name: t, value: e, op: 's' })
        }
        delete(t, e) {
          return this.clone({ name: t, value: e, op: 'd' })
        }
        maybeSetNormalizedName(t, e) {
          this.normalizedNames.has(e) || this.normalizedNames.set(e, t)
        }
        init() {
          this.lazyInit &&
            (this.lazyInit instanceof v
              ? this.copyFrom(this.lazyInit)
              : this.lazyInit(),
            (this.lazyInit = null),
            this.lazyUpdate &&
              (this.lazyUpdate.forEach((t) => this.applyUpdate(t)),
              (this.lazyUpdate = null)))
        }
        copyFrom(t) {
          t.init(),
            Array.from(t.headers.keys()).forEach((e) => {
              this.headers.set(e, t.headers.get(e)),
                this.normalizedNames.set(e, t.normalizedNames.get(e))
            })
        }
        clone(t) {
          const e = new v()
          return (
            (e.lazyInit =
              this.lazyInit && this.lazyInit instanceof v
                ? this.lazyInit
                : this),
            (e.lazyUpdate = (this.lazyUpdate || []).concat([t])),
            e
          )
        }
        applyUpdate(t) {
          const e = t.name.toLowerCase()
          switch (t.op) {
            case 'a':
            case 's':
              let n = t.value
              if (('string' == typeof n && (n = [n]), 0 === n.length)) return
              this.maybeSetNormalizedName(t.name, e)
              const i = ('a' === t.op ? this.headers.get(e) : void 0) || []
              i.push(...n), this.headers.set(e, i)
              break
            case 'd':
              const r = t.value
              if (r) {
                let t = this.headers.get(e)
                if (!t) return
                ;(t = t.filter((t) => -1 === r.indexOf(t))),
                  0 === t.length
                    ? (this.headers.delete(e), this.normalizedNames.delete(e))
                    : this.headers.set(e, t)
              } else this.headers.delete(e), this.normalizedNames.delete(e)
          }
        }
        forEach(t) {
          this.init(),
            Array.from(this.normalizedNames.keys()).forEach((e) =>
              t(this.normalizedNames.get(e), this.headers.get(e))
            )
        }
      }
      class w {
        encodeKey(t) {
          return C(t)
        }
        encodeValue(t) {
          return C(t)
        }
        decodeKey(t) {
          return decodeURIComponent(t)
        }
        decodeValue(t) {
          return decodeURIComponent(t)
        }
      }
      function C(t) {
        return encodeURIComponent(t)
          .replace(/%40/gi, '@')
          .replace(/%3A/gi, ':')
          .replace(/%24/gi, '$')
          .replace(/%2C/gi, ',')
          .replace(/%3B/gi, ';')
          .replace(/%2B/gi, '+')
          .replace(/%3D/gi, '=')
          .replace(/%3F/gi, '?')
          .replace(/%2F/gi, '/')
      }
      class x {
        constructor(t = {}) {
          if (
            ((this.updates = null),
            (this.cloneFrom = null),
            (this.encoder = t.encoder || new w()),
            t.fromString)
          ) {
            if (t.fromObject)
              throw new Error('Cannot specify both fromString and fromObject.')
            this.map = (function (t, e) {
              const n = new Map()
              return (
                t.length > 0 &&
                  t.split('&').forEach((t) => {
                    const i = t.indexOf('='),
                      [r, s] =
                        -1 == i
                          ? [e.decodeKey(t), '']
                          : [
                              e.decodeKey(t.slice(0, i)),
                              e.decodeValue(t.slice(i + 1)),
                            ],
                      o = n.get(r) || []
                    o.push(s), n.set(r, o)
                  }),
                n
              )
            })(t.fromString, this.encoder)
          } else
            t.fromObject
              ? ((this.map = new Map()),
                Object.keys(t.fromObject).forEach((e) => {
                  const n = t.fromObject[e]
                  this.map.set(e, Array.isArray(n) ? n : [n])
                }))
              : (this.map = null)
        }
        has(t) {
          return this.init(), this.map.has(t)
        }
        get(t) {
          this.init()
          const e = this.map.get(t)
          return e ? e[0] : null
        }
        getAll(t) {
          return this.init(), this.map.get(t) || null
        }
        keys() {
          return this.init(), Array.from(this.map.keys())
        }
        append(t, e) {
          return this.clone({ param: t, value: e, op: 'a' })
        }
        set(t, e) {
          return this.clone({ param: t, value: e, op: 's' })
        }
        delete(t, e) {
          return this.clone({ param: t, value: e, op: 'd' })
        }
        toString() {
          return (
            this.init(),
            this.keys()
              .map((t) => {
                const e = this.encoder.encodeKey(t)
                return this.map
                  .get(t)
                  .map((t) => e + '=' + this.encoder.encodeValue(t))
                  .join('&')
              })
              .filter((t) => '' !== t)
              .join('&')
          )
        }
        clone(t) {
          const e = new x({ encoder: this.encoder })
          return (
            (e.cloneFrom = this.cloneFrom || this),
            (e.updates = (this.updates || []).concat([t])),
            e
          )
        }
        init() {
          null === this.map && (this.map = new Map()),
            null !== this.cloneFrom &&
              (this.cloneFrom.init(),
              this.cloneFrom
                .keys()
                .forEach((t) => this.map.set(t, this.cloneFrom.map.get(t))),
              this.updates.forEach((t) => {
                switch (t.op) {
                  case 'a':
                  case 's':
                    const e =
                      ('a' === t.op ? this.map.get(t.param) : void 0) || []
                    e.push(t.value), this.map.set(t.param, e)
                    break
                  case 'd':
                    if (void 0 === t.value) {
                      this.map.delete(t.param)
                      break
                    }
                    {
                      let e = this.map.get(t.param) || []
                      const n = e.indexOf(t.value)
                      ;-1 !== n && e.splice(n, 1),
                        e.length > 0
                          ? this.map.set(t.param, e)
                          : this.map.delete(t.param)
                    }
                }
              }),
              (this.cloneFrom = this.updates = null))
        }
      }
      function S(t) {
        return 'undefined' != typeof ArrayBuffer && t instanceof ArrayBuffer
      }
      function O(t) {
        return 'undefined' != typeof Blob && t instanceof Blob
      }
      function k(t) {
        return 'undefined' != typeof FormData && t instanceof FormData
      }
      class E {
        constructor(t, e, n, i) {
          let r
          if (
            ((this.url = e),
            (this.body = null),
            (this.reportProgress = !1),
            (this.withCredentials = !1),
            (this.responseType = 'json'),
            (this.method = t.toUpperCase()),
            (function (t) {
              switch (t) {
                case 'DELETE':
                case 'GET':
                case 'HEAD':
                case 'OPTIONS':
                case 'JSONP':
                  return !1
                default:
                  return !0
              }
            })(this.method) || i
              ? ((this.body = void 0 !== n ? n : null), (r = i))
              : (r = n),
            r &&
              ((this.reportProgress = !!r.reportProgress),
              (this.withCredentials = !!r.withCredentials),
              r.responseType && (this.responseType = r.responseType),
              r.headers && (this.headers = r.headers),
              r.params && (this.params = r.params)),
            this.headers || (this.headers = new v()),
            this.params)
          ) {
            const t = this.params.toString()
            if (0 === t.length) this.urlWithParams = e
            else {
              const n = e.indexOf('?')
              this.urlWithParams =
                e + (-1 === n ? '?' : n < e.length - 1 ? '&' : '') + t
            }
          } else (this.params = new x()), (this.urlWithParams = e)
        }
        serializeBody() {
          return null === this.body
            ? null
            : S(this.body) ||
              O(this.body) ||
              k(this.body) ||
              'string' == typeof this.body
            ? this.body
            : this.body instanceof x
            ? this.body.toString()
            : 'object' == typeof this.body ||
              'boolean' == typeof this.body ||
              Array.isArray(this.body)
            ? JSON.stringify(this.body)
            : this.body.toString()
        }
        detectContentTypeHeader() {
          return null === this.body || k(this.body)
            ? null
            : O(this.body)
            ? this.body.type || null
            : S(this.body)
            ? null
            : 'string' == typeof this.body
            ? 'text/plain'
            : this.body instanceof x
            ? 'application/x-www-form-urlencoded;charset=UTF-8'
            : 'object' == typeof this.body ||
              'number' == typeof this.body ||
              Array.isArray(this.body)
            ? 'application/json'
            : null
        }
        clone(t = {}) {
          const e = t.method || this.method,
            n = t.url || this.url,
            i = t.responseType || this.responseType,
            r = void 0 !== t.body ? t.body : this.body,
            s =
              void 0 !== t.withCredentials
                ? t.withCredentials
                : this.withCredentials,
            o =
              void 0 !== t.reportProgress
                ? t.reportProgress
                : this.reportProgress
          let a = t.headers || this.headers,
            l = t.params || this.params
          return (
            void 0 !== t.setHeaders &&
              (a = Object.keys(t.setHeaders).reduce(
                (e, n) => e.set(n, t.setHeaders[n]),
                a
              )),
            t.setParams &&
              (l = Object.keys(t.setParams).reduce(
                (e, n) => e.set(n, t.setParams[n]),
                l
              )),
            new E(e, n, r, {
              params: l,
              headers: a,
              reportProgress: o,
              responseType: i,
              withCredentials: s,
            })
          )
        }
      }
      var A = (function (t) {
        return (
          (t[(t.Sent = 0)] = 'Sent'),
          (t[(t.UploadProgress = 1)] = 'UploadProgress'),
          (t[(t.ResponseHeader = 2)] = 'ResponseHeader'),
          (t[(t.DownloadProgress = 3)] = 'DownloadProgress'),
          (t[(t.Response = 4)] = 'Response'),
          (t[(t.User = 5)] = 'User'),
          t
        )
      })({})
      class T extends class {
        constructor(t, e = 200, n = 'OK') {
          ;(this.headers = t.headers || new v()),
            (this.status = void 0 !== t.status ? t.status : e),
            (this.statusText = t.statusText || n),
            (this.url = t.url || null),
            (this.ok = this.status >= 200 && this.status < 300)
        }
      } {
        constructor(t = {}) {
          super(t),
            (this.type = A.Response),
            (this.body = void 0 !== t.body ? t.body : null)
        }
        clone(t = {}) {
          return new T({
            body: void 0 !== t.body ? t.body : this.body,
            headers: t.headers || this.headers,
            status: void 0 !== t.status ? t.status : this.status,
            statusText: t.statusText || this.statusText,
            url: t.url || this.url || void 0,
          })
        }
      }
      function j(t, e) {
        return {
          body: e,
          headers: t.headers,
          observe: t.observe,
          params: t.params,
          reportProgress: t.reportProgress,
          responseType: t.responseType,
          withCredentials: t.withCredentials,
        }
      }
      let I = (() => {
        class t {
          constructor(t) {
            this.handler = t
          }
          request(t, e, n = {}) {
            let i
            if (t instanceof E) i = t
            else {
              let r = void 0
              r = n.headers instanceof v ? n.headers : new v(n.headers)
              let s = void 0
              n.params &&
                (s =
                  n.params instanceof x
                    ? n.params
                    : new x({ fromObject: n.params })),
                (i = new E(t, e, void 0 !== n.body ? n.body : null, {
                  headers: r,
                  params: s,
                  reportProgress: n.reportProgress,
                  responseType: n.responseType || 'json',
                  withCredentials: n.withCredentials,
                }))
            }
            const r = Object(a.a)(i).pipe(
              Object(b.a)((t) => this.handler.handle(t))
            )
            if (t instanceof E || 'events' === n.observe) return r
            const s = r.pipe(Object(_.a)((t) => t instanceof T))
            switch (n.observe || 'body') {
              case 'body':
                switch (i.responseType) {
                  case 'arraybuffer':
                    return s.pipe(
                      Object(d.a)((t) => {
                        if (null !== t.body && !(t.body instanceof ArrayBuffer))
                          throw new Error('Response is not an ArrayBuffer.')
                        return t.body
                      })
                    )
                  case 'blob':
                    return s.pipe(
                      Object(d.a)((t) => {
                        if (null !== t.body && !(t.body instanceof Blob))
                          throw new Error('Response is not a Blob.')
                        return t.body
                      })
                    )
                  case 'text':
                    return s.pipe(
                      Object(d.a)((t) => {
                        if (null !== t.body && 'string' != typeof t.body)
                          throw new Error('Response is not a string.')
                        return t.body
                      })
                    )
                  case 'json':
                  default:
                    return s.pipe(Object(d.a)((t) => t.body))
                }
              case 'response':
                return s
              default:
                throw new Error(
                  `Unreachable: unhandled observe type ${n.observe}}`
                )
            }
          }
          delete(t, e = {}) {
            return this.request('DELETE', t, e)
          }
          get(t, e = {}) {
            return this.request('GET', t, e)
          }
          head(t, e = {}) {
            return this.request('HEAD', t, e)
          }
          jsonp(t, e) {
            return this.request('JSONP', t, {
              params: new x().append(e, 'JSONP_CALLBACK'),
              observe: 'body',
              responseType: 'json',
            })
          }
          options(t, e = {}) {
            return this.request('OPTIONS', t, e)
          }
          patch(t, e, n = {}) {
            return this.request('PATCH', t, j(n, e))
          }
          post(t, e, n = {}) {
            return this.request('POST', t, j(n, e))
          }
          put(t, e, n = {}) {
            return this.request('PUT', t, j(n, e))
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Ub(y))
          }),
          (t.ɵprov = i.Hb({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      var P = n('jhN1')
      const R = ['*']
      function D(t) {
        return Error(`Unable to find icon with the name "${t}"`)
      }
      function L(t) {
        return Error(
          `The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${t}".`
        )
      }
      function F(t) {
        return Error(
          `The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${t}".`
        )
      }
      class N {
        constructor(t, e, n) {
          ;(this.url = t), (this.svgText = e), (this.options = n)
        }
      }
      let M = (() => {
        class t {
          constructor(t, e, n, i) {
            ;(this._httpClient = t),
              (this._sanitizer = e),
              (this._errorHandler = i),
              (this._svgIconConfigs = new Map()),
              (this._iconSetConfigs = new Map()),
              (this._cachedIconsByUrl = new Map()),
              (this._inProgressUrlFetches = new Map()),
              (this._fontCssClassesByAlias = new Map()),
              (this._defaultFontSetClass = 'material-icons'),
              (this._document = n)
          }
          addSvgIcon(t, e, n) {
            return this.addSvgIconInNamespace('', t, e, n)
          }
          addSvgIconLiteral(t, e, n) {
            return this.addSvgIconLiteralInNamespace('', t, e, n)
          }
          addSvgIconInNamespace(t, e, n, i) {
            return this._addSvgIconConfig(t, e, new N(n, null, i))
          }
          addSvgIconLiteralInNamespace(t, e, n, r) {
            const s = this._sanitizer.sanitize(i.I.HTML, n)
            if (!s) throw F(n)
            return this._addSvgIconConfig(t, e, new N('', s, r))
          }
          addSvgIconSet(t, e) {
            return this.addSvgIconSetInNamespace('', t, e)
          }
          addSvgIconSetLiteral(t, e) {
            return this.addSvgIconSetLiteralInNamespace('', t, e)
          }
          addSvgIconSetInNamespace(t, e, n) {
            return this._addSvgIconSetConfig(t, new N(e, null, n))
          }
          addSvgIconSetLiteralInNamespace(t, e, n) {
            const r = this._sanitizer.sanitize(i.I.HTML, e)
            if (!r) throw F(e)
            return this._addSvgIconSetConfig(t, new N('', r, n))
          }
          registerFontClassAlias(t, e = t) {
            return this._fontCssClassesByAlias.set(t, e), this
          }
          classNameForFontAlias(t) {
            return this._fontCssClassesByAlias.get(t) || t
          }
          setDefaultFontSetClass(t) {
            return (this._defaultFontSetClass = t), this
          }
          getDefaultFontSetClass() {
            return this._defaultFontSetClass
          }
          getSvgIconFromUrl(t) {
            const e = this._sanitizer.sanitize(i.I.RESOURCE_URL, t)
            if (!e) throw L(t)
            const n = this._cachedIconsByUrl.get(e)
            return n
              ? Object(a.a)(V(n))
              : this._loadSvgIconFromConfig(new N(t, null)).pipe(
                  Object(h.a)((t) => this._cachedIconsByUrl.set(e, t)),
                  Object(d.a)((t) => V(t))
                )
          }
          getNamedSvgIcon(t, e = '') {
            const n = U(e, t),
              i = this._svgIconConfigs.get(n)
            if (i) return this._getSvgFromConfig(i)
            const r = this._iconSetConfigs.get(e)
            return r ? this._getSvgFromIconSetConfigs(t, r) : Object(l.a)(D(n))
          }
          ngOnDestroy() {
            this._svgIconConfigs.clear(),
              this._iconSetConfigs.clear(),
              this._cachedIconsByUrl.clear()
          }
          _getSvgFromConfig(t) {
            return t.svgText
              ? Object(a.a)(V(this._svgElementFromConfig(t)))
              : this._loadSvgIconFromConfig(t).pipe(Object(d.a)((t) => V(t)))
          }
          _getSvgFromIconSetConfigs(t, e) {
            const n = this._extractIconWithNameFromAnySet(t, e)
            if (n) return Object(a.a)(n)
            const r = e
              .filter((t) => !t.svgText)
              .map((t) =>
                this._loadSvgIconSetFromConfig(t).pipe(
                  Object(p.a)((e) => {
                    const n = this._sanitizer.sanitize(i.I.RESOURCE_URL, t.url)
                    return (
                      this._errorHandler.handleError(
                        new Error(
                          `Loading icon set URL: ${n} failed: ${e.message}`
                        )
                      ),
                      Object(a.a)(null)
                    )
                  })
                )
              )
            return Object(c.a)(r).pipe(
              Object(d.a)(() => {
                const n = this._extractIconWithNameFromAnySet(t, e)
                if (!n) throw D(t)
                return n
              })
            )
          }
          _extractIconWithNameFromAnySet(t, e) {
            for (let n = e.length - 1; n >= 0; n--) {
              const i = e[n]
              if (i.svgText && i.svgText.indexOf(t) > -1) {
                const e = this._svgElementFromConfig(i),
                  n = this._extractSvgIconFromSet(e, t, i.options)
                if (n) return n
              }
            }
            return null
          }
          _loadSvgIconFromConfig(t) {
            return this._fetchIcon(t).pipe(
              Object(h.a)((e) => (t.svgText = e)),
              Object(d.a)(() => this._svgElementFromConfig(t))
            )
          }
          _loadSvgIconSetFromConfig(t) {
            return t.svgText
              ? Object(a.a)(null)
              : this._fetchIcon(t).pipe(Object(h.a)((e) => (t.svgText = e)))
          }
          _extractSvgIconFromSet(t, e, n) {
            const i = t.querySelector(`[id="${e}"]`)
            if (!i) return null
            const r = i.cloneNode(!0)
            if ((r.removeAttribute('id'), 'svg' === r.nodeName.toLowerCase()))
              return this._setSvgAttributes(r, n)
            if ('symbol' === r.nodeName.toLowerCase())
              return this._setSvgAttributes(this._toSvgElement(r), n)
            const s = this._svgElementFromString('<svg></svg>')
            return s.appendChild(r), this._setSvgAttributes(s, n)
          }
          _svgElementFromString(t) {
            const e = this._document.createElement('DIV')
            e.innerHTML = t
            const n = e.querySelector('svg')
            if (!n) throw Error('<svg> tag not found')
            return n
          }
          _toSvgElement(t) {
            const e = this._svgElementFromString('<svg></svg>'),
              n = t.attributes
            for (let i = 0; i < n.length; i++) {
              const { name: t, value: r } = n[i]
              'id' !== t && e.setAttribute(t, r)
            }
            for (let i = 0; i < t.childNodes.length; i++)
              t.childNodes[i].nodeType === this._document.ELEMENT_NODE &&
                e.appendChild(t.childNodes[i].cloneNode(!0))
            return e
          }
          _setSvgAttributes(t, e) {
            return (
              t.setAttribute('fit', ''),
              t.setAttribute('height', '100%'),
              t.setAttribute('width', '100%'),
              t.setAttribute('preserveAspectRatio', 'xMidYMid meet'),
              t.setAttribute('focusable', 'false'),
              e && e.viewBox && t.setAttribute('viewBox', e.viewBox),
              t
            )
          }
          _fetchIcon(t) {
            var e
            const { url: n, options: r } = t,
              s =
                null !== (e = null == r ? void 0 : r.withCredentials) &&
                void 0 !== e &&
                e
            if (!this._httpClient)
              throw Error(
                'Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports.'
              )
            if (null == n) throw Error(`Cannot fetch icon from URL "${n}".`)
            const o = this._sanitizer.sanitize(i.I.RESOURCE_URL, n)
            if (!o) throw L(n)
            const a = this._inProgressUrlFetches.get(o)
            if (a) return a
            const l = this._httpClient
              .get(o, { responseType: 'text', withCredentials: s })
              .pipe(
                Object(f.a)(() => this._inProgressUrlFetches.delete(o)),
                Object(m.a)()
              )
            return this._inProgressUrlFetches.set(o, l), l
          }
          _addSvgIconConfig(t, e, n) {
            return this._svgIconConfigs.set(U(t, e), n), this
          }
          _addSvgIconSetConfig(t, e) {
            const n = this._iconSetConfigs.get(t)
            return n ? n.push(e) : this._iconSetConfigs.set(t, [e]), this
          }
          _svgElementFromConfig(t) {
            if (!t.svgElement) {
              const e = this._svgElementFromString(t.svgText)
              this._setSvgAttributes(e, t.options), (t.svgElement = e)
            }
            return t.svgElement
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Ub(I, 8), i.Ub(P.b), i.Ub(o.d, 8), i.Ub(i.m))
          }),
          (t.ɵprov = Object(i.Hb)({
            factory: function () {
              return new t(
                Object(i.Ub)(I, 8),
                Object(i.Ub)(P.b),
                Object(i.Ub)(o.d, 8),
                Object(i.Ub)(i.m)
              )
            },
            token: t,
            providedIn: 'root',
          })),
          t
        )
      })()
      function V(t) {
        return t.cloneNode(!0)
      }
      function U(t, e) {
        return t + ':' + e
      }
      class B {
        constructor(t) {
          this._elementRef = t
        }
      }
      const z = Object(r.o)(B),
        H = new i.q('mat-icon-location', {
          providedIn: 'root',
          factory: function () {
            const t = Object(i.U)(o.d),
              e = t ? t.location : null
            return { getPathname: () => (e ? e.pathname + e.search : '') }
          },
        }),
        q = [
          'clip-path',
          'color-profile',
          'src',
          'cursor',
          'fill',
          'filter',
          'marker',
          'marker-start',
          'marker-mid',
          'marker-end',
          'mask',
          'stroke',
        ],
        W = q.map((t) => `[${t}]`).join(', '),
        $ = /^url\(['"]?#(.*?)['"]?\)$/
      let G = (() => {
          class t extends z {
            constructor(t, e, n, i, r) {
              super(t),
                (this._iconRegistry = e),
                (this._location = i),
                (this._errorHandler = r),
                (this._inline = !1),
                (this._currentIconFetch = u.a.EMPTY),
                n || t.nativeElement.setAttribute('aria-hidden', 'true')
            }
            get inline() {
              return this._inline
            }
            set inline(t) {
              this._inline = Object(s.b)(t)
            }
            get svgIcon() {
              return this._svgIcon
            }
            set svgIcon(t) {
              t !== this._svgIcon &&
                (t
                  ? this._updateSvgIcon(t)
                  : this._svgIcon && this._clearSvgElement(),
                (this._svgIcon = t))
            }
            get fontSet() {
              return this._fontSet
            }
            set fontSet(t) {
              const e = this._cleanupFontValue(t)
              e !== this._fontSet &&
                ((this._fontSet = e), this._updateFontIconClasses())
            }
            get fontIcon() {
              return this._fontIcon
            }
            set fontIcon(t) {
              const e = this._cleanupFontValue(t)
              e !== this._fontIcon &&
                ((this._fontIcon = e), this._updateFontIconClasses())
            }
            _splitIconName(t) {
              if (!t) return ['', '']
              const e = t.split(':')
              switch (e.length) {
                case 1:
                  return ['', e[0]]
                case 2:
                  return e
                default:
                  throw Error(`Invalid icon name: "${t}"`)
              }
            }
            ngOnInit() {
              this._updateFontIconClasses()
            }
            ngAfterViewChecked() {
              const t = this._elementsWithExternalReferences
              if (t && t.size) {
                const t = this._location.getPathname()
                t !== this._previousPath &&
                  ((this._previousPath = t), this._prependPathToReferences(t))
              }
            }
            ngOnDestroy() {
              this._currentIconFetch.unsubscribe(),
                this._elementsWithExternalReferences &&
                  this._elementsWithExternalReferences.clear()
            }
            _usingFontIcon() {
              return !this.svgIcon
            }
            _setSvgElement(t) {
              this._clearSvgElement()
              const e = t.querySelectorAll('style')
              for (let i = 0; i < e.length; i++) e[i].textContent += ' '
              const n = this._location.getPathname()
              ;(this._previousPath = n),
                this._cacheChildrenWithExternalReferences(t),
                this._prependPathToReferences(n),
                this._elementRef.nativeElement.appendChild(t)
            }
            _clearSvgElement() {
              const t = this._elementRef.nativeElement
              let e = t.childNodes.length
              for (
                this._elementsWithExternalReferences &&
                this._elementsWithExternalReferences.clear();
                e--;

              ) {
                const n = t.childNodes[e]
                ;(1 === n.nodeType && 'svg' !== n.nodeName.toLowerCase()) ||
                  t.removeChild(n)
              }
            }
            _updateFontIconClasses() {
              if (!this._usingFontIcon()) return
              const t = this._elementRef.nativeElement,
                e = this.fontSet
                  ? this._iconRegistry.classNameForFontAlias(this.fontSet)
                  : this._iconRegistry.getDefaultFontSetClass()
              e != this._previousFontSetClass &&
                (this._previousFontSetClass &&
                  t.classList.remove(this._previousFontSetClass),
                e && t.classList.add(e),
                (this._previousFontSetClass = e)),
                this.fontIcon != this._previousFontIconClass &&
                  (this._previousFontIconClass &&
                    t.classList.remove(this._previousFontIconClass),
                  this.fontIcon && t.classList.add(this.fontIcon),
                  (this._previousFontIconClass = this.fontIcon))
            }
            _cleanupFontValue(t) {
              return 'string' == typeof t ? t.trim().split(' ')[0] : t
            }
            _prependPathToReferences(t) {
              const e = this._elementsWithExternalReferences
              e &&
                e.forEach((e, n) => {
                  e.forEach((e) => {
                    n.setAttribute(e.name, `url('${t}#${e.value}')`)
                  })
                })
            }
            _cacheChildrenWithExternalReferences(t) {
              const e = t.querySelectorAll(W),
                n = (this._elementsWithExternalReferences =
                  this._elementsWithExternalReferences || new Map())
              for (let i = 0; i < e.length; i++)
                q.forEach((t) => {
                  const r = e[i],
                    s = r.getAttribute(t),
                    o = s ? s.match($) : null
                  if (o) {
                    let e = n.get(r)
                    e || ((e = []), n.set(r, e)),
                      e.push({ name: t, value: o[1] })
                  }
                })
            }
            _updateSvgIcon(t) {
              if (
                ((this._svgNamespace = null),
                (this._svgName = null),
                this._currentIconFetch.unsubscribe(),
                t)
              ) {
                const [e, n] = this._splitIconName(t)
                e && (this._svgNamespace = e),
                  n && (this._svgName = n),
                  (this._currentIconFetch = this._iconRegistry
                    .getNamedSvgIcon(n, e)
                    .pipe(Object(g.a)(1))
                    .subscribe(
                      (t) => this._setSvgElement(t),
                      (t) => {
                        this._errorHandler.handleError(
                          new Error(
                            `Error retrieving icon ${e}:${n}! ${t.message}`
                          )
                        )
                      }
                    ))
              }
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                i.Lb(i.l),
                i.Lb(M),
                i.Vb('aria-hidden'),
                i.Lb(H),
                i.Lb(i.m)
              )
            }),
            (t.ɵcmp = i.Fb({
              type: t,
              selectors: [['mat-icon']],
              hostAttrs: ['role', 'img', 1, 'mat-icon', 'notranslate'],
              hostVars: 7,
              hostBindings: function (t, e) {
                2 & t &&
                  (i.Ab(
                    'data-mat-icon-type',
                    e._usingFontIcon() ? 'font' : 'svg'
                  )('data-mat-icon-name', e._svgName || e.fontIcon)(
                    'data-mat-icon-namespace',
                    e._svgNamespace || e.fontSet
                  ),
                  i.Db('mat-icon-inline', e.inline)(
                    'mat-icon-no-color',
                    'primary' !== e.color &&
                      'accent' !== e.color &&
                      'warn' !== e.color
                  ))
              },
              inputs: {
                color: 'color',
                inline: 'inline',
                svgIcon: 'svgIcon',
                fontSet: 'fontSet',
                fontIcon: 'fontIcon',
              },
              exportAs: ['matIcon'],
              features: [i.wb],
              ngContentSelectors: R,
              decls: 1,
              vars: 0,
              template: function (t, e) {
                1 & t && (i.fc(), i.ec(0))
              },
              styles: [
                '.mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\n',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        Q = (() => {
          class t {}
          return (
            (t.ɵmod = i.Jb({ type: t })),
            (t.ɵinj = i.Ib({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[r.d], r.d],
            })),
            t
          )
        })()
    },
    NJ4a: function (t, e, n) {
      'use strict'
      function i(t) {
        setTimeout(() => {
          throw t
        }, 0)
      }
      n.d(e, 'a', function () {
        return i
      })
    },
    NOtv: function (t, e, n) {
      function i() {
        var t
        try {
          t = e.storage.debug
        } catch (n) {}
        return (
          !t &&
            'undefined' != typeof process &&
            'env' in process &&
            (t = process.env.DEBUG),
          t
        )
      }
      ;((e = t.exports = n('lv48')).log = function () {
        return (
          'object' == typeof console &&
          console.log &&
          Function.prototype.apply.call(console.log, console, arguments)
        )
      }),
        (e.formatArgs = function (t) {
          var n = this.useColors
          if (
            ((t[0] =
              (n ? '%c' : '') +
              this.namespace +
              (n ? ' %c' : ' ') +
              t[0] +
              (n ? '%c ' : ' ') +
              '+' +
              e.humanize(this.diff)),
            n)
          ) {
            var i = 'color: ' + this.color
            t.splice(1, 0, i, 'color: inherit')
            var r = 0,
              s = 0
            t[0].replace(/%[a-zA-Z%]/g, function (t) {
              '%%' !== t && (r++, '%c' === t && (s = r))
            }),
              t.splice(s, 0, i)
          }
        }),
        (e.save = function (t) {
          try {
            null == t ? e.storage.removeItem('debug') : (e.storage.debug = t)
          } catch (n) {}
        }),
        (e.load = i),
        (e.useColors = function () {
          return (
            !(
              'undefined' == typeof window ||
              !window.process ||
              'renderer' !== window.process.type
            ) ||
            (('undefined' == typeof navigator ||
              !navigator.userAgent ||
              !navigator.userAgent
                .toLowerCase()
                .match(/(edge|trident)\/(\d+)/)) &&
              (('undefined' != typeof document &&
                document.documentElement &&
                document.documentElement.style &&
                document.documentElement.style.WebkitAppearance) ||
                ('undefined' != typeof window &&
                  window.console &&
                  (window.console.firebug ||
                    (window.console.exception && window.console.table))) ||
                ('undefined' != typeof navigator &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                  parseInt(RegExp.$1, 10) >= 31) ||
                ('undefined' != typeof navigator &&
                  navigator.userAgent &&
                  navigator.userAgent
                    .toLowerCase()
                    .match(/applewebkit\/(\d+)/))))
          )
        }),
        (e.storage =
          'undefined' != typeof chrome && void 0 !== chrome.storage
            ? chrome.storage.local
            : (function () {
                try {
                  return window.localStorage
                } catch (t) {}
              })()),
        (e.colors = [
          '#0000CC',
          '#0000FF',
          '#0033CC',
          '#0033FF',
          '#0066CC',
          '#0066FF',
          '#0099CC',
          '#0099FF',
          '#00CC00',
          '#00CC33',
          '#00CC66',
          '#00CC99',
          '#00CCCC',
          '#00CCFF',
          '#3300CC',
          '#3300FF',
          '#3333CC',
          '#3333FF',
          '#3366CC',
          '#3366FF',
          '#3399CC',
          '#3399FF',
          '#33CC00',
          '#33CC33',
          '#33CC66',
          '#33CC99',
          '#33CCCC',
          '#33CCFF',
          '#6600CC',
          '#6600FF',
          '#6633CC',
          '#6633FF',
          '#66CC00',
          '#66CC33',
          '#9900CC',
          '#9900FF',
          '#9933CC',
          '#9933FF',
          '#99CC00',
          '#99CC33',
          '#CC0000',
          '#CC0033',
          '#CC0066',
          '#CC0099',
          '#CC00CC',
          '#CC00FF',
          '#CC3300',
          '#CC3333',
          '#CC3366',
          '#CC3399',
          '#CC33CC',
          '#CC33FF',
          '#CC6600',
          '#CC6633',
          '#CC9900',
          '#CC9933',
          '#CCCC00',
          '#CCCC33',
          '#FF0000',
          '#FF0033',
          '#FF0066',
          '#FF0099',
          '#FF00CC',
          '#FF00FF',
          '#FF3300',
          '#FF3333',
          '#FF3366',
          '#FF3399',
          '#FF33CC',
          '#FF33FF',
          '#FF6600',
          '#FF6633',
          '#FF9900',
          '#FF9933',
          '#FFCC00',
          '#FFCC33',
        ]),
        (e.formatters.j = function (t) {
          try {
            return JSON.stringify(t)
          } catch (e) {
            return '[UnexpectedJSONParseError]: ' + e.message
          }
        }),
        e.enable(i())
    },
    NXyV: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return o
      })
      var i = n('HDdC'),
        r = n('Cfvw'),
        s = n('EY2u')
      function o(t) {
        return new i.a((e) => {
          let n
          try {
            n = t()
          } catch (i) {
            return void e.error(i)
          }
          return (n ? Object(r.a)(n) : Object(s.b)()).subscribe(e)
        })
      }
    },
    Njrz: function (t, e, n) {
      var i = n('luTP'),
        r = n('qGlh'),
        s = Object.prototype.toString,
        o =
          'function' == typeof Blob ||
          ('undefined' != typeof Blob &&
            '[object BlobConstructor]' === s.call(Blob)),
        a =
          'function' == typeof File ||
          ('undefined' != typeof File &&
            '[object FileConstructor]' === s.call(File))
      function l(t, e) {
        if (!t) return t
        if (r(t)) {
          var n = { _placeholder: !0, num: e.length }
          return e.push(t), n
        }
        if (i(t)) {
          for (var s = new Array(t.length), o = 0; o < t.length; o++)
            s[o] = l(t[o], e)
          return s
        }
        if ('object' == typeof t && !(t instanceof Date)) {
          for (var a in ((s = {}), t)) s[a] = l(t[a], e)
          return s
        }
        return t
      }
      function c(t, e) {
        if (!t) return t
        if (t && t._placeholder) return e[t.num]
        if (i(t)) for (var n = 0; n < t.length; n++) t[n] = c(t[n], e)
        else if ('object' == typeof t) for (var r in t) t[r] = c(t[r], e)
        return t
      }
      ;(e.deconstructPacket = function (t) {
        var e = [],
          n = t
        return (
          (n.data = l(t.data, e)),
          (n.attachments = e.length),
          { packet: n, buffers: e }
        )
      }),
        (e.reconstructPacket = function (t, e) {
          return (t.data = c(t.data, e)), (t.attachments = void 0), t
        }),
        (e.removeBlobs = function (t, e) {
          var n = 0,
            s = t
          !(function t(l, c, u) {
            if (!l) return l
            if ((o && l instanceof Blob) || (a && l instanceof File)) {
              n++
              var h = new FileReader()
              ;(h.onload = function () {
                u ? (u[c] = this.result) : (s = this.result), --n || e(s)
              }),
                h.readAsArrayBuffer(l)
            } else if (i(l)) for (var d = 0; d < l.length; d++) t(l[d], d, l)
            else if ('object' == typeof l && !r(l))
              for (var p in l) t(l[p], p, l)
          })(s),
            n || e(s)
        })
    },
    QN7Q: function (t, e) {
      var n = [].slice
      t.exports = function (t, e) {
        if (('string' == typeof e && (e = t[e]), 'function' != typeof e))
          throw new Error('bind() requires a function')
        var i = n.call(arguments, 2)
        return function () {
          return e.apply(t, i.concat(n.call(arguments)))
        }
      }
    },
    R0Ic: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return s
      }),
        n.d(e, 'b', function () {
          return i
        }),
        n.d(e, 'c', function () {
          return r
        }),
        n.d(e, 'd', function () {
          return b
        }),
        n.d(e, 'e', function () {
          return a
        }),
        n.d(e, 'f', function () {
          return f
        }),
        n.d(e, 'g', function () {
          return p
        }),
        n.d(e, 'h', function () {
          return h
        }),
        n.d(e, 'i', function () {
          return m
        }),
        n.d(e, 'j', function () {
          return l
        }),
        n.d(e, 'k', function () {
          return u
        }),
        n.d(e, 'l', function () {
          return c
        }),
        n.d(e, 'm', function () {
          return d
        }),
        n.d(e, 'n', function () {
          return o
        }),
        n.d(e, 'o', function () {
          return _
        }),
        n.d(e, 'p', function () {
          return y
        })
      class i {}
      class r {}
      const s = '*'
      function o(t, e) {
        return { type: 7, name: t, definitions: e, options: {} }
      }
      function a(t, e = null) {
        return { type: 4, styles: e, timings: t }
      }
      function l(t, e = null) {
        return { type: 2, steps: t, options: e }
      }
      function c(t) {
        return { type: 6, styles: t, offset: null }
      }
      function u(t, e, n) {
        return { type: 0, name: t, styles: e, options: n }
      }
      function h(t) {
        return { type: 5, steps: t }
      }
      function d(t, e, n = null) {
        return { type: 1, expr: t, animation: e, options: n }
      }
      function p(t, e = null) {
        return { type: 8, animation: t, options: e }
      }
      function f(t = null) {
        return { type: 9, options: t }
      }
      function m(t, e, n = null) {
        return { type: 11, selector: t, animation: e, options: n }
      }
      function g(t) {
        Promise.resolve(null).then(t)
      }
      class b {
        constructor(t = 0, e = 0) {
          ;(this._onDoneFns = []),
            (this._onStartFns = []),
            (this._onDestroyFns = []),
            (this._started = !1),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._position = 0),
            (this.parentPlayer = null),
            (this.totalTime = t + e)
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((t) => t()),
            (this._onDoneFns = []))
        }
        onStart(t) {
          this._onStartFns.push(t)
        }
        onDone(t) {
          this._onDoneFns.push(t)
        }
        onDestroy(t) {
          this._onDestroyFns.push(t)
        }
        hasStarted() {
          return this._started
        }
        init() {}
        play() {
          this.hasStarted() || (this._onStart(), this.triggerMicrotask()),
            (this._started = !0)
        }
        triggerMicrotask() {
          g(() => this._onFinish())
        }
        _onStart() {
          this._onStartFns.forEach((t) => t()), (this._onStartFns = [])
        }
        pause() {}
        restart() {}
        finish() {
          this._onFinish()
        }
        destroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this.hasStarted() || this._onStart(),
            this.finish(),
            this._onDestroyFns.forEach((t) => t()),
            (this._onDestroyFns = []))
        }
        reset() {}
        setPosition(t) {
          this._position = this.totalTime ? t * this.totalTime : 1
        }
        getPosition() {
          return this.totalTime ? this._position / this.totalTime : 1
        }
        triggerCallback(t) {
          const e = 'start' == t ? this._onStartFns : this._onDoneFns
          e.forEach((t) => t()), (e.length = 0)
        }
      }
      class _ {
        constructor(t) {
          ;(this._onDoneFns = []),
            (this._onStartFns = []),
            (this._finished = !1),
            (this._started = !1),
            (this._destroyed = !1),
            (this._onDestroyFns = []),
            (this.parentPlayer = null),
            (this.totalTime = 0),
            (this.players = t)
          let e = 0,
            n = 0,
            i = 0
          const r = this.players.length
          0 == r
            ? g(() => this._onFinish())
            : this.players.forEach((t) => {
                t.onDone(() => {
                  ++e == r && this._onFinish()
                }),
                  t.onDestroy(() => {
                    ++n == r && this._onDestroy()
                  }),
                  t.onStart(() => {
                    ++i == r && this._onStart()
                  })
              }),
            (this.totalTime = this.players.reduce(
              (t, e) => Math.max(t, e.totalTime),
              0
            ))
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((t) => t()),
            (this._onDoneFns = []))
        }
        init() {
          this.players.forEach((t) => t.init())
        }
        onStart(t) {
          this._onStartFns.push(t)
        }
        _onStart() {
          this.hasStarted() ||
            ((this._started = !0),
            this._onStartFns.forEach((t) => t()),
            (this._onStartFns = []))
        }
        onDone(t) {
          this._onDoneFns.push(t)
        }
        onDestroy(t) {
          this._onDestroyFns.push(t)
        }
        hasStarted() {
          return this._started
        }
        play() {
          this.parentPlayer || this.init(),
            this._onStart(),
            this.players.forEach((t) => t.play())
        }
        pause() {
          this.players.forEach((t) => t.pause())
        }
        restart() {
          this.players.forEach((t) => t.restart())
        }
        finish() {
          this._onFinish(), this.players.forEach((t) => t.finish())
        }
        destroy() {
          this._onDestroy()
        }
        _onDestroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this._onFinish(),
            this.players.forEach((t) => t.destroy()),
            this._onDestroyFns.forEach((t) => t()),
            (this._onDestroyFns = []))
        }
        reset() {
          this.players.forEach((t) => t.reset()),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._started = !1)
        }
        setPosition(t) {
          const e = t * this.totalTime
          this.players.forEach((t) => {
            const n = t.totalTime ? Math.min(1, e / t.totalTime) : 1
            t.setPosition(n)
          })
        }
        getPosition() {
          const t = this.players.reduce(
            (t, e) => (null === t || e.totalTime > t.totalTime ? e : t),
            null
          )
          return null != t ? t.getPosition() : 0
        }
        beforeDestroy() {
          this.players.forEach((t) => {
            t.beforeDestroy && t.beforeDestroy()
          })
        }
        triggerCallback(t) {
          const e = 'start' == t ? this._onStartFns : this._onDoneFns
          e.forEach((t) => t()), (e.length = 0)
        }
      }
      const y = '!'
    },
    R1ws: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return Ie
      }),
        n.d(e, 'b', function () {
          return Re
        })
      var i = n('fXoL'),
        r = n('jhN1'),
        s = n('R0Ic')
      function o() {
        return (
          'undefined' != typeof process &&
          '[object process]' === {}.toString.call(process)
        )
      }
      function a(t) {
        switch (t.length) {
          case 0:
            return new s.d()
          case 1:
            return t[0]
          default:
            return new s.o(t)
        }
      }
      function l(t, e, n, i, r = {}, o = {}) {
        const a = [],
          l = []
        let c = -1,
          u = null
        if (
          (i.forEach((t) => {
            const n = t.offset,
              i = n == c,
              h = (i && u) || {}
            Object.keys(t).forEach((n) => {
              let i = n,
                l = t[n]
              if ('offset' !== n)
                switch (((i = e.normalizePropertyName(i, a)), l)) {
                  case s.p:
                    l = r[n]
                    break
                  case s.a:
                    l = o[n]
                    break
                  default:
                    l = e.normalizeStyleValue(n, i, l, a)
                }
              h[i] = l
            }),
              i || l.push(h),
              (u = h),
              (c = n)
          }),
          a.length)
        ) {
          const t = '\n - '
          throw new Error(
            `Unable to animate due to the following errors:${t}${a.join(t)}`
          )
        }
        return l
      }
      function c(t, e, n, i) {
        switch (e) {
          case 'start':
            t.onStart(() => i(n && u(n, 'start', t)))
            break
          case 'done':
            t.onDone(() => i(n && u(n, 'done', t)))
            break
          case 'destroy':
            t.onDestroy(() => i(n && u(n, 'destroy', t)))
        }
      }
      function u(t, e, n) {
        const i = n.totalTime,
          r = h(
            t.element,
            t.triggerName,
            t.fromState,
            t.toState,
            e || t.phaseName,
            null == i ? t.totalTime : i,
            !!n.disabled
          ),
          s = t._data
        return null != s && (r._data = s), r
      }
      function h(t, e, n, i, r = '', s = 0, o) {
        return {
          element: t,
          triggerName: e,
          fromState: n,
          toState: i,
          phaseName: r,
          totalTime: s,
          disabled: !!o,
        }
      }
      function d(t, e, n) {
        let i
        return (
          t instanceof Map
            ? ((i = t.get(e)), i || t.set(e, (i = n)))
            : ((i = t[e]), i || (i = t[e] = n)),
          i
        )
      }
      function p(t) {
        const e = t.indexOf(':')
        return [t.substring(1, e), t.substr(e + 1)]
      }
      let f = (t, e) => !1,
        m = (t, e) => !1,
        g = (t, e, n) => []
      const b = o()
      ;(b || 'undefined' != typeof Element) &&
        ((f = (t, e) => t.contains(e)),
        (m = (() => {
          if (b || Element.prototype.matches) return (t, e) => t.matches(e)
          {
            const t = Element.prototype,
              e =
                t.matchesSelector ||
                t.mozMatchesSelector ||
                t.msMatchesSelector ||
                t.oMatchesSelector ||
                t.webkitMatchesSelector
            return e ? (t, n) => e.apply(t, [n]) : m
          }
        })()),
        (g = (t, e, n) => {
          let i = []
          if (n) {
            const n = t.querySelectorAll(e)
            for (let t = 0; t < n.length; t++) i.push(n[t])
          } else {
            const n = t.querySelector(e)
            n && i.push(n)
          }
          return i
        }))
      let _ = null,
        y = !1
      function v(t) {
        _ ||
          ((_ = ('undefined' != typeof document ? document.body : null) || {}),
          (y = !!_.style && 'WebkitAppearance' in _.style))
        let e = !0
        return (
          _.style &&
            !(function (t) {
              return 'ebkit' == t.substring(1, 6)
            })(t) &&
            ((e = t in _.style), !e && y) &&
            (e = 'Webkit' + t.charAt(0).toUpperCase() + t.substr(1) in _.style),
          e
        )
      }
      const w = m,
        C = f,
        x = g
      function S(t) {
        const e = {}
        return (
          Object.keys(t).forEach((n) => {
            const i = n.replace(/([a-z])([A-Z])/g, '$1-$2')
            e[i] = t[n]
          }),
          e
        )
      }
      let O = (() => {
          class t {
            validateStyleProperty(t) {
              return v(t)
            }
            matchesElement(t, e) {
              return w(t, e)
            }
            containsElement(t, e) {
              return C(t, e)
            }
            query(t, e, n) {
              return x(t, e, n)
            }
            computeStyle(t, e, n) {
              return n || ''
            }
            animate(t, e, n, i, r, o = [], a) {
              return new s.d(n, i)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵprov = i.Hb({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        k = (() => {
          class t {}
          return (t.NOOP = new O()), t
        })()
      const E = 'ng-enter',
        A = 'ng-leave',
        T = 'ng-trigger',
        j = '.ng-trigger',
        I = 'ng-animating',
        P = '.ng-animating'
      function R(t) {
        if ('number' == typeof t) return t
        const e = t.match(/^(-?[\.\d]+)(m?s)/)
        return !e || e.length < 2 ? 0 : D(parseFloat(e[1]), e[2])
      }
      function D(t, e) {
        switch (e) {
          case 's':
            return 1e3 * t
          default:
            return t
        }
      }
      function L(t, e, n) {
        return t.hasOwnProperty('duration')
          ? t
          : (function (t, e, n) {
              let i,
                r = 0,
                s = ''
              if ('string' == typeof t) {
                const n = t.match(
                  /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i
                )
                if (null === n)
                  return (
                    e.push(`The provided timing value "${t}" is invalid.`),
                    { duration: 0, delay: 0, easing: '' }
                  )
                i = D(parseFloat(n[1]), n[2])
                const o = n[3]
                null != o && (r = D(parseFloat(o), n[4]))
                const a = n[5]
                a && (s = a)
              } else i = t
              if (!n) {
                let n = !1,
                  s = e.length
                i < 0 &&
                  (e.push(
                    'Duration values below 0 are not allowed for this animation step.'
                  ),
                  (n = !0)),
                  r < 0 &&
                    (e.push(
                      'Delay values below 0 are not allowed for this animation step.'
                    ),
                    (n = !0)),
                  n &&
                    e.splice(
                      s,
                      0,
                      `The provided timing value "${t}" is invalid.`
                    )
              }
              return { duration: i, delay: r, easing: s }
            })(t, e, n)
      }
      function F(t, e = {}) {
        return (
          Object.keys(t).forEach((n) => {
            e[n] = t[n]
          }),
          e
        )
      }
      function N(t, e, n = {}) {
        if (e) for (let i in t) n[i] = t[i]
        else F(t, n)
        return n
      }
      function M(t, e, n) {
        return n ? e + ':' + n + ';' : ''
      }
      function V(t) {
        let e = ''
        for (let n = 0; n < t.style.length; n++) {
          const i = t.style.item(n)
          e += M(0, i, t.style.getPropertyValue(i))
        }
        for (const n in t.style)
          t.style.hasOwnProperty(n) &&
            !n.startsWith('_') &&
            (e += M(
              0,
              n.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase(),
              t.style[n]
            ))
        t.setAttribute('style', e)
      }
      function U(t, e, n) {
        t.style &&
          (Object.keys(e).forEach((i) => {
            const r = Q(i)
            n && !n.hasOwnProperty(i) && (n[i] = t.style[r]),
              (t.style[r] = e[i])
          }),
          o() && V(t))
      }
      function B(t, e) {
        t.style &&
          (Object.keys(e).forEach((e) => {
            const n = Q(e)
            t.style[n] = ''
          }),
          o() && V(t))
      }
      function z(t) {
        return Array.isArray(t) ? (1 == t.length ? t[0] : Object(s.j)(t)) : t
      }
      const H = new RegExp('{{\\s*(.+?)\\s*}}', 'g')
      function q(t) {
        let e = []
        if ('string' == typeof t) {
          let n
          for (; (n = H.exec(t)); ) e.push(n[1])
          H.lastIndex = 0
        }
        return e
      }
      function W(t, e, n) {
        const i = t.toString(),
          r = i.replace(H, (t, i) => {
            let r = e[i]
            return (
              e.hasOwnProperty(i) ||
                (n.push('Please provide a value for the animation param ' + i),
                (r = '')),
              r.toString()
            )
          })
        return r == i ? t : r
      }
      function $(t) {
        const e = []
        let n = t.next()
        for (; !n.done; ) e.push(n.value), (n = t.next())
        return e
      }
      const G = /-+([a-z0-9])/g
      function Q(t) {
        return t.replace(G, (...t) => t[1].toUpperCase())
      }
      function X(t, e) {
        return 0 === t || 0 === e
      }
      function K(t, e, n) {
        const i = Object.keys(n)
        if (i.length && e.length) {
          let s = e[0],
            o = []
          if (
            (i.forEach((t) => {
              s.hasOwnProperty(t) || o.push(t), (s[t] = n[t])
            }),
            o.length)
          )
            for (var r = 1; r < e.length; r++) {
              let n = e[r]
              o.forEach(function (e) {
                n[e] = Z(t, e)
              })
            }
        }
        return e
      }
      function Y(t, e, n) {
        switch (e.type) {
          case 7:
            return t.visitTrigger(e, n)
          case 0:
            return t.visitState(e, n)
          case 1:
            return t.visitTransition(e, n)
          case 2:
            return t.visitSequence(e, n)
          case 3:
            return t.visitGroup(e, n)
          case 4:
            return t.visitAnimate(e, n)
          case 5:
            return t.visitKeyframes(e, n)
          case 6:
            return t.visitStyle(e, n)
          case 8:
            return t.visitReference(e, n)
          case 9:
            return t.visitAnimateChild(e, n)
          case 10:
            return t.visitAnimateRef(e, n)
          case 11:
            return t.visitQuery(e, n)
          case 12:
            return t.visitStagger(e, n)
          default:
            throw new Error(
              'Unable to resolve animation metadata node #' + e.type
            )
        }
      }
      function Z(t, e) {
        return window.getComputedStyle(t)[e]
      }
      const J = '*'
      function tt(t, e) {
        const n = []
        return (
          'string' == typeof t
            ? t.split(/\s*,\s*/).forEach((t) =>
                (function (t, e, n) {
                  if (':' == t[0]) {
                    const i = (function (t, e) {
                      switch (t) {
                        case ':enter':
                          return 'void => *'
                        case ':leave':
                          return '* => void'
                        case ':increment':
                          return (t, e) => parseFloat(e) > parseFloat(t)
                        case ':decrement':
                          return (t, e) => parseFloat(e) < parseFloat(t)
                        default:
                          return (
                            e.push(
                              `The transition alias value "${t}" is not supported`
                            ),
                            '* => *'
                          )
                      }
                    })(t, n)
                    if ('function' == typeof i) return void e.push(i)
                    t = i
                  }
                  const i = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/)
                  if (null == i || i.length < 4)
                    return (
                      n.push(
                        `The provided transition expression "${t}" is not supported`
                      ),
                      e
                    )
                  const r = i[1],
                    s = i[2],
                    o = i[3]
                  e.push(it(r, o)),
                    '<' != s[0] || (r == J && o == J) || e.push(it(o, r))
                })(t, n, e)
              )
            : n.push(t),
          n
        )
      }
      const et = new Set(['true', '1']),
        nt = new Set(['false', '0'])
      function it(t, e) {
        const n = et.has(t) || nt.has(t),
          i = et.has(e) || nt.has(e)
        return (r, s) => {
          let o = t == J || t == r,
            a = e == J || e == s
          return (
            !o && n && 'boolean' == typeof r && (o = r ? et.has(t) : nt.has(t)),
            !a && i && 'boolean' == typeof s && (a = s ? et.has(e) : nt.has(e)),
            o && a
          )
        }
      }
      const rt = new RegExp('s*:selfs*,?', 'g')
      function st(t, e, n) {
        return new ot(t).build(e, n)
      }
      class ot {
        constructor(t) {
          this._driver = t
        }
        build(t, e) {
          const n = new at(e)
          return this._resetContextStyleTimingState(n), Y(this, z(t), n)
        }
        _resetContextStyleTimingState(t) {
          ;(t.currentQuerySelector = ''),
            (t.collectedStyles = {}),
            (t.collectedStyles[''] = {}),
            (t.currentTime = 0)
        }
        visitTrigger(t, e) {
          let n = (e.queryCount = 0),
            i = (e.depCount = 0)
          const r = [],
            s = []
          return (
            '@' == t.name.charAt(0) &&
              e.errors.push(
                "animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"
              ),
            t.definitions.forEach((t) => {
              if ((this._resetContextStyleTimingState(e), 0 == t.type)) {
                const n = t,
                  i = n.name
                i
                  .toString()
                  .split(/\s*,\s*/)
                  .forEach((t) => {
                    ;(n.name = t), r.push(this.visitState(n, e))
                  }),
                  (n.name = i)
              } else if (1 == t.type) {
                const r = this.visitTransition(t, e)
                ;(n += r.queryCount), (i += r.depCount), s.push(r)
              } else
                e.errors.push(
                  'only state() and transition() definitions can sit inside of a trigger()'
                )
            }),
            {
              type: 7,
              name: t.name,
              states: r,
              transitions: s,
              queryCount: n,
              depCount: i,
              options: null,
            }
          )
        }
        visitState(t, e) {
          const n = this.visitStyle(t.styles, e),
            i = (t.options && t.options.params) || null
          if (n.containsDynamicStyles) {
            const r = new Set(),
              s = i || {}
            if (
              (n.styles.forEach((t) => {
                if (lt(t)) {
                  const e = t
                  Object.keys(e).forEach((t) => {
                    q(e[t]).forEach((t) => {
                      s.hasOwnProperty(t) || r.add(t)
                    })
                  })
                }
              }),
              r.size)
            ) {
              const n = $(r.values())
              e.errors.push(
                `state("${
                  t.name
                }", ...) must define default values for all the following style substitutions: ${n.join(
                  ', '
                )}`
              )
            }
          }
          return {
            type: 0,
            name: t.name,
            style: n,
            options: i ? { params: i } : null,
          }
        }
        visitTransition(t, e) {
          ;(e.queryCount = 0), (e.depCount = 0)
          const n = Y(this, z(t.animation), e)
          return {
            type: 1,
            matchers: tt(t.expr, e.errors),
            animation: n,
            queryCount: e.queryCount,
            depCount: e.depCount,
            options: ct(t.options),
          }
        }
        visitSequence(t, e) {
          return {
            type: 2,
            steps: t.steps.map((t) => Y(this, t, e)),
            options: ct(t.options),
          }
        }
        visitGroup(t, e) {
          const n = e.currentTime
          let i = 0
          const r = t.steps.map((t) => {
            e.currentTime = n
            const r = Y(this, t, e)
            return (i = Math.max(i, e.currentTime)), r
          })
          return (
            (e.currentTime = i), { type: 3, steps: r, options: ct(t.options) }
          )
        }
        visitAnimate(t, e) {
          const n = (function (t, e) {
            let n = null
            if (t.hasOwnProperty('duration')) n = t
            else if ('number' == typeof t) return ut(L(t, e).duration, 0, '')
            const i = t
            if (
              i
                .split(/\s+/)
                .some((t) => '{' == t.charAt(0) && '{' == t.charAt(1))
            ) {
              const t = ut(0, 0, '')
              return (t.dynamic = !0), (t.strValue = i), t
            }
            return (n = n || L(i, e)), ut(n.duration, n.delay, n.easing)
          })(t.timings, e.errors)
          let i
          e.currentAnimateTimings = n
          let r = t.styles ? t.styles : Object(s.l)({})
          if (5 == r.type) i = this.visitKeyframes(r, e)
          else {
            let r = t.styles,
              o = !1
            if (!r) {
              o = !0
              const t = {}
              n.easing && (t.easing = n.easing), (r = Object(s.l)(t))
            }
            e.currentTime += n.duration + n.delay
            const a = this.visitStyle(r, e)
            ;(a.isEmptyStep = o), (i = a)
          }
          return (
            (e.currentAnimateTimings = null),
            { type: 4, timings: n, style: i, options: null }
          )
        }
        visitStyle(t, e) {
          const n = this._makeStyleAst(t, e)
          return this._validateStyleAst(n, e), n
        }
        _makeStyleAst(t, e) {
          const n = []
          Array.isArray(t.styles)
            ? t.styles.forEach((t) => {
                'string' == typeof t
                  ? t == s.a
                    ? n.push(t)
                    : e.errors.push(
                        `The provided style string value ${t} is not allowed.`
                      )
                  : n.push(t)
              })
            : n.push(t.styles)
          let i = !1,
            r = null
          return (
            n.forEach((t) => {
              if (lt(t)) {
                const e = t,
                  n = e.easing
                if ((n && ((r = n), delete e.easing), !i))
                  for (let t in e)
                    if (e[t].toString().indexOf('{{') >= 0) {
                      i = !0
                      break
                    }
              }
            }),
            {
              type: 6,
              styles: n,
              easing: r,
              offset: t.offset,
              containsDynamicStyles: i,
              options: null,
            }
          )
        }
        _validateStyleAst(t, e) {
          const n = e.currentAnimateTimings
          let i = e.currentTime,
            r = e.currentTime
          n && r > 0 && (r -= n.duration + n.delay),
            t.styles.forEach((t) => {
              'string' != typeof t &&
                Object.keys(t).forEach((n) => {
                  if (!this._driver.validateStyleProperty(n))
                    return void e.errors.push(
                      `The provided animation property "${n}" is not a supported CSS property for animations`
                    )
                  const s = e.collectedStyles[e.currentQuerySelector],
                    o = s[n]
                  let a = !0
                  o &&
                    (r != i &&
                      r >= o.startTime &&
                      i <= o.endTime &&
                      (e.errors.push(
                        `The CSS property "${n}" that exists between the times of "${o.startTime}ms" and "${o.endTime}ms" is also being animated in a parallel animation between the times of "${r}ms" and "${i}ms"`
                      ),
                      (a = !1)),
                    (r = o.startTime)),
                    a && (s[n] = { startTime: r, endTime: i }),
                    e.options &&
                      (function (t, e, n) {
                        const i = e.params || {},
                          r = q(t)
                        r.length &&
                          r.forEach((t) => {
                            i.hasOwnProperty(t) ||
                              n.push(
                                `Unable to resolve the local animation param ${t} in the given list of values`
                              )
                          })
                      })(t[n], e.options, e.errors)
                })
            })
        }
        visitKeyframes(t, e) {
          const n = { type: 5, styles: [], options: null }
          if (!e.currentAnimateTimings)
            return (
              e.errors.push(
                'keyframes() must be placed inside of a call to animate()'
              ),
              n
            )
          let i = 0
          const r = []
          let s = !1,
            o = !1,
            a = 0
          const l = t.steps.map((t) => {
            const n = this._makeStyleAst(t, e)
            let l =
                null != n.offset
                  ? n.offset
                  : (function (t) {
                      if ('string' == typeof t) return null
                      let e = null
                      if (Array.isArray(t))
                        t.forEach((t) => {
                          if (lt(t) && t.hasOwnProperty('offset')) {
                            const n = t
                            ;(e = parseFloat(n.offset)), delete n.offset
                          }
                        })
                      else if (lt(t) && t.hasOwnProperty('offset')) {
                        const n = t
                        ;(e = parseFloat(n.offset)), delete n.offset
                      }
                      return e
                    })(n.styles),
              c = 0
            return (
              null != l && (i++, (c = n.offset = l)),
              (o = o || c < 0 || c > 1),
              (s = s || c < a),
              (a = c),
              r.push(c),
              n
            )
          })
          o &&
            e.errors.push(
              'Please ensure that all keyframe offsets are between 0 and 1'
            ),
            s &&
              e.errors.push(
                'Please ensure that all keyframe offsets are in order'
              )
          const c = t.steps.length
          let u = 0
          i > 0 && i < c
            ? e.errors.push(
                'Not all style() steps within the declared keyframes() contain offsets'
              )
            : 0 == i && (u = 1 / (c - 1))
          const h = c - 1,
            d = e.currentTime,
            p = e.currentAnimateTimings,
            f = p.duration
          return (
            l.forEach((t, i) => {
              const s = u > 0 ? (i == h ? 1 : u * i) : r[i],
                o = s * f
              ;(e.currentTime = d + p.delay + o),
                (p.duration = o),
                this._validateStyleAst(t, e),
                (t.offset = s),
                n.styles.push(t)
            }),
            n
          )
        }
        visitReference(t, e) {
          return {
            type: 8,
            animation: Y(this, z(t.animation), e),
            options: ct(t.options),
          }
        }
        visitAnimateChild(t, e) {
          return e.depCount++, { type: 9, options: ct(t.options) }
        }
        visitAnimateRef(t, e) {
          return {
            type: 10,
            animation: this.visitReference(t.animation, e),
            options: ct(t.options),
          }
        }
        visitQuery(t, e) {
          const n = e.currentQuerySelector,
            i = t.options || {}
          e.queryCount++, (e.currentQuery = t)
          const [r, s] = (function (t) {
            const e = !!t.split(/\s*,\s*/).find((t) => ':self' == t)
            return (
              e && (t = t.replace(rt, '')),
              [
                (t = t
                  .replace(/@\*/g, j)
                  .replace(/@\w+/g, (t) => '.ng-trigger-' + t.substr(1))
                  .replace(/:animating/g, P)),
                e,
              ]
            )
          })(t.selector)
          ;(e.currentQuerySelector = n.length ? n + ' ' + r : r),
            d(e.collectedStyles, e.currentQuerySelector, {})
          const o = Y(this, z(t.animation), e)
          return (
            (e.currentQuery = null),
            (e.currentQuerySelector = n),
            {
              type: 11,
              selector: r,
              limit: i.limit || 0,
              optional: !!i.optional,
              includeSelf: s,
              animation: o,
              originalSelector: t.selector,
              options: ct(t.options),
            }
          )
        }
        visitStagger(t, e) {
          e.currentQuery ||
            e.errors.push('stagger() can only be used inside of query()')
          const n =
            'full' === t.timings
              ? { duration: 0, delay: 0, easing: 'full' }
              : L(t.timings, e.errors, !0)
          return {
            type: 12,
            animation: Y(this, z(t.animation), e),
            timings: n,
            options: null,
          }
        }
      }
      class at {
        constructor(t) {
          ;(this.errors = t),
            (this.queryCount = 0),
            (this.depCount = 0),
            (this.currentTransition = null),
            (this.currentQuery = null),
            (this.currentQuerySelector = null),
            (this.currentAnimateTimings = null),
            (this.currentTime = 0),
            (this.collectedStyles = {}),
            (this.options = null)
        }
      }
      function lt(t) {
        return !Array.isArray(t) && 'object' == typeof t
      }
      function ct(t) {
        var e
        return (
          t
            ? (t = F(t)).params && (t.params = (e = t.params) ? F(e) : null)
            : (t = {}),
          t
        )
      }
      function ut(t, e, n) {
        return { duration: t, delay: e, easing: n }
      }
      function ht(t, e, n, i, r, s, o = null, a = !1) {
        return {
          type: 1,
          element: t,
          keyframes: e,
          preStyleProps: n,
          postStyleProps: i,
          duration: r,
          delay: s,
          totalTime: r + s,
          easing: o,
          subTimeline: a,
        }
      }
      class dt {
        constructor() {
          this._map = new Map()
        }
        consume(t) {
          let e = this._map.get(t)
          return e ? this._map.delete(t) : (e = []), e
        }
        append(t, e) {
          let n = this._map.get(t)
          n || this._map.set(t, (n = [])), n.push(...e)
        }
        has(t) {
          return this._map.has(t)
        }
        clear() {
          this._map.clear()
        }
      }
      const pt = new RegExp(':enter', 'g'),
        ft = new RegExp(':leave', 'g')
      function mt(t, e, n, i, r, s = {}, o = {}, a, l, c = []) {
        return new gt().buildKeyframes(t, e, n, i, r, s, o, a, l, c)
      }
      class gt {
        buildKeyframes(t, e, n, i, r, s, o, a, l, c = []) {
          l = l || new dt()
          const u = new _t(t, e, l, i, r, c, [])
          ;(u.options = a),
            u.currentTimeline.setStyles([s], null, u.errors, a),
            Y(this, n, u)
          const h = u.timelines.filter((t) => t.containsAnimation())
          if (h.length && Object.keys(o).length) {
            const t = h[h.length - 1]
            t.allowOnlyTimelineStyles() || t.setStyles([o], null, u.errors, a)
          }
          return h.length
            ? h.map((t) => t.buildKeyframes())
            : [ht(e, [], [], [], 0, 0, '', !1)]
        }
        visitTrigger(t, e) {}
        visitState(t, e) {}
        visitTransition(t, e) {}
        visitAnimateChild(t, e) {
          const n = e.subInstructions.consume(e.element)
          if (n) {
            const i = e.createSubContext(t.options),
              r = e.currentTimeline.currentTime,
              s = this._visitSubInstructions(n, i, i.options)
            r != s && e.transformIntoNewTimeline(s)
          }
          e.previousNode = t
        }
        visitAnimateRef(t, e) {
          const n = e.createSubContext(t.options)
          n.transformIntoNewTimeline(),
            this.visitReference(t.animation, n),
            e.transformIntoNewTimeline(n.currentTimeline.currentTime),
            (e.previousNode = t)
        }
        _visitSubInstructions(t, e, n) {
          let i = e.currentTimeline.currentTime
          const r = null != n.duration ? R(n.duration) : null,
            s = null != n.delay ? R(n.delay) : null
          return (
            0 !== r &&
              t.forEach((t) => {
                const n = e.appendInstructionToTimeline(t, r, s)
                i = Math.max(i, n.duration + n.delay)
              }),
            i
          )
        }
        visitReference(t, e) {
          e.updateOptions(t.options, !0),
            Y(this, t.animation, e),
            (e.previousNode = t)
        }
        visitSequence(t, e) {
          const n = e.subContextCount
          let i = e
          const r = t.options
          if (
            r &&
            (r.params || r.delay) &&
            ((i = e.createSubContext(r)),
            i.transformIntoNewTimeline(),
            null != r.delay)
          ) {
            6 == i.previousNode.type &&
              (i.currentTimeline.snapshotCurrentStyles(), (i.previousNode = bt))
            const t = R(r.delay)
            i.delayNextStep(t)
          }
          t.steps.length &&
            (t.steps.forEach((t) => Y(this, t, i)),
            i.currentTimeline.applyStylesToKeyframe(),
            i.subContextCount > n && i.transformIntoNewTimeline()),
            (e.previousNode = t)
        }
        visitGroup(t, e) {
          const n = []
          let i = e.currentTimeline.currentTime
          const r = t.options && t.options.delay ? R(t.options.delay) : 0
          t.steps.forEach((s) => {
            const o = e.createSubContext(t.options)
            r && o.delayNextStep(r),
              Y(this, s, o),
              (i = Math.max(i, o.currentTimeline.currentTime)),
              n.push(o.currentTimeline)
          }),
            n.forEach((t) => e.currentTimeline.mergeTimelineCollectedStyles(t)),
            e.transformIntoNewTimeline(i),
            (e.previousNode = t)
        }
        _visitTiming(t, e) {
          if (t.dynamic) {
            const n = t.strValue
            return L(e.params ? W(n, e.params, e.errors) : n, e.errors)
          }
          return { duration: t.duration, delay: t.delay, easing: t.easing }
        }
        visitAnimate(t, e) {
          const n = (e.currentAnimateTimings = this._visitTiming(t.timings, e)),
            i = e.currentTimeline
          n.delay && (e.incrementTime(n.delay), i.snapshotCurrentStyles())
          const r = t.style
          5 == r.type
            ? this.visitKeyframes(r, e)
            : (e.incrementTime(n.duration),
              this.visitStyle(r, e),
              i.applyStylesToKeyframe()),
            (e.currentAnimateTimings = null),
            (e.previousNode = t)
        }
        visitStyle(t, e) {
          const n = e.currentTimeline,
            i = e.currentAnimateTimings
          !i && n.getCurrentStyleProperties().length && n.forwardFrame()
          const r = (i && i.easing) || t.easing
          t.isEmptyStep
            ? n.applyEmptyStep(r)
            : n.setStyles(t.styles, r, e.errors, e.options),
            (e.previousNode = t)
        }
        visitKeyframes(t, e) {
          const n = e.currentAnimateTimings,
            i = e.currentTimeline.duration,
            r = n.duration,
            s = e.createSubContext().currentTimeline
          ;(s.easing = n.easing),
            t.styles.forEach((t) => {
              s.forwardTime((t.offset || 0) * r),
                s.setStyles(t.styles, t.easing, e.errors, e.options),
                s.applyStylesToKeyframe()
            }),
            e.currentTimeline.mergeTimelineCollectedStyles(s),
            e.transformIntoNewTimeline(i + r),
            (e.previousNode = t)
        }
        visitQuery(t, e) {
          const n = e.currentTimeline.currentTime,
            i = t.options || {},
            r = i.delay ? R(i.delay) : 0
          r &&
            (6 === e.previousNode.type ||
              (0 == n &&
                e.currentTimeline.getCurrentStyleProperties().length)) &&
            (e.currentTimeline.snapshotCurrentStyles(), (e.previousNode = bt))
          let s = n
          const o = e.invokeQuery(
            t.selector,
            t.originalSelector,
            t.limit,
            t.includeSelf,
            !!i.optional,
            e.errors
          )
          e.currentQueryTotal = o.length
          let a = null
          o.forEach((n, i) => {
            e.currentQueryIndex = i
            const o = e.createSubContext(t.options, n)
            r && o.delayNextStep(r),
              n === e.element && (a = o.currentTimeline),
              Y(this, t.animation, o),
              o.currentTimeline.applyStylesToKeyframe(),
              (s = Math.max(s, o.currentTimeline.currentTime))
          }),
            (e.currentQueryIndex = 0),
            (e.currentQueryTotal = 0),
            e.transformIntoNewTimeline(s),
            a &&
              (e.currentTimeline.mergeTimelineCollectedStyles(a),
              e.currentTimeline.snapshotCurrentStyles()),
            (e.previousNode = t)
        }
        visitStagger(t, e) {
          const n = e.parentContext,
            i = e.currentTimeline,
            r = t.timings,
            s = Math.abs(r.duration),
            o = s * (e.currentQueryTotal - 1)
          let a = s * e.currentQueryIndex
          switch (r.duration < 0 ? 'reverse' : r.easing) {
            case 'reverse':
              a = o - a
              break
            case 'full':
              a = n.currentStaggerTime
          }
          const l = e.currentTimeline
          a && l.delayNextStep(a)
          const c = l.currentTime
          Y(this, t.animation, e),
            (e.previousNode = t),
            (n.currentStaggerTime =
              i.currentTime - c + (i.startTime - n.currentTimeline.startTime))
        }
      }
      const bt = {}
      class _t {
        constructor(t, e, n, i, r, s, o, a) {
          ;(this._driver = t),
            (this.element = e),
            (this.subInstructions = n),
            (this._enterClassName = i),
            (this._leaveClassName = r),
            (this.errors = s),
            (this.timelines = o),
            (this.parentContext = null),
            (this.currentAnimateTimings = null),
            (this.previousNode = bt),
            (this.subContextCount = 0),
            (this.options = {}),
            (this.currentQueryIndex = 0),
            (this.currentQueryTotal = 0),
            (this.currentStaggerTime = 0),
            (this.currentTimeline = a || new yt(this._driver, e, 0)),
            o.push(this.currentTimeline)
        }
        get params() {
          return this.options.params
        }
        updateOptions(t, e) {
          if (!t) return
          const n = t
          let i = this.options
          null != n.duration && (i.duration = R(n.duration)),
            null != n.delay && (i.delay = R(n.delay))
          const r = n.params
          if (r) {
            let t = i.params
            t || (t = this.options.params = {}),
              Object.keys(r).forEach((n) => {
                ;(e && t.hasOwnProperty(n)) || (t[n] = W(r[n], t, this.errors))
              })
          }
        }
        _copyOptions() {
          const t = {}
          if (this.options) {
            const e = this.options.params
            if (e) {
              const n = (t.params = {})
              Object.keys(e).forEach((t) => {
                n[t] = e[t]
              })
            }
          }
          return t
        }
        createSubContext(t = null, e, n) {
          const i = e || this.element,
            r = new _t(
              this._driver,
              i,
              this.subInstructions,
              this._enterClassName,
              this._leaveClassName,
              this.errors,
              this.timelines,
              this.currentTimeline.fork(i, n || 0)
            )
          return (
            (r.previousNode = this.previousNode),
            (r.currentAnimateTimings = this.currentAnimateTimings),
            (r.options = this._copyOptions()),
            r.updateOptions(t),
            (r.currentQueryIndex = this.currentQueryIndex),
            (r.currentQueryTotal = this.currentQueryTotal),
            (r.parentContext = this),
            this.subContextCount++,
            r
          )
        }
        transformIntoNewTimeline(t) {
          return (
            (this.previousNode = bt),
            (this.currentTimeline = this.currentTimeline.fork(this.element, t)),
            this.timelines.push(this.currentTimeline),
            this.currentTimeline
          )
        }
        appendInstructionToTimeline(t, e, n) {
          const i = {
              duration: null != e ? e : t.duration,
              delay:
                this.currentTimeline.currentTime +
                (null != n ? n : 0) +
                t.delay,
              easing: '',
            },
            r = new vt(
              this._driver,
              t.element,
              t.keyframes,
              t.preStyleProps,
              t.postStyleProps,
              i,
              t.stretchStartingKeyframe
            )
          return this.timelines.push(r), i
        }
        incrementTime(t) {
          this.currentTimeline.forwardTime(this.currentTimeline.duration + t)
        }
        delayNextStep(t) {
          t > 0 && this.currentTimeline.delayNextStep(t)
        }
        invokeQuery(t, e, n, i, r, s) {
          let o = []
          if ((i && o.push(this.element), t.length > 0)) {
            t = (t = t.replace(pt, '.' + this._enterClassName)).replace(
              ft,
              '.' + this._leaveClassName
            )
            let e = this._driver.query(this.element, t, 1 != n)
            0 !== n &&
              (e = n < 0 ? e.slice(e.length + n, e.length) : e.slice(0, n)),
              o.push(...e)
          }
          return (
            r ||
              0 != o.length ||
              s.push(
                `\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`
              ),
            o
          )
        }
      }
      class yt {
        constructor(t, e, n, i) {
          ;(this._driver = t),
            (this.element = e),
            (this.startTime = n),
            (this._elementTimelineStylesLookup = i),
            (this.duration = 0),
            (this._previousKeyframe = {}),
            (this._currentKeyframe = {}),
            (this._keyframes = new Map()),
            (this._styleSummary = {}),
            (this._pendingStyles = {}),
            (this._backFill = {}),
            (this._currentEmptyStepKeyframe = null),
            this._elementTimelineStylesLookup ||
              (this._elementTimelineStylesLookup = new Map()),
            (this._localTimelineStyles = Object.create(this._backFill, {})),
            (this._globalTimelineStyles = this._elementTimelineStylesLookup.get(
              e
            )),
            this._globalTimelineStyles ||
              ((this._globalTimelineStyles = this._localTimelineStyles),
              this._elementTimelineStylesLookup.set(
                e,
                this._localTimelineStyles
              )),
            this._loadKeyframe()
        }
        containsAnimation() {
          switch (this._keyframes.size) {
            case 0:
              return !1
            case 1:
              return this.getCurrentStyleProperties().length > 0
            default:
              return !0
          }
        }
        getCurrentStyleProperties() {
          return Object.keys(this._currentKeyframe)
        }
        get currentTime() {
          return this.startTime + this.duration
        }
        delayNextStep(t) {
          const e =
            1 == this._keyframes.size && Object.keys(this._pendingStyles).length
          this.duration || e
            ? (this.forwardTime(this.currentTime + t),
              e && this.snapshotCurrentStyles())
            : (this.startTime += t)
        }
        fork(t, e) {
          return (
            this.applyStylesToKeyframe(),
            new yt(
              this._driver,
              t,
              e || this.currentTime,
              this._elementTimelineStylesLookup
            )
          )
        }
        _loadKeyframe() {
          this._currentKeyframe &&
            (this._previousKeyframe = this._currentKeyframe),
            (this._currentKeyframe = this._keyframes.get(this.duration)),
            this._currentKeyframe ||
              ((this._currentKeyframe = Object.create(this._backFill, {})),
              this._keyframes.set(this.duration, this._currentKeyframe))
        }
        forwardFrame() {
          ;(this.duration += 1), this._loadKeyframe()
        }
        forwardTime(t) {
          this.applyStylesToKeyframe(),
            (this.duration = t),
            this._loadKeyframe()
        }
        _updateStyle(t, e) {
          ;(this._localTimelineStyles[t] = e),
            (this._globalTimelineStyles[t] = e),
            (this._styleSummary[t] = { time: this.currentTime, value: e })
        }
        allowOnlyTimelineStyles() {
          return this._currentEmptyStepKeyframe !== this._currentKeyframe
        }
        applyEmptyStep(t) {
          t && (this._previousKeyframe.easing = t),
            Object.keys(this._globalTimelineStyles).forEach((t) => {
              ;(this._backFill[t] = this._globalTimelineStyles[t] || s.a),
                (this._currentKeyframe[t] = s.a)
            }),
            (this._currentEmptyStepKeyframe = this._currentKeyframe)
        }
        setStyles(t, e, n, i) {
          e && (this._previousKeyframe.easing = e)
          const r = (i && i.params) || {},
            o = (function (t, e) {
              const n = {}
              let i
              return (
                t.forEach((t) => {
                  '*' === t
                    ? ((i = i || Object.keys(e)),
                      i.forEach((t) => {
                        n[t] = s.a
                      }))
                    : N(t, !1, n)
                }),
                n
              )
            })(t, this._globalTimelineStyles)
          Object.keys(o).forEach((t) => {
            const e = W(o[t], r, n)
            ;(this._pendingStyles[t] = e),
              this._localTimelineStyles.hasOwnProperty(t) ||
                (this._backFill[t] = this._globalTimelineStyles.hasOwnProperty(
                  t
                )
                  ? this._globalTimelineStyles[t]
                  : s.a),
              this._updateStyle(t, e)
          })
        }
        applyStylesToKeyframe() {
          const t = this._pendingStyles,
            e = Object.keys(t)
          0 != e.length &&
            ((this._pendingStyles = {}),
            e.forEach((e) => {
              this._currentKeyframe[e] = t[e]
            }),
            Object.keys(this._localTimelineStyles).forEach((t) => {
              this._currentKeyframe.hasOwnProperty(t) ||
                (this._currentKeyframe[t] = this._localTimelineStyles[t])
            }))
        }
        snapshotCurrentStyles() {
          Object.keys(this._localTimelineStyles).forEach((t) => {
            const e = this._localTimelineStyles[t]
            ;(this._pendingStyles[t] = e), this._updateStyle(t, e)
          })
        }
        getFinalKeyframe() {
          return this._keyframes.get(this.duration)
        }
        get properties() {
          const t = []
          for (let e in this._currentKeyframe) t.push(e)
          return t
        }
        mergeTimelineCollectedStyles(t) {
          Object.keys(t._styleSummary).forEach((e) => {
            const n = this._styleSummary[e],
              i = t._styleSummary[e]
            ;(!n || i.time > n.time) && this._updateStyle(e, i.value)
          })
        }
        buildKeyframes() {
          this.applyStylesToKeyframe()
          const t = new Set(),
            e = new Set(),
            n = 1 === this._keyframes.size && 0 === this.duration
          let i = []
          this._keyframes.forEach((r, o) => {
            const a = N(r, !0)
            Object.keys(a).forEach((n) => {
              const i = a[n]
              i == s.p ? t.add(n) : i == s.a && e.add(n)
            }),
              n || (a.offset = o / this.duration),
              i.push(a)
          })
          const r = t.size ? $(t.values()) : [],
            o = e.size ? $(e.values()) : []
          if (n) {
            const t = i[0],
              e = F(t)
            ;(t.offset = 0), (e.offset = 1), (i = [t, e])
          }
          return ht(
            this.element,
            i,
            r,
            o,
            this.duration,
            this.startTime,
            this.easing,
            !1
          )
        }
      }
      class vt extends yt {
        constructor(t, e, n, i, r, s, o = !1) {
          super(t, e, s.delay),
            (this.element = e),
            (this.keyframes = n),
            (this.preStyleProps = i),
            (this.postStyleProps = r),
            (this._stretchStartingKeyframe = o),
            (this.timings = {
              duration: s.duration,
              delay: s.delay,
              easing: s.easing,
            })
        }
        containsAnimation() {
          return this.keyframes.length > 1
        }
        buildKeyframes() {
          let t = this.keyframes,
            { delay: e, duration: n, easing: i } = this.timings
          if (this._stretchStartingKeyframe && e) {
            const r = [],
              s = n + e,
              o = e / s,
              a = N(t[0], !1)
            ;(a.offset = 0), r.push(a)
            const l = N(t[0], !1)
            ;(l.offset = wt(o)), r.push(l)
            const c = t.length - 1
            for (let i = 1; i <= c; i++) {
              let o = N(t[i], !1)
              ;(o.offset = wt((e + o.offset * n) / s)), r.push(o)
            }
            ;(n = s), (e = 0), (i = ''), (t = r)
          }
          return ht(
            this.element,
            t,
            this.preStyleProps,
            this.postStyleProps,
            n,
            e,
            i,
            !0
          )
        }
      }
      function wt(t, e = 3) {
        const n = Math.pow(10, e - 1)
        return Math.round(t * n) / n
      }
      class Ct {}
      class xt extends Ct {
        normalizePropertyName(t, e) {
          return Q(t)
        }
        normalizeStyleValue(t, e, n, i) {
          let r = ''
          const s = n.toString().trim()
          if (St[e] && 0 !== n && '0' !== n)
            if ('number' == typeof n) r = 'px'
            else {
              const e = n.match(/^[+-]?[\d\.]+([a-z]*)$/)
              e &&
                0 == e[1].length &&
                i.push(`Please provide a CSS unit value for ${t}:${n}`)
            }
          return s + r
        }
      }
      const St = (() =>
        (function (t) {
          const e = {}
          return t.forEach((t) => (e[t] = !0)), e
        })(
          'width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective'.split(
            ','
          )
        ))()
      function Ot(t, e, n, i, r, s, o, a, l, c, u, h, d) {
        return {
          type: 0,
          element: t,
          triggerName: e,
          isRemovalTransition: r,
          fromState: n,
          fromStyles: s,
          toState: i,
          toStyles: o,
          timelines: a,
          queriedElements: l,
          preStyleProps: c,
          postStyleProps: u,
          totalTime: h,
          errors: d,
        }
      }
      const kt = {}
      class Et {
        constructor(t, e, n) {
          ;(this._triggerName = t), (this.ast = e), (this._stateStyles = n)
        }
        match(t, e, n, i) {
          return (function (t, e, n, i, r) {
            return t.some((t) => t(e, n, i, r))
          })(this.ast.matchers, t, e, n, i)
        }
        buildStyles(t, e, n) {
          const i = this._stateStyles['*'],
            r = this._stateStyles[t],
            s = i ? i.buildStyles(e, n) : {}
          return r ? r.buildStyles(e, n) : s
        }
        build(t, e, n, i, r, s, o, a, l, c) {
          const u = [],
            h = (this.ast.options && this.ast.options.params) || kt,
            p = this.buildStyles(n, (o && o.params) || kt, u),
            f = (a && a.params) || kt,
            m = this.buildStyles(i, f, u),
            g = new Set(),
            b = new Map(),
            _ = new Map(),
            y = 'void' === i,
            v = { params: Object.assign(Object.assign({}, h), f) },
            w = c ? [] : mt(t, e, this.ast.animation, r, s, p, m, v, l, u)
          let C = 0
          if (
            (w.forEach((t) => {
              C = Math.max(t.duration + t.delay, C)
            }),
            u.length)
          )
            return Ot(e, this._triggerName, n, i, y, p, m, [], [], b, _, C, u)
          w.forEach((t) => {
            const n = t.element,
              i = d(b, n, {})
            t.preStyleProps.forEach((t) => (i[t] = !0))
            const r = d(_, n, {})
            t.postStyleProps.forEach((t) => (r[t] = !0)), n !== e && g.add(n)
          })
          const x = $(g.values())
          return Ot(e, this._triggerName, n, i, y, p, m, w, x, b, _, C)
        }
      }
      class At {
        constructor(t, e) {
          ;(this.styles = t), (this.defaultParams = e)
        }
        buildStyles(t, e) {
          const n = {},
            i = F(this.defaultParams)
          return (
            Object.keys(t).forEach((e) => {
              const n = t[e]
              null != n && (i[e] = n)
            }),
            this.styles.styles.forEach((t) => {
              if ('string' != typeof t) {
                const r = t
                Object.keys(r).forEach((t) => {
                  let s = r[t]
                  s.length > 1 && (s = W(s, i, e)), (n[t] = s)
                })
              }
            }),
            n
          )
        }
      }
      class Tt {
        constructor(t, e) {
          ;(this.name = t),
            (this.ast = e),
            (this.transitionFactories = []),
            (this.states = {}),
            e.states.forEach((t) => {
              this.states[t.name] = new At(
                t.style,
                (t.options && t.options.params) || {}
              )
            }),
            jt(this.states, 'true', '1'),
            jt(this.states, 'false', '0'),
            e.transitions.forEach((e) => {
              this.transitionFactories.push(new Et(t, e, this.states))
            }),
            (this.fallbackTransition = new Et(
              t,
              {
                type: 1,
                animation: { type: 2, steps: [], options: null },
                matchers: [(t, e) => !0],
                options: null,
                queryCount: 0,
                depCount: 0,
              },
              this.states
            ))
        }
        get containsQueries() {
          return this.ast.queryCount > 0
        }
        matchTransition(t, e, n, i) {
          return (
            this.transitionFactories.find((r) => r.match(t, e, n, i)) || null
          )
        }
        matchStyles(t, e, n) {
          return this.fallbackTransition.buildStyles(t, e, n)
        }
      }
      function jt(t, e, n) {
        t.hasOwnProperty(e)
          ? t.hasOwnProperty(n) || (t[n] = t[e])
          : t.hasOwnProperty(n) && (t[e] = t[n])
      }
      const It = new dt()
      class Pt {
        constructor(t, e, n) {
          ;(this.bodyNode = t),
            (this._driver = e),
            (this._normalizer = n),
            (this._animations = {}),
            (this._playersById = {}),
            (this.players = [])
        }
        register(t, e) {
          const n = [],
            i = st(this._driver, e, n)
          if (n.length)
            throw new Error(
              'Unable to build the animation due to the following errors: ' +
                n.join('\n')
            )
          this._animations[t] = i
        }
        _buildPlayer(t, e, n) {
          const i = t.element,
            r = l(0, this._normalizer, 0, t.keyframes, e, n)
          return this._driver.animate(
            i,
            r,
            t.duration,
            t.delay,
            t.easing,
            [],
            !0
          )
        }
        create(t, e, n = {}) {
          const i = [],
            r = this._animations[t]
          let o
          const l = new Map()
          if (
            (r
              ? ((o = mt(this._driver, e, r, E, A, {}, {}, n, It, i)),
                o.forEach((t) => {
                  const e = d(l, t.element, {})
                  t.postStyleProps.forEach((t) => (e[t] = null))
                }))
              : (i.push(
                  "The requested animation doesn't exist or has already been destroyed"
                ),
                (o = [])),
            i.length)
          )
            throw new Error(
              'Unable to create the animation due to the following errors: ' +
                i.join('\n')
            )
          l.forEach((t, e) => {
            Object.keys(t).forEach((n) => {
              t[n] = this._driver.computeStyle(e, n, s.a)
            })
          })
          const c = a(
            o.map((t) => {
              const e = l.get(t.element)
              return this._buildPlayer(t, {}, e)
            })
          )
          return (
            (this._playersById[t] = c),
            c.onDestroy(() => this.destroy(t)),
            this.players.push(c),
            c
          )
        }
        destroy(t) {
          const e = this._getPlayer(t)
          e.destroy(), delete this._playersById[t]
          const n = this.players.indexOf(e)
          n >= 0 && this.players.splice(n, 1)
        }
        _getPlayer(t) {
          const e = this._playersById[t]
          if (!e)
            throw new Error(
              'Unable to find the timeline player referenced by ' + t
            )
          return e
        }
        listen(t, e, n, i) {
          const r = h(e, '', '', '')
          return c(this._getPlayer(t), n, r, i), () => {}
        }
        command(t, e, n, i) {
          if ('register' == n) return void this.register(t, i[0])
          if ('create' == n) return void this.create(t, e, i[0] || {})
          const r = this._getPlayer(t)
          switch (n) {
            case 'play':
              r.play()
              break
            case 'pause':
              r.pause()
              break
            case 'reset':
              r.reset()
              break
            case 'restart':
              r.restart()
              break
            case 'finish':
              r.finish()
              break
            case 'init':
              r.init()
              break
            case 'setPosition':
              r.setPosition(parseFloat(i[0]))
              break
            case 'destroy':
              this.destroy(t)
          }
        }
      }
      const Rt = 'ng-animate-queued',
        Dt = 'ng-animate-disabled',
        Lt = '.ng-animate-disabled',
        Ft = [],
        Nt = {
          namespaceId: '',
          setForRemoval: !1,
          setForMove: !1,
          hasAnimation: !1,
          removedBeforeQueried: !1,
        },
        Mt = {
          namespaceId: '',
          setForMove: !1,
          setForRemoval: !1,
          hasAnimation: !1,
          removedBeforeQueried: !0,
        }
      class Vt {
        constructor(t, e = '') {
          this.namespaceId = e
          const n = t && t.hasOwnProperty('value')
          if (((this.value = null != (i = n ? t.value : t) ? i : null), n)) {
            const e = F(t)
            delete e.value, (this.options = e)
          } else this.options = {}
          var i
          this.options.params || (this.options.params = {})
        }
        get params() {
          return this.options.params
        }
        absorbOptions(t) {
          const e = t.params
          if (e) {
            const t = this.options.params
            Object.keys(e).forEach((n) => {
              null == t[n] && (t[n] = e[n])
            })
          }
        }
      }
      const Ut = 'void',
        Bt = new Vt(Ut)
      class zt {
        constructor(t, e, n) {
          ;(this.id = t),
            (this.hostElement = e),
            (this._engine = n),
            (this.players = []),
            (this._triggers = {}),
            (this._queue = []),
            (this._elementListeners = new Map()),
            (this._hostClassName = 'ng-tns-' + t),
            Xt(e, this._hostClassName)
        }
        listen(t, e, n, i) {
          if (!this._triggers.hasOwnProperty(e))
            throw new Error(
              `Unable to listen on the animation trigger event "${n}" because the animation trigger "${e}" doesn't exist!`
            )
          if (null == n || 0 == n.length)
            throw new Error(
              `Unable to listen on the animation trigger "${e}" because the provided event is undefined!`
            )
          if ('start' != (r = n) && 'done' != r)
            throw new Error(
              `The provided animation trigger event "${n}" for the animation trigger "${e}" is not supported!`
            )
          var r
          const s = d(this._elementListeners, t, []),
            o = { name: e, phase: n, callback: i }
          s.push(o)
          const a = d(this._engine.statesByElement, t, {})
          return (
            a.hasOwnProperty(e) ||
              (Xt(t, T), Xt(t, 'ng-trigger-' + e), (a[e] = Bt)),
            () => {
              this._engine.afterFlush(() => {
                const t = s.indexOf(o)
                t >= 0 && s.splice(t, 1), this._triggers[e] || delete a[e]
              })
            }
          )
        }
        register(t, e) {
          return !this._triggers[t] && ((this._triggers[t] = e), !0)
        }
        _getTrigger(t) {
          const e = this._triggers[t]
          if (!e)
            throw new Error(
              `The provided animation trigger "${t}" has not been registered!`
            )
          return e
        }
        trigger(t, e, n, i = !0) {
          const r = this._getTrigger(e),
            s = new qt(this.id, e, t)
          let o = this._engine.statesByElement.get(t)
          o ||
            (Xt(t, T),
            Xt(t, 'ng-trigger-' + e),
            this._engine.statesByElement.set(t, (o = {})))
          let a = o[e]
          const l = new Vt(n, this.id)
          if (
            (!(n && n.hasOwnProperty('value')) &&
              a &&
              l.absorbOptions(a.options),
            (o[e] = l),
            a || (a = Bt),
            l.value !== Ut && a.value === l.value)
          ) {
            if (
              !(function (t, e) {
                const n = Object.keys(t),
                  i = Object.keys(e)
                if (n.length != i.length) return !1
                for (let r = 0; r < n.length; r++) {
                  const i = n[r]
                  if (!e.hasOwnProperty(i) || t[i] !== e[i]) return !1
                }
                return !0
              })(a.params, l.params)
            ) {
              const e = [],
                n = r.matchStyles(a.value, a.params, e),
                i = r.matchStyles(l.value, l.params, e)
              e.length
                ? this._engine.reportError(e)
                : this._engine.afterFlush(() => {
                    B(t, n), U(t, i)
                  })
            }
            return
          }
          const c = d(this._engine.playersByElement, t, [])
          c.forEach((t) => {
            t.namespaceId == this.id &&
              t.triggerName == e &&
              t.queued &&
              t.destroy()
          })
          let u = r.matchTransition(a.value, l.value, t, l.params),
            h = !1
          if (!u) {
            if (!i) return
            ;(u = r.fallbackTransition), (h = !0)
          }
          return (
            this._engine.totalQueuedPlayers++,
            this._queue.push({
              element: t,
              triggerName: e,
              transition: u,
              fromState: a,
              toState: l,
              player: s,
              isFallbackTransition: h,
            }),
            h ||
              (Xt(t, Rt),
              s.onStart(() => {
                Kt(t, Rt)
              })),
            s.onDone(() => {
              let e = this.players.indexOf(s)
              e >= 0 && this.players.splice(e, 1)
              const n = this._engine.playersByElement.get(t)
              if (n) {
                let t = n.indexOf(s)
                t >= 0 && n.splice(t, 1)
              }
            }),
            this.players.push(s),
            c.push(s),
            s
          )
        }
        deregister(t) {
          delete this._triggers[t],
            this._engine.statesByElement.forEach((e, n) => {
              delete e[t]
            }),
            this._elementListeners.forEach((e, n) => {
              this._elementListeners.set(
                n,
                e.filter((e) => e.name != t)
              )
            })
        }
        clearElementCache(t) {
          this._engine.statesByElement.delete(t),
            this._elementListeners.delete(t)
          const e = this._engine.playersByElement.get(t)
          e &&
            (e.forEach((t) => t.destroy()),
            this._engine.playersByElement.delete(t))
        }
        _signalRemovalForInnerTriggers(t, e) {
          const n = this._engine.driver.query(t, j, !0)
          n.forEach((t) => {
            if (t.__ng_removed) return
            const n = this._engine.fetchNamespacesByElement(t)
            n.size
              ? n.forEach((n) => n.triggerLeaveAnimation(t, e, !1, !0))
              : this.clearElementCache(t)
          }),
            this._engine.afterFlushAnimationsDone(() =>
              n.forEach((t) => this.clearElementCache(t))
            )
        }
        triggerLeaveAnimation(t, e, n, i) {
          const r = this._engine.statesByElement.get(t)
          if (r) {
            const s = []
            if (
              (Object.keys(r).forEach((e) => {
                if (this._triggers[e]) {
                  const n = this.trigger(t, e, Ut, i)
                  n && s.push(n)
                }
              }),
              s.length)
            )
              return (
                this._engine.markElementAsRemoved(this.id, t, !0, e),
                n && a(s).onDone(() => this._engine.processLeaveNode(t)),
                !0
              )
          }
          return !1
        }
        prepareLeaveAnimationListeners(t) {
          const e = this._elementListeners.get(t)
          if (e) {
            const n = new Set()
            e.forEach((e) => {
              const i = e.name
              if (n.has(i)) return
              n.add(i)
              const r = this._triggers[i].fallbackTransition,
                s = this._engine.statesByElement.get(t)[i] || Bt,
                o = new Vt(Ut),
                a = new qt(this.id, i, t)
              this._engine.totalQueuedPlayers++,
                this._queue.push({
                  element: t,
                  triggerName: i,
                  transition: r,
                  fromState: s,
                  toState: o,
                  player: a,
                  isFallbackTransition: !0,
                })
            })
          }
        }
        removeNode(t, e) {
          const n = this._engine
          if (
            (t.childElementCount && this._signalRemovalForInnerTriggers(t, e),
            this.triggerLeaveAnimation(t, e, !0))
          )
            return
          let i = !1
          if (n.totalAnimations) {
            const e = n.players.length ? n.playersByQueriedElement.get(t) : []
            if (e && e.length) i = !0
            else {
              let e = t
              for (; (e = e.parentNode); )
                if (n.statesByElement.get(e)) {
                  i = !0
                  break
                }
            }
          }
          if ((this.prepareLeaveAnimationListeners(t), i))
            n.markElementAsRemoved(this.id, t, !1, e)
          else {
            const i = t.__ng_removed
            ;(i && i !== Nt) ||
              (n.afterFlush(() => this.clearElementCache(t)),
              n.destroyInnerAnimations(t),
              n._onRemovalComplete(t, e))
          }
        }
        insertNode(t, e) {
          Xt(t, this._hostClassName)
        }
        drainQueuedTransitions(t) {
          const e = []
          return (
            this._queue.forEach((n) => {
              const i = n.player
              if (i.destroyed) return
              const r = n.element,
                s = this._elementListeners.get(r)
              s &&
                s.forEach((e) => {
                  if (e.name == n.triggerName) {
                    const i = h(
                      r,
                      n.triggerName,
                      n.fromState.value,
                      n.toState.value
                    )
                    ;(i._data = t), c(n.player, e.phase, i, e.callback)
                  }
                }),
                i.markedForDestroy
                  ? this._engine.afterFlush(() => {
                      i.destroy()
                    })
                  : e.push(n)
            }),
            (this._queue = []),
            e.sort((t, e) => {
              const n = t.transition.ast.depCount,
                i = e.transition.ast.depCount
              return 0 == n || 0 == i
                ? n - i
                : this._engine.driver.containsElement(t.element, e.element)
                ? 1
                : -1
            })
          )
        }
        destroy(t) {
          this.players.forEach((t) => t.destroy()),
            this._signalRemovalForInnerTriggers(this.hostElement, t)
        }
        elementContainsData(t) {
          let e = !1
          return (
            this._elementListeners.has(t) && (e = !0),
            (e = !!this._queue.find((e) => e.element === t) || e),
            e
          )
        }
      }
      class Ht {
        constructor(t, e, n) {
          ;(this.bodyNode = t),
            (this.driver = e),
            (this._normalizer = n),
            (this.players = []),
            (this.newHostElements = new Map()),
            (this.playersByElement = new Map()),
            (this.playersByQueriedElement = new Map()),
            (this.statesByElement = new Map()),
            (this.disabledNodes = new Set()),
            (this.totalAnimations = 0),
            (this.totalQueuedPlayers = 0),
            (this._namespaceLookup = {}),
            (this._namespaceList = []),
            (this._flushFns = []),
            (this._whenQuietFns = []),
            (this.namespacesByHostElement = new Map()),
            (this.collectedEnterElements = []),
            (this.collectedLeaveElements = []),
            (this.onRemovalComplete = (t, e) => {})
        }
        _onRemovalComplete(t, e) {
          this.onRemovalComplete(t, e)
        }
        get queuedPlayers() {
          const t = []
          return (
            this._namespaceList.forEach((e) => {
              e.players.forEach((e) => {
                e.queued && t.push(e)
              })
            }),
            t
          )
        }
        createNamespace(t, e) {
          const n = new zt(t, e, this)
          return (
            e.parentNode
              ? this._balanceNamespaceList(n, e)
              : (this.newHostElements.set(e, n), this.collectEnterElement(e)),
            (this._namespaceLookup[t] = n)
          )
        }
        _balanceNamespaceList(t, e) {
          const n = this._namespaceList.length - 1
          if (n >= 0) {
            let i = !1
            for (let r = n; r >= 0; r--)
              if (
                this.driver.containsElement(
                  this._namespaceList[r].hostElement,
                  e
                )
              ) {
                this._namespaceList.splice(r + 1, 0, t), (i = !0)
                break
              }
            i || this._namespaceList.splice(0, 0, t)
          } else this._namespaceList.push(t)
          return this.namespacesByHostElement.set(e, t), t
        }
        register(t, e) {
          let n = this._namespaceLookup[t]
          return n || (n = this.createNamespace(t, e)), n
        }
        registerTrigger(t, e, n) {
          let i = this._namespaceLookup[t]
          i && i.register(e, n) && this.totalAnimations++
        }
        destroy(t, e) {
          if (!t) return
          const n = this._fetchNamespace(t)
          this.afterFlush(() => {
            this.namespacesByHostElement.delete(n.hostElement),
              delete this._namespaceLookup[t]
            const e = this._namespaceList.indexOf(n)
            e >= 0 && this._namespaceList.splice(e, 1)
          }),
            this.afterFlushAnimationsDone(() => n.destroy(e))
        }
        _fetchNamespace(t) {
          return this._namespaceLookup[t]
        }
        fetchNamespacesByElement(t) {
          const e = new Set(),
            n = this.statesByElement.get(t)
          if (n) {
            const t = Object.keys(n)
            for (let i = 0; i < t.length; i++) {
              const r = n[t[i]].namespaceId
              if (r) {
                const t = this._fetchNamespace(r)
                t && e.add(t)
              }
            }
          }
          return e
        }
        trigger(t, e, n, i) {
          if (Wt(e)) {
            const r = this._fetchNamespace(t)
            if (r) return r.trigger(e, n, i), !0
          }
          return !1
        }
        insertNode(t, e, n, i) {
          if (!Wt(e)) return
          const r = e.__ng_removed
          if (r && r.setForRemoval) {
            ;(r.setForRemoval = !1), (r.setForMove = !0)
            const t = this.collectedLeaveElements.indexOf(e)
            t >= 0 && this.collectedLeaveElements.splice(t, 1)
          }
          if (t) {
            const i = this._fetchNamespace(t)
            i && i.insertNode(e, n)
          }
          i && this.collectEnterElement(e)
        }
        collectEnterElement(t) {
          this.collectedEnterElements.push(t)
        }
        markElementAsDisabled(t, e) {
          e
            ? this.disabledNodes.has(t) ||
              (this.disabledNodes.add(t), Xt(t, Dt))
            : this.disabledNodes.has(t) &&
              (this.disabledNodes.delete(t), Kt(t, Dt))
        }
        removeNode(t, e, n, i) {
          if (Wt(e)) {
            const r = t ? this._fetchNamespace(t) : null
            if (
              (r ? r.removeNode(e, i) : this.markElementAsRemoved(t, e, !1, i),
              n)
            ) {
              const n = this.namespacesByHostElement.get(e)
              n && n.id !== t && n.removeNode(e, i)
            }
          } else this._onRemovalComplete(e, i)
        }
        markElementAsRemoved(t, e, n, i) {
          this.collectedLeaveElements.push(e),
            (e.__ng_removed = {
              namespaceId: t,
              setForRemoval: i,
              hasAnimation: n,
              removedBeforeQueried: !1,
            })
        }
        listen(t, e, n, i, r) {
          return Wt(e) ? this._fetchNamespace(t).listen(e, n, i, r) : () => {}
        }
        _buildInstruction(t, e, n, i, r) {
          return t.transition.build(
            this.driver,
            t.element,
            t.fromState.value,
            t.toState.value,
            n,
            i,
            t.fromState.options,
            t.toState.options,
            e,
            r
          )
        }
        destroyInnerAnimations(t) {
          let e = this.driver.query(t, j, !0)
          e.forEach((t) => this.destroyActiveAnimationsForElement(t)),
            0 != this.playersByQueriedElement.size &&
              ((e = this.driver.query(t, P, !0)),
              e.forEach((t) => this.finishActiveQueriedAnimationOnElement(t)))
        }
        destroyActiveAnimationsForElement(t) {
          const e = this.playersByElement.get(t)
          e &&
            e.forEach((t) => {
              t.queued ? (t.markedForDestroy = !0) : t.destroy()
            })
        }
        finishActiveQueriedAnimationOnElement(t) {
          const e = this.playersByQueriedElement.get(t)
          e && e.forEach((t) => t.finish())
        }
        whenRenderingDone() {
          return new Promise((t) => {
            if (this.players.length) return a(this.players).onDone(() => t())
            t()
          })
        }
        processLeaveNode(t) {
          const e = t.__ng_removed
          if (e && e.setForRemoval) {
            if (((t.__ng_removed = Nt), e.namespaceId)) {
              this.destroyInnerAnimations(t)
              const n = this._fetchNamespace(e.namespaceId)
              n && n.clearElementCache(t)
            }
            this._onRemovalComplete(t, e.setForRemoval)
          }
          this.driver.matchesElement(t, Lt) &&
            this.markElementAsDisabled(t, !1),
            this.driver.query(t, Lt, !0).forEach((t) => {
              this.markElementAsDisabled(t, !1)
            })
        }
        flush(t = -1) {
          let e = []
          if (
            (this.newHostElements.size &&
              (this.newHostElements.forEach((t, e) =>
                this._balanceNamespaceList(t, e)
              ),
              this.newHostElements.clear()),
            this.totalAnimations && this.collectedEnterElements.length)
          )
            for (let n = 0; n < this.collectedEnterElements.length; n++)
              Xt(this.collectedEnterElements[n], 'ng-star-inserted')
          if (
            this._namespaceList.length &&
            (this.totalQueuedPlayers || this.collectedLeaveElements.length)
          ) {
            const n = []
            try {
              e = this._flushAnimations(n, t)
            } finally {
              for (let t = 0; t < n.length; t++) n[t]()
            }
          } else
            for (let n = 0; n < this.collectedLeaveElements.length; n++)
              this.processLeaveNode(this.collectedLeaveElements[n])
          if (
            ((this.totalQueuedPlayers = 0),
            (this.collectedEnterElements.length = 0),
            (this.collectedLeaveElements.length = 0),
            this._flushFns.forEach((t) => t()),
            (this._flushFns = []),
            this._whenQuietFns.length)
          ) {
            const t = this._whenQuietFns
            ;(this._whenQuietFns = []),
              e.length
                ? a(e).onDone(() => {
                    t.forEach((t) => t())
                  })
                : t.forEach((t) => t())
          }
        }
        reportError(t) {
          throw new Error(
            'Unable to process animations due to the following failed trigger transitions\n ' +
              t.join('\n')
          )
        }
        _flushAnimations(t, e) {
          const n = new dt(),
            i = [],
            r = new Map(),
            o = [],
            l = new Map(),
            c = new Map(),
            u = new Map(),
            h = new Set()
          this.disabledNodes.forEach((t) => {
            h.add(t)
            const e = this.driver.query(t, '.ng-animate-queued', !0)
            for (let n = 0; n < e.length; n++) h.add(e[n])
          })
          const p = this.bodyNode,
            f = Array.from(this.statesByElement.keys()),
            m = Qt(f, this.collectedEnterElements),
            g = new Map()
          let b = 0
          m.forEach((t, e) => {
            const n = E + b++
            g.set(e, n), t.forEach((t) => Xt(t, n))
          })
          const _ = [],
            y = new Set(),
            v = new Set()
          for (let s = 0; s < this.collectedLeaveElements.length; s++) {
            const t = this.collectedLeaveElements[s],
              e = t.__ng_removed
            e &&
              e.setForRemoval &&
              (_.push(t),
              y.add(t),
              e.hasAnimation
                ? this.driver
                    .query(t, '.ng-star-inserted', !0)
                    .forEach((t) => y.add(t))
                : v.add(t))
          }
          const w = new Map(),
            C = Qt(f, Array.from(y))
          C.forEach((t, e) => {
            const n = A + b++
            w.set(e, n), t.forEach((t) => Xt(t, n))
          }),
            t.push(() => {
              m.forEach((t, e) => {
                const n = g.get(e)
                t.forEach((t) => Kt(t, n))
              }),
                C.forEach((t, e) => {
                  const n = w.get(e)
                  t.forEach((t) => Kt(t, n))
                }),
                _.forEach((t) => {
                  this.processLeaveNode(t)
                })
            })
          const x = [],
            S = []
          for (let s = this._namespaceList.length - 1; s >= 0; s--)
            this._namespaceList[s].drainQueuedTransitions(e).forEach((t) => {
              const e = t.player,
                r = t.element
              if ((x.push(e), this.collectedEnterElements.length)) {
                const t = r.__ng_removed
                if (t && t.setForMove) return void e.destroy()
              }
              const s = !p || !this.driver.containsElement(p, r),
                a = w.get(r),
                h = g.get(r),
                f = this._buildInstruction(t, n, h, a, s)
              if (f.errors && f.errors.length) S.push(f)
              else {
                if (s)
                  return (
                    e.onStart(() => B(r, f.fromStyles)),
                    e.onDestroy(() => U(r, f.toStyles)),
                    void i.push(e)
                  )
                if (t.isFallbackTransition)
                  return (
                    e.onStart(() => B(r, f.fromStyles)),
                    e.onDestroy(() => U(r, f.toStyles)),
                    void i.push(e)
                  )
                f.timelines.forEach((t) => (t.stretchStartingKeyframe = !0)),
                  n.append(r, f.timelines),
                  o.push({ instruction: f, player: e, element: r }),
                  f.queriedElements.forEach((t) => d(l, t, []).push(e)),
                  f.preStyleProps.forEach((t, e) => {
                    const n = Object.keys(t)
                    if (n.length) {
                      let t = c.get(e)
                      t || c.set(e, (t = new Set())), n.forEach((e) => t.add(e))
                    }
                  }),
                  f.postStyleProps.forEach((t, e) => {
                    const n = Object.keys(t)
                    let i = u.get(e)
                    i || u.set(e, (i = new Set())), n.forEach((t) => i.add(t))
                  })
              }
            })
          if (S.length) {
            const t = []
            S.forEach((e) => {
              t.push(`@${e.triggerName} has failed due to:\n`),
                e.errors.forEach((e) => t.push(`- ${e}\n`))
            }),
              x.forEach((t) => t.destroy()),
              this.reportError(t)
          }
          const O = new Map(),
            k = new Map()
          o.forEach((t) => {
            const e = t.element
            n.has(e) &&
              (k.set(e, e),
              this._beforeAnimationBuild(
                t.player.namespaceId,
                t.instruction,
                O
              ))
          }),
            i.forEach((t) => {
              const e = t.element
              this._getPreviousPlayers(
                e,
                !1,
                t.namespaceId,
                t.triggerName,
                null
              ).forEach((t) => {
                d(O, e, []).push(t), t.destroy()
              })
            })
          const T = _.filter((t) => Jt(t, c, u)),
            j = new Map()
          Gt(j, this.driver, v, u, s.a).forEach((t) => {
            Jt(t, c, u) && T.push(t)
          })
          const I = new Map()
          m.forEach((t, e) => {
            Gt(I, this.driver, new Set(t), c, s.p)
          }),
            T.forEach((t) => {
              const e = j.get(t),
                n = I.get(t)
              j.set(t, Object.assign(Object.assign({}, e), n))
            })
          const R = [],
            D = [],
            L = {}
          o.forEach((t) => {
            const { element: e, player: s, instruction: o } = t
            if (n.has(e)) {
              if (h.has(e))
                return (
                  s.onDestroy(() => U(e, o.toStyles)),
                  (s.disabled = !0),
                  s.overrideTotalTime(o.totalTime),
                  void i.push(s)
                )
              let t = L
              if (k.size > 1) {
                let n = e
                const i = []
                for (; (n = n.parentNode); ) {
                  const e = k.get(n)
                  if (e) {
                    t = e
                    break
                  }
                  i.push(n)
                }
                i.forEach((e) => k.set(e, t))
              }
              const n = this._buildAnimation(s.namespaceId, o, O, r, I, j)
              if ((s.setRealPlayer(n), t === L)) R.push(s)
              else {
                const e = this.playersByElement.get(t)
                e && e.length && (s.parentPlayer = a(e)), i.push(s)
              }
            } else
              B(e, o.fromStyles),
                s.onDestroy(() => U(e, o.toStyles)),
                D.push(s),
                h.has(e) && i.push(s)
          }),
            D.forEach((t) => {
              const e = r.get(t.element)
              if (e && e.length) {
                const n = a(e)
                t.setRealPlayer(n)
              }
            }),
            i.forEach((t) => {
              t.parentPlayer ? t.syncPlayerEvents(t.parentPlayer) : t.destroy()
            })
          for (let s = 0; s < _.length; s++) {
            const t = _[s],
              e = t.__ng_removed
            if ((Kt(t, A), e && e.hasAnimation)) continue
            let n = []
            if (l.size) {
              let e = l.get(t)
              e && e.length && n.push(...e)
              let i = this.driver.query(t, P, !0)
              for (let t = 0; t < i.length; t++) {
                let e = l.get(i[t])
                e && e.length && n.push(...e)
              }
            }
            const i = n.filter((t) => !t.destroyed)
            i.length ? Yt(this, t, i) : this.processLeaveNode(t)
          }
          return (
            (_.length = 0),
            R.forEach((t) => {
              this.players.push(t),
                t.onDone(() => {
                  t.destroy()
                  const e = this.players.indexOf(t)
                  this.players.splice(e, 1)
                }),
                t.play()
            }),
            R
          )
        }
        elementContainsData(t, e) {
          let n = !1
          const i = e.__ng_removed
          return (
            i && i.setForRemoval && (n = !0),
            this.playersByElement.has(e) && (n = !0),
            this.playersByQueriedElement.has(e) && (n = !0),
            this.statesByElement.has(e) && (n = !0),
            this._fetchNamespace(t).elementContainsData(e) || n
          )
        }
        afterFlush(t) {
          this._flushFns.push(t)
        }
        afterFlushAnimationsDone(t) {
          this._whenQuietFns.push(t)
        }
        _getPreviousPlayers(t, e, n, i, r) {
          let s = []
          if (e) {
            const e = this.playersByQueriedElement.get(t)
            e && (s = e)
          } else {
            const e = this.playersByElement.get(t)
            if (e) {
              const t = !r || r == Ut
              e.forEach((e) => {
                e.queued || ((t || e.triggerName == i) && s.push(e))
              })
            }
          }
          return (
            (n || i) &&
              (s = s.filter(
                (t) => !((n && n != t.namespaceId) || (i && i != t.triggerName))
              )),
            s
          )
        }
        _beforeAnimationBuild(t, e, n) {
          const i = e.element,
            r = e.isRemovalTransition ? void 0 : t,
            s = e.isRemovalTransition ? void 0 : e.triggerName
          for (const o of e.timelines) {
            const t = o.element,
              a = t !== i,
              l = d(n, t, [])
            this._getPreviousPlayers(t, a, r, s, e.toState).forEach((t) => {
              const e = t.getRealPlayer()
              e.beforeDestroy && e.beforeDestroy(), t.destroy(), l.push(t)
            })
          }
          B(i, e.fromStyles)
        }
        _buildAnimation(t, e, n, i, r, o) {
          const c = e.triggerName,
            u = e.element,
            h = [],
            p = new Set(),
            f = new Set(),
            m = e.timelines.map((e) => {
              const a = e.element
              p.add(a)
              const d = a.__ng_removed
              if (d && d.removedBeforeQueried)
                return new s.d(e.duration, e.delay)
              const m = a !== u,
                g = (function (t) {
                  const e = []
                  return Zt(t, e), e
                })((n.get(a) || Ft).map((t) => t.getRealPlayer())).filter(
                  (t) => !!t.element && t.element === a
                ),
                b = r.get(a),
                _ = o.get(a),
                y = l(0, this._normalizer, 0, e.keyframes, b, _),
                v = this._buildPlayer(e, y, g)
              if ((e.subTimeline && i && f.add(a), m)) {
                const e = new qt(t, c, a)
                e.setRealPlayer(v), h.push(e)
              }
              return v
            })
          h.forEach((t) => {
            d(this.playersByQueriedElement, t.element, []).push(t),
              t.onDone(() =>
                (function (t, e, n) {
                  let i
                  if (t instanceof Map) {
                    if (((i = t.get(e)), i)) {
                      if (i.length) {
                        const t = i.indexOf(n)
                        i.splice(t, 1)
                      }
                      0 == i.length && t.delete(e)
                    }
                  } else if (((i = t[e]), i)) {
                    if (i.length) {
                      const t = i.indexOf(n)
                      i.splice(t, 1)
                    }
                    0 == i.length && delete t[e]
                  }
                  return i
                })(this.playersByQueriedElement, t.element, t)
              )
          }),
            p.forEach((t) => Xt(t, I))
          const g = a(m)
          return (
            g.onDestroy(() => {
              p.forEach((t) => Kt(t, I)), U(u, e.toStyles)
            }),
            f.forEach((t) => {
              d(i, t, []).push(g)
            }),
            g
          )
        }
        _buildPlayer(t, e, n) {
          return e.length > 0
            ? this.driver.animate(
                t.element,
                e,
                t.duration,
                t.delay,
                t.easing,
                n
              )
            : new s.d(t.duration, t.delay)
        }
      }
      class qt {
        constructor(t, e, n) {
          ;(this.namespaceId = t),
            (this.triggerName = e),
            (this.element = n),
            (this._player = new s.d()),
            (this._containsRealPlayer = !1),
            (this._queuedCallbacks = {}),
            (this.destroyed = !1),
            (this.markedForDestroy = !1),
            (this.disabled = !1),
            (this.queued = !0),
            (this.totalTime = 0)
        }
        setRealPlayer(t) {
          this._containsRealPlayer ||
            ((this._player = t),
            Object.keys(this._queuedCallbacks).forEach((e) => {
              this._queuedCallbacks[e].forEach((n) => c(t, e, void 0, n))
            }),
            (this._queuedCallbacks = {}),
            (this._containsRealPlayer = !0),
            this.overrideTotalTime(t.totalTime),
            (this.queued = !1))
        }
        getRealPlayer() {
          return this._player
        }
        overrideTotalTime(t) {
          this.totalTime = t
        }
        syncPlayerEvents(t) {
          const e = this._player
          e.triggerCallback && t.onStart(() => e.triggerCallback('start')),
            t.onDone(() => this.finish()),
            t.onDestroy(() => this.destroy())
        }
        _queueEvent(t, e) {
          d(this._queuedCallbacks, t, []).push(e)
        }
        onDone(t) {
          this.queued && this._queueEvent('done', t), this._player.onDone(t)
        }
        onStart(t) {
          this.queued && this._queueEvent('start', t), this._player.onStart(t)
        }
        onDestroy(t) {
          this.queued && this._queueEvent('destroy', t),
            this._player.onDestroy(t)
        }
        init() {
          this._player.init()
        }
        hasStarted() {
          return !this.queued && this._player.hasStarted()
        }
        play() {
          !this.queued && this._player.play()
        }
        pause() {
          !this.queued && this._player.pause()
        }
        restart() {
          !this.queued && this._player.restart()
        }
        finish() {
          this._player.finish()
        }
        destroy() {
          ;(this.destroyed = !0), this._player.destroy()
        }
        reset() {
          !this.queued && this._player.reset()
        }
        setPosition(t) {
          this.queued || this._player.setPosition(t)
        }
        getPosition() {
          return this.queued ? 0 : this._player.getPosition()
        }
        triggerCallback(t) {
          const e = this._player
          e.triggerCallback && e.triggerCallback(t)
        }
      }
      function Wt(t) {
        return t && 1 === t.nodeType
      }
      function $t(t, e) {
        const n = t.style.display
        return (t.style.display = null != e ? e : 'none'), n
      }
      function Gt(t, e, n, i, r) {
        const s = []
        n.forEach((t) => s.push($t(t)))
        const o = []
        i.forEach((n, i) => {
          const s = {}
          n.forEach((t) => {
            const n = (s[t] = e.computeStyle(i, t, r))
            ;(n && 0 != n.length) || ((i.__ng_removed = Mt), o.push(i))
          }),
            t.set(i, s)
        })
        let a = 0
        return n.forEach((t) => $t(t, s[a++])), o
      }
      function Qt(t, e) {
        const n = new Map()
        if ((t.forEach((t) => n.set(t, [])), 0 == e.length)) return n
        const i = new Set(e),
          r = new Map()
        function s(t) {
          if (!t) return 1
          let e = r.get(t)
          if (e) return e
          const o = t.parentNode
          return (e = n.has(o) ? o : i.has(o) ? 1 : s(o)), r.set(t, e), e
        }
        return (
          e.forEach((t) => {
            const e = s(t)
            1 !== e && n.get(e).push(t)
          }),
          n
        )
      }
      function Xt(t, e) {
        if (t.classList) t.classList.add(e)
        else {
          let n = t.$$classes
          n || (n = t.$$classes = {}), (n[e] = !0)
        }
      }
      function Kt(t, e) {
        if (t.classList) t.classList.remove(e)
        else {
          let n = t.$$classes
          n && delete n[e]
        }
      }
      function Yt(t, e, n) {
        a(n).onDone(() => t.processLeaveNode(e))
      }
      function Zt(t, e) {
        for (let n = 0; n < t.length; n++) {
          const i = t[n]
          i instanceof s.o ? Zt(i.players, e) : e.push(i)
        }
      }
      function Jt(t, e, n) {
        const i = n.get(t)
        if (!i) return !1
        let r = e.get(t)
        return r ? i.forEach((t) => r.add(t)) : e.set(t, i), n.delete(t), !0
      }
      class te {
        constructor(t, e, n) {
          ;(this.bodyNode = t),
            (this._driver = e),
            (this._triggerCache = {}),
            (this.onRemovalComplete = (t, e) => {}),
            (this._transitionEngine = new Ht(t, e, n)),
            (this._timelineEngine = new Pt(t, e, n)),
            (this._transitionEngine.onRemovalComplete = (t, e) =>
              this.onRemovalComplete(t, e))
        }
        registerTrigger(t, e, n, i, r) {
          const s = t + '-' + i
          let o = this._triggerCache[s]
          if (!o) {
            const t = [],
              e = st(this._driver, r, t)
            if (t.length)
              throw new Error(
                `The animation trigger "${i}" has failed to build due to the following errors:\n - ${t.join(
                  '\n - '
                )}`
              )
            ;(o = (function (t, e) {
              return new Tt(t, e)
            })(i, e)),
              (this._triggerCache[s] = o)
          }
          this._transitionEngine.registerTrigger(e, i, o)
        }
        register(t, e) {
          this._transitionEngine.register(t, e)
        }
        destroy(t, e) {
          this._transitionEngine.destroy(t, e)
        }
        onInsert(t, e, n, i) {
          this._transitionEngine.insertNode(t, e, n, i)
        }
        onRemove(t, e, n, i) {
          this._transitionEngine.removeNode(t, e, i || !1, n)
        }
        disableAnimations(t, e) {
          this._transitionEngine.markElementAsDisabled(t, e)
        }
        process(t, e, n, i) {
          if ('@' == n.charAt(0)) {
            const [t, r] = p(n)
            this._timelineEngine.command(t, e, r, i)
          } else this._transitionEngine.trigger(t, e, n, i)
        }
        listen(t, e, n, i, r) {
          if ('@' == n.charAt(0)) {
            const [t, i] = p(n)
            return this._timelineEngine.listen(t, e, i, r)
          }
          return this._transitionEngine.listen(t, e, n, i, r)
        }
        flush(t = -1) {
          this._transitionEngine.flush(t)
        }
        get players() {
          return this._transitionEngine.players.concat(
            this._timelineEngine.players
          )
        }
        whenRenderingDone() {
          return this._transitionEngine.whenRenderingDone()
        }
      }
      function ee(t, e) {
        let n = null,
          i = null
        return (
          Array.isArray(e) && e.length
            ? ((n = ie(e[0])), e.length > 1 && (i = ie(e[e.length - 1])))
            : e && (n = ie(e)),
          n || i ? new ne(t, n, i) : null
        )
      }
      let ne = (() => {
        class t {
          constructor(e, n, i) {
            ;(this._element = e),
              (this._startStyles = n),
              (this._endStyles = i),
              (this._state = 0)
            let r = t.initialStylesByElement.get(e)
            r || t.initialStylesByElement.set(e, (r = {})),
              (this._initialStyles = r)
          }
          start() {
            this._state < 1 &&
              (this._startStyles &&
                U(this._element, this._startStyles, this._initialStyles),
              (this._state = 1))
          }
          finish() {
            this.start(),
              this._state < 2 &&
                (U(this._element, this._initialStyles),
                this._endStyles &&
                  (U(this._element, this._endStyles), (this._endStyles = null)),
                (this._state = 1))
          }
          destroy() {
            this.finish(),
              this._state < 3 &&
                (t.initialStylesByElement.delete(this._element),
                this._startStyles &&
                  (B(this._element, this._startStyles),
                  (this._endStyles = null)),
                this._endStyles &&
                  (B(this._element, this._endStyles), (this._endStyles = null)),
                U(this._element, this._initialStyles),
                (this._state = 3))
          }
        }
        return (t.initialStylesByElement = new WeakMap()), t
      })()
      function ie(t) {
        let e = null
        const n = Object.keys(t)
        for (let i = 0; i < n.length; i++) {
          const r = n[i]
          re(r) && ((e = e || {}), (e[r] = t[r]))
        }
        return e
      }
      function re(t) {
        return 'display' === t || 'position' === t
      }
      const se = 'animation',
        oe = 'animationend'
      class ae {
        constructor(t, e, n, i, r, s, o) {
          ;(this._element = t),
            (this._name = e),
            (this._duration = n),
            (this._delay = i),
            (this._easing = r),
            (this._fillMode = s),
            (this._onDoneFn = o),
            (this._finished = !1),
            (this._destroyed = !1),
            (this._startTime = 0),
            (this._position = 0),
            (this._eventFn = (t) => this._handleCallback(t))
        }
        apply() {
          !(function (t, e) {
            const n = pe(t, '').trim()
            n.length &&
              ((function (t, e) {
                let n = 0
                for (let i = 0; i < t.length; i++) ',' === t.charAt(i) && n++
              })(n),
              (e = `${n}, ${e}`)),
              de(t, '', e)
          })(
            this._element,
            `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`
          ),
            he(this._element, this._eventFn, !1),
            (this._startTime = Date.now())
        }
        pause() {
          le(this._element, this._name, 'paused')
        }
        resume() {
          le(this._element, this._name, 'running')
        }
        setPosition(t) {
          const e = ce(this._element, this._name)
          ;(this._position = t * this._duration),
            de(this._element, 'Delay', `-${this._position}ms`, e)
        }
        getPosition() {
          return this._position
        }
        _handleCallback(t) {
          const e = t._ngTestManualTimestamp || Date.now(),
            n = 1e3 * parseFloat(t.elapsedTime.toFixed(3))
          t.animationName == this._name &&
            Math.max(e - this._startTime, 0) >= this._delay &&
            n >= this._duration &&
            this.finish()
        }
        finish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFn(),
            he(this._element, this._eventFn, !0))
        }
        destroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this.finish(),
            (function (t, e) {
              const n = pe(t, '').split(','),
                i = ue(n, e)
              i >= 0 && (n.splice(i, 1), de(t, '', n.join(',')))
            })(this._element, this._name))
        }
      }
      function le(t, e, n) {
        de(t, 'PlayState', n, ce(t, e))
      }
      function ce(t, e) {
        const n = pe(t, '')
        return n.indexOf(',') > 0 ? ue(n.split(','), e) : ue([n], e)
      }
      function ue(t, e) {
        for (let n = 0; n < t.length; n++) if (t[n].indexOf(e) >= 0) return n
        return -1
      }
      function he(t, e, n) {
        n ? t.removeEventListener(oe, e) : t.addEventListener(oe, e)
      }
      function de(t, e, n, i) {
        const r = se + e
        if (null != i) {
          const e = t.style[r]
          if (e.length) {
            const t = e.split(',')
            ;(t[i] = n), (n = t.join(','))
          }
        }
        t.style[r] = n
      }
      function pe(t, e) {
        return t.style[se + e] || ''
      }
      class fe {
        constructor(t, e, n, i, r, s, o, a) {
          ;(this.element = t),
            (this.keyframes = e),
            (this.animationName = n),
            (this._duration = i),
            (this._delay = r),
            (this._finalStyles = o),
            (this._specialStyles = a),
            (this._onDoneFns = []),
            (this._onStartFns = []),
            (this._onDestroyFns = []),
            (this._started = !1),
            (this.currentSnapshot = {}),
            (this._state = 0),
            (this.easing = s || 'linear'),
            (this.totalTime = i + r),
            this._buildStyler()
        }
        onStart(t) {
          this._onStartFns.push(t)
        }
        onDone(t) {
          this._onDoneFns.push(t)
        }
        onDestroy(t) {
          this._onDestroyFns.push(t)
        }
        destroy() {
          this.init(),
            this._state >= 4 ||
              ((this._state = 4),
              this._styler.destroy(),
              this._flushStartFns(),
              this._flushDoneFns(),
              this._specialStyles && this._specialStyles.destroy(),
              this._onDestroyFns.forEach((t) => t()),
              (this._onDestroyFns = []))
        }
        _flushDoneFns() {
          this._onDoneFns.forEach((t) => t()), (this._onDoneFns = [])
        }
        _flushStartFns() {
          this._onStartFns.forEach((t) => t()), (this._onStartFns = [])
        }
        finish() {
          this.init(),
            this._state >= 3 ||
              ((this._state = 3),
              this._styler.finish(),
              this._flushStartFns(),
              this._specialStyles && this._specialStyles.finish(),
              this._flushDoneFns())
        }
        setPosition(t) {
          this._styler.setPosition(t)
        }
        getPosition() {
          return this._styler.getPosition()
        }
        hasStarted() {
          return this._state >= 2
        }
        init() {
          this._state >= 1 ||
            ((this._state = 1),
            this._styler.apply(),
            this._delay && this._styler.pause())
        }
        play() {
          this.init(),
            this.hasStarted() ||
              (this._flushStartFns(),
              (this._state = 2),
              this._specialStyles && this._specialStyles.start()),
            this._styler.resume()
        }
        pause() {
          this.init(), this._styler.pause()
        }
        restart() {
          this.reset(), this.play()
        }
        reset() {
          this._styler.destroy(), this._buildStyler(), this._styler.apply()
        }
        _buildStyler() {
          this._styler = new ae(
            this.element,
            this.animationName,
            this._duration,
            this._delay,
            this.easing,
            'forwards',
            () => this.finish()
          )
        }
        triggerCallback(t) {
          const e = 'start' == t ? this._onStartFns : this._onDoneFns
          e.forEach((t) => t()), (e.length = 0)
        }
        beforeDestroy() {
          this.init()
          const t = {}
          if (this.hasStarted()) {
            const e = this._state >= 3
            Object.keys(this._finalStyles).forEach((n) => {
              'offset' != n &&
                (t[n] = e ? this._finalStyles[n] : Z(this.element, n))
            })
          }
          this.currentSnapshot = t
        }
      }
      class me extends s.d {
        constructor(t, e) {
          super(),
            (this.element = t),
            (this._startingStyles = {}),
            (this.__initialized = !1),
            (this._styles = S(e))
        }
        init() {
          !this.__initialized &&
            this._startingStyles &&
            ((this.__initialized = !0),
            Object.keys(this._styles).forEach((t) => {
              this._startingStyles[t] = this.element.style[t]
            }),
            super.init())
        }
        play() {
          this._startingStyles &&
            (this.init(),
            Object.keys(this._styles).forEach((t) =>
              this.element.style.setProperty(t, this._styles[t])
            ),
            super.play())
        }
        destroy() {
          this._startingStyles &&
            (Object.keys(this._startingStyles).forEach((t) => {
              const e = this._startingStyles[t]
              e
                ? this.element.style.setProperty(t, e)
                : this.element.style.removeProperty(t)
            }),
            (this._startingStyles = null),
            super.destroy())
        }
      }
      class ge {
        constructor() {
          ;(this._count = 0), (this._head = document.querySelector('head'))
        }
        validateStyleProperty(t) {
          return v(t)
        }
        matchesElement(t, e) {
          return w(t, e)
        }
        containsElement(t, e) {
          return C(t, e)
        }
        query(t, e, n) {
          return x(t, e, n)
        }
        computeStyle(t, e, n) {
          return window.getComputedStyle(t)[e]
        }
        buildKeyframeElement(t, e, n) {
          n = n.map((t) => S(t))
          let i = `@keyframes ${e} {\n`,
            r = ''
          n.forEach((t) => {
            r = ' '
            const e = parseFloat(t.offset)
            ;(i += `${r}${100 * e}% {\n`),
              (r += ' '),
              Object.keys(t).forEach((e) => {
                const n = t[e]
                switch (e) {
                  case 'offset':
                    return
                  case 'easing':
                    return void (
                      n && (i += `${r}animation-timing-function: ${n};\n`)
                    )
                  default:
                    return void (i += `${r}${e}: ${n};\n`)
                }
              }),
              (i += r + '}\n')
          }),
            (i += '}\n')
          const s = document.createElement('style')
          return (s.textContent = i), s
        }
        animate(t, e, n, i, r, s = [], o) {
          const a = s.filter((t) => t instanceof fe),
            l = {}
          X(n, i) &&
            a.forEach((t) => {
              let e = t.currentSnapshot
              Object.keys(e).forEach((t) => (l[t] = e[t]))
            })
          const c = (function (t) {
            let e = {}
            return (
              t &&
                (Array.isArray(t) ? t : [t]).forEach((t) => {
                  Object.keys(t).forEach((n) => {
                    'offset' != n && 'easing' != n && (e[n] = t[n])
                  })
                }),
              e
            )
          })((e = K(t, e, l)))
          if (0 == n) return new me(t, c)
          const u = 'gen_css_kf_' + this._count++,
            h = this.buildKeyframeElement(t, u, e)
          document.querySelector('head').appendChild(h)
          const d = ee(t, e),
            p = new fe(t, e, u, n, i, r, c, d)
          return (
            p.onDestroy(() => {
              var t
              ;(t = h).parentNode.removeChild(t)
            }),
            p
          )
        }
      }
      class be {
        constructor(t, e, n, i) {
          ;(this.element = t),
            (this.keyframes = e),
            (this.options = n),
            (this._specialStyles = i),
            (this._onDoneFns = []),
            (this._onStartFns = []),
            (this._onDestroyFns = []),
            (this._initialized = !1),
            (this._finished = !1),
            (this._started = !1),
            (this._destroyed = !1),
            (this.time = 0),
            (this.parentPlayer = null),
            (this.currentSnapshot = {}),
            (this._duration = n.duration),
            (this._delay = n.delay || 0),
            (this.time = this._duration + this._delay)
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((t) => t()),
            (this._onDoneFns = []))
        }
        init() {
          this._buildPlayer(), this._preparePlayerBeforeStart()
        }
        _buildPlayer() {
          if (this._initialized) return
          this._initialized = !0
          const t = this.keyframes
          ;(this.domPlayer = this._triggerWebAnimation(
            this.element,
            t,
            this.options
          )),
            (this._finalKeyframe = t.length ? t[t.length - 1] : {}),
            this.domPlayer.addEventListener('finish', () => this._onFinish())
        }
        _preparePlayerBeforeStart() {
          this._delay ? this._resetDomPlayerState() : this.domPlayer.pause()
        }
        _triggerWebAnimation(t, e, n) {
          return t.animate(e, n)
        }
        onStart(t) {
          this._onStartFns.push(t)
        }
        onDone(t) {
          this._onDoneFns.push(t)
        }
        onDestroy(t) {
          this._onDestroyFns.push(t)
        }
        play() {
          this._buildPlayer(),
            this.hasStarted() ||
              (this._onStartFns.forEach((t) => t()),
              (this._onStartFns = []),
              (this._started = !0),
              this._specialStyles && this._specialStyles.start()),
            this.domPlayer.play()
        }
        pause() {
          this.init(), this.domPlayer.pause()
        }
        finish() {
          this.init(),
            this._specialStyles && this._specialStyles.finish(),
            this._onFinish(),
            this.domPlayer.finish()
        }
        reset() {
          this._resetDomPlayerState(),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._started = !1)
        }
        _resetDomPlayerState() {
          this.domPlayer && this.domPlayer.cancel()
        }
        restart() {
          this.reset(), this.play()
        }
        hasStarted() {
          return this._started
        }
        destroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this._resetDomPlayerState(),
            this._onFinish(),
            this._specialStyles && this._specialStyles.destroy(),
            this._onDestroyFns.forEach((t) => t()),
            (this._onDestroyFns = []))
        }
        setPosition(t) {
          this.domPlayer.currentTime = t * this.time
        }
        getPosition() {
          return this.domPlayer.currentTime / this.time
        }
        get totalTime() {
          return this._delay + this._duration
        }
        beforeDestroy() {
          const t = {}
          this.hasStarted() &&
            Object.keys(this._finalKeyframe).forEach((e) => {
              'offset' != e &&
                (t[e] = this._finished
                  ? this._finalKeyframe[e]
                  : Z(this.element, e))
            }),
            (this.currentSnapshot = t)
        }
        triggerCallback(t) {
          const e = 'start' == t ? this._onStartFns : this._onDoneFns
          e.forEach((t) => t()), (e.length = 0)
        }
      }
      class _e {
        constructor() {
          ;(this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(
            ye().toString()
          )),
            (this._cssKeyframesDriver = new ge())
        }
        validateStyleProperty(t) {
          return v(t)
        }
        matchesElement(t, e) {
          return w(t, e)
        }
        containsElement(t, e) {
          return C(t, e)
        }
        query(t, e, n) {
          return x(t, e, n)
        }
        computeStyle(t, e, n) {
          return window.getComputedStyle(t)[e]
        }
        overrideWebAnimationsSupport(t) {
          this._isNativeImpl = t
        }
        animate(t, e, n, i, r, s = [], o) {
          if (!o && !this._isNativeImpl)
            return this._cssKeyframesDriver.animate(t, e, n, i, r, s)
          const a = {
            duration: n,
            delay: i,
            fill: 0 == i ? 'both' : 'forwards',
          }
          r && (a.easing = r)
          const l = {},
            c = s.filter((t) => t instanceof be)
          X(n, i) &&
            c.forEach((t) => {
              let e = t.currentSnapshot
              Object.keys(e).forEach((t) => (l[t] = e[t]))
            })
          const u = ee(t, (e = K(t, (e = e.map((t) => N(t, !1))), l)))
          return new be(t, e, a, u)
        }
      }
      function ye() {
        return (
          ('undefined' != typeof window &&
            void 0 !== window.document &&
            Element.prototype.animate) ||
          {}
        )
      }
      var ve = n('ofXK')
      let we = (() => {
        class t extends s.b {
          constructor(t, e) {
            super(),
              (this._nextAnimationId = 0),
              (this._renderer = t.createRenderer(e.body, {
                id: '0',
                encapsulation: i.Q.None,
                styles: [],
                data: { animation: [] },
              }))
          }
          build(t) {
            const e = this._nextAnimationId.toString()
            this._nextAnimationId++
            const n = Array.isArray(t) ? Object(s.j)(t) : t
            return (
              Se(this._renderer, null, e, 'register', [n]),
              new Ce(e, this._renderer)
            )
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Ub(i.F), i.Ub(ve.d))
          }),
          (t.ɵprov = i.Hb({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      class Ce extends s.c {
        constructor(t, e) {
          super(), (this._id = t), (this._renderer = e)
        }
        create(t, e) {
          return new xe(this._id, t, e || {}, this._renderer)
        }
      }
      class xe {
        constructor(t, e, n, i) {
          ;(this.id = t),
            (this.element = e),
            (this._renderer = i),
            (this.parentPlayer = null),
            (this._started = !1),
            (this.totalTime = 0),
            this._command('create', n)
        }
        _listen(t, e) {
          return this._renderer.listen(this.element, `@@${this.id}:${t}`, e)
        }
        _command(t, ...e) {
          return Se(this._renderer, this.element, this.id, t, e)
        }
        onDone(t) {
          this._listen('done', t)
        }
        onStart(t) {
          this._listen('start', t)
        }
        onDestroy(t) {
          this._listen('destroy', t)
        }
        init() {
          this._command('init')
        }
        hasStarted() {
          return this._started
        }
        play() {
          this._command('play'), (this._started = !0)
        }
        pause() {
          this._command('pause')
        }
        restart() {
          this._command('restart')
        }
        finish() {
          this._command('finish')
        }
        destroy() {
          this._command('destroy')
        }
        reset() {
          this._command('reset')
        }
        setPosition(t) {
          this._command('setPosition', t)
        }
        getPosition() {
          var t, e
          return null !==
            (e =
              null === (t = this._renderer.engine.players[+this.id]) ||
              void 0 === t
                ? void 0
                : t.getPosition()) && void 0 !== e
            ? e
            : 0
        }
      }
      function Se(t, e, n, i, r) {
        return t.setProperty(e, `@@${n}:${i}`, r)
      }
      const Oe = '@',
        ke = '@.disabled'
      let Ee = (() => {
        class t {
          constructor(t, e, n) {
            ;(this.delegate = t),
              (this.engine = e),
              (this._zone = n),
              (this._currentId = 0),
              (this._microtaskId = 1),
              (this._animationCallbacksBuffer = []),
              (this._rendererCache = new Map()),
              (this._cdRecurDepth = 0),
              (this.promise = Promise.resolve(0)),
              (e.onRemovalComplete = (t, e) => {
                e && e.parentNode(t) && e.removeChild(t.parentNode, t)
              })
          }
          createRenderer(t, e) {
            const n = this.delegate.createRenderer(t, e)
            if (!(t && e && e.data && e.data.animation)) {
              let t = this._rendererCache.get(n)
              return (
                t ||
                  ((t = new Ae('', n, this.engine)),
                  this._rendererCache.set(n, t)),
                t
              )
            }
            const i = e.id,
              r = e.id + '-' + this._currentId
            this._currentId++, this.engine.register(r, t)
            const s = (e) => {
              Array.isArray(e)
                ? e.forEach(s)
                : this.engine.registerTrigger(i, r, t, e.name, e)
            }
            return e.data.animation.forEach(s), new Te(this, r, n, this.engine)
          }
          begin() {
            this._cdRecurDepth++, this.delegate.begin && this.delegate.begin()
          }
          _scheduleCountTask() {
            this.promise.then(() => {
              this._microtaskId++
            })
          }
          scheduleListenerCallback(t, e, n) {
            t >= 0 && t < this._microtaskId
              ? this._zone.run(() => e(n))
              : (0 == this._animationCallbacksBuffer.length &&
                  Promise.resolve(null).then(() => {
                    this._zone.run(() => {
                      this._animationCallbacksBuffer.forEach((t) => {
                        const [e, n] = t
                        e(n)
                      }),
                        (this._animationCallbacksBuffer = [])
                    })
                  }),
                this._animationCallbacksBuffer.push([e, n]))
          }
          end() {
            this._cdRecurDepth--,
              0 == this._cdRecurDepth &&
                this._zone.runOutsideAngular(() => {
                  this._scheduleCountTask(),
                    this.engine.flush(this._microtaskId)
                }),
              this.delegate.end && this.delegate.end()
          }
          whenRenderingDone() {
            return this.engine.whenRenderingDone()
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Ub(i.F), i.Ub(te), i.Ub(i.z))
          }),
          (t.ɵprov = i.Hb({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      class Ae {
        constructor(t, e, n) {
          ;(this.namespaceId = t),
            (this.delegate = e),
            (this.engine = n),
            (this.destroyNode = this.delegate.destroyNode
              ? (t) => e.destroyNode(t)
              : null)
        }
        get data() {
          return this.delegate.data
        }
        destroy() {
          this.engine.destroy(this.namespaceId, this.delegate),
            this.delegate.destroy()
        }
        createElement(t, e) {
          return this.delegate.createElement(t, e)
        }
        createComment(t) {
          return this.delegate.createComment(t)
        }
        createText(t) {
          return this.delegate.createText(t)
        }
        appendChild(t, e) {
          this.delegate.appendChild(t, e),
            this.engine.onInsert(this.namespaceId, e, t, !1)
        }
        insertBefore(t, e, n, i = !0) {
          this.delegate.insertBefore(t, e, n),
            this.engine.onInsert(this.namespaceId, e, t, i)
        }
        removeChild(t, e, n) {
          this.engine.onRemove(this.namespaceId, e, this.delegate, n)
        }
        selectRootElement(t, e) {
          return this.delegate.selectRootElement(t, e)
        }
        parentNode(t) {
          return this.delegate.parentNode(t)
        }
        nextSibling(t) {
          return this.delegate.nextSibling(t)
        }
        setAttribute(t, e, n, i) {
          this.delegate.setAttribute(t, e, n, i)
        }
        removeAttribute(t, e, n) {
          this.delegate.removeAttribute(t, e, n)
        }
        addClass(t, e) {
          this.delegate.addClass(t, e)
        }
        removeClass(t, e) {
          this.delegate.removeClass(t, e)
        }
        setStyle(t, e, n, i) {
          this.delegate.setStyle(t, e, n, i)
        }
        removeStyle(t, e, n) {
          this.delegate.removeStyle(t, e, n)
        }
        setProperty(t, e, n) {
          e.charAt(0) == Oe && e == ke
            ? this.disableAnimations(t, !!n)
            : this.delegate.setProperty(t, e, n)
        }
        setValue(t, e) {
          this.delegate.setValue(t, e)
        }
        listen(t, e, n) {
          return this.delegate.listen(t, e, n)
        }
        disableAnimations(t, e) {
          this.engine.disableAnimations(t, e)
        }
      }
      class Te extends Ae {
        constructor(t, e, n, i) {
          super(e, n, i), (this.factory = t), (this.namespaceId = e)
        }
        setProperty(t, e, n) {
          e.charAt(0) == Oe
            ? '.' == e.charAt(1) && e == ke
              ? this.disableAnimations(t, (n = void 0 === n || !!n))
              : this.engine.process(this.namespaceId, t, e.substr(1), n)
            : this.delegate.setProperty(t, e, n)
        }
        listen(t, e, n) {
          if (e.charAt(0) == Oe) {
            const i = (function (t) {
              switch (t) {
                case 'body':
                  return document.body
                case 'document':
                  return document
                case 'window':
                  return window
                default:
                  return t
              }
            })(t)
            let r = e.substr(1),
              s = ''
            return (
              r.charAt(0) != Oe &&
                ([r, s] = (function (t) {
                  const e = t.indexOf('.')
                  return [t.substring(0, e), t.substr(e + 1)]
                })(r)),
              this.engine.listen(this.namespaceId, i, r, s, (t) => {
                this.factory.scheduleListenerCallback(t._data || -1, n, t)
              })
            )
          }
          return this.delegate.listen(t, e, n)
        }
      }
      let je = (() => {
        class t extends te {
          constructor(t, e, n) {
            super(t.body, e, n)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Ub(ve.d), i.Ub(k), i.Ub(Ct))
          }),
          (t.ɵprov = i.Hb({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      const Ie = new i.q('AnimationModuleType'),
        Pe = [
          {
            provide: k,
            useFactory: function () {
              return 'function' == typeof ye() ? new _e() : new ge()
            },
          },
          { provide: Ie, useValue: 'BrowserAnimations' },
          { provide: s.b, useClass: we },
          {
            provide: Ct,
            useFactory: function () {
              return new xt()
            },
          },
          { provide: te, useClass: je },
          {
            provide: i.F,
            useFactory: function (t, e, n) {
              return new Ee(t, e, n)
            },
            deps: [r.d, te, i.z],
          },
        ]
      let Re = (() => {
        class t {}
        return (
          (t.ɵmod = i.Jb({ type: t })),
          (t.ɵinj = i.Ib({
            factory: function (e) {
              return new (e || t)()
            },
            providers: Pe,
            imports: [r.a],
          })),
          t
        )
      })()
    },
    SeVD: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return u
      })
      var i = n('ngJS'),
        r = n('NJ4a'),
        s = n('Lhse'),
        o = n('kJWO'),
        a = n('I55L'),
        l = n('c2HN'),
        c = n('XoHu')
      const u = (t) => {
        if (t && 'function' == typeof t[o.a])
          return (
            (u = t),
            (t) => {
              const e = u[o.a]()
              if ('function' != typeof e.subscribe)
                throw new TypeError(
                  'Provided object does not correctly implement Symbol.observable'
                )
              return e.subscribe(t)
            }
          )
        if (Object(a.a)(t)) return Object(i.a)(t)
        if (Object(l.a)(t))
          return (
            (n = t),
            (t) => (
              n
                .then(
                  (e) => {
                    t.closed || (t.next(e), t.complete())
                  },
                  (e) => t.error(e)
                )
                .then(null, r.a),
              t
            )
          )
        if (t && 'function' == typeof t[s.a])
          return (
            (e = t),
            (t) => {
              const n = e[s.a]()
              for (;;) {
                const e = n.next()
                if (e.done) {
                  t.complete()
                  break
                }
                if ((t.next(e.value), t.closed)) break
              }
              return (
                'function' == typeof n.return &&
                  t.add(() => {
                    n.return && n.return()
                  }),
                t
              )
            }
          )
        {
          const e = Object(c.a)(t) ? 'an invalid object' : `'${t}'`
          throw new TypeError(
            `You provided ${e} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`
          )
        }
        var e, n, u
      }
    },
    SpAZ: function (t, e, n) {
      'use strict'
      function i(t) {
        return t
      }
      n.d(e, 'a', function () {
        return i
      })
    },
    TypT: function (t, e) {
      ;(e.encode = function (t) {
        var e = ''
        for (var n in t)
          t.hasOwnProperty(n) &&
            (e.length && (e += '&'),
            (e += encodeURIComponent(n) + '=' + encodeURIComponent(t[n])))
        return e
      }),
        (e.decode = function (t) {
          for (var e = {}, n = t.split('&'), i = 0, r = n.length; i < r; i++) {
            var s = n[i].split('=')
            e[decodeURIComponent(s[0])] = decodeURIComponent(s[1])
          }
          return e
        })
    },
    Uwu7: function (t, e, n) {
      var i = n('NOtv')('socket.io-parser'),
        r = n('cpc2'),
        s = n('Njrz'),
        o = n('luTP'),
        a = n('qGlh')
      function l() {}
      ;(e.protocol = 4),
        (e.types = [
          'CONNECT',
          'DISCONNECT',
          'EVENT',
          'ACK',
          'ERROR',
          'BINARY_EVENT',
          'BINARY_ACK',
        ]),
        (e.CONNECT = 0),
        (e.DISCONNECT = 1),
        (e.EVENT = 2),
        (e.ACK = 3),
        (e.ERROR = 4),
        (e.BINARY_EVENT = 5),
        (e.BINARY_ACK = 6),
        (e.Encoder = l),
        (e.Decoder = h)
      var c = e.ERROR + '"encode error"'
      function u(t) {
        var n = '' + t.type
        if (
          ((e.BINARY_EVENT !== t.type && e.BINARY_ACK !== t.type) ||
            (n += t.attachments + '-'),
          t.nsp && '/' !== t.nsp && (n += t.nsp + ','),
          null != t.id && (n += t.id),
          null != t.data)
        ) {
          var r = (function (t) {
            try {
              return JSON.stringify(t)
            } catch (e) {
              return !1
            }
          })(t.data)
          if (!1 === r) return c
          n += r
        }
        return i('encoded %j as %s', t, n), n
      }
      function h() {
        this.reconstructor = null
      }
      function d(t) {
        ;(this.reconPack = t), (this.buffers = [])
      }
      function p(t) {
        return { type: e.ERROR, data: 'parser error: ' + t }
      }
      ;(l.prototype.encode = function (t, n) {
        i('encoding packet %j', t),
          e.BINARY_EVENT === t.type || e.BINARY_ACK === t.type
            ? (function (t, e) {
                s.removeBlobs(t, function (t) {
                  var n = s.deconstructPacket(t),
                    i = u(n.packet),
                    r = n.buffers
                  r.unshift(i), e(r)
                })
              })(t, n)
            : n([u(t)])
      }),
        r(h.prototype),
        (h.prototype.add = function (t) {
          var n
          if ('string' == typeof t)
            (n = (function (t) {
              var n = 0,
                r = { type: Number(t.charAt(0)) }
              if (null == e.types[r.type])
                return p('unknown packet type ' + r.type)
              if (e.BINARY_EVENT === r.type || e.BINARY_ACK === r.type) {
                for (
                  var s = '';
                  '-' !== t.charAt(++n) && ((s += t.charAt(n)), n != t.length);

                );
                if (s != Number(s) || '-' !== t.charAt(n))
                  throw new Error('Illegal attachments')
                r.attachments = Number(s)
              }
              if ('/' === t.charAt(n + 1))
                for (
                  r.nsp = '';
                  ++n &&
                  ',' !== (l = t.charAt(n)) &&
                  ((r.nsp += l), n !== t.length);

                );
              else r.nsp = '/'
              var a = t.charAt(n + 1)
              if ('' !== a && Number(a) == a) {
                for (r.id = ''; ++n; ) {
                  var l
                  if (null == (l = t.charAt(n)) || Number(l) != l) {
                    --n
                    break
                  }
                  if (((r.id += t.charAt(n)), n === t.length)) break
                }
                r.id = Number(r.id)
              }
              if (t.charAt(++n)) {
                var c = (function (t) {
                  try {
                    return JSON.parse(t)
                  } catch (e) {
                    return !1
                  }
                })(t.substr(n))
                if (!1 === c || (r.type !== e.ERROR && !o(c)))
                  return p('invalid payload')
                r.data = c
              }
              return i('decoded %s as %j', t, r), r
            })(t)),
              e.BINARY_EVENT === n.type || e.BINARY_ACK === n.type
                ? ((this.reconstructor = new d(n)),
                  0 === this.reconstructor.reconPack.attachments &&
                    this.emit('decoded', n))
                : this.emit('decoded', n)
          else {
            if (!a(t) && !t.base64) throw new Error('Unknown type: ' + t)
            if (!this.reconstructor)
              throw new Error(
                'got binary data when not reconstructing a packet'
              )
            ;(n = this.reconstructor.takeBinaryData(t)) &&
              ((this.reconstructor = null), this.emit('decoded', n))
          }
        }),
        (h.prototype.destroy = function () {
          this.reconstructor && this.reconstructor.finishedReconstruction()
        }),
        (d.prototype.takeBinaryData = function (t) {
          if (
            (this.buffers.push(t),
            this.buffers.length === this.reconPack.attachments)
          ) {
            var e = s.reconstructPacket(this.reconPack, this.buffers)
            return this.finishedReconstruction(), e
          }
          return null
        }),
        (d.prototype.finishedReconstruction = function () {
          ;(this.reconPack = null), (this.buffers = [])
        })
    },
    Uxeu: function (t, e) {
      var n = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
        i = [
          'source',
          'protocol',
          'authority',
          'userInfo',
          'user',
          'password',
          'host',
          'port',
          'relative',
          'path',
          'directory',
          'file',
          'query',
          'anchor',
        ]
      t.exports = function (t) {
        var e,
          r,
          s = t,
          o = t.indexOf('['),
          a = t.indexOf(']')
        ;-1 != o &&
          -1 != a &&
          (t =
            t.substring(0, o) +
            t.substring(o, a).replace(/:/g, ';') +
            t.substring(a, t.length))
        for (var l, c = n.exec(t || ''), u = {}, h = 14; h--; )
          u[i[h]] = c[h] || ''
        return (
          -1 != o &&
            -1 != a &&
            ((u.source = s),
            (u.host = u.host
              .substring(1, u.host.length - 1)
              .replace(/;/g, ':')),
            (u.authority = u.authority
              .replace('[', '')
              .replace(']', '')
              .replace(/;/g, ':')),
            (u.ipv6uri = !0)),
          (u.pathNames =
            ((r = (e = u.path).replace(/\/{2,9}/g, '/').split('/')),
            ('/' != e.substr(0, 1) && 0 !== e.length) || r.splice(0, 1),
            '/' == e.substr(e.length - 1, 1) && r.splice(r.length - 1, 1),
            r)),
          (u.queryKey =
            ((l = {}),
            u.query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (t, e, n) {
              e && (l[e] = n)
            }),
            l)),
          u
        )
      }
    },
    VRyK: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return a
      })
      var i = n('HDdC'),
        r = n('z+Ro'),
        s = n('bHdf'),
        o = n('yCtX')
      function a(...t) {
        let e = Number.POSITIVE_INFINITY,
          n = null,
          a = t[t.length - 1]
        return (
          Object(r.a)(a)
            ? ((n = t.pop()),
              t.length > 1 &&
                'number' == typeof t[t.length - 1] &&
                (e = t.pop()))
            : 'number' == typeof a && (e = t.pop()),
          null === n && 1 === t.length && t[0] instanceof i.a
            ? t[0]
            : Object(s.a)(e)(Object(o.a)(t, n))
        )
      }
    },
    WLGk: function (t, e, n) {
      var i = n('luTP'),
        r = Object.prototype.toString,
        s =
          'function' == typeof Blob ||
          ('undefined' != typeof Blob &&
            '[object BlobConstructor]' === r.call(Blob)),
        o =
          'function' == typeof File ||
          ('undefined' != typeof File &&
            '[object FileConstructor]' === r.call(File))
      t.exports = function t(e) {
        if (!e || 'object' != typeof e) return !1
        if (i(e)) {
          for (var n = 0, r = e.length; n < r; n++) if (t(e[n])) return !0
          return !1
        }
        if (
          ('function' == typeof Buffer &&
            Buffer.isBuffer &&
            Buffer.isBuffer(e)) ||
          ('function' == typeof ArrayBuffer && e instanceof ArrayBuffer) ||
          (s && e instanceof Blob) ||
          (o && e instanceof File)
        )
          return !0
        if (e.toJSON && 'function' == typeof e.toJSON && 1 === arguments.length)
          return t(e.toJSON(), !0)
        for (var a in e)
          if (Object.prototype.hasOwnProperty.call(e, a) && t(e[a])) return !0
        return !1
      }
    },
    WMd4: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return o
      })
      var i = n('EY2u'),
        r = n('LRne'),
        s = n('z6cu')
      let o = (() => {
        class t {
          constructor(t, e, n) {
            ;(this.kind = t),
              (this.value = e),
              (this.error = n),
              (this.hasValue = 'N' === t)
          }
          observe(t) {
            switch (this.kind) {
              case 'N':
                return t.next && t.next(this.value)
              case 'E':
                return t.error && t.error(this.error)
              case 'C':
                return t.complete && t.complete()
            }
          }
          do(t, e, n) {
            switch (this.kind) {
              case 'N':
                return t && t(this.value)
              case 'E':
                return e && e(this.error)
              case 'C':
                return n && n()
            }
          }
          accept(t, e, n) {
            return t && 'function' == typeof t.next
              ? this.observe(t)
              : this.do(t, e, n)
          }
          toObservable() {
            switch (this.kind) {
              case 'N':
                return Object(r.a)(this.value)
              case 'E':
                return Object(s.a)(this.error)
              case 'C':
                return Object(i.b)()
            }
            throw new Error('unexpected notification kind value')
          }
          static createNext(e) {
            return void 0 !== e ? new t('N', e) : t.undefinedValueNotification
          }
          static createError(e) {
            return new t('E', void 0, e)
          }
          static createComplete() {
            return t.completeNotification
          }
        }
        return (
          (t.completeNotification = new t('C')),
          (t.undefinedValueNotification = new t('N', void 0)),
          t
        )
      })()
    },
    WX4o: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return l
      })
      var i = n('fXoL'),
        r = n('ofXK')
      function s(t, e) {
        if ((1 & t && (i.Ob(0), i.Mb(1, 'img', 3), i.Nb()), 2 & t)) {
          const t = i.bc()
          i.zb(1), i.gc('src', t.src, i.oc)('alt', t.alt)
        }
      }
      function o(t, e) {
        1 & t &&
          (i.ac(),
          i.Qb(0, 'svg', 4),
          i.Mb(1, 'path', 5),
          i.Mb(2, 'path', 6),
          i.Pb())
      }
      const a = function (t) {
        return { 'call-avatar-animation': t }
      }
      let l = (() => {
        class t {
          constructor() {
            this.alt = 'avatar'
          }
          get animation() {
            return this._animation
          }
          set animation(t) {
            this._animation = null != t && t
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵcmp = i.Fb({
            type: t,
            selectors: [['quertc-call-avatar']],
            inputs: { src: 'src', alt: 'alt', animation: 'animation' },
            decls: 4,
            vars: 5,
            consts: [
              [1, 'call-avatar', 3, 'ngClass'],
              [4, 'ngIf', 'ngIfElse'],
              ['noSrc', ''],
              ['width', '135', 3, 'src', 'alt'],
              [
                'xmlns',
                'http://www.w3.org/2000/svg',
                'viewBox',
                '0 0 496.158 496.158',
              ],
              [
                'd',
                'M496.158,248.085c0-137.022-111.069-248.082-248.075-248.082C111.07,0.003,0,111.063,0,248.085\n\tc0,137.001,111.07,248.07,248.083,248.07C385.089,496.155,496.158,385.086,496.158,248.085z',
              ],
              [
                'd',
                'M138.216,173.592c0-13.915,4.467-28.015,13.403-42.297c8.933-14.282,21.973-26.11,39.111-35.486\n\tc17.139-9.373,37.134-14.062,59.985-14.062c21.238,0,39.99,3.921,56.25,11.755c16.26,7.838,28.818,18.495,37.683,31.97\n\tc8.861,13.479,13.293,28.125,13.293,43.945c0,12.452-2.527,23.367-7.581,32.739c-5.054,9.376-11.062,17.469-18.018,24.279\n\tc-6.959,6.812-19.446,18.275-37.463,34.388c-4.981,4.542-8.975,8.535-11.975,11.976c-3.004,3.443-5.239,6.592-6.702,9.447\n\tc-1.466,2.857-2.603,5.713-3.406,8.57c-0.807,2.855-2.015,7.875-3.625,15.051c-2.784,15.236-11.501,22.852-26.147,22.852\n\tc-7.618,0-14.028-2.489-19.226-7.471c-5.201-4.979-7.8-12.377-7.8-22.192c0-12.305,1.902-22.962,5.713-31.97\n\tc3.808-9.01,8.861-16.92,15.161-23.73c6.296-6.812,14.794-14.904,25.488-24.28c9.373-8.202,16.15-14.392,20.325-18.567\n\tc4.175-4.175,7.69-8.823,10.547-13.953c2.856-5.126,4.285-10.691,4.285-16.699c0-11.718-4.36-21.605-13.074-29.663\n\tc-8.717-8.054-19.961-12.085-33.728-12.085c-16.116,0-27.981,4.065-35.596,12.195c-7.618,8.13-14.062,20.105-19.336,35.925\n\tc-4.981,16.555-14.43,24.829-28.345,24.829c-8.206,0-15.127-2.891-20.764-8.679C141.035,186.593,138.216,180.331,138.216,173.592z\n\t M245.442,414.412c-8.937,0-16.737-2.895-23.401-8.68c-6.667-5.784-9.998-13.877-9.998-24.279c0-9.229,3.22-16.991,9.668-23.291\n\tc6.444-6.297,14.354-9.448,23.73-9.448c9.229,0,16.991,3.151,23.291,9.448c6.296,6.3,9.448,14.062,9.448,23.291\n\tc0,10.255-3.296,18.312-9.888,24.17C261.7,411.481,254.084,414.412,245.442,414.412z',
              ],
            ],
            template: function (t, e) {
              if (
                (1 & t &&
                  (i.Qb(0, 'div', 0),
                  i.vc(1, s, 2, 2, 'ng-container', 1),
                  i.Pb(),
                  i.vc(2, o, 3, 0, 'ng-template', null, 2, i.wc)),
                2 & t)
              ) {
                const t = i.kc(3)
                i.gc('ngClass', i.hc(3, a, e.animation)),
                  i.zb(1),
                  i.gc('ngIf', e.src)('ngIfElse', t)
              }
            },
            directives: [r.i, r.k],
            styles: [
              '[_nghost-%COMP%]{display:block}[_nghost-%COMP%]   .call-avatar[_ngcontent-%COMP%]{background:#fff;width:135px;height:135px;position:relative;margin:0 auto;border-radius:100%;border:5px solid #fff}[_nghost-%COMP%]   .call-avatar-animation[_ngcontent-%COMP%]{-webkit-animation:play 2s ease infinite;animation:play 2s ease infinite;-webkit-backface-visibility:hidden;backface-visibility:hidden}[_nghost-%COMP%]     video, [_nghost-%COMP%]   img[_ngcontent-%COMP%], [_nghost-%COMP%]   video[_ngcontent-%COMP%]{width:135px;height:135px;border-radius:100%;position:absolute;left:0;top:0}@-webkit-keyframes play{0%{transform:scale(1)}15%{box-shadow:0 0 0 5px hsla(0,0%,100%,.4)}25%{box-shadow:0 0 0 10px hsla(0,0%,100%,.4),0 0 0 20px hsla(0,0%,100%,.2)}25%{box-shadow:0 0 0 15px hsla(0,0%,100%,.4),0 0 0 30px hsla(0,0%,100%,.2)}}@keyframes play{0%{transform:scale(1)}15%{box-shadow:0 0 0 5px hsla(0,0%,100%,.4)}25%{box-shadow:0 0 0 10px hsla(0,0%,100%,.4),0 0 0 20px hsla(0,0%,100%,.2)}25%{box-shadow:0 0 0 15px hsla(0,0%,100%,.4),0 0 0 30px hsla(0,0%,100%,.2)}}',
            ],
          })),
          t
        )
      })()
    },
    Wm4p: function (t, e, n) {
      var i,
        r = n('dkv/'),
        s = n('WLGk'),
        o = n('ypnn'),
        a = n('zMFY'),
        l = n('oIG/')
      'undefined' != typeof ArrayBuffer && (i = n('g5Dd'))
      var c =
          'undefined' != typeof navigator &&
          /Android/i.test(navigator.userAgent),
        u =
          'undefined' != typeof navigator &&
          /PhantomJS/i.test(navigator.userAgent),
        h = c || u
      e.protocol = 3
      var d = (e.packets = {
          open: 0,
          close: 1,
          ping: 2,
          pong: 3,
          message: 4,
          upgrade: 5,
          noop: 6,
        }),
        p = r(d),
        f = { type: 'error', data: 'parser error' },
        m = n('14A5')
      function g(t, e, n) {
        for (
          var i = new Array(t.length),
            r = a(t.length, n),
            s = function (t, n, r) {
              e(n, function (e, n) {
                ;(i[t] = n), r(e, i)
              })
            },
            o = 0;
          o < t.length;
          o++
        )
          s(o, t[o], r)
      }
      ;(e.encodePacket = function (t, n, i, r) {
        'function' == typeof n && ((r = n), (n = !1)),
          'function' == typeof i && ((r = i), (i = null))
        var s = void 0 === t.data ? void 0 : t.data.buffer || t.data
        if ('undefined' != typeof ArrayBuffer && s instanceof ArrayBuffer)
          return (function (t, n, i) {
            if (!n) return e.encodeBase64Packet(t, i)
            var r = t.data,
              s = new Uint8Array(r),
              o = new Uint8Array(1 + r.byteLength)
            o[0] = d[t.type]
            for (var a = 0; a < s.length; a++) o[a + 1] = s[a]
            return i(o.buffer)
          })(t, n, r)
        if (void 0 !== m && s instanceof m)
          return (function (t, n, i) {
            if (!n) return e.encodeBase64Packet(t, i)
            if (h)
              return (function (t, n, i) {
                if (!n) return e.encodeBase64Packet(t, i)
                var r = new FileReader()
                return (
                  (r.onload = function () {
                    e.encodePacket({ type: t.type, data: r.result }, n, !0, i)
                  }),
                  r.readAsArrayBuffer(t.data)
                )
              })(t, n, i)
            var r = new Uint8Array(1)
            return (r[0] = d[t.type]), i(new m([r.buffer, t.data]))
          })(t, n, r)
        if (s && s.base64)
          return (function (t, n) {
            return n('b' + e.packets[t.type] + t.data.data)
          })(t, r)
        var o = d[t.type]
        return (
          void 0 !== t.data &&
            (o += i
              ? l.encode(String(t.data), { strict: !1 })
              : String(t.data)),
          r('' + o)
        )
      }),
        (e.encodeBase64Packet = function (t, n) {
          var i,
            r = 'b' + e.packets[t.type]
          if (void 0 !== m && t.data instanceof m) {
            var s = new FileReader()
            return (
              (s.onload = function () {
                var t = s.result.split(',')[1]
                n(r + t)
              }),
              s.readAsDataURL(t.data)
            )
          }
          try {
            i = String.fromCharCode.apply(null, new Uint8Array(t.data))
          } catch (c) {
            for (
              var o = new Uint8Array(t.data), a = new Array(o.length), l = 0;
              l < o.length;
              l++
            )
              a[l] = o[l]
            i = String.fromCharCode.apply(null, a)
          }
          return (r += btoa(i)), n(r)
        }),
        (e.decodePacket = function (t, n, i) {
          if (void 0 === t) return f
          if ('string' == typeof t) {
            if ('b' === t.charAt(0)) return e.decodeBase64Packet(t.substr(1), n)
            if (
              i &&
              !1 ===
                (t = (function (t) {
                  try {
                    t = l.decode(t, { strict: !1 })
                  } catch (e) {
                    return !1
                  }
                  return t
                })(t))
            )
              return f
            var r = t.charAt(0)
            return Number(r) == r && p[r]
              ? t.length > 1
                ? { type: p[r], data: t.substring(1) }
                : { type: p[r] }
              : f
          }
          r = new Uint8Array(t)[0]
          var s = o(t, 1)
          return m && 'blob' === n && (s = new m([s])), { type: p[r], data: s }
        }),
        (e.decodeBase64Packet = function (t, e) {
          var n = p[t.charAt(0)]
          if (!i) return { type: n, data: { base64: !0, data: t.substr(1) } }
          var r = i.decode(t.substr(1))
          return 'blob' === e && m && (r = new m([r])), { type: n, data: r }
        }),
        (e.encodePayload = function (t, n, i) {
          'function' == typeof n && ((i = n), (n = null))
          var r = s(t)
          return n && r
            ? m && !h
              ? e.encodePayloadAsBlob(t, i)
              : e.encodePayloadAsArrayBuffer(t, i)
            : t.length
            ? void g(
                t,
                function (t, i) {
                  e.encodePacket(t, !!r && n, !1, function (t) {
                    i(
                      null,
                      (function (t) {
                        return t.length + ':' + t
                      })(t)
                    )
                  })
                },
                function (t, e) {
                  return i(e.join(''))
                }
              )
            : i('0:')
        }),
        (e.decodePayload = function (t, n, i) {
          if ('string' != typeof t) return e.decodePayloadAsBinary(t, n, i)
          var r
          if (('function' == typeof n && ((i = n), (n = null)), '' === t))
            return i(f, 0, 1)
          for (var s, o, a = '', l = 0, c = t.length; l < c; l++) {
            var u = t.charAt(l)
            if (':' === u) {
              if ('' === a || a != (s = Number(a))) return i(f, 0, 1)
              if (a != (o = t.substr(l + 1, s)).length) return i(f, 0, 1)
              if (o.length) {
                if (
                  ((r = e.decodePacket(o, n, !1)),
                  f.type === r.type && f.data === r.data)
                )
                  return i(f, 0, 1)
                if (!1 === i(r, l + s, c)) return
              }
              ;(l += s), (a = '')
            } else a += u
          }
          return '' !== a ? i(f, 0, 1) : void 0
        }),
        (e.encodePayloadAsArrayBuffer = function (t, n) {
          if (!t.length) return n(new ArrayBuffer(0))
          g(
            t,
            function (t, n) {
              e.encodePacket(t, !0, !0, function (t) {
                return n(null, t)
              })
            },
            function (t, e) {
              var i = e.reduce(function (t, e) {
                  var n
                  return (
                    t +
                    (n =
                      'string' == typeof e ? e.length : e.byteLength).toString()
                      .length +
                    n +
                    2
                  )
                }, 0),
                r = new Uint8Array(i),
                s = 0
              return (
                e.forEach(function (t) {
                  var e = 'string' == typeof t,
                    n = t
                  if (e) {
                    for (
                      var i = new Uint8Array(t.length), o = 0;
                      o < t.length;
                      o++
                    )
                      i[o] = t.charCodeAt(o)
                    n = i.buffer
                  }
                  r[s++] = e ? 0 : 1
                  var a = n.byteLength.toString()
                  for (o = 0; o < a.length; o++) r[s++] = parseInt(a[o])
                  for (
                    r[s++] = 255, i = new Uint8Array(n), o = 0;
                    o < i.length;
                    o++
                  )
                    r[s++] = i[o]
                }),
                n(r.buffer)
              )
            }
          )
        }),
        (e.encodePayloadAsBlob = function (t, n) {
          g(
            t,
            function (t, n) {
              e.encodePacket(t, !0, !0, function (t) {
                var e = new Uint8Array(1)
                if (((e[0] = 1), 'string' == typeof t)) {
                  for (
                    var i = new Uint8Array(t.length), r = 0;
                    r < t.length;
                    r++
                  )
                    i[r] = t.charCodeAt(r)
                  ;(t = i.buffer), (e[0] = 0)
                }
                var s = (t instanceof ArrayBuffer
                    ? t.byteLength
                    : t.size
                  ).toString(),
                  o = new Uint8Array(s.length + 1)
                for (r = 0; r < s.length; r++) o[r] = parseInt(s[r])
                if (((o[s.length] = 255), m)) {
                  var a = new m([e.buffer, o.buffer, t])
                  n(null, a)
                }
              })
            },
            function (t, e) {
              return n(new m(e))
            }
          )
        }),
        (e.decodePayloadAsBinary = function (t, n, i) {
          'function' == typeof n && ((i = n), (n = null))
          for (var r = t, s = []; r.byteLength > 0; ) {
            for (
              var a = new Uint8Array(r), l = 0 === a[0], c = '', u = 1;
              255 !== a[u];
              u++
            ) {
              if (c.length > 310) return i(f, 0, 1)
              c += a[u]
            }
            ;(r = o(r, 2 + c.length)), (c = parseInt(c))
            var h = o(r, 0, c)
            if (l)
              try {
                h = String.fromCharCode.apply(null, new Uint8Array(h))
              } catch (m) {
                var d = new Uint8Array(h)
                for (h = '', u = 0; u < d.length; u++)
                  h += String.fromCharCode(d[u])
              }
            s.push(h), (r = o(r, c))
          }
          var p = s.length
          s.forEach(function (t, r) {
            i(e.decodePacket(t, n, !0), r, p)
          })
        })
    },
    Wp6s: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return h
      }),
        n.d(e, 'b', function () {
          return u
        }),
        n.d(e, 'c', function () {
          return d
        }),
        n.d(e, 'd', function () {
          return c
        }),
        n.d(e, 'e', function () {
          return l
        })
      var i = n('R1ws'),
        r = n('FKr1'),
        s = n('fXoL')
      const o = ['*', [['mat-card-footer']]],
        a = ['*', 'mat-card-footer']
      let l = (() => {
          class t {}
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵdir = s.Gb({
              type: t,
              selectors: [
                ['mat-card-title'],
                ['', 'mat-card-title', ''],
                ['', 'matCardTitle', ''],
              ],
              hostAttrs: [1, 'mat-card-title'],
            })),
            t
          )
        })(),
        c = (() => {
          class t {}
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵdir = s.Gb({
              type: t,
              selectors: [
                ['mat-card-subtitle'],
                ['', 'mat-card-subtitle', ''],
                ['', 'matCardSubtitle', ''],
              ],
              hostAttrs: [1, 'mat-card-subtitle'],
            })),
            t
          )
        })(),
        u = (() => {
          class t {}
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵdir = s.Gb({
              type: t,
              selectors: [
                ['', 'mat-card-image', ''],
                ['', 'matCardImage', ''],
              ],
              hostAttrs: [1, 'mat-card-image'],
            })),
            t
          )
        })(),
        h = (() => {
          class t {
            constructor(t) {
              this._animationMode = t
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(s.Lb(i.a, 8))
            }),
            (t.ɵcmp = s.Fb({
              type: t,
              selectors: [['mat-card']],
              hostAttrs: [1, 'mat-card', 'mat-focus-indicator'],
              hostVars: 2,
              hostBindings: function (t, e) {
                2 & t &&
                  s.Db(
                    '_mat-animation-noopable',
                    'NoopAnimations' === e._animationMode
                  )
              },
              exportAs: ['matCard'],
              ngContentSelectors: a,
              decls: 2,
              vars: 0,
              template: function (t, e) {
                1 & t && (s.fc(o), s.ec(0), s.ec(1, 1))
              },
              styles: [
                '.mat-card{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:block;position:relative;padding:16px;border-radius:4px}._mat-animation-noopable.mat-card{transition:none;animation:none}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}.cdk-high-contrast-active .mat-card{outline:solid 1px}.mat-card-actions,.mat-card-subtitle,.mat-card-content{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button,.mat-card-actions .mat-stroked-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px}@media(max-width: 599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card>:first-child,.mat-card-content>:first-child{margin-top:0}.mat-card>:last-child:not(.mat-card-footer),.mat-card-content>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions .mat-button:first-child,.mat-card-actions .mat-raised-button:first-child,.mat-card-actions .mat-stroked-button:first-child{margin-left:0;margin-right:0}.mat-card-title:not(:first-child),.mat-card-subtitle:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}\n',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        d = (() => {
          class t {}
          return (
            (t.ɵmod = s.Jb({ type: t })),
            (t.ɵinj = s.Ib({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[r.d], r.d],
            })),
            t
          )
        })()
    },
    XNiG: function (t, e, n) {
      'use strict'
      n.d(e, 'b', function () {
        return c
      }),
        n.d(e, 'a', function () {
          return u
        })
      var i = n('HDdC'),
        r = n('7o/Q'),
        s = n('quSY'),
        o = n('9ppp'),
        a = n('Ylt2'),
        l = n('2QA8')
      class c extends r.a {
        constructor(t) {
          super(t), (this.destination = t)
        }
      }
      let u = (() => {
        class t extends i.a {
          constructor() {
            super(),
              (this.observers = []),
              (this.closed = !1),
              (this.isStopped = !1),
              (this.hasError = !1),
              (this.thrownError = null)
          }
          [l.a]() {
            return new c(this)
          }
          lift(t) {
            const e = new h(this, this)
            return (e.operator = t), e
          }
          next(t) {
            if (this.closed) throw new o.a()
            if (!this.isStopped) {
              const { observers: e } = this,
                n = e.length,
                i = e.slice()
              for (let r = 0; r < n; r++) i[r].next(t)
            }
          }
          error(t) {
            if (this.closed) throw new o.a()
            ;(this.hasError = !0), (this.thrownError = t), (this.isStopped = !0)
            const { observers: e } = this,
              n = e.length,
              i = e.slice()
            for (let r = 0; r < n; r++) i[r].error(t)
            this.observers.length = 0
          }
          complete() {
            if (this.closed) throw new o.a()
            this.isStopped = !0
            const { observers: t } = this,
              e = t.length,
              n = t.slice()
            for (let i = 0; i < e; i++) n[i].complete()
            this.observers.length = 0
          }
          unsubscribe() {
            ;(this.isStopped = !0), (this.closed = !0), (this.observers = null)
          }
          _trySubscribe(t) {
            if (this.closed) throw new o.a()
            return super._trySubscribe(t)
          }
          _subscribe(t) {
            if (this.closed) throw new o.a()
            return this.hasError
              ? (t.error(this.thrownError), s.a.EMPTY)
              : this.isStopped
              ? (t.complete(), s.a.EMPTY)
              : (this.observers.push(t), new a.a(this, t))
          }
          asObservable() {
            const t = new i.a()
            return (t.source = this), t
          }
        }
        return (t.create = (t, e) => new h(t, e)), t
      })()
      class h extends u {
        constructor(t, e) {
          super(), (this.destination = t), (this.source = e)
        }
        next(t) {
          const { destination: e } = this
          e && e.next && e.next(t)
        }
        error(t) {
          const { destination: e } = this
          e && e.error && this.destination.error(t)
        }
        complete() {
          const { destination: t } = this
          t && t.complete && this.destination.complete()
        }
        _subscribe(t) {
          const { source: e } = this
          return e ? this.source.subscribe(t) : s.a.EMPTY
        }
      }
    },
    XoHu: function (t, e, n) {
      'use strict'
      function i(t) {
        return null !== t && 'object' == typeof t
      }
      n.d(e, 'a', function () {
        return i
      })
    },
    Ylt2: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return r
      })
      var i = n('quSY')
      class r extends i.a {
        constructor(t, e) {
          super(), (this.subject = t), (this.subscriber = e), (this.closed = !1)
        }
        unsubscribe() {
          if (this.closed) return
          this.closed = !0
          const t = this.subject,
            e = t.observers
          if (
            ((this.subject = null),
            !e || 0 === e.length || t.isStopped || t.closed)
          )
            return
          const n = e.indexOf(this.subscriber)
          ;-1 !== n && e.splice(n, 1)
        }
      }
    },
    Yvos: function (t, e) {
      t.exports = function (t, e) {
        var n = function () {}
        ;(n.prototype = e.prototype),
          (t.prototype = new n()),
          (t.prototype.constructor = t)
      }
    },
    'ZL+G': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return i
      })
      class i {
        constructor(t) {
          this.overlay = t
        }
        close() {
          this.overlay.dispose()
        }
        isVisible() {
          return this.overlay && this.overlay.overlayElement
        }
        getPosition() {
          return this.overlay.overlayElement.getBoundingClientRect()
        }
      }
    },
    ZUHj: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return o
      })
      var i = n('51Dv'),
        r = n('SeVD'),
        s = n('HDdC')
      function o(t, e, n, o, a = new i.a(t, n, o)) {
        if (!a.closed)
          return e instanceof s.a ? e.subscribe(a) : Object(r.a)(e)(a)
      }
    },
    Zr4m: function (t, e, n) {
      'use strict'
      n.r(e)
      var i = n('fXoL')
      const r = {
        prod: !0,
        signaling: 'https://webrtc-community.herokuapp.com',
        configuration: {
          iceServers: [
            { urls: 'stun:stun.services.mozilla.com' },
            { urls: 'stun:stun.l.google.com:19302' },
          ],
        },
      }
      var s = n('u47x'),
        o = n('ofXK'),
        a = n('bTqV'),
        l = n('NFeN')
      const c = ['contentWrapper']
      function u(t, e) {
        if (1 & t) {
          const t = i.Rb()
          i.Qb(0, 'button', 5),
            i.Xb('click', function () {
              return i.nc(t), i.bc().previous()
            }),
            i.Qb(1, 'mat-icon'),
            i.xc(2, 'navigate_before'),
            i.Pb(),
            i.Pb()
        }
      }
      function h(t, e) {
        if (1 & t) {
          const t = i.Rb()
          i.Qb(0, 'button', 6),
            i.Xb('click', function () {
              return i.nc(t), i.bc().next()
            }),
            i.Qb(1, 'mat-icon'),
            i.xc(2, 'navigate_next'),
            i.Pb(),
            i.Pb()
        }
      }
      const d = ['*']
      let p = (() => {
          class t {
            constructor(t, e) {
              ;(this.carousel = t),
                (this.element = e),
                (this.role = 'listitem'),
                (this.width = this.carousel.itemWidth),
                (this.tabindex = '-1')
            }
            focus() {
              this.element.nativeElement.focus({ preventScroll: !0 })
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Lb(f), i.Lb(i.l))
            }),
            (t.ɵdir = i.Gb({
              type: t,
              selectors: [['', 'carousel-item', '']],
              hostVars: 4,
              hostBindings: function (t, e) {
                2 & t &&
                  (i.Tb('tabindex', e.tabindex),
                  i.Ab('role', e.role),
                  i.sc('width', e.width, 'px'))
              },
            })),
            t
          )
        })(),
        f = (() => {
          class t {
            constructor(t) {
              ;(this.element = t),
                (this.position = 0),
                (this.showPrevArrow = !1),
                (this.showNextArrow = !0),
                (this._index = 0)
            }
            get index() {
              return this._index
            }
            set index(t) {
              ;(this._index = t),
                (this.showPrevArrow = t > 0),
                (this.showNextArrow = t < this.items.length - this.visibleItems)
            }
            onKeydown(t) {
              switch (t.key) {
                case 'Tab':
                  this.focusKeyManager.activeItem ||
                    (this.focusKeyManager.setFirstItemActive(),
                    this._updateItemTabIndices())
                  break
                case 'ArrowLeft':
                  this.focusKeyManager.activeItemIndex === this.index &&
                    this.previous(),
                    this.focusKeyManager.setPreviousItemActive(),
                    this._updateItemTabIndices()
                  break
                case 'ArrowRight':
                  this.focusKeyManager.activeItemIndex ===
                    this.index + this.visibleItems - 1 && this.next(),
                    this.focusKeyManager.setNextItemActive(),
                    this._updateItemTabIndices()
              }
            }
            onResize() {
              this._resizeCarousel()
            }
            ngAfterContentInit() {
              ;(this.focusKeyManager = new s.d(this.items)),
                setTimeout(() => {
                  ;(this.itemsArray = this.items.toArray()),
                    (this.shiftWidth = this.items.first.element.nativeElement.clientWidth),
                    this._resizeCarousel()
                })
            }
            next() {
              this.showNextArrow && this._shiftItems(1)
            }
            previous() {
              this.showPrevArrow && this._shiftItems(-1)
            }
            _updateItemTabIndices() {
              this.items.forEach((t) => {
                t.tabindex = t === this.focusKeyManager.activeItem ? '0' : '-1'
              })
            }
            _shiftItems(t) {
              ;(this.index += t),
                (this.position += t * this.shiftWidth),
                this.items.forEach((t) => {
                  t.element.nativeElement.style.transform = `translateX(-${this.position}px)`
                })
            }
            _resizeCarousel() {
              const t = Math.max(
                1,
                Math.min(
                  Math.floor(
                    this.element.nativeElement.offsetWidth / this.shiftWidth
                  ),
                  this.items.length
                )
              )
              if (this.visibleItems !== t) {
                if (this.visibleItems < t) {
                  const t =
                    this.index - (this.items.length - this.visibleItems) + 1
                  t > 0 && this._shiftItems(-t)
                } else
                  this.focusKeyManager.activeItemIndex &&
                    this.focusKeyManager.activeItemIndex > this.index + t - 1 &&
                    (this.focusKeyManager.setPreviousItemActive(),
                    this._updateItemTabIndices())
                ;(this.visibleItems = t),
                  (this.showNextArrow =
                    this.index < this.items.length - this.visibleItems)
              }
              this.wrapper.nativeElement.style.width =
                this.visibleItems * this.shiftWidth + 'px'
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Lb(i.l))
            }),
            (t.ɵcmp = i.Fb({
              type: t,
              selectors: [['quertc-carousel']],
              contentQueries: function (t, e, n) {
                if ((1 & t && i.Eb(n, p, !1), 2 & t)) {
                  let t
                  i.jc((t = i.Yb())) && (e.items = t)
                }
              },
              viewQuery: function (t, e) {
                if ((1 & t && i.Ac(c, !0), 2 & t)) {
                  let t
                  i.jc((t = i.Yb())) && (e.wrapper = t.first)
                }
              },
              inputs: {
                ariaLabel: ['aria-label', 'ariaLabel'],
                itemWidth: 'itemWidth',
              },
              ngContentSelectors: d,
              decls: 6,
              vars: 4,
              consts: [
                [
                  'role',
                  'region',
                  1,
                  'docs-carousel-content-wrapper',
                  3,
                  'keyup',
                  'resize',
                ],
                ['contentWrapper', ''],
                [
                  'aria-hidden',
                  'true',
                  'tabindex',
                  '-1',
                  'class',
                  'docs-carousel-nav docs-carousel-nav-prev',
                  'mat-mini-fab',
                  '',
                  'aria-label',
                  'previous',
                  3,
                  'click',
                  4,
                  'ngIf',
                ],
                ['role', 'list', 'tabindex', '0', 1, 'docs-carousel-content'],
                [
                  'aria-hidden',
                  'true',
                  'tabindex',
                  '-1',
                  'class',
                  'docs-carousel-nav docs-carousel-nav-next',
                  'mat-mini-fab',
                  '',
                  'aria-label',
                  'next',
                  3,
                  'click',
                  4,
                  'ngIf',
                ],
                [
                  'aria-hidden',
                  'true',
                  'tabindex',
                  '-1',
                  'mat-mini-fab',
                  '',
                  'aria-label',
                  'previous',
                  1,
                  'docs-carousel-nav',
                  'docs-carousel-nav-prev',
                  3,
                  'click',
                ],
                [
                  'aria-hidden',
                  'true',
                  'tabindex',
                  '-1',
                  'mat-mini-fab',
                  '',
                  'aria-label',
                  'next',
                  1,
                  'docs-carousel-nav',
                  'docs-carousel-nav-next',
                  3,
                  'click',
                ],
              ],
              template: function (t, e) {
                1 & t &&
                  (i.fc(),
                  i.Qb(0, 'div', 0, 1),
                  i.Xb('keyup', function (t) {
                    return e.onKeydown(t)
                  })(
                    'resize',
                    function () {
                      return e.onResize()
                    },
                    !1,
                    i.mc
                  ),
                  i.vc(2, u, 3, 0, 'button', 2),
                  i.Qb(3, 'div', 3),
                  i.ec(4),
                  i.Pb(),
                  i.vc(5, h, 3, 0, 'button', 4),
                  i.Pb()),
                  2 & t &&
                    (i.sc('min-width', e.shiftWidth + 'px'),
                    i.zb(2),
                    i.gc('ngIf', e.showPrevArrow),
                    i.zb(3),
                    i.gc('ngIf', e.showNextArrow))
              },
              directives: [o.k, a.b, l.a],
              styles: [
                'quertc-carousel{display:flex;align-items:center;justify-content:center;margin:0 40px}.docs-carousel-content{display:flex;flex-direction:row;overflow:hidden;outline:none}.docs-carousel-content-wrapper{position:relative}[carousel-item]{flex-shrink:0;transition:transform .5s ease-in-out}.docs-carousel-nav{position:absolute;top:50%;transform:translateY(-50%)}.docs-carousel-nav-prev{left:-40px}.docs-carousel-nav-next{right:-40px}',
              ],
              encapsulation: 2,
            })),
            t
          )
        })()
      var m = n('8LU1'),
        g = n('FKr1')
      let b = (() => {
          class t {
            constructor() {
              ;(this._vertical = !1), (this._inset = !1)
            }
            get vertical() {
              return this._vertical
            }
            set vertical(t) {
              this._vertical = Object(m.b)(t)
            }
            get inset() {
              return this._inset
            }
            set inset(t) {
              this._inset = Object(m.b)(t)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵcmp = i.Fb({
              type: t,
              selectors: [['mat-divider']],
              hostAttrs: ['role', 'separator', 1, 'mat-divider'],
              hostVars: 7,
              hostBindings: function (t, e) {
                2 & t &&
                  (i.Ab(
                    'aria-orientation',
                    e.vertical ? 'vertical' : 'horizontal'
                  ),
                  i.Db('mat-divider-vertical', e.vertical)(
                    'mat-divider-horizontal',
                    !e.vertical
                  )('mat-divider-inset', e.inset))
              },
              inputs: { vertical: 'vertical', inset: 'inset' },
              decls: 0,
              vars: 0,
              template: function (t, e) {},
              styles: [
                '.mat-divider{display:block;margin:0;border-top-width:1px;border-top-style:solid}.mat-divider.mat-divider-vertical{border-top:0;border-right-width:1px;border-right-style:solid}.mat-divider.mat-divider-inset{margin-left:80px}[dir=rtl] .mat-divider.mat-divider-inset{margin-left:auto;margin-right:80px}\n',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        _ = (() => {
          class t {}
          return (
            (t.ɵmod = i.Jb({ type: t })),
            (t.ɵinj = i.Ib({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[g.d], g.d],
            })),
            t
          )
        })()
      var y = n('tyNb'),
        v = n('/t3+')
      let w = (() => {
        class t {}
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵcmp = i.Fb({
            type: t,
            selectors: [['app-footer']],
            decls: 8,
            vars: 0,
            consts: [
              [
                'rel',
                'external',
                'target',
                '_blank',
                'href',
                'https://github.com/guiseek/webrtc.community/blob/main/LICENSE',
                1,
                'docs-link',
              ],
              [
                'rel',
                'external',
                'target',
                '_blank',
                'href',
                'https://github.com/guiseek/webrtc.community',
                1,
                'docs-link',
              ],
              [
                'xmlns',
                'http://www.w3.org/2000/svg',
                'height',
                '32',
                'viewBox',
                '0 0 16 16',
                'version',
                '1.1',
                'width',
                '32',
                'aria-hidden',
                'true',
              ],
              [
                'fill-rule',
                'evenodd',
                'd',
                'M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z',
              ],
            ],
            template: function (t, e) {
              1 & t &&
                (i.Qb(0, 'mat-toolbar'),
                i.Qb(1, 'a', 0),
                i.xc(2, ' BSD 3-Clause License '),
                i.Pb(),
                i.Qb(3, 'a', 1),
                i.ac(),
                i.Qb(4, 'svg', 2),
                i.Mb(5, 'path', 3),
                i.Pb(),
                i.Pb(),
                i.Zb(),
                i.Qb(6, 'span'),
                i.xc(7, '(c) 2020, Guilherme Siquinelli'),
                i.Pb(),
                i.Pb())
            },
            directives: [v.a],
            styles: [
              'app-footer{display:flex;flex-direction:column;align-items:center}app-footer .mat-toolbar{font-size:90%;justify-content:center;align-items:center}app-footer .mat-toolbar a{display:inline-flex}app-footer .mat-toolbar svg{display:inline-flex;width:24px;height:auto;margin:0 12px}@media (max-width:720px){app-footer .mat-toolbar{flex-direction:column}app-footer .mat-toolbar span{display:none}}',
            ],
            encapsulation: 2,
          })),
          t
        )
      })()
      function C(t, e) {
        if (
          (1 & t &&
            (i.Qb(0, 'div', 7),
            i.Qb(1, 'div', 8),
            i.Mb(2, 'img', 9),
            i.Pb(),
            i.xc(3),
            i.Pb()),
          2 & t)
        ) {
          const t = e.$implicit
          i.zb(2),
            i.gc('alt', t.alt)('src', t.src, i.oc),
            i.zb(1),
            i.zc(' ', t.alt, ' ')
        }
      }
      const x = [
        {
          path: '',
          component: (() => {
            class t {
              constructor() {
                this.banners = [
                  {
                    src: 'assets/banners/peer-to-peer.svg',
                    alt: 'Ponto a ponto',
                    action: '',
                  },
                  {
                    src: 'assets/banners/live.svg',
                    alt: 'Tempo real',
                    action: '',
                  },
                  {
                    src: 'assets/banners/broadcast.svg',
                    alt: 'Difusor',
                    action: '',
                  },
                  {
                    src: 'assets/banners/multi-protocols.svg',
                    alt: 'Multi protocolo',
                    action: '',
                  },
                  {
                    src: 'assets/banners/security.svg',
                    alt: 'Seguro',
                    action: '',
                  },
                  {
                    src: 'assets/banners/easy.svg',
                    alt: 'Simples',
                    action: '',
                  },
                ]
              }
            }
            return (
              (t.ɵfac = function (e) {
                return new (e || t)()
              }),
              (t.ɵcmp = i.Fb({
                type: t,
                selectors: [['app-home']],
                decls: 47,
                vars: 3,
                consts: [
                  [1, 'docs-home-promo'],
                  [
                    1,
                    'docs-home-featured-components',
                    'docs-home-carousel-row',
                  ],
                  [3, 'itemWidth', 'aria-label'],
                  [
                    'carousel-item',
                    '',
                    'class',
                    'docs-featured-components-carousel-item',
                    4,
                    'ngFor',
                    'ngForOf',
                  ],
                  [1, 'docs-home-row', 'docs-introduction'],
                  [1, 'docs-home-row-column'],
                  ['routerLink', '', 1, 'docs-link'],
                  [
                    'carousel-item',
                    '',
                    1,
                    'docs-featured-components-carousel-item',
                  ],
                  [1, 'docs-home-img-container'],
                  ['role', 'presentation', 3, 'alt', 'src'],
                ],
                template: function (t, e) {
                  1 & t &&
                    (i.Qb(0, 'main', 0),
                    i.Qb(1, 'div', 1),
                    i.Qb(2, 'quertc-carousel', 2),
                    i.vc(3, C, 4, 3, 'div', 3),
                    i.Pb(),
                    i.Pb(),
                    i.Mb(4, 'mat-divider'),
                    i.Qb(5, 'div', 4),
                    i.Qb(6, 'div', 5),
                    i.Qb(7, 'h2'),
                    i.xc(8, 'C\xf3digo aberto'),
                    i.Pb(),
                    i.Qb(9, 'p'),
                    i.xc(
                      10,
                      ' O projeto WebRTC \xe9 de c\xf3digo aberto e suportado pela Apple, Google, Microsoft e Mozilla, entre outros. '
                    ),
                    i.Pb(),
                    i.Qb(11, 'p'),
                    i.xc(
                      12,
                      ' Todo conte\xfado do projeto s\xe3o/ser\xe3o mantidos pela comunidade. '
                    ),
                    i.Qb(13, 'a', 6),
                    i.xc(14, 'Gostaria de contribuir?'),
                    i.Pb(),
                    i.Pb(),
                    i.Pb(),
                    i.Qb(15, 'div', 5),
                    i.Qb(16, 'h2'),
                    i.xc(17, 'Vers\xe1til'),
                    i.Pb(),
                    i.Qb(18, 'p'),
                    i.xc(
                      19,
                      ' Projetado de forma que possa ser integrado aos sistemas de comunica\xe7\xe3o existentes: voz sobre IP (VOIP), v\xe1rios clientes SIP. '
                    ),
                    i.Pb(),
                    i.Qb(20, 'p'),
                    i.xc(
                      21,
                      'Inclusive rede telef\xf4nica p\xfablica comutada.'
                    ),
                    i.Pb(),
                    i.Pb(),
                    i.Qb(22, 'div', 5),
                    i.Qb(23, 'h2'),
                    i.xc(24, 'Simples'),
                    i.Pb(),
                    i.Qb(25, 'p'),
                    i.xc(
                      26,
                      ' Aplica\xe7\xf5es de \xe1udio, v\xeddeo e troca de dados ponto a ponto com alta qualidade, requer muitas novas funcionalidades no navegador. '
                    ),
                    i.Pb(),
                    i.Qb(27, 'p'),
                    i.xc(
                      28,
                      ' Felizmente, o navegador abstrai a essa complexidade com tr\xeas APIs principais. '
                    ),
                    i.Mb(29, 'br'),
                    i.Pb(),
                    i.Pb(),
                    i.Pb(),
                    i.Qb(30, 'div', 4),
                    i.Qb(31, 'div', 5),
                    i.Qb(32, 'h2'),
                    i.xc(33, 'MediaStream'),
                    i.Pb(),
                    i.Qb(34, 'p'),
                    i.xc(
                      35,
                      'Aquisi\xe7\xe3o de streams para \xe1udio e v\xeddeo'
                    ),
                    i.Pb(),
                    i.Pb(),
                    i.Qb(36, 'div', 5),
                    i.Qb(37, 'h2'),
                    i.xc(38, 'RTCPeerConnection'),
                    i.Pb(),
                    i.Qb(39, 'p'),
                    i.xc(
                      40,
                      'Comunica\xe7\xe3o de dados para \xe1udio e v\xeddeo'
                    ),
                    i.Pb(),
                    i.Pb(),
                    i.Qb(41, 'div', 5),
                    i.Qb(42, 'h2'),
                    i.xc(43, 'RTCDataChannel'),
                    i.Pb(),
                    i.Qb(44, 'p'),
                    i.xc(45, 'Comunica\xe7\xe3o de dados para aplicativos'),
                    i.Pb(),
                    i.Pb(),
                    i.Pb(),
                    i.Pb(),
                    i.Mb(46, 'app-footer')),
                    2 & t &&
                      (i.zb(2),
                      i.gc('itemWidth', 260)(
                        'aria-label',
                        'Featured components'
                      ),
                      i.zb(1),
                      i.gc('ngForOf', e.banners))
                },
                directives: [f, o.j, b, y.c, w, p],
                styles: [
                  '[_nghost-%COMP%]{position:relative;display:flex;flex-direction:column;flex:1}.docs-header-background[_ngcontent-%COMP%]{overflow:hidden;position:relative;height:420px}.docs-header-background[_ngcontent-%COMP%]:before{content:"";position:absolute;background-size:600px;top:0;bottom:0;left:0;right:0;background-repeat:no-repeat;background-position:80% 20px;opacity:.2}.docs-header-section[_ngcontent-%COMP%]{width:90%;position:absolute;z-index:0;text-align:center;top:50%;left:50%;transform:translate(-50%,-50%)}.docs-header-headline[_ngcontent-%COMP%]   h1[_ngcontent-%COMP%]{font-size:56px;font-weight:700;line-height:56px;margin:15px 5px}.docs-header-headline[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{font-size:20px;font-weight:300;line-height:28px;margin:15px 0 25px}.docs-home-promo[_ngcontent-%COMP%]{flex:1;align-items:center;display:flex;flex-direction:column;padding:16px}.docs-home-promo[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{text-decoration:none}.docs-home-promo[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{font-size:25px;font-weight:400;margin:16px 0;padding:0}.docs-home-promo[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-size:16px;font-weight:400;line-height:28px;margin:0 0 24px;padding:0}.docs-home-promo[_ngcontent-%COMP%]   mat-divider[_ngcontent-%COMP%]{width:75%}.docs-home-promo[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{vertical-align:middle}.docs-home-row[_ngcontent-%COMP%]{width:75%;display:flex;flex-direction:row;margin:50px 0}.docs-home-carousel-row[_ngcontent-%COMP%]{margin:50px 0;width:75%;display:flex;flex-direction:column}.docs-home-carousel-row[_ngcontent-%COMP%]   a.docs-link[_ngcontent-%COMP%]{width:100%;text-align:right}.docs-home-carousel-row[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{margin-top:0}.docs-home-guides[_ngcontent-%COMP%]   .docs-home-guides-card-divider[_ngcontent-%COMP%]{width:30%;height:5px;margin:15px auto}.docs-home-guides[_ngcontent-%COMP%]   .docs-home-guides-carousel-item[_ngcontent-%COMP%]{padding:15px;display:flex;text-decoration:none}.docs-home-guides[_ngcontent-%COMP%]   .docs-home-guides-card.mat-card[_ngcontent-%COMP%]{text-align:center}.docs-home-guides[_ngcontent-%COMP%]   .docs-home-guides-card[_ngcontent-%COMP%]   .mat-card-title[_ngcontent-%COMP%]{height:35%;display:flex;align-items:center;justify-content:center;font-size:20px}.docs-home-featured-components[_ngcontent-%COMP%]   .docs-featured-components-carousel-item[_ngcontent-%COMP%]{padding:15px;text-align:center}.docs-home-featured-components[_ngcontent-%COMP%]   .docs-featured-components-carousel-item[_ngcontent-%COMP%]   .docs-home-img-container[_ngcontent-%COMP%]{overflow:hidden;width:259px;height:144px;margin-bottom:10px}.docs-home-featured-components[_ngcontent-%COMP%]   .docs-featured-components-carousel-item[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{transition:.3s ease-in-out;width:100%}.docs-home-row-column[_ngcontent-%COMP%]{display:flex;flex-direction:column;margin:0 auto;width:30%}.docs-header-start[_ngcontent-%COMP%]{text-align:center;margin:50px 0 0}.docs-header-start[_ngcontent-%COMP%]   .mat-raised-button[_ngcontent-%COMP%]{font-size:15px}@media (max-width:1200px){.docs-header-background[_ngcontent-%COMP%]{height:330px}.docs-header-background[_ngcontent-%COMP%]:before{background-image:none}}@media (max-width:850px){.docs-header-background[_ngcontent-%COMP%]:before{background-image:none}.docs-introduction[_ngcontent-%COMP%]{flex-direction:column}.docs-home-row-column[_ngcontent-%COMP%]{width:100%}}@media (max-width:720px){.docs-header-start[_ngcontent-%COMP%]{margin:15px 0 0}.docs-home-carousel-row[_ngcontent-%COMP%], .docs-home-row[_ngcontent-%COMP%]{margin:15px 0}}',
                ],
              })),
              t
            )
          })(),
        },
        {
          path: 'restart-ice',
          loadChildren: () =>
            n
              .e(6)
              .then(n.bind(null, 'R3tv'))
              .then((t) => t.RestartIceModule),
        },
        {
          path: 'peer-to-peer',
          loadChildren: () =>
            n
              .e(4)
              .then(n.bind(null, 'E4j7'))
              .then((t) => t.PeerToPeerModule),
        },
        {
          path: 'perfect-negotiation',
          loadChildren: () =>
            n
              .e(5)
              .then(n.bind(null, 'zOaj'))
              .then((t) => t.PerfectNegotiationModule),
        },
      ]
      var S = n('kmnG'),
        O = n('R1ws'),
        k = n('jhN1'),
        E = n('t7Mq'),
        A = n('MAu8')
      let T = (() => {
        class t {}
        return (
          (t.ɵmod = i.Jb({ type: t })),
          (t.ɵinj = i.Ib({
            factory: function (e) {
              return new (e || t)()
            },
            imports: [[o.c, l.b, a.c]],
          })),
          t
        )
      })()
      var j = n('Huv7'),
        I = n('2Mw2'),
        P = n('pLZG'),
        R = n('XNiG'),
        D = n('itXk'),
        L = n('GyhO'),
        F = n('HDdC'),
        N = n('IzEk'),
        M = n('7o/Q')
      class V {
        constructor(t) {
          this.total = t
        }
        call(t, e) {
          return e.subscribe(new U(t, this.total))
        }
      }
      class U extends M.a {
        constructor(t, e) {
          super(t), (this.total = e), (this.count = 0)
        }
        _next(t) {
          ++this.count > this.total && this.destination.next(t)
        }
      }
      var B = n('Kj3r'),
        z = n('lJxs'),
        H = n('JX91'),
        q = n('1G5W'),
        W = n('nLfN')
      let $ = (() => {
        class t {}
        return (
          (t.ɵmod = i.Jb({ type: t })),
          (t.ɵinj = i.Ib({
            factory: function (e) {
              return new (e || t)()
            },
          })),
          t
        )
      })()
      const G = new Set()
      let Q,
        X = (() => {
          class t {
            constructor(t) {
              ;(this._platform = t),
                (this._matchMedia =
                  this._platform.isBrowser && window.matchMedia
                    ? window.matchMedia.bind(window)
                    : K)
            }
            matchMedia(t) {
              return (
                this._platform.WEBKIT &&
                  (function (t) {
                    if (!G.has(t))
                      try {
                        Q ||
                          ((Q = document.createElement('style')),
                          Q.setAttribute('type', 'text/css'),
                          document.head.appendChild(Q)),
                          Q.sheet &&
                            (Q.sheet.insertRule(
                              `@media ${t} {.fx-query-test{ }}`,
                              0
                            ),
                            G.add(t))
                      } catch (e) {
                        console.error(e)
                      }
                  })(t),
                this._matchMedia(t)
              )
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Ub(W.a))
            }),
            (t.ɵprov = Object(i.Hb)({
              factory: function () {
                return new t(Object(i.Ub)(W.a))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })()
      function K(t) {
        return {
          matches: 'all' === t || '' === t,
          media: t,
          addListener: () => {},
          removeListener: () => {},
        }
      }
      let Y = (() => {
        class t {
          constructor(t, e) {
            ;(this._mediaMatcher = t),
              (this._zone = e),
              (this._queries = new Map()),
              (this._destroySubject = new R.a())
          }
          ngOnDestroy() {
            this._destroySubject.next(), this._destroySubject.complete()
          }
          isMatched(t) {
            return Z(Object(m.a)(t)).some(
              (t) => this._registerQuery(t).mql.matches
            )
          }
          observe(t) {
            const e = Z(Object(m.a)(t)).map(
              (t) => this._registerQuery(t).observable
            )
            let n = Object(D.b)(e)
            return (
              (n = Object(L.a)(
                n.pipe(Object(N.a)(1)),
                n.pipe((t) => t.lift(new V(1)), Object(B.a)(0))
              )),
              n.pipe(
                Object(z.a)((t) => {
                  const e = { matches: !1, breakpoints: {} }
                  return (
                    t.forEach(({ matches: t, query: n }) => {
                      ;(e.matches = e.matches || t), (e.breakpoints[n] = t)
                    }),
                    e
                  )
                })
              )
            )
          }
          _registerQuery(t) {
            if (this._queries.has(t)) return this._queries.get(t)
            const e = this._mediaMatcher.matchMedia(t),
              n = {
                observable: new F.a((t) => {
                  const n = (e) => this._zone.run(() => t.next(e))
                  return (
                    e.addListener(n),
                    () => {
                      e.removeListener(n)
                    }
                  )
                }).pipe(
                  Object(H.a)(e),
                  Object(z.a)(({ matches: e }) => ({ query: t, matches: e })),
                  Object(q.a)(this._destroySubject)
                ),
                mql: e,
              }
            return this._queries.set(t, n), n
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Ub(X), i.Ub(i.z))
          }),
          (t.ɵprov = Object(i.Hb)({
            factory: function () {
              return new t(Object(i.Ub)(X), Object(i.Ub)(i.z))
            },
            token: t,
            providedIn: 'root',
          })),
          t
        )
      })()
      function Z(t) {
        return t
          .map((t) => t.split(','))
          .reduce((t, e) => t.concat(e))
          .map((t) => t.trim())
      }
      let J = (() => {
        class t {
          constructor() {}
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵcmp = i.Fb({
            type: t,
            selectors: [['app-navbar']],
            inputs: { snav: 'snav', title: 'title' },
            decls: 11,
            vars: 1,
            consts: [
              ['color', 'primary', 1, 'client-toolbar'],
              ['mat-icon-button', '', 3, 'click'],
              ['mat-icon-button', '', 'routerLink', '/'],
              [1, 'client-app-name'],
              [1, 'spacer'],
              ['src', 'assets/message.svg', 'alt', ''],
            ],
            template: function (t, e) {
              1 & t &&
                (i.Qb(0, 'mat-toolbar', 0),
                i.Qb(1, 'button', 1),
                i.Xb('click', function () {
                  return e.snav.toggle()
                }),
                i.Qb(2, 'mat-icon'),
                i.xc(3, 'menu'),
                i.Pb(),
                i.Pb(),
                i.Qb(4, 'a', 2),
                i.Qb(5, 'mat-icon'),
                i.xc(6, 'home'),
                i.Pb(),
                i.Pb(),
                i.Qb(7, 'h1', 3),
                i.xc(8),
                i.Pb(),
                i.Mb(9, 'span', 4),
                i.Mb(10, 'img', 5),
                i.Pb()),
                2 & t && (i.zb(8), i.yc(e.title))
            },
            directives: [v.a, a.b, l.a, a.a, y.c],
            styles: [
              '@media (max-width:720px){.client-app-name[_ngcontent-%COMP%]{font-size:86%}}',
            ],
          })),
          t
        )
      })()
      var tt = n('vxfF'),
        et = n('FtGj'),
        nt = n('xgIS'),
        it = n('VRyK')
      function rt(t) {
        return (e) => e.lift(new st(t))
      }
      class st {
        constructor(t) {
          this.value = t
        }
        call(t, e) {
          return e.subscribe(new ot(t, this.value))
        }
      }
      class ot extends M.a {
        constructor(t, e) {
          super(t), (this.value = e)
        }
        _next(t) {
          this.destination.next(this.value)
        }
      }
      var at = n('/uUt'),
        lt = n('R0Ic'),
        ct = n('cH1L')
      const ut = ['*']
      function ht(t, e) {
        if (1 & t) {
          const t = i.Rb()
          i.Qb(0, 'div', 2),
            i.Xb('click', function () {
              return i.nc(t), i.bc()._onBackdropClicked()
            }),
            i.Pb()
        }
        if (2 & t) {
          const t = i.bc()
          i.Db('mat-drawer-shown', t._isShowingBackdrop())
        }
      }
      function dt(t, e) {
        1 & t && (i.Qb(0, 'mat-drawer-content'), i.ec(1, 2), i.Pb())
      }
      const pt = [[['mat-drawer']], [['mat-drawer-content']], '*'],
        ft = ['mat-drawer', 'mat-drawer-content', '*']
      function mt(t, e) {
        if (1 & t) {
          const t = i.Rb()
          i.Qb(0, 'div', 2),
            i.Xb('click', function () {
              return i.nc(t), i.bc()._onBackdropClicked()
            }),
            i.Pb()
        }
        if (2 & t) {
          const t = i.bc()
          i.Db('mat-drawer-shown', t._isShowingBackdrop())
        }
      }
      function gt(t, e) {
        1 & t && (i.Qb(0, 'mat-sidenav-content', 3), i.ec(1, 2), i.Pb())
      }
      const bt = [[['mat-sidenav']], [['mat-sidenav-content']], '*'],
        _t = ['mat-sidenav', 'mat-sidenav-content', '*'],
        yt =
          '.mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\n',
        vt = {
          transformDrawer: Object(lt.n)('transform', [
            Object(lt.k)(
              'open, open-instant',
              Object(lt.l)({ transform: 'none', visibility: 'visible' })
            ),
            Object(lt.k)(
              'void',
              Object(lt.l)({ 'box-shadow': 'none', visibility: 'hidden' })
            ),
            Object(lt.m)('void => open-instant', Object(lt.e)('0ms')),
            Object(lt.m)(
              'void <=> open, open-instant => void',
              Object(lt.e)('400ms cubic-bezier(0.25, 0.8, 0.25, 1)')
            ),
          ]),
        },
        wt = new i.q('MAT_DRAWER_DEFAULT_AUTOSIZE', {
          providedIn: 'root',
          factory: function () {
            return !1
          },
        }),
        Ct = new i.q('MAT_DRAWER_CONTAINER')
      let xt = (() => {
          class t extends tt.a {
            constructor(t, e, n, i, r) {
              super(n, i, r),
                (this._changeDetectorRef = t),
                (this._container = e)
            }
            ngAfterContentInit() {
              this._container._contentMarginChanges.subscribe(() => {
                this._changeDetectorRef.markForCheck()
              })
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                i.Lb(i.h),
                i.Lb(Object(i.T)(() => Ot)),
                i.Lb(i.l),
                i.Lb(tt.c),
                i.Lb(i.z)
              )
            }),
            (t.ɵcmp = i.Fb({
              type: t,
              selectors: [['mat-drawer-content']],
              hostAttrs: [1, 'mat-drawer-content'],
              hostVars: 4,
              hostBindings: function (t, e) {
                2 & t &&
                  i.sc('margin-left', e._container._contentMargins.left, 'px')(
                    'margin-right',
                    e._container._contentMargins.right,
                    'px'
                  )
              },
              features: [i.wb],
              ngContentSelectors: ut,
              decls: 1,
              vars: 0,
              template: function (t, e) {
                1 & t && (i.fc(), i.ec(0))
              },
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        St = (() => {
          class t {
            constructor(t, e, n, r, s, o, a) {
              ;(this._elementRef = t),
                (this._focusTrapFactory = e),
                (this._focusMonitor = n),
                (this._platform = r),
                (this._ngZone = s),
                (this._doc = o),
                (this._container = a),
                (this._elementFocusedBeforeDrawerWasOpened = null),
                (this._enableAnimations = !1),
                (this._position = 'start'),
                (this._mode = 'over'),
                (this._disableClose = !1),
                (this._opened = !1),
                (this._animationStarted = new R.a()),
                (this._animationEnd = new R.a()),
                (this._animationState = 'void'),
                (this.openedChange = new i.n(!0)),
                (this._openedStream = this.openedChange.pipe(
                  Object(P.a)((t) => t),
                  Object(z.a)(() => {})
                )),
                (this.openedStart = this._animationStarted.pipe(
                  Object(P.a)(
                    (t) =>
                      t.fromState !== t.toState &&
                      0 === t.toState.indexOf('open')
                  ),
                  rt(void 0)
                )),
                (this._closedStream = this.openedChange.pipe(
                  Object(P.a)((t) => !t),
                  Object(z.a)(() => {})
                )),
                (this.closedStart = this._animationStarted.pipe(
                  Object(P.a)(
                    (t) => t.fromState !== t.toState && 'void' === t.toState
                  ),
                  rt(void 0)
                )),
                (this._destroyed = new R.a()),
                (this.onPositionChanged = new i.n()),
                (this._modeChanged = new R.a()),
                this.openedChange.subscribe((t) => {
                  t
                    ? (this._doc &&
                        (this._elementFocusedBeforeDrawerWasOpened = this._doc.activeElement),
                      this._takeFocus())
                    : this._isFocusWithinDrawer() && this._restoreFocus()
                }),
                this._ngZone.runOutsideAngular(() => {
                  Object(nt.a)(this._elementRef.nativeElement, 'keydown')
                    .pipe(
                      Object(P.a)(
                        (t) =>
                          t.keyCode === et.e &&
                          !this.disableClose &&
                          !Object(et.o)(t)
                      ),
                      Object(q.a)(this._destroyed)
                    )
                    .subscribe((t) =>
                      this._ngZone.run(() => {
                        this.close(), t.stopPropagation(), t.preventDefault()
                      })
                    )
                }),
                this._animationEnd
                  .pipe(
                    Object(at.a)(
                      (t, e) =>
                        t.fromState === e.fromState && t.toState === e.toState
                    )
                  )
                  .subscribe((t) => {
                    const { fromState: e, toState: n } = t
                    ;((0 === n.indexOf('open') && 'void' === e) ||
                      ('void' === n && 0 === e.indexOf('open'))) &&
                      this.openedChange.emit(this._opened)
                  })
            }
            get position() {
              return this._position
            }
            set position(t) {
              ;(t = 'end' === t ? 'end' : 'start') != this._position &&
                ((this._position = t), this.onPositionChanged.emit())
            }
            get mode() {
              return this._mode
            }
            set mode(t) {
              ;(this._mode = t),
                this._updateFocusTrapState(),
                this._modeChanged.next()
            }
            get disableClose() {
              return this._disableClose
            }
            set disableClose(t) {
              this._disableClose = Object(m.b)(t)
            }
            get autoFocus() {
              const t = this._autoFocus
              return null == t ? 'side' !== this.mode : t
            }
            set autoFocus(t) {
              this._autoFocus = Object(m.b)(t)
            }
            get opened() {
              return this._opened
            }
            set opened(t) {
              this.toggle(Object(m.b)(t))
            }
            _takeFocus() {
              this.autoFocus &&
                this._focusTrap &&
                this._focusTrap.focusInitialElementWhenReady().then((t) => {
                  t ||
                    'function' != typeof this._elementRef.nativeElement.focus ||
                    this._elementRef.nativeElement.focus()
                })
            }
            _restoreFocus() {
              this.autoFocus &&
                (this._elementFocusedBeforeDrawerWasOpened
                  ? this._focusMonitor.focusVia(
                      this._elementFocusedBeforeDrawerWasOpened,
                      this._openedVia
                    )
                  : this._elementRef.nativeElement.blur(),
                (this._elementFocusedBeforeDrawerWasOpened = null),
                (this._openedVia = null))
            }
            _isFocusWithinDrawer() {
              var t
              const e =
                null === (t = this._doc) || void 0 === t
                  ? void 0
                  : t.activeElement
              return !!e && this._elementRef.nativeElement.contains(e)
            }
            ngAfterContentInit() {
              ;(this._focusTrap = this._focusTrapFactory.create(
                this._elementRef.nativeElement
              )),
                this._updateFocusTrapState()
            }
            ngAfterContentChecked() {
              this._platform.isBrowser && (this._enableAnimations = !0)
            }
            ngOnDestroy() {
              this._focusTrap && this._focusTrap.destroy(),
                this._animationStarted.complete(),
                this._animationEnd.complete(),
                this._modeChanged.complete(),
                this._destroyed.next(),
                this._destroyed.complete()
            }
            open(t) {
              return this.toggle(!0, t)
            }
            close() {
              return this.toggle(!1)
            }
            _closeViaBackdropClick() {
              return this._setOpen(!1, !0)
            }
            toggle(t = !this.opened, e) {
              return this._setOpen(t, !t && this._isFocusWithinDrawer(), e)
            }
            _setOpen(t, e, n = 'program') {
              return (
                (this._opened = t),
                t
                  ? ((this._animationState = this._enableAnimations
                      ? 'open'
                      : 'open-instant'),
                    (this._openedVia = n))
                  : ((this._animationState = 'void'),
                    e && this._restoreFocus()),
                this._updateFocusTrapState(),
                new Promise((t) => {
                  this.openedChange
                    .pipe(Object(N.a)(1))
                    .subscribe((e) => t(e ? 'open' : 'close'))
                })
              )
            }
            _getWidth() {
              return (
                (this._elementRef.nativeElement &&
                  this._elementRef.nativeElement.offsetWidth) ||
                0
              )
            }
            _updateFocusTrapState() {
              this._focusTrap &&
                (this._focusTrap.enabled = this.opened && 'side' !== this.mode)
            }
            _animationStartListener(t) {
              this._animationStarted.next(t)
            }
            _animationDoneListener(t) {
              this._animationEnd.next(t)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                i.Lb(i.l),
                i.Lb(s.f),
                i.Lb(s.e),
                i.Lb(W.a),
                i.Lb(i.z),
                i.Lb(o.d, 8),
                i.Lb(Ct, 8)
              )
            }),
            (t.ɵcmp = i.Fb({
              type: t,
              selectors: [['mat-drawer']],
              hostAttrs: ['tabIndex', '-1', 1, 'mat-drawer'],
              hostVars: 12,
              hostBindings: function (t, e) {
                1 & t &&
                  i.tc('@transform.start', function (t) {
                    return e._animationStartListener(t)
                  })('@transform.done', function (t) {
                    return e._animationDoneListener(t)
                  }),
                  2 & t &&
                    (i.Ab('align', null),
                    i.uc('@transform', e._animationState),
                    i.Db('mat-drawer-end', 'end' === e.position)(
                      'mat-drawer-over',
                      'over' === e.mode
                    )('mat-drawer-push', 'push' === e.mode)(
                      'mat-drawer-side',
                      'side' === e.mode
                    )('mat-drawer-opened', e.opened))
              },
              inputs: {
                position: 'position',
                mode: 'mode',
                disableClose: 'disableClose',
                autoFocus: 'autoFocus',
                opened: 'opened',
              },
              outputs: {
                openedChange: 'openedChange',
                _openedStream: 'opened',
                openedStart: 'openedStart',
                _closedStream: 'closed',
                closedStart: 'closedStart',
                onPositionChanged: 'positionChanged',
              },
              exportAs: ['matDrawer'],
              ngContentSelectors: ut,
              decls: 2,
              vars: 0,
              consts: [[1, 'mat-drawer-inner-container']],
              template: function (t, e) {
                1 & t && (i.fc(), i.Qb(0, 'div', 0), i.ec(1), i.Pb())
              },
              encapsulation: 2,
              data: { animation: [vt.transformDrawer] },
              changeDetection: 0,
            })),
            t
          )
        })(),
        Ot = (() => {
          class t {
            constructor(t, e, n, r, s, o = !1, a) {
              ;(this._dir = t),
                (this._element = e),
                (this._ngZone = n),
                (this._changeDetectorRef = r),
                (this._animationMode = a),
                (this._drawers = new i.D()),
                (this.backdropClick = new i.n()),
                (this._destroyed = new R.a()),
                (this._doCheckSubject = new R.a()),
                (this._contentMargins = { left: null, right: null }),
                (this._contentMarginChanges = new R.a()),
                t &&
                  t.change.pipe(Object(q.a)(this._destroyed)).subscribe(() => {
                    this._validateDrawers(), this.updateContentMargins()
                  }),
                s
                  .change()
                  .pipe(Object(q.a)(this._destroyed))
                  .subscribe(() => this.updateContentMargins()),
                (this._autosize = o)
            }
            get start() {
              return this._start
            }
            get end() {
              return this._end
            }
            get autosize() {
              return this._autosize
            }
            set autosize(t) {
              this._autosize = Object(m.b)(t)
            }
            get hasBackdrop() {
              return null == this._backdropOverride
                ? !this._start ||
                    'side' !== this._start.mode ||
                    !this._end ||
                    'side' !== this._end.mode
                : this._backdropOverride
            }
            set hasBackdrop(t) {
              this._backdropOverride = null == t ? null : Object(m.b)(t)
            }
            get scrollable() {
              return this._userContent || this._content
            }
            ngAfterContentInit() {
              this._allDrawers.changes
                .pipe(
                  Object(H.a)(this._allDrawers),
                  Object(q.a)(this._destroyed)
                )
                .subscribe((t) => {
                  this._drawers.reset(
                    t.filter((t) => !t._container || t._container === this)
                  ),
                    this._drawers.notifyOnChanges()
                }),
                this._drawers.changes.pipe(Object(H.a)(null)).subscribe(() => {
                  this._validateDrawers(),
                    this._drawers.forEach((t) => {
                      this._watchDrawerToggle(t),
                        this._watchDrawerPosition(t),
                        this._watchDrawerMode(t)
                    }),
                    (!this._drawers.length ||
                      this._isDrawerOpen(this._start) ||
                      this._isDrawerOpen(this._end)) &&
                      this.updateContentMargins(),
                    this._changeDetectorRef.markForCheck()
                }),
                this._ngZone.runOutsideAngular(() => {
                  this._doCheckSubject
                    .pipe(Object(B.a)(10), Object(q.a)(this._destroyed))
                    .subscribe(() => this.updateContentMargins())
                })
            }
            ngOnDestroy() {
              this._contentMarginChanges.complete(),
                this._doCheckSubject.complete(),
                this._drawers.destroy(),
                this._destroyed.next(),
                this._destroyed.complete()
            }
            open() {
              this._drawers.forEach((t) => t.open())
            }
            close() {
              this._drawers.forEach((t) => t.close())
            }
            updateContentMargins() {
              let t = 0,
                e = 0
              if (this._left && this._left.opened)
                if ('side' == this._left.mode) t += this._left._getWidth()
                else if ('push' == this._left.mode) {
                  const n = this._left._getWidth()
                  ;(t += n), (e -= n)
                }
              if (this._right && this._right.opened)
                if ('side' == this._right.mode) e += this._right._getWidth()
                else if ('push' == this._right.mode) {
                  const n = this._right._getWidth()
                  ;(e += n), (t -= n)
                }
              ;(t = t || null),
                (e = e || null),
                (t === this._contentMargins.left &&
                  e === this._contentMargins.right) ||
                  ((this._contentMargins = { left: t, right: e }),
                  this._ngZone.run(() =>
                    this._contentMarginChanges.next(this._contentMargins)
                  ))
            }
            ngDoCheck() {
              this._autosize &&
                this._isPushed() &&
                this._ngZone.runOutsideAngular(() =>
                  this._doCheckSubject.next()
                )
            }
            _watchDrawerToggle(t) {
              t._animationStarted
                .pipe(
                  Object(P.a)((t) => t.fromState !== t.toState),
                  Object(q.a)(this._drawers.changes)
                )
                .subscribe((t) => {
                  'open-instant' !== t.toState &&
                    'NoopAnimations' !== this._animationMode &&
                    this._element.nativeElement.classList.add(
                      'mat-drawer-transition'
                    ),
                    this.updateContentMargins(),
                    this._changeDetectorRef.markForCheck()
                }),
                'side' !== t.mode &&
                  t.openedChange
                    .pipe(Object(q.a)(this._drawers.changes))
                    .subscribe(() => this._setContainerClass(t.opened))
            }
            _watchDrawerPosition(t) {
              t &&
                t.onPositionChanged
                  .pipe(Object(q.a)(this._drawers.changes))
                  .subscribe(() => {
                    this._ngZone.onMicrotaskEmpty
                      .pipe(Object(N.a)(1))
                      .subscribe(() => {
                        this._validateDrawers()
                      })
                  })
            }
            _watchDrawerMode(t) {
              t &&
                t._modeChanged
                  .pipe(
                    Object(q.a)(
                      Object(it.a)(this._drawers.changes, this._destroyed)
                    )
                  )
                  .subscribe(() => {
                    this.updateContentMargins(),
                      this._changeDetectorRef.markForCheck()
                  })
            }
            _setContainerClass(t) {
              const e = this._element.nativeElement.classList,
                n = 'mat-drawer-container-has-open'
              t ? e.add(n) : e.remove(n)
            }
            _validateDrawers() {
              ;(this._start = this._end = null),
                this._drawers.forEach((t) => {
                  'end' == t.position ? (this._end = t) : (this._start = t)
                }),
                (this._right = this._left = null),
                this._dir && 'rtl' === this._dir.value
                  ? ((this._left = this._end), (this._right = this._start))
                  : ((this._left = this._start), (this._right = this._end))
            }
            _isPushed() {
              return (
                (this._isDrawerOpen(this._start) &&
                  'over' != this._start.mode) ||
                (this._isDrawerOpen(this._end) && 'over' != this._end.mode)
              )
            }
            _onBackdropClicked() {
              this.backdropClick.emit(), this._closeModalDrawersViaBackdrop()
            }
            _closeModalDrawersViaBackdrop() {
              ;[this._start, this._end]
                .filter((t) => t && !t.disableClose && this._canHaveBackdrop(t))
                .forEach((t) => t._closeViaBackdropClick())
            }
            _isShowingBackdrop() {
              return (
                (this._isDrawerOpen(this._start) &&
                  this._canHaveBackdrop(this._start)) ||
                (this._isDrawerOpen(this._end) &&
                  this._canHaveBackdrop(this._end))
              )
            }
            _canHaveBackdrop(t) {
              return 'side' !== t.mode || !!this._backdropOverride
            }
            _isDrawerOpen(t) {
              return null != t && t.opened
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                i.Lb(ct.b, 8),
                i.Lb(i.l),
                i.Lb(i.z),
                i.Lb(i.h),
                i.Lb(tt.e),
                i.Lb(wt),
                i.Lb(O.a, 8)
              )
            }),
            (t.ɵcmp = i.Fb({
              type: t,
              selectors: [['mat-drawer-container']],
              contentQueries: function (t, e, n) {
                if ((1 & t && (i.Eb(n, xt, !0), i.Eb(n, St, !0)), 2 & t)) {
                  let t
                  i.jc((t = i.Yb())) && (e._content = t.first),
                    i.jc((t = i.Yb())) && (e._allDrawers = t)
                }
              },
              viewQuery: function (t, e) {
                if ((1 & t && i.Ac(xt, !0), 2 & t)) {
                  let t
                  i.jc((t = i.Yb())) && (e._userContent = t.first)
                }
              },
              hostAttrs: [1, 'mat-drawer-container'],
              hostVars: 2,
              hostBindings: function (t, e) {
                2 & t &&
                  i.Db(
                    'mat-drawer-container-explicit-backdrop',
                    e._backdropOverride
                  )
              },
              inputs: { autosize: 'autosize', hasBackdrop: 'hasBackdrop' },
              outputs: { backdropClick: 'backdropClick' },
              exportAs: ['matDrawerContainer'],
              features: [i.yb([{ provide: Ct, useExisting: t }])],
              ngContentSelectors: ft,
              decls: 4,
              vars: 2,
              consts: [
                [
                  'class',
                  'mat-drawer-backdrop',
                  3,
                  'mat-drawer-shown',
                  'click',
                  4,
                  'ngIf',
                ],
                [4, 'ngIf'],
                [1, 'mat-drawer-backdrop', 3, 'click'],
              ],
              template: function (t, e) {
                1 & t &&
                  (i.fc(pt),
                  i.vc(0, ht, 1, 2, 'div', 0),
                  i.ec(1),
                  i.ec(2, 1),
                  i.vc(3, dt, 2, 0, 'mat-drawer-content', 1)),
                  2 & t &&
                    (i.gc('ngIf', e.hasBackdrop),
                    i.zb(3),
                    i.gc('ngIf', !e._content))
              },
              directives: [o.k, xt],
              styles: [yt],
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        kt = (() => {
          class t extends xt {
            constructor(t, e, n, i, r) {
              super(t, e, n, i, r)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                i.Lb(i.h),
                i.Lb(Object(i.T)(() => Tt)),
                i.Lb(i.l),
                i.Lb(tt.c),
                i.Lb(i.z)
              )
            }),
            (t.ɵcmp = i.Fb({
              type: t,
              selectors: [['mat-sidenav-content']],
              hostAttrs: [1, 'mat-drawer-content', 'mat-sidenav-content'],
              hostVars: 4,
              hostBindings: function (t, e) {
                2 & t &&
                  i.sc('margin-left', e._container._contentMargins.left, 'px')(
                    'margin-right',
                    e._container._contentMargins.right,
                    'px'
                  )
              },
              features: [i.wb],
              ngContentSelectors: ut,
              decls: 1,
              vars: 0,
              template: function (t, e) {
                1 & t && (i.fc(), i.ec(0))
              },
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        Et = (() => {
          class t extends St {
            constructor() {
              super(...arguments),
                (this._fixedInViewport = !1),
                (this._fixedTopGap = 0),
                (this._fixedBottomGap = 0)
            }
            get fixedInViewport() {
              return this._fixedInViewport
            }
            set fixedInViewport(t) {
              this._fixedInViewport = Object(m.b)(t)
            }
            get fixedTopGap() {
              return this._fixedTopGap
            }
            set fixedTopGap(t) {
              this._fixedTopGap = Object(m.e)(t)
            }
            get fixedBottomGap() {
              return this._fixedBottomGap
            }
            set fixedBottomGap(t) {
              this._fixedBottomGap = Object(m.e)(t)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return At(e || t)
            }),
            (t.ɵcmp = i.Fb({
              type: t,
              selectors: [['mat-sidenav']],
              hostAttrs: ['tabIndex', '-1', 1, 'mat-drawer', 'mat-sidenav'],
              hostVars: 17,
              hostBindings: function (t, e) {
                2 & t &&
                  (i.Ab('align', null),
                  i.sc('top', e.fixedInViewport ? e.fixedTopGap : null, 'px')(
                    'bottom',
                    e.fixedInViewport ? e.fixedBottomGap : null,
                    'px'
                  ),
                  i.Db('mat-drawer-end', 'end' === e.position)(
                    'mat-drawer-over',
                    'over' === e.mode
                  )('mat-drawer-push', 'push' === e.mode)(
                    'mat-drawer-side',
                    'side' === e.mode
                  )('mat-drawer-opened', e.opened)(
                    'mat-sidenav-fixed',
                    e.fixedInViewport
                  ))
              },
              inputs: {
                fixedInViewport: 'fixedInViewport',
                fixedTopGap: 'fixedTopGap',
                fixedBottomGap: 'fixedBottomGap',
              },
              exportAs: ['matSidenav'],
              features: [i.wb],
              ngContentSelectors: ut,
              decls: 2,
              vars: 0,
              consts: [[1, 'mat-drawer-inner-container']],
              template: function (t, e) {
                1 & t && (i.fc(), i.Qb(0, 'div', 0), i.ec(1), i.Pb())
              },
              encapsulation: 2,
              data: { animation: [vt.transformDrawer] },
              changeDetection: 0,
            })),
            t
          )
        })()
      const At = i.Sb(Et)
      let Tt = (() => {
        class t extends Ot {}
        return (
          (t.ɵfac = function (e) {
            return jt(e || t)
          }),
          (t.ɵcmp = i.Fb({
            type: t,
            selectors: [['mat-sidenav-container']],
            contentQueries: function (t, e, n) {
              if ((1 & t && (i.Eb(n, kt, !0), i.Eb(n, Et, !0)), 2 & t)) {
                let t
                i.jc((t = i.Yb())) && (e._content = t.first),
                  i.jc((t = i.Yb())) && (e._allDrawers = t)
              }
            },
            hostAttrs: [1, 'mat-drawer-container', 'mat-sidenav-container'],
            hostVars: 2,
            hostBindings: function (t, e) {
              2 & t &&
                i.Db(
                  'mat-drawer-container-explicit-backdrop',
                  e._backdropOverride
                )
            },
            exportAs: ['matSidenavContainer'],
            features: [i.yb([{ provide: Ct, useExisting: t }]), i.wb],
            ngContentSelectors: _t,
            decls: 4,
            vars: 2,
            consts: [
              [
                'class',
                'mat-drawer-backdrop',
                3,
                'mat-drawer-shown',
                'click',
                4,
                'ngIf',
              ],
              ['cdkScrollable', '', 4, 'ngIf'],
              [1, 'mat-drawer-backdrop', 3, 'click'],
              ['cdkScrollable', ''],
            ],
            template: function (t, e) {
              1 & t &&
                (i.fc(bt),
                i.vc(0, mt, 1, 2, 'div', 0),
                i.ec(1),
                i.ec(2, 1),
                i.vc(3, gt, 2, 0, 'mat-sidenav-content', 1)),
                2 & t &&
                  (i.gc('ngIf', e.hasBackdrop),
                  i.zb(3),
                  i.gc('ngIf', !e._content))
            },
            directives: [o.k, kt, tt.a],
            styles: [yt],
            encapsulation: 2,
            changeDetection: 0,
          })),
          t
        )
      })()
      const jt = i.Sb(Tt)
      let It = (() => {
        class t {}
        return (
          (t.ɵmod = i.Jb({ type: t })),
          (t.ɵinj = i.Ib({
            factory: function (e) {
              return new (e || t)()
            },
            imports: [[o.c, g.d, W.b, tt.b], tt.b, g.d],
          })),
          t
        )
      })()
      n('0EQZ')
      var Pt = n('3Pt+')
      const Rt = ['*'],
        Dt = [
          [
            ['', 'mat-list-avatar', ''],
            ['', 'mat-list-icon', ''],
            ['', 'matListAvatar', ''],
            ['', 'matListIcon', ''],
          ],
          [
            ['', 'mat-line', ''],
            ['', 'matLine', ''],
          ],
          '*',
        ],
        Lt = [
          '[mat-list-avatar], [mat-list-icon], [matListAvatar], [matListIcon]',
          '[mat-line], [matLine]',
          '*',
        ]
      class Ft {}
      const Nt = Object(g.q)(Object(g.p)(Ft))
      class Mt {}
      const Vt = Object(g.p)(Mt),
        Ut = new i.q('MatList'),
        Bt = new i.q('MatNavList')
      let zt = (() => {
        class t extends Nt {
          constructor() {
            super(...arguments), (this._stateChanges = new R.a())
          }
          ngOnChanges() {
            this._stateChanges.next()
          }
          ngOnDestroy() {
            this._stateChanges.complete()
          }
        }
        return (
          (t.ɵfac = function (e) {
            return Ht(e || t)
          }),
          (t.ɵcmp = i.Fb({
            type: t,
            selectors: [['mat-nav-list']],
            hostAttrs: [
              'role',
              'navigation',
              1,
              'mat-nav-list',
              'mat-list-base',
            ],
            inputs: { disableRipple: 'disableRipple', disabled: 'disabled' },
            exportAs: ['matNavList'],
            features: [i.yb([{ provide: Bt, useExisting: t }]), i.wb, i.xb],
            ngContentSelectors: Rt,
            decls: 1,
            vars: 0,
            template: function (t, e) {
              1 & t && (i.fc(), i.ec(0))
            },
            styles: [
              '.mat-subheader{display:flex;box-sizing:border-box;padding:16px;align-items:center}.mat-list-base .mat-subheader{margin:0}.mat-list-base{padding-top:8px;display:block;-webkit-tap-highlight-color:transparent}.mat-list-base .mat-subheader{height:48px;line-height:16px}.mat-list-base .mat-subheader:first-child{margin-top:-8px}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{display:block;height:48px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base .mat-list-item .mat-list-item-content,.mat-list-base .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base .mat-list-item .mat-list-item-content-reverse,.mat-list-base .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base .mat-list-item .mat-list-item-ripple,.mat-list-base .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar,.mat-list-base .mat-list-option.mat-list-item-with-avatar{height:56px}.mat-list-base .mat-list-item.mat-2-line,.mat-list-base .mat-list-option.mat-2-line{height:72px}.mat-list-base .mat-list-item.mat-3-line,.mat-list-base .mat-list-option.mat-3-line{height:88px}.mat-list-base .mat-list-item.mat-multi-line,.mat-list-base .mat-list-option.mat-multi-line{height:auto}.mat-list-base .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base .mat-list-item .mat-list-text,.mat-list-base .mat-list-option .mat-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base .mat-list-item .mat-list-text>*,.mat-list-base .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-list-base .mat-list-item .mat-list-text:empty,.mat-list-base .mat-list-option .mat-list-text:empty{display:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base .mat-list-item .mat-list-avatar,.mat-list-base .mat-list-option .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%;object-fit:cover}.mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:72px;width:calc(100% - 72px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:72px}.mat-list-base .mat-list-item .mat-list-icon,.mat-list-base .mat-list-option .mat-list-icon{flex-shrink:0;width:24px;height:24px;font-size:24px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:64px;width:calc(100% - 64px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:64px}.mat-list-base .mat-list-item .mat-divider,.mat-list-base .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base .mat-list-item .mat-divider,[dir=rtl] .mat-list-base .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-list-base[dense]{padding-top:4px;display:block}.mat-list-base[dense] .mat-subheader{height:40px;line-height:8px}.mat-list-base[dense] .mat-subheader:first-child{margin-top:-4px}.mat-list-base[dense] .mat-list-item,.mat-list-base[dense] .mat-list-option{display:block;height:40px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-item-content,.mat-list-base[dense] .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base[dense] .mat-list-item .mat-list-item-content-reverse,.mat-list-base[dense] .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base[dense] .mat-list-item .mat-list-item-ripple,.mat-list-base[dense] .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar{height:48px}.mat-list-base[dense] .mat-list-item.mat-2-line,.mat-list-base[dense] .mat-list-option.mat-2-line{height:60px}.mat-list-base[dense] .mat-list-item.mat-3-line,.mat-list-base[dense] .mat-list-option.mat-3-line{height:76px}.mat-list-base[dense] .mat-list-item.mat-multi-line,.mat-list-base[dense] .mat-list-option.mat-multi-line{height:auto}.mat-list-base[dense] .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base[dense] .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base[dense] .mat-list-item .mat-list-text,.mat-list-base[dense] .mat-list-option .mat-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-text>*,.mat-list-base[dense] .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-list-base[dense] .mat-list-item .mat-list-text:empty,.mat-list-base[dense] .mat-list-option .mat-list-text:empty{display:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base[dense] .mat-list-item .mat-list-avatar,.mat-list-base[dense] .mat-list-option .mat-list-avatar{flex-shrink:0;width:36px;height:36px;border-radius:50%;object-fit:cover}.mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:68px;width:calc(100% - 68px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:68px}.mat-list-base[dense] .mat-list-item .mat-list-icon,.mat-list-base[dense] .mat-list-option .mat-list-icon{flex-shrink:0;width:20px;height:20px;font-size:20px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:60px;width:calc(100% - 60px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:60px}.mat-list-base[dense] .mat-list-item .mat-divider,.mat-list-base[dense] .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-divider,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base[dense] .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-nav-list a{text-decoration:none;color:inherit}.mat-nav-list .mat-list-item{cursor:pointer;outline:none}mat-action-list button{background:none;color:inherit;border:none;font:inherit;outline:inherit;-webkit-tap-highlight-color:transparent;text-align:left}[dir=rtl] mat-action-list button{text-align:right}mat-action-list button::-moz-focus-inner{border:0}mat-action-list .mat-list-item{cursor:pointer;outline:inherit}.mat-list-option:not(.mat-list-item-disabled){cursor:pointer;outline:none}.mat-list-item-disabled{pointer-events:none}.cdk-high-contrast-active .mat-list-item-disabled{opacity:.5}.cdk-high-contrast-active :host .mat-list-item-disabled{opacity:.5}.cdk-high-contrast-active .mat-selection-list:focus{outline-style:dotted}.cdk-high-contrast-active .mat-list-option:hover,.cdk-high-contrast-active .mat-list-option:focus,.cdk-high-contrast-active .mat-nav-list .mat-list-item:hover,.cdk-high-contrast-active .mat-nav-list .mat-list-item:focus,.cdk-high-contrast-active mat-action-list .mat-list-item:hover,.cdk-high-contrast-active mat-action-list .mat-list-item:focus{outline:dotted 1px}.cdk-high-contrast-active .mat-list-single-selected-option::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}.cdk-high-contrast-active [dir=rtl] .mat-list-single-selected-option::after{right:auto;left:16px}@media(hover: none){.mat-list-option:not(.mat-list-single-selected-option):not(.mat-list-item-disabled):hover,.mat-nav-list .mat-list-item:not(.mat-list-item-disabled):hover,.mat-action-list .mat-list-item:not(.mat-list-item-disabled):hover{background:none}}\n',
            ],
            encapsulation: 2,
            changeDetection: 0,
          })),
          t
        )
      })()
      const Ht = i.Sb(zt)
      let qt = (() => {
          class t {}
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵdir = i.Gb({
              type: t,
              selectors: [
                ['', 'mat-list-avatar', ''],
                ['', 'matListAvatar', ''],
              ],
              hostAttrs: [1, 'mat-list-avatar'],
            })),
            t
          )
        })(),
        Wt = (() => {
          class t {}
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵdir = i.Gb({
              type: t,
              selectors: [
                ['', 'mat-list-icon', ''],
                ['', 'matListIcon', ''],
              ],
              hostAttrs: [1, 'mat-list-icon'],
            })),
            t
          )
        })(),
        $t = (() => {
          class t extends Vt {
            constructor(t, e, n, i) {
              super(),
                (this._element = t),
                (this._isInteractiveList = !1),
                (this._destroyed = new R.a()),
                (this._disabled = !1),
                (this._isInteractiveList = !!(
                  n ||
                  (i && 'action-list' === i._getListType())
                )),
                (this._list = n || i)
              const r = this._getHostElement()
              'button' !== r.nodeName.toLowerCase() ||
                r.hasAttribute('type') ||
                r.setAttribute('type', 'button'),
                this._list &&
                  this._list._stateChanges
                    .pipe(Object(q.a)(this._destroyed))
                    .subscribe(() => {
                      e.markForCheck()
                    })
            }
            get disabled() {
              return this._disabled || !(!this._list || !this._list.disabled)
            }
            set disabled(t) {
              this._disabled = Object(m.b)(t)
            }
            ngAfterContentInit() {
              Object(g.t)(this._lines, this._element)
            }
            ngOnDestroy() {
              this._destroyed.next(), this._destroyed.complete()
            }
            _isRippleDisabled() {
              return (
                !this._isInteractiveList ||
                this.disableRipple ||
                !(!this._list || !this._list.disableRipple)
              )
            }
            _getHostElement() {
              return this._element.nativeElement
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                i.Lb(i.l),
                i.Lb(i.h),
                i.Lb(Bt, 8),
                i.Lb(Ut, 8)
              )
            }),
            (t.ɵcmp = i.Fb({
              type: t,
              selectors: [
                ['mat-list-item'],
                ['a', 'mat-list-item', ''],
                ['button', 'mat-list-item', ''],
              ],
              contentQueries: function (t, e, n) {
                if (
                  (1 & t &&
                    (i.Eb(n, qt, !0), i.Eb(n, Wt, !0), i.Eb(n, g.e, !0)),
                  2 & t)
                ) {
                  let t
                  i.jc((t = i.Yb())) && (e._avatar = t.first),
                    i.jc((t = i.Yb())) && (e._icon = t.first),
                    i.jc((t = i.Yb())) && (e._lines = t)
                }
              },
              hostAttrs: [1, 'mat-list-item', 'mat-focus-indicator'],
              hostVars: 6,
              hostBindings: function (t, e) {
                2 & t &&
                  i.Db('mat-list-item-disabled', e.disabled)(
                    'mat-list-item-avatar',
                    e._avatar || e._icon
                  )('mat-list-item-with-avatar', e._avatar || e._icon)
              },
              inputs: { disableRipple: 'disableRipple', disabled: 'disabled' },
              exportAs: ['matListItem'],
              features: [i.wb],
              ngContentSelectors: Lt,
              decls: 6,
              vars: 2,
              consts: [
                [1, 'mat-list-item-content'],
                [
                  'mat-ripple',
                  '',
                  1,
                  'mat-list-item-ripple',
                  3,
                  'matRippleTrigger',
                  'matRippleDisabled',
                ],
                [1, 'mat-list-text'],
              ],
              template: function (t, e) {
                1 & t &&
                  (i.fc(Dt),
                  i.Qb(0, 'div', 0),
                  i.Mb(1, 'div', 1),
                  i.ec(2),
                  i.Qb(3, 'div', 2),
                  i.ec(4, 1),
                  i.Pb(),
                  i.ec(5, 2),
                  i.Pb()),
                  2 & t &&
                    (i.zb(1),
                    i.gc('matRippleTrigger', e._getHostElement())(
                      'matRippleDisabled',
                      e._isRippleDisabled()
                    ))
              },
              directives: [g.k],
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        Gt = (() => {
          class t {}
          return (
            (t.ɵmod = i.Jb({ type: t })),
            (t.ɵinj = i.Ib({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[g.f, g.l, g.d, g.j, o.c], g.f, g.d, g.j, _],
            })),
            t
          )
        })(),
        Qt = (() => {
          class t {
            constructor() {
              this.githubCorner = !0
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵcmp = i.Fb({
              type: t,
              selectors: [
                ['app-github-corner'],
                ['a', 'app-github-corner', ''],
              ],
              hostVars: 2,
              hostBindings: function (t, e) {
                2 & t && i.Db('github-corner', e.githubCorner)
              },
              decls: 4,
              vars: 0,
              consts: [
                ['width', '80', 'height', '80', 'viewBox', '0 0 250 250'],
                ['d', 'M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z'],
                [
                  'd',
                  'M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2',
                  1,
                  'octo-arm',
                  2,
                  'transform-origin',
                  '130px 106px',
                ],
                [
                  'd',
                  'M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z',
                  1,
                  'octo-body',
                ],
              ],
              template: function (t, e) {
                1 & t &&
                  (i.ac(),
                  i.Qb(0, 'svg', 0),
                  i.Mb(1, 'path', 1),
                  i.Mb(2, 'path', 2),
                  i.Mb(3, 'path', 3),
                  i.Pb())
              },
              styles: [
                '[_nghost-%COMP%]{display:flex;position:absolute;top:0;border:0;right:0;z-index:10}.github-corner[_nghost-%COMP%]:hover   .octo-arm[_ngcontent-%COMP%]{animation:octocat-wave .56s ease-in-out}@keyframes octocat-wave{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-15deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner[_ngcontent-%COMP%]:hover   .octo-arm[_ngcontent-%COMP%]{animation:none}.github-corner[_ngcontent-%COMP%]   .octo-arm[_ngcontent-%COMP%]{animation:octocat-wave .56s ease-in-out}}',
              ],
            })),
            t
          )
        })()
      var Xt = n('rDax'),
        Kt = n('+rOU')
      const Yt = {
          tooltipState: Object(lt.n)('state', [
            Object(lt.k)(
              'initial, void, hidden',
              Object(lt.l)({ opacity: 0, transform: 'scale(0)' })
            ),
            Object(lt.k)('visible', Object(lt.l)({ transform: 'scale(1)' })),
            Object(lt.m)(
              '* => visible',
              Object(lt.e)(
                '200ms cubic-bezier(0, 0, 0.2, 1)',
                Object(lt.h)([
                  Object(lt.l)({
                    opacity: 0,
                    transform: 'scale(0)',
                    offset: 0,
                  }),
                  Object(lt.l)({
                    opacity: 0.5,
                    transform: 'scale(0.99)',
                    offset: 0.5,
                  }),
                  Object(lt.l)({
                    opacity: 1,
                    transform: 'scale(1)',
                    offset: 1,
                  }),
                ])
              )
            ),
            Object(lt.m)(
              '* => hidden',
              Object(lt.e)(
                '100ms cubic-bezier(0, 0, 0.2, 1)',
                Object(lt.l)({ opacity: 0 })
              )
            ),
          ]),
        },
        Zt = Object(W.e)({ passive: !0 }),
        Jt = new i.q('mat-tooltip-scroll-strategy'),
        te = {
          provide: Jt,
          deps: [Xt.c],
          useFactory: function (t) {
            return () => t.scrollStrategies.reposition({ scrollThrottle: 20 })
          },
        },
        ee = new i.q('mat-tooltip-default-options', {
          providedIn: 'root',
          factory: function () {
            return { showDelay: 0, hideDelay: 0, touchendHideDelay: 1500 }
          },
        })
      let ne = (() => {
          class t {
            constructor(t, e, n, i, r, s, o, a, l, c, u) {
              ;(this._overlay = t),
                (this._elementRef = e),
                (this._scrollDispatcher = n),
                (this._viewContainerRef = i),
                (this._ngZone = r),
                (this._platform = s),
                (this._ariaDescriber = o),
                (this._focusMonitor = a),
                (this._dir = c),
                (this._defaultOptions = u),
                (this._position = 'below'),
                (this._disabled = !1),
                (this._viewInitialized = !1),
                (this._pointerExitEventsInitialized = !1),
                (this.showDelay = this._defaultOptions.showDelay),
                (this.hideDelay = this._defaultOptions.hideDelay),
                (this.touchGestures = 'auto'),
                (this._message = ''),
                (this._passiveListeners = []),
                (this._destroyed = new R.a()),
                (this._handleKeydown = (t) => {
                  this._isTooltipVisible() &&
                    t.keyCode === et.e &&
                    !Object(et.o)(t) &&
                    (t.preventDefault(),
                    t.stopPropagation(),
                    this._ngZone.run(() => this.hide(0)))
                }),
                (this._scrollStrategy = l),
                u &&
                  (u.position && (this.position = u.position),
                  u.touchGestures && (this.touchGestures = u.touchGestures)),
                r.runOutsideAngular(() => {
                  e.nativeElement.addEventListener(
                    'keydown',
                    this._handleKeydown
                  )
                })
            }
            get position() {
              return this._position
            }
            set position(t) {
              t !== this._position &&
                ((this._position = t),
                this._overlayRef &&
                  (this._updatePosition(),
                  this._tooltipInstance && this._tooltipInstance.show(0),
                  this._overlayRef.updatePosition()))
            }
            get disabled() {
              return this._disabled
            }
            set disabled(t) {
              ;(this._disabled = Object(m.b)(t)),
                this._disabled
                  ? this.hide(0)
                  : this._setupPointerEnterEventsIfNeeded()
            }
            get message() {
              return this._message
            }
            set message(t) {
              this._ariaDescriber.removeDescription(
                this._elementRef.nativeElement,
                this._message
              ),
                (this._message = null != t ? String(t).trim() : ''),
                !this._message && this._isTooltipVisible()
                  ? this.hide(0)
                  : (this._setupPointerEnterEventsIfNeeded(),
                    this._updateTooltipMessage(),
                    this._ngZone.runOutsideAngular(() => {
                      Promise.resolve().then(() => {
                        this._ariaDescriber.describe(
                          this._elementRef.nativeElement,
                          this.message
                        )
                      })
                    }))
            }
            get tooltipClass() {
              return this._tooltipClass
            }
            set tooltipClass(t) {
              ;(this._tooltipClass = t),
                this._tooltipInstance &&
                  this._setTooltipClass(this._tooltipClass)
            }
            ngAfterViewInit() {
              ;(this._viewInitialized = !0),
                this._setupPointerEnterEventsIfNeeded(),
                this._focusMonitor
                  .monitor(this._elementRef)
                  .pipe(Object(q.a)(this._destroyed))
                  .subscribe((t) => {
                    t
                      ? 'keyboard' === t && this._ngZone.run(() => this.show())
                      : this._ngZone.run(() => this.hide(0))
                  })
            }
            ngOnDestroy() {
              const t = this._elementRef.nativeElement
              clearTimeout(this._touchstartTimeout),
                this._overlayRef &&
                  (this._overlayRef.dispose(), (this._tooltipInstance = null)),
                t.removeEventListener('keydown', this._handleKeydown),
                this._passiveListeners.forEach(([e, n]) => {
                  t.removeEventListener(e, n, Zt)
                }),
                (this._passiveListeners.length = 0),
                this._destroyed.next(),
                this._destroyed.complete(),
                this._ariaDescriber.removeDescription(t, this.message),
                this._focusMonitor.stopMonitoring(t)
            }
            show(t = this.showDelay) {
              if (
                this.disabled ||
                !this.message ||
                (this._isTooltipVisible() &&
                  !this._tooltipInstance._showTimeoutId &&
                  !this._tooltipInstance._hideTimeoutId)
              )
                return
              const e = this._createOverlay()
              this._detach(),
                (this._portal =
                  this._portal || new Kt.a(ie, this._viewContainerRef)),
                (this._tooltipInstance = e.attach(this._portal).instance),
                this._tooltipInstance
                  .afterHidden()
                  .pipe(Object(q.a)(this._destroyed))
                  .subscribe(() => this._detach()),
                this._setTooltipClass(this._tooltipClass),
                this._updateTooltipMessage(),
                this._tooltipInstance.show(t)
            }
            hide(t = this.hideDelay) {
              this._tooltipInstance && this._tooltipInstance.hide(t)
            }
            toggle() {
              this._isTooltipVisible() ? this.hide() : this.show()
            }
            _isTooltipVisible() {
              return (
                !!this._tooltipInstance && this._tooltipInstance.isVisible()
              )
            }
            _createOverlay() {
              if (this._overlayRef) return this._overlayRef
              const t = this._scrollDispatcher.getAncestorScrollContainers(
                  this._elementRef
                ),
                e = this._overlay
                  .position()
                  .flexibleConnectedTo(this._elementRef)
                  .withTransformOriginOn('.mat-tooltip')
                  .withFlexibleDimensions(!1)
                  .withViewportMargin(8)
                  .withScrollableContainers(t)
              return (
                e.positionChanges
                  .pipe(Object(q.a)(this._destroyed))
                  .subscribe((t) => {
                    this._tooltipInstance &&
                      t.scrollableViewProperties.isOverlayClipped &&
                      this._tooltipInstance.isVisible() &&
                      this._ngZone.run(() => this.hide(0))
                  }),
                (this._overlayRef = this._overlay.create({
                  direction: this._dir,
                  positionStrategy: e,
                  panelClass: 'mat-tooltip-panel',
                  scrollStrategy: this._scrollStrategy(),
                })),
                this._updatePosition(),
                this._overlayRef
                  .detachments()
                  .pipe(Object(q.a)(this._destroyed))
                  .subscribe(() => this._detach()),
                this._overlayRef
              )
            }
            _detach() {
              this._overlayRef &&
                this._overlayRef.hasAttached() &&
                this._overlayRef.detach(),
                (this._tooltipInstance = null)
            }
            _updatePosition() {
              const t = this._overlayRef.getConfig().positionStrategy,
                e = this._getOrigin(),
                n = this._getOverlayPosition()
              t.withPositions([
                Object.assign(Object.assign({}, e.main), n.main),
                Object.assign(Object.assign({}, e.fallback), n.fallback),
              ])
            }
            _getOrigin() {
              const t = !this._dir || 'ltr' == this._dir.value,
                e = this.position
              let n
              'above' == e || 'below' == e
                ? (n = {
                    originX: 'center',
                    originY: 'above' == e ? 'top' : 'bottom',
                  })
                : 'before' == e || ('left' == e && t) || ('right' == e && !t)
                ? (n = { originX: 'start', originY: 'center' })
                : ('after' == e ||
                    ('right' == e && t) ||
                    ('left' == e && !t)) &&
                  (n = { originX: 'end', originY: 'center' })
              const { x: i, y: r } = this._invertPosition(n.originX, n.originY)
              return { main: n, fallback: { originX: i, originY: r } }
            }
            _getOverlayPosition() {
              const t = !this._dir || 'ltr' == this._dir.value,
                e = this.position
              let n
              'above' == e
                ? (n = { overlayX: 'center', overlayY: 'bottom' })
                : 'below' == e
                ? (n = { overlayX: 'center', overlayY: 'top' })
                : 'before' == e || ('left' == e && t) || ('right' == e && !t)
                ? (n = { overlayX: 'end', overlayY: 'center' })
                : ('after' == e ||
                    ('right' == e && t) ||
                    ('left' == e && !t)) &&
                  (n = { overlayX: 'start', overlayY: 'center' })
              const { x: i, y: r } = this._invertPosition(
                n.overlayX,
                n.overlayY
              )
              return { main: n, fallback: { overlayX: i, overlayY: r } }
            }
            _updateTooltipMessage() {
              this._tooltipInstance &&
                ((this._tooltipInstance.message = this.message),
                this._tooltipInstance._markForCheck(),
                this._ngZone.onMicrotaskEmpty
                  .pipe(Object(N.a)(1), Object(q.a)(this._destroyed))
                  .subscribe(() => {
                    this._tooltipInstance && this._overlayRef.updatePosition()
                  }))
            }
            _setTooltipClass(t) {
              this._tooltipInstance &&
                ((this._tooltipInstance.tooltipClass = t),
                this._tooltipInstance._markForCheck())
            }
            _invertPosition(t, e) {
              return (
                'above' === this.position || 'below' === this.position
                  ? 'top' === e
                    ? (e = 'bottom')
                    : 'bottom' === e && (e = 'top')
                  : 'end' === t
                  ? (t = 'start')
                  : 'start' === t && (t = 'end'),
                { x: t, y: e }
              )
            }
            _setupPointerEnterEventsIfNeeded() {
              !this._disabled &&
                this.message &&
                this._viewInitialized &&
                !this._passiveListeners.length &&
                (this._platformSupportsMouseEvents()
                  ? this._passiveListeners.push([
                      'mouseenter',
                      () => {
                        this._setupPointerExitEventsIfNeeded(), this.show()
                      },
                    ])
                  : 'off' !== this.touchGestures &&
                    (this._disableNativeGesturesIfNecessary(),
                    this._passiveListeners.push([
                      'touchstart',
                      () => {
                        this._setupPointerExitEventsIfNeeded(),
                          clearTimeout(this._touchstartTimeout),
                          (this._touchstartTimeout = setTimeout(
                            () => this.show(),
                            500
                          ))
                      },
                    ])),
                this._addListeners(this._passiveListeners))
            }
            _setupPointerExitEventsIfNeeded() {
              if (this._pointerExitEventsInitialized) return
              this._pointerExitEventsInitialized = !0
              const t = []
              if (this._platformSupportsMouseEvents())
                t.push(['mouseleave', () => this.hide()])
              else if ('off' !== this.touchGestures) {
                this._disableNativeGesturesIfNecessary()
                const e = () => {
                  clearTimeout(this._touchstartTimeout),
                    this.hide(this._defaultOptions.touchendHideDelay)
                }
                t.push(['touchend', e], ['touchcancel', e])
              }
              this._addListeners(t), this._passiveListeners.push(...t)
            }
            _addListeners(t) {
              t.forEach(([t, e]) => {
                this._elementRef.nativeElement.addEventListener(t, e, Zt)
              })
            }
            _platformSupportsMouseEvents() {
              return !this._platform.IOS && !this._platform.ANDROID
            }
            _disableNativeGesturesIfNecessary() {
              const t = this.touchGestures
              if ('off' !== t) {
                const e = this._elementRef.nativeElement,
                  n = e.style
                ;('on' === t ||
                  ('INPUT' !== e.nodeName && 'TEXTAREA' !== e.nodeName)) &&
                  (n.userSelect = n.msUserSelect = n.webkitUserSelect = n.MozUserSelect =
                    'none'),
                  ('on' !== t && e.draggable) || (n.webkitUserDrag = 'none'),
                  (n.touchAction = 'none'),
                  (n.webkitTapHighlightColor = 'transparent')
              }
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                i.Lb(Xt.c),
                i.Lb(i.l),
                i.Lb(tt.c),
                i.Lb(i.P),
                i.Lb(i.z),
                i.Lb(W.a),
                i.Lb(s.c),
                i.Lb(s.e),
                i.Lb(Jt),
                i.Lb(ct.b, 8),
                i.Lb(ee, 8)
              )
            }),
            (t.ɵdir = i.Gb({
              type: t,
              selectors: [['', 'matTooltip', '']],
              hostAttrs: [1, 'mat-tooltip-trigger'],
              inputs: {
                showDelay: ['matTooltipShowDelay', 'showDelay'],
                hideDelay: ['matTooltipHideDelay', 'hideDelay'],
                touchGestures: ['matTooltipTouchGestures', 'touchGestures'],
                position: ['matTooltipPosition', 'position'],
                disabled: ['matTooltipDisabled', 'disabled'],
                message: ['matTooltip', 'message'],
                tooltipClass: ['matTooltipClass', 'tooltipClass'],
              },
              exportAs: ['matTooltip'],
            })),
            t
          )
        })(),
        ie = (() => {
          class t {
            constructor(t, e) {
              ;(this._changeDetectorRef = t),
                (this._breakpointObserver = e),
                (this._visibility = 'initial'),
                (this._closeOnInteraction = !1),
                (this._onHide = new R.a()),
                (this._isHandset = this._breakpointObserver.observe(
                  '(max-width: 599.98px) and (orientation: portrait), (max-width: 959.98px) and (orientation: landscape)'
                ))
            }
            show(t) {
              this._hideTimeoutId &&
                (clearTimeout(this._hideTimeoutId),
                (this._hideTimeoutId = null)),
                (this._closeOnInteraction = !0),
                (this._showTimeoutId = setTimeout(() => {
                  ;(this._visibility = 'visible'),
                    (this._showTimeoutId = null),
                    this._markForCheck()
                }, t))
            }
            hide(t) {
              this._showTimeoutId &&
                (clearTimeout(this._showTimeoutId),
                (this._showTimeoutId = null)),
                (this._hideTimeoutId = setTimeout(() => {
                  ;(this._visibility = 'hidden'),
                    (this._hideTimeoutId = null),
                    this._markForCheck()
                }, t))
            }
            afterHidden() {
              return this._onHide
            }
            isVisible() {
              return 'visible' === this._visibility
            }
            ngOnDestroy() {
              this._onHide.complete()
            }
            _animationStart() {
              this._closeOnInteraction = !1
            }
            _animationDone(t) {
              const e = t.toState
              'hidden' !== e || this.isVisible() || this._onHide.next(),
                ('visible' !== e && 'hidden' !== e) ||
                  (this._closeOnInteraction = !0)
            }
            _handleBodyInteraction() {
              this._closeOnInteraction && this.hide(0)
            }
            _markForCheck() {
              this._changeDetectorRef.markForCheck()
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Lb(i.h), i.Lb(Y))
            }),
            (t.ɵcmp = i.Fb({
              type: t,
              selectors: [['mat-tooltip-component']],
              hostAttrs: ['aria-hidden', 'true'],
              hostVars: 2,
              hostBindings: function (t, e) {
                1 & t &&
                  i.Xb(
                    'click',
                    function () {
                      return e._handleBodyInteraction()
                    },
                    !1,
                    i.lc
                  ),
                  2 & t && i.sc('zoom', 'visible' === e._visibility ? 1 : null)
              },
              decls: 3,
              vars: 7,
              consts: [[1, 'mat-tooltip', 3, 'ngClass']],
              template: function (t, e) {
                if (
                  (1 & t &&
                    (i.Qb(0, 'div', 0),
                    i.Xb('@state.start', function () {
                      return e._animationStart()
                    })('@state.done', function (t) {
                      return e._animationDone(t)
                    }),
                    i.cc(1, 'async'),
                    i.xc(2),
                    i.Pb()),
                  2 & t)
                ) {
                  let t = null
                  i.Db(
                    'mat-tooltip-handset',
                    null == (t = i.dc(1, 5, e._isHandset)) ? null : t.matches
                  ),
                    i.gc('ngClass', e.tooltipClass)('@state', e._visibility),
                    i.zb(2),
                    i.yc(e.message)
                }
              },
              directives: [o.i],
              pipes: [o.b],
              styles: [
                '.mat-tooltip-panel{pointer-events:none !important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}.cdk-high-contrast-active .mat-tooltip{outline:solid 1px}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}\n',
              ],
              encapsulation: 2,
              data: { animation: [Yt.tooltipState] },
              changeDetection: 0,
            })),
            t
          )
        })(),
        re = (() => {
          class t {}
          return (
            (t.ɵmod = i.Jb({ type: t })),
            (t.ɵinj = i.Ib({
              factory: function (e) {
                return new (e || t)()
              },
              providers: [te],
              imports: [[s.a, o.c, Xt.d, g.d], g.d, tt.b],
            })),
            t
          )
        })()
      const se = ['snav']
      function oe(t, e) {
        if (
          (1 & t &&
            (i.Qb(0, 'a', 9),
            i.Qb(1, 'mat-icon', 10),
            i.xc(2),
            i.Pb(),
            i.Qb(3, 'span'),
            i.xc(4),
            i.Pb(),
            i.Pb()),
          2 & t)
        ) {
          const t = e.$implicit
          i.gc('routerLink', t.route),
            i.zb(2),
            i.yc(t.icon),
            i.zb(2),
            i.yc(t.label)
        }
      }
      let ae = (() => {
        class t {
          constructor(t, e, n, i) {
            ;(this.stream = t),
              (this.title = 'WebRTC.Community'),
              (this.navLinks = [
                { route: '/', icon: 'home', label: 'Home' },
                {
                  route: '/restart-ice',
                  icon: 'cached',
                  label: 'Reiniciar candidato',
                },
                {
                  route: '/peer-to-peer',
                  icon: 'alt_route',
                  label: 'Ponto a ponto',
                },
                {
                  route: '/perfect-negotiation',
                  icon: 'swap_calls',
                  label: 'Negocia\xe7\xe3o perfeita',
                },
              ]),
              (this.mobileQuery = e.matchMedia('(max-width: 600px)')),
              (this._mobileQueryListener = () => n.detectChanges()),
              this.mobileQuery.addEventListener(
                'change',
                this._mobileQueryListener
              ),
              (this.subscription = i.events
                .pipe(Object(P.a)((t) => t instanceof y.a))
                .subscribe(() => this.onRouteChange()))
          }
          onRouteChange() {
            var t
            this.snav.opened && this.snav.close(),
              (null === (t = this.stream.currentStream) || void 0 === t
                ? void 0
                : t.active) &&
                this.stream.currentStream.getTracks().forEach((t) => t.stop())
          }
          ngOnDestroy() {
            this.subscription.unsubscribe(),
              this.mobileQuery.removeEventListener(
                'change',
                this._mobileQueryListener
              )
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Lb(I.a), i.Lb(X), i.Lb(i.h), i.Lb(y.b))
          }),
          (t.ɵcmp = i.Fb({
            type: t,
            selectors: [['app-root']],
            viewQuery: function (t, e) {
              if ((1 & t && i.Ac(se, !0), 2 & t)) {
                let t
                i.jc((t = i.Yb())) && (e.snav = t.first)
              }
            },
            decls: 10,
            vars: 7,
            consts: [
              [1, 'client-container'],
              [3, 'snav', 'title'],
              [1, 'client-sidenav-container'],
              ['fixedTopGap', '56', 3, 'mode', 'fixedInViewport'],
              ['snav', ''],
              [1, 'client-nav-list'],
              ['mat-list-item', '', 3, 'routerLink', 4, 'ngFor', 'ngForOf'],
              [1, 'client-sidenav-content'],
              [
                'rel',
                'external',
                'target',
                '_blank',
                'app-github-corner',
                '',
                'matTooltip',
                'Contribua com o projeto',
                'matTooltipPosition',
                'before',
                'href',
                'https://github.com/guiseek/webrtc.community',
              ],
              ['mat-list-item', '', 3, 'routerLink'],
              ['color', 'accent', 1, 'mat-18'],
            ],
            template: function (t, e) {
              if (
                (1 & t &&
                  (i.Qb(0, 'div', 0),
                  i.Mb(1, 'app-navbar', 1),
                  i.Qb(2, 'mat-sidenav-container', 2),
                  i.Qb(3, 'mat-sidenav', 3, 4),
                  i.Qb(5, 'mat-nav-list', 5),
                  i.vc(6, oe, 5, 3, 'a', 6),
                  i.Pb(),
                  i.Pb(),
                  i.Qb(7, 'mat-sidenav-content', 7),
                  i.Mb(8, 'a', 8),
                  i.Mb(9, 'router-outlet'),
                  i.Pb(),
                  i.Pb(),
                  i.Pb()),
                2 & t)
              ) {
                const t = i.kc(4)
                i.Db('client-is-mobile', e.mobileQuery.matches),
                  i.zb(1),
                  i.gc('snav', t)('title', e.title),
                  i.zb(2),
                  i.gc('mode', 'over')(
                    'fixedInViewport',
                    e.mobileQuery.matches
                  ),
                  i.zb(3),
                  i.gc('ngForOf', e.navLinks)
              }
            },
            directives: [J, Tt, Et, zt, o.j, kt, Qt, ne, y.e, $t, y.c, l.a],
            styles: [
              '[_nghost-%COMP%]{flex:1;display:flex;flex-direction:column;height:100%;font-family:sans-serif}.client-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;position:absolute;top:0;bottom:0;left:0;right:0}.client-is-mobile[_ngcontent-%COMP%]   .client-toolbar[_ngcontent-%COMP%]{position:fixed;z-index:2}h1.client-app-name[_ngcontent-%COMP%]{margin-left:8px}.client-nav-list[_ngcontent-%COMP%]   .mat-icon[_ngcontent-%COMP%]{margin-right:8px}.client-sidenav-container[_ngcontent-%COMP%]{flex:1}.client-sidenav-content[_ngcontent-%COMP%]{display:flex;flex-direction:column}.client-is-mobile[_ngcontent-%COMP%]   .client-sidenav-container[_ngcontent-%COMP%]{flex:1 0 auto}',
            ],
            changeDetection: 0,
          })),
          t
        )
      })()
      var le = n('Wp6s'),
        ce = n('NXyV'),
        ue = n('z6cu'),
        he = n('LRne'),
        de = n('KqfI')
      const pe = new F.a(de.a)
      var fe = n('eIep'),
        me = n('oB13'),
        ge = n('vkgz'),
        be = n('D0XW'),
        _e = n('WMd4')
      class ye {
        constructor(t, e) {
          ;(this.delay = t), (this.scheduler = e)
        }
        call(t, e) {
          return e.subscribe(new ve(t, this.delay, this.scheduler))
        }
      }
      class ve extends M.a {
        constructor(t, e, n) {
          super(t),
            (this.delay = e),
            (this.scheduler = n),
            (this.queue = []),
            (this.active = !1),
            (this.errored = !1)
        }
        static dispatch(t) {
          const e = t.source,
            n = e.queue,
            i = t.scheduler,
            r = t.destination
          for (; n.length > 0 && n[0].time - i.now() <= 0; )
            n.shift().notification.observe(r)
          if (n.length > 0) {
            const e = Math.max(0, n[0].time - i.now())
            this.schedule(t, e)
          } else this.unsubscribe(), (e.active = !1)
        }
        _schedule(t) {
          ;(this.active = !0),
            this.destination.add(
              t.schedule(ve.dispatch, this.delay, {
                source: this,
                destination: this.destination,
                scheduler: t,
              })
            )
        }
        scheduleNotification(t) {
          if (!0 === this.errored) return
          const e = this.scheduler,
            n = new we(e.now() + this.delay, t)
          this.queue.push(n), !1 === this.active && this._schedule(e)
        }
        _next(t) {
          this.scheduleNotification(_e.a.createNext(t))
        }
        _error(t) {
          ;(this.errored = !0),
            (this.queue = []),
            this.destination.error(t),
            this.unsubscribe()
        }
        _complete() {
          this.scheduleNotification(_e.a.createComplete()), this.unsubscribe()
        }
      }
      class we {
        constructor(t, e) {
          ;(this.time = t), (this.notification = e)
        }
      }
      const Ce = 'Service workers are disabled or not supported by this browser'
      class xe {
        constructor(t) {
          if (((this.serviceWorker = t), t)) {
            const e = Object(nt.a)(t, 'controllerchange').pipe(
                Object(z.a)(() => t.controller)
              ),
              n = Object(ce.a)(() => Object(he.a)(t.controller)),
              i = Object(L.a)(n, e)
            ;(this.worker = i.pipe(Object(P.a)((t) => !!t))),
              (this.registration = this.worker.pipe(
                Object(fe.a)(() => t.getRegistration())
              ))
            const r = Object(nt.a)(t, 'message')
              .pipe(Object(z.a)((t) => t.data))
              .pipe(Object(P.a)((t) => t && t.type))
              .pipe(Object(me.a)(new R.a()))
            r.connect(), (this.events = r)
          } else
            this.worker = this.events = this.registration = Object(ce.a)(() =>
              Object(ue.a)(
                new Error(
                  'Service workers are disabled or not supported by this browser'
                )
              )
            )
        }
        postMessage(t, e) {
          return this.worker
            .pipe(
              Object(N.a)(1),
              Object(ge.a)((n) => {
                n.postMessage(Object.assign({ action: t }, e))
              })
            )
            .toPromise()
            .then(() => {})
        }
        postMessageWithStatus(t, e, n) {
          const i = this.waitForStatus(n),
            r = this.postMessage(t, e)
          return Promise.all([i, r]).then(() => {})
        }
        generateNonce() {
          return Math.round(1e7 * Math.random())
        }
        eventsOfType(t) {
          return this.events.pipe(Object(P.a)((e) => e.type === t))
        }
        nextEventOfType(t) {
          return this.eventsOfType(t).pipe(Object(N.a)(1))
        }
        waitForStatus(t) {
          return this.eventsOfType('STATUS')
            .pipe(
              Object(P.a)((e) => e.nonce === t),
              Object(N.a)(1),
              Object(z.a)((t) => {
                if (!t.status) throw new Error(t.error)
              })
            )
            .toPromise()
        }
        get isEnabled() {
          return !!this.serviceWorker
        }
      }
      let Se = (() => {
          class t {
            constructor(t) {
              if (
                ((this.sw = t),
                (this.subscriptionChanges = new R.a()),
                !t.isEnabled)
              )
                return (
                  (this.messages = pe),
                  (this.notificationClicks = pe),
                  void (this.subscription = pe)
                )
              ;(this.messages = this.sw
                .eventsOfType('PUSH')
                .pipe(Object(z.a)((t) => t.data))),
                (this.notificationClicks = this.sw
                  .eventsOfType('NOTIFICATION_CLICK')
                  .pipe(Object(z.a)((t) => t.data))),
                (this.pushManager = this.sw.registration.pipe(
                  Object(z.a)((t) => t.pushManager)
                ))
              const e = this.pushManager.pipe(
                Object(fe.a)((t) => t.getSubscription())
              )
              this.subscription = Object(it.a)(e, this.subscriptionChanges)
            }
            get isEnabled() {
              return this.sw.isEnabled
            }
            requestSubscription(t) {
              if (!this.sw.isEnabled) return Promise.reject(new Error(Ce))
              const e = { userVisibleOnly: !0 }
              let n = this.decodeBase64(
                  t.serverPublicKey.replace(/_/g, '/').replace(/-/g, '+')
                ),
                i = new Uint8Array(new ArrayBuffer(n.length))
              for (let r = 0; r < n.length; r++) i[r] = n.charCodeAt(r)
              return (
                (e.applicationServerKey = i),
                this.pushManager
                  .pipe(
                    Object(fe.a)((t) => t.subscribe(e)),
                    Object(N.a)(1)
                  )
                  .toPromise()
                  .then((t) => (this.subscriptionChanges.next(t), t))
              )
            }
            unsubscribe() {
              return this.sw.isEnabled
                ? this.subscription
                    .pipe(
                      Object(N.a)(1),
                      Object(fe.a)((t) => {
                        if (null === t)
                          throw new Error(
                            'Not subscribed to push notifications.'
                          )
                        return t.unsubscribe().then((t) => {
                          if (!t) throw new Error('Unsubscribe failed!')
                          this.subscriptionChanges.next(null)
                        })
                      })
                    )
                    .toPromise()
                : Promise.reject(new Error(Ce))
            }
            decodeBase64(t) {
              return atob(t)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Ub(xe))
            }),
            (t.ɵprov = i.Hb({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        Oe = (() => {
          class t {
            constructor(t) {
              if (((this.sw = t), !t.isEnabled))
                return (
                  (this.available = pe),
                  (this.activated = pe),
                  void (this.unrecoverable = pe)
                )
              ;(this.available = this.sw.eventsOfType('UPDATE_AVAILABLE')),
                (this.activated = this.sw.eventsOfType('UPDATE_ACTIVATED')),
                (this.unrecoverable = this.sw.eventsOfType(
                  'UNRECOVERABLE_STATE'
                ))
            }
            get isEnabled() {
              return this.sw.isEnabled
            }
            checkForUpdate() {
              if (!this.sw.isEnabled) return Promise.reject(new Error(Ce))
              const t = this.sw.generateNonce()
              return this.sw.postMessageWithStatus(
                'CHECK_FOR_UPDATES',
                { statusNonce: t },
                t
              )
            }
            activateUpdate() {
              if (!this.sw.isEnabled) return Promise.reject(new Error(Ce))
              const t = this.sw.generateNonce()
              return this.sw.postMessageWithStatus(
                'ACTIVATE_UPDATE',
                { statusNonce: t },
                t
              )
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Ub(xe))
            }),
            (t.ɵprov = i.Hb({ token: t, factory: t.ɵfac })),
            t
          )
        })()
      class ke {}
      const Ee = new i.q('NGSW_REGISTER_SCRIPT')
      function Ae(t, e, n, r) {
        return () => {
          if (
            !Object(o.r)(r) ||
            !('serviceWorker' in navigator) ||
            !1 === n.enabled
          )
            return
          let s
          if (
            (navigator.serviceWorker.addEventListener(
              'controllerchange',
              () => {
                null !== navigator.serviceWorker.controller &&
                  navigator.serviceWorker.controller.postMessage({
                    action: 'INITIALIZE',
                  })
              }
            ),
            'function' == typeof n.registrationStrategy)
          )
            s = n.registrationStrategy()
          else {
            const [e, ...i] = (
              n.registrationStrategy || 'registerWhenStable:30000'
            ).split(':')
            switch (e) {
              case 'registerImmediately':
                s = Object(he.a)(null)
                break
              case 'registerWithDelay':
                s = Te(+i[0] || 0)
                break
              case 'registerWhenStable':
                s = i[0] ? Object(it.a)(je(t), Te(+i[0])) : je(t)
                break
              default:
                throw new Error(
                  'Unknown ServiceWorker registration strategy: ' +
                    n.registrationStrategy
                )
            }
          }
          t.get(i.z).runOutsideAngular(() =>
            s.pipe(Object(N.a)(1)).subscribe(() =>
              navigator.serviceWorker
                .register(e, { scope: n.scope })
                .catch((e) => {
                  t.get(i.m).handleError(e)
                })
            )
          )
        }
      }
      function Te(t) {
        return Object(he.a)(null).pipe(
          (function (t, e = be.a) {
            var n
            const i =
              (n = t) instanceof Date && !isNaN(+n) ? +t - e.now() : Math.abs(t)
            return (t) => t.lift(new ye(i, e))
          })(t)
        )
      }
      function je(t) {
        return t.get(i.g).isStable.pipe(Object(P.a)((t) => t))
      }
      function Ie(t, e) {
        return new xe(
          Object(o.r)(e) && !1 !== t.enabled ? navigator.serviceWorker : void 0
        )
      }
      let Pe = (() => {
        class t {
          static register(e, n = {}) {
            return {
              ngModule: t,
              providers: [
                { provide: Ee, useValue: e },
                { provide: ke, useValue: n },
                { provide: xe, useFactory: Ie, deps: [ke, i.B] },
                {
                  provide: i.d,
                  useFactory: Ae,
                  deps: [i.r, Ee, ke, i.B],
                  multi: !0,
                },
              ],
            }
          }
        }
        return (
          (t.ɵmod = i.Jb({ type: t })),
          (t.ɵinj = i.Ib({
            factory: function (e) {
              return new (e || t)()
            },
            providers: [Se, Oe],
          })),
          t
        )
      })()
      function Re(t) {
        return new j.d(t)
      }
      const De = new i.q('SignalingChannel')
      n('0ujj')
      let Le = (() => {
        class t {}
        return (
          (t.ɵmod = i.Jb({ type: t, bootstrap: [ae] })),
          (t.ɵinj = i.Ib({
            factory: function (e) {
              return new (e || t)()
            },
            providers: [
              { provide: De, useValue: r.signaling },
              { provide: j.d, useFactory: Re, deps: [De] },
              { provide: I.b, useValue: r.configuration },
            ],
            imports: [
              [
                $,
                I.c,
                k.a,
                l.b,
                Gt,
                le.c,
                a.c,
                v.b,
                _,
                It,
                S.e,
                re,
                A.a,
                T,
                Pt.l,
                E.a.forRoot(),
                y.d.forRoot(x, { initialNavigation: 'enabled', useHash: !0 }),
                O.b,
                Pe.register('ngsw-worker.js', { enabled: r.prod }),
              ],
            ],
          })),
          t
        )
      })()
      r.prod && Object(i.S)(),
        k
          .c()
          .bootstrapModule(Le)
          .catch((t) => console.error(t))
    },
    akSB: function (t, e, n) {
      var i = n('AdPF'),
        r = n('0z79'),
        s = n('Cl5A'),
        o = n('CIKq')
      ;(e.polling = function (t) {
        var e = !1,
          n = !1,
          o = !1 !== t.jsonp
        if ('undefined' != typeof location) {
          var a = 'https:' === location.protocol,
            l = location.port
          l || (l = a ? 443 : 80),
            (e = t.hostname !== location.hostname || l !== t.port),
            (n = t.secure !== a)
        }
        if (
          ((t.xdomain = e),
          (t.xscheme = n),
          'open' in new i(t) && !t.forceJSONP)
        )
          return new r(t)
        if (!o) throw new Error('JSONP disabled')
        return new s(t)
      }),
        (e.websocket = o)
    },
    bHdf: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return s
      })
      var i = n('5+tZ'),
        r = n('SpAZ')
      function s(t = Number.POSITIVE_INFINITY) {
        return Object(i.a)(r.a, t)
      }
    },
    bOdf: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return r
      })
      var i = n('5+tZ')
      function r(t, e) {
        return Object(i.a)(t, e, 1)
      }
    },
    bTqV: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return f
      }),
        n.d(e, 'b', function () {
          return p
        }),
        n.d(e, 'c', function () {
          return m
        })
      var i = n('FKr1'),
        r = n('R1ws'),
        s = n('fXoL'),
        o = n('u47x')
      const a = ['mat-button', ''],
        l = ['*'],
        c =
          '.mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:block;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\n',
        u = [
          'mat-button',
          'mat-flat-button',
          'mat-icon-button',
          'mat-raised-button',
          'mat-stroked-button',
          'mat-mini-fab',
          'mat-fab',
        ]
      class h {
        constructor(t) {
          this._elementRef = t
        }
      }
      const d = Object(i.o)(Object(i.q)(Object(i.p)(h)))
      let p = (() => {
          class t extends d {
            constructor(t, e, n) {
              super(t),
                (this._focusMonitor = e),
                (this._animationMode = n),
                (this.isRoundButton = this._hasHostAttributes(
                  'mat-fab',
                  'mat-mini-fab'
                )),
                (this.isIconButton = this._hasHostAttributes('mat-icon-button'))
              for (const i of u)
                this._hasHostAttributes(i) &&
                  this._getHostElement().classList.add(i)
              t.nativeElement.classList.add('mat-button-base'),
                this.isRoundButton && (this.color = 'accent')
            }
            ngAfterViewInit() {
              this._focusMonitor.monitor(this._elementRef, !0)
            }
            ngOnDestroy() {
              this._focusMonitor.stopMonitoring(this._elementRef)
            }
            focus(t = 'program', e) {
              this._focusMonitor.focusVia(this._getHostElement(), t, e)
            }
            _getHostElement() {
              return this._elementRef.nativeElement
            }
            _isRippleDisabled() {
              return this.disableRipple || this.disabled
            }
            _hasHostAttributes(...t) {
              return t.some((t) => this._getHostElement().hasAttribute(t))
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(s.Lb(s.l), s.Lb(o.e), s.Lb(r.a, 8))
            }),
            (t.ɵcmp = s.Fb({
              type: t,
              selectors: [
                ['button', 'mat-button', ''],
                ['button', 'mat-raised-button', ''],
                ['button', 'mat-icon-button', ''],
                ['button', 'mat-fab', ''],
                ['button', 'mat-mini-fab', ''],
                ['button', 'mat-stroked-button', ''],
                ['button', 'mat-flat-button', ''],
              ],
              viewQuery: function (t, e) {
                if ((1 & t && s.Ac(i.k, !0), 2 & t)) {
                  let t
                  s.jc((t = s.Yb())) && (e.ripple = t.first)
                }
              },
              hostAttrs: [1, 'mat-focus-indicator'],
              hostVars: 5,
              hostBindings: function (t, e) {
                2 & t &&
                  (s.Ab('disabled', e.disabled || null),
                  s.Db(
                    '_mat-animation-noopable',
                    'NoopAnimations' === e._animationMode
                  )('mat-button-disabled', e.disabled))
              },
              inputs: {
                disabled: 'disabled',
                disableRipple: 'disableRipple',
                color: 'color',
              },
              exportAs: ['matButton'],
              features: [s.wb],
              attrs: a,
              ngContentSelectors: l,
              decls: 4,
              vars: 5,
              consts: [
                [1, 'mat-button-wrapper'],
                [
                  'matRipple',
                  '',
                  1,
                  'mat-button-ripple',
                  3,
                  'matRippleDisabled',
                  'matRippleCentered',
                  'matRippleTrigger',
                ],
                [1, 'mat-button-focus-overlay'],
              ],
              template: function (t, e) {
                1 & t &&
                  (s.fc(),
                  s.Qb(0, 'span', 0),
                  s.ec(1),
                  s.Pb(),
                  s.Mb(2, 'span', 1),
                  s.Mb(3, 'span', 2)),
                  2 & t &&
                    (s.zb(2),
                    s.Db(
                      'mat-button-ripple-round',
                      e.isRoundButton || e.isIconButton
                    ),
                    s.gc('matRippleDisabled', e._isRippleDisabled())(
                      'matRippleCentered',
                      e.isIconButton
                    )('matRippleTrigger', e._getHostElement()))
              },
              directives: [i.k],
              styles: [c],
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        f = (() => {
          class t extends p {
            constructor(t, e, n) {
              super(e, t, n)
            }
            _haltDisabledEvents(t) {
              this.disabled &&
                (t.preventDefault(), t.stopImmediatePropagation())
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(s.Lb(o.e), s.Lb(s.l), s.Lb(r.a, 8))
            }),
            (t.ɵcmp = s.Fb({
              type: t,
              selectors: [
                ['a', 'mat-button', ''],
                ['a', 'mat-raised-button', ''],
                ['a', 'mat-icon-button', ''],
                ['a', 'mat-fab', ''],
                ['a', 'mat-mini-fab', ''],
                ['a', 'mat-stroked-button', ''],
                ['a', 'mat-flat-button', ''],
              ],
              hostAttrs: [1, 'mat-focus-indicator'],
              hostVars: 7,
              hostBindings: function (t, e) {
                1 & t &&
                  s.Xb('click', function (t) {
                    return e._haltDisabledEvents(t)
                  }),
                  2 & t &&
                    (s.Ab('tabindex', e.disabled ? -1 : e.tabIndex || 0)(
                      'disabled',
                      e.disabled || null
                    )('aria-disabled', e.disabled.toString()),
                    s.Db(
                      '_mat-animation-noopable',
                      'NoopAnimations' === e._animationMode
                    )('mat-button-disabled', e.disabled))
              },
              inputs: {
                disabled: 'disabled',
                disableRipple: 'disableRipple',
                color: 'color',
                tabIndex: 'tabIndex',
              },
              exportAs: ['matButton', 'matAnchor'],
              features: [s.wb],
              attrs: a,
              ngContentSelectors: l,
              decls: 4,
              vars: 5,
              consts: [
                [1, 'mat-button-wrapper'],
                [
                  'matRipple',
                  '',
                  1,
                  'mat-button-ripple',
                  3,
                  'matRippleDisabled',
                  'matRippleCentered',
                  'matRippleTrigger',
                ],
                [1, 'mat-button-focus-overlay'],
              ],
              template: function (t, e) {
                1 & t &&
                  (s.fc(),
                  s.Qb(0, 'span', 0),
                  s.ec(1),
                  s.Pb(),
                  s.Mb(2, 'span', 1),
                  s.Mb(3, 'span', 2)),
                  2 & t &&
                    (s.zb(2),
                    s.Db(
                      'mat-button-ripple-round',
                      e.isRoundButton || e.isIconButton
                    ),
                    s.gc('matRippleDisabled', e._isRippleDisabled())(
                      'matRippleCentered',
                      e.isIconButton
                    )('matRippleTrigger', e._getHostElement()))
              },
              directives: [i.k],
              styles: [c],
              encapsulation: 2,
              changeDetection: 0,
            })),
            t
          )
        })(),
        m = (() => {
          class t {}
          return (
            (t.ɵmod = s.Jb({ type: t })),
            (t.ɵinj = s.Ib({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[i.l, i.d], i.d],
            })),
            t
          )
        })()
    },
    c2HN: function (t, e, n) {
      'use strict'
      function i(t) {
        return (
          !!t && 'function' != typeof t.subscribe && 'function' == typeof t.then
        )
      }
      n.d(e, 'a', function () {
        return i
      })
    },
    cH1L: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return a
      }),
        n.d(e, 'b', function () {
          return o
        })
      var i = n('fXoL'),
        r = n('ofXK')
      const s = new i.q('cdk-dir-doc', {
        providedIn: 'root',
        factory: function () {
          return Object(i.U)(r.d)
        },
      })
      let o = (() => {
          class t {
            constructor(t) {
              if (((this.value = 'ltr'), (this.change = new i.n()), t)) {
                const e = t.documentElement ? t.documentElement.dir : null,
                  n = (t.body ? t.body.dir : null) || e
                this.value = 'ltr' === n || 'rtl' === n ? n : 'ltr'
              }
            }
            ngOnDestroy() {
              this.change.complete()
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Ub(s, 8))
            }),
            (t.ɵprov = Object(i.Hb)({
              factory: function () {
                return new t(Object(i.Ub)(s, 8))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        a = (() => {
          class t {}
          return (
            (t.ɵmod = i.Jb({ type: t })),
            (t.ɵinj = i.Ib({
              factory: function (e) {
                return new (e || t)()
              },
            })),
            t
          )
        })()
    },
    cPJY: function (t, e, n) {
      'use strict'
      n.d(e, 'b', function () {
        return r
      }),
        n.d(e, 'c', function () {
          return s
        }),
        n.d(e, 'd', function () {
          return o
        }),
        n.d(e, 'a', function () {
          return a
        })
      var i = n('fXoL')
      class r {
        constructor() {
          this.type = 'info'
        }
      }
      const s = {
          position: { top: 20, right: 20, bottom: 20 },
          animation: { fadeOut: 500, fadeIn: 0 },
        },
        o = [
          {
            overlayX: 'center',
            overlayY: 'bottom',
            originX: 'center',
            originY: 'top',
            panelClass: ['bottom', 'center'],
          },
          {
            overlayX: 'start',
            overlayY: 'bottom',
            originX: 'center',
            originY: 'top',
          },
          {
            overlayX: 'end',
            overlayY: 'bottom',
            originX: 'center',
            originY: 'top',
            panelClass: ['bottom', 'right'],
          },
          {
            overlayX: 'center',
            overlayY: 'top',
            originX: 'center',
            originY: 'bottom',
            panelClass: ['top', 'center'],
          },
          {
            overlayX: 'start',
            overlayY: 'top',
            originX: 'center',
            originY: 'bottom',
            panelClass: ['top', 'left'],
          },
          {
            overlayX: 'end',
            overlayY: 'top',
            originX: 'center',
            originY: 'bottom',
            panelClass: ['top', 'right'],
          },
        ],
        a = new i.q('OverlogConfig')
    },
    cp0P: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return l
      })
      var i = n('HDdC'),
        r = n('DH7j'),
        s = n('lJxs'),
        o = n('XoHu'),
        a = n('Cfvw')
      function l(...t) {
        if (1 === t.length) {
          const e = t[0]
          if (Object(r.a)(e)) return c(e, null)
          if (Object(o.a)(e) && Object.getPrototypeOf(e) === Object.prototype) {
            const t = Object.keys(e)
            return c(
              t.map((t) => e[t]),
              t
            )
          }
        }
        if ('function' == typeof t[t.length - 1]) {
          const e = t.pop()
          return c(
            (t = 1 === t.length && Object(r.a)(t[0]) ? t[0] : t),
            null
          ).pipe(Object(s.a)((t) => e(...t)))
        }
        return c(t, null)
      }
      function c(t, e) {
        return new i.a((n) => {
          const i = t.length
          if (0 === i) return void n.complete()
          const r = new Array(i)
          let s = 0,
            o = 0
          for (let l = 0; l < i; l++) {
            const c = Object(a.a)(t[l])
            let u = !1
            n.add(
              c.subscribe({
                next: (t) => {
                  u || ((u = !0), o++), (r[l] = t)
                },
                error: (t) => n.error(t),
                complete: () => {
                  s++,
                    (s !== i && u) ||
                      (o === i &&
                        n.next(
                          e ? e.reduce((t, e, n) => ((t[e] = r[n]), t), {}) : r
                        ),
                      n.complete())
                },
              })
            )
          }
        })
      }
    },
    cpc2: function (t, e, n) {
      function i(t) {
        if (t)
          return (function (t) {
            for (var e in i.prototype) t[e] = i.prototype[e]
            return t
          })(t)
      }
      ;(t.exports = i),
        (i.prototype.on = i.prototype.addEventListener = function (t, e) {
          return (
            (this._callbacks = this._callbacks || {}),
            (this._callbacks['$' + t] = this._callbacks['$' + t] || []).push(e),
            this
          )
        }),
        (i.prototype.once = function (t, e) {
          function n() {
            this.off(t, n), e.apply(this, arguments)
          }
          return (n.fn = e), this.on(t, n), this
        }),
        (i.prototype.off = i.prototype.removeListener = i.prototype.removeAllListeners = i.prototype.removeEventListener = function (
          t,
          e
        ) {
          if (
            ((this._callbacks = this._callbacks || {}), 0 == arguments.length)
          )
            return (this._callbacks = {}), this
          var n,
            i = this._callbacks['$' + t]
          if (!i) return this
          if (1 == arguments.length)
            return delete this._callbacks['$' + t], this
          for (var r = 0; r < i.length; r++)
            if ((n = i[r]) === e || n.fn === e) {
              i.splice(r, 1)
              break
            }
          return 0 === i.length && delete this._callbacks['$' + t], this
        }),
        (i.prototype.emit = function (t) {
          this._callbacks = this._callbacks || {}
          for (
            var e = new Array(arguments.length - 1),
              n = this._callbacks['$' + t],
              i = 1;
            i < arguments.length;
            i++
          )
            e[i - 1] = arguments[i]
          if (n) {
            i = 0
            for (var r = (n = n.slice(0)).length; i < r; ++i)
              n[i].apply(this, e)
          }
          return this
        }),
        (i.prototype.listeners = function (t) {
          return (
            (this._callbacks = this._callbacks || {}),
            this._callbacks['$' + t] || []
          )
        }),
        (i.prototype.hasListeners = function (t) {
          return !!this.listeners(t).length
        })
    },
    'dkv/': function (t, e) {
      t.exports =
        Object.keys ||
        function (t) {
          var e = [],
            n = Object.prototype.hasOwnProperty
          for (var i in t) n.call(t, i) && e.push(i)
          return e
        }
    },
    eIep: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return l
      })
      var i = n('l7GE'),
        r = n('51Dv'),
        s = n('ZUHj'),
        o = n('lJxs'),
        a = n('Cfvw')
      function l(t, e) {
        return 'function' == typeof e
          ? (n) =>
              n.pipe(
                l((n, i) =>
                  Object(a.a)(t(n, i)).pipe(
                    Object(o.a)((t, r) => e(n, t, i, r))
                  )
                )
              )
          : (e) => e.lift(new c(t))
      }
      class c {
        constructor(t) {
          this.project = t
        }
        call(t, e) {
          return e.subscribe(new u(t, this.project))
        }
      }
      class u extends i.a {
        constructor(t, e) {
          super(t), (this.project = e), (this.index = 0)
        }
        _next(t) {
          let e
          const n = this.index++
          try {
            e = this.project(t, n)
          } catch (i) {
            return void this.destination.error(i)
          }
          this._innerSub(e, t, n)
        }
        _innerSub(t, e, n) {
          const i = this.innerSubscription
          i && i.unsubscribe()
          const o = new r.a(this, e, n),
            a = this.destination
          a.add(o),
            (this.innerSubscription = Object(s.a)(this, t, void 0, void 0, o)),
            this.innerSubscription !== o && a.add(this.innerSubscription)
        }
        _complete() {
          const { innerSubscription: t } = this
          ;(t && !t.closed) || super._complete(), this.unsubscribe()
        }
        _unsubscribe() {
          this.innerSubscription = null
        }
        notifyComplete(t) {
          this.destination.remove(t),
            (this.innerSubscription = null),
            this.isStopped && super._complete()
        }
        notifyNext(t, e, n, i, r) {
          this.destination.next(e)
        }
      }
    },
    eOtv: function (t, e, n) {
      var i = n('lKxJ'),
        r = n('KFGy'),
        s = n('cpc2'),
        o = n('Uwu7'),
        a = n('2Dig'),
        l = n('QN7Q'),
        c = n('NOtv')('socket.io-client:manager'),
        u = n('7jRU'),
        h = n('C2QD'),
        d = Object.prototype.hasOwnProperty
      function p(t, e) {
        if (!(this instanceof p)) return new p(t, e)
        t && 'object' == typeof t && ((e = t), (t = void 0)),
          ((e = e || {}).path = e.path || '/socket.io'),
          (this.nsps = {}),
          (this.subs = []),
          (this.opts = e),
          this.reconnection(!1 !== e.reconnection),
          this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0),
          this.reconnectionDelay(e.reconnectionDelay || 1e3),
          this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3),
          this.randomizationFactor(e.randomizationFactor || 0.5),
          (this.backoff = new h({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor(),
          })),
          this.timeout(null == e.timeout ? 2e4 : e.timeout),
          (this.readyState = 'closed'),
          (this.uri = t),
          (this.connecting = []),
          (this.lastPing = null),
          (this.encoding = !1),
          (this.packetBuffer = [])
        var n = e.parser || o
        ;(this.encoder = new n.Encoder()),
          (this.decoder = new n.Decoder()),
          (this.autoConnect = !1 !== e.autoConnect),
          this.autoConnect && this.open()
      }
      ;(t.exports = p),
        (p.prototype.emitAll = function () {
          for (var t in (this.emit.apply(this, arguments), this.nsps))
            d.call(this.nsps, t) &&
              this.nsps[t].emit.apply(this.nsps[t], arguments)
        }),
        (p.prototype.updateSocketIds = function () {
          for (var t in this.nsps)
            d.call(this.nsps, t) && (this.nsps[t].id = this.generateId(t))
        }),
        (p.prototype.generateId = function (t) {
          return ('/' === t ? '' : t + '#') + this.engine.id
        }),
        s(p.prototype),
        (p.prototype.reconnection = function (t) {
          return arguments.length
            ? ((this._reconnection = !!t), this)
            : this._reconnection
        }),
        (p.prototype.reconnectionAttempts = function (t) {
          return arguments.length
            ? ((this._reconnectionAttempts = t), this)
            : this._reconnectionAttempts
        }),
        (p.prototype.reconnectionDelay = function (t) {
          return arguments.length
            ? ((this._reconnectionDelay = t),
              this.backoff && this.backoff.setMin(t),
              this)
            : this._reconnectionDelay
        }),
        (p.prototype.randomizationFactor = function (t) {
          return arguments.length
            ? ((this._randomizationFactor = t),
              this.backoff && this.backoff.setJitter(t),
              this)
            : this._randomizationFactor
        }),
        (p.prototype.reconnectionDelayMax = function (t) {
          return arguments.length
            ? ((this._reconnectionDelayMax = t),
              this.backoff && this.backoff.setMax(t),
              this)
            : this._reconnectionDelayMax
        }),
        (p.prototype.timeout = function (t) {
          return arguments.length ? ((this._timeout = t), this) : this._timeout
        }),
        (p.prototype.maybeReconnectOnOpen = function () {
          !this.reconnecting &&
            this._reconnection &&
            0 === this.backoff.attempts &&
            this.reconnect()
        }),
        (p.prototype.open = p.prototype.connect = function (t, e) {
          if (
            (c('readyState %s', this.readyState),
            ~this.readyState.indexOf('open'))
          )
            return this
          c('opening %s', this.uri), (this.engine = i(this.uri, this.opts))
          var n = this.engine,
            r = this
          ;(this.readyState = 'opening'), (this.skipReconnect = !1)
          var s = a(n, 'open', function () {
              r.onopen(), t && t()
            }),
            o = a(n, 'error', function (e) {
              if (
                (c('connect_error'),
                r.cleanup(),
                (r.readyState = 'closed'),
                r.emitAll('connect_error', e),
                t)
              ) {
                var n = new Error('Connection error')
                ;(n.data = e), t(n)
              } else r.maybeReconnectOnOpen()
            })
          if (!1 !== this._timeout) {
            var l = this._timeout
            c('connect attempt will timeout after %d', l),
              0 === l && s.destroy()
            var u = setTimeout(function () {
              c('connect attempt timed out after %d', l),
                s.destroy(),
                n.close(),
                n.emit('error', 'timeout'),
                r.emitAll('connect_timeout', l)
            }, l)
            this.subs.push({
              destroy: function () {
                clearTimeout(u)
              },
            })
          }
          return this.subs.push(s), this.subs.push(o), this
        }),
        (p.prototype.onopen = function () {
          c('open'),
            this.cleanup(),
            (this.readyState = 'open'),
            this.emit('open')
          var t = this.engine
          this.subs.push(a(t, 'data', l(this, 'ondata'))),
            this.subs.push(a(t, 'ping', l(this, 'onping'))),
            this.subs.push(a(t, 'pong', l(this, 'onpong'))),
            this.subs.push(a(t, 'error', l(this, 'onerror'))),
            this.subs.push(a(t, 'close', l(this, 'onclose'))),
            this.subs.push(a(this.decoder, 'decoded', l(this, 'ondecoded')))
        }),
        (p.prototype.onping = function () {
          ;(this.lastPing = new Date()), this.emitAll('ping')
        }),
        (p.prototype.onpong = function () {
          this.emitAll('pong', new Date() - this.lastPing)
        }),
        (p.prototype.ondata = function (t) {
          this.decoder.add(t)
        }),
        (p.prototype.ondecoded = function (t) {
          this.emit('packet', t)
        }),
        (p.prototype.onerror = function (t) {
          c('error', t), this.emitAll('error', t)
        }),
        (p.prototype.socket = function (t, e) {
          var n = this.nsps[t]
          if (!n) {
            ;(n = new r(this, t, e)), (this.nsps[t] = n)
            var i = this
            n.on('connecting', s),
              n.on('connect', function () {
                n.id = i.generateId(t)
              }),
              this.autoConnect && s()
          }
          function s() {
            ~u(i.connecting, n) || i.connecting.push(n)
          }
          return n
        }),
        (p.prototype.destroy = function (t) {
          var e = u(this.connecting, t)
          ~e && this.connecting.splice(e, 1),
            this.connecting.length || this.close()
        }),
        (p.prototype.packet = function (t) {
          c('writing packet %j', t)
          var e = this
          t.query && 0 === t.type && (t.nsp += '?' + t.query),
            e.encoding
              ? e.packetBuffer.push(t)
              : ((e.encoding = !0),
                this.encoder.encode(t, function (n) {
                  for (var i = 0; i < n.length; i++)
                    e.engine.write(n[i], t.options)
                  ;(e.encoding = !1), e.processPacketQueue()
                }))
        }),
        (p.prototype.processPacketQueue = function () {
          if (this.packetBuffer.length > 0 && !this.encoding) {
            var t = this.packetBuffer.shift()
            this.packet(t)
          }
        }),
        (p.prototype.cleanup = function () {
          c('cleanup')
          for (var t = this.subs.length, e = 0; e < t; e++)
            this.subs.shift().destroy()
          ;(this.packetBuffer = []),
            (this.encoding = !1),
            (this.lastPing = null),
            this.decoder.destroy()
        }),
        (p.prototype.close = p.prototype.disconnect = function () {
          c('disconnect'),
            (this.skipReconnect = !0),
            (this.reconnecting = !1),
            'opening' === this.readyState && this.cleanup(),
            this.backoff.reset(),
            (this.readyState = 'closed'),
            this.engine && this.engine.close()
        }),
        (p.prototype.onclose = function (t) {
          c('onclose'),
            this.cleanup(),
            this.backoff.reset(),
            (this.readyState = 'closed'),
            this.emit('close', t),
            this._reconnection && !this.skipReconnect && this.reconnect()
        }),
        (p.prototype.reconnect = function () {
          if (this.reconnecting || this.skipReconnect) return this
          var t = this
          if (this.backoff.attempts >= this._reconnectionAttempts)
            c('reconnect failed'),
              this.backoff.reset(),
              this.emitAll('reconnect_failed'),
              (this.reconnecting = !1)
          else {
            var e = this.backoff.duration()
            c('will wait %dms before reconnect attempt', e),
              (this.reconnecting = !0)
            var n = setTimeout(function () {
              t.skipReconnect ||
                (c('attempting reconnect'),
                t.emitAll('reconnect_attempt', t.backoff.attempts),
                t.emitAll('reconnecting', t.backoff.attempts),
                t.skipReconnect ||
                  t.open(function (e) {
                    e
                      ? (c('reconnect attempt error'),
                        (t.reconnecting = !1),
                        t.reconnect(),
                        t.emitAll('reconnect_error', e.data))
                      : (c('reconnect success'), t.onreconnect())
                  }))
            }, e)
            this.subs.push({
              destroy: function () {
                clearTimeout(n)
              },
            })
          }
        }),
        (p.prototype.onreconnect = function () {
          var t = this.backoff.attempts
          ;(this.reconnecting = !1),
            this.backoff.reset(),
            this.updateSocketIds(),
            this.emitAll('reconnect', t)
        })
    },
    fXoL: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return an
      }),
        n.d(e, 'b', function () {
          return ql
        }),
        n.d(e, 'c', function () {
          return Vl
        }),
        n.d(e, 'd', function () {
          return Nl
        }),
        n.d(e, 'e', function () {
          return Ml
        }),
        n.d(e, 'f', function () {
          return Nc
        }),
        n.d(e, 'g', function () {
          return Ec
        }),
        n.d(e, 'h', function () {
          return Pa
        }),
        n.d(e, 'i', function () {
          return ec
        }),
        n.d(e, 'j', function () {
          return sa
        }),
        n.d(e, 'k', function () {
          return Gl
        }),
        n.d(e, 'l', function () {
          return ca
        }),
        n.d(e, 'm', function () {
          return wi
        }),
        n.d(e, 'n', function () {
          return dl
        }),
        n.d(e, 'o', function () {
          return cs
        }),
        n.d(e, 'p', function () {
          return bn
        }),
        n.d(e, 'q', function () {
          return on
        }),
        n.d(e, 'r', function () {
          return Os
        }),
        n.d(e, 's', function () {
          return ka
        }),
        n.d(e, 't', function () {
          return Ea
        }),
        n.d(e, 'u', function () {
          return $l
        }),
        n.d(e, 'v', function () {
          return Ha
        }),
        n.d(e, 'w', function () {
          return Tc
        }),
        n.d(e, 'x', function () {
          return za
        }),
        n.d(e, 'y', function () {
          return Cc
        }),
        n.d(e, 'z', function () {
          return rc
        }),
        n.d(e, 'A', function () {
          return _n
        }),
        n.d(e, 'B', function () {
          return Hl
        }),
        n.d(e, 'C', function () {
          return zl
        }),
        n.d(e, 'D', function () {
          return fl
        }),
        n.d(e, 'E', function () {
          return ha
        }),
        n.d(e, 'F', function () {
          return ua
        }),
        n.d(e, 'G', function () {
          return Ei
        }),
        n.d(e, 'H', function () {
          return pa
        }),
        n.d(e, 'I', function () {
          return gi
        }),
        n.d(e, 'J', function () {
          return vn
        }),
        n.d(e, 'K', function () {
          return Pc
        }),
        n.d(e, 'L', function () {
          return Ma
        }),
        n.d(e, 'M', function () {
          return hc
        }),
        n.d(e, 'N', function () {
          return ln
        }),
        n.d(e, 'O', function () {
          return fa
        }),
        n.d(e, 'P', function () {
          return Wa
        }),
        n.d(e, 'Q', function () {
          return I
        }),
        n.d(e, 'R', function () {
          return xc
        }),
        n.d(e, 'S', function () {
          return vc
        }),
        n.d(e, 'T', function () {
          return p
        }),
        n.d(e, 'U', function () {
          return Tn
        }),
        n.d(e, 'V', function () {
          return yc
        }),
        n.d(e, 'W', function () {
          return Lc
        }),
        n.d(e, 'X', function () {
          return fc
        }),
        n.d(e, 'Y', function () {
          return Wl
        }),
        n.d(e, 'Z', function () {
          return hs
        }),
        n.d(e, 'ab', function () {
          return Wo
        }),
        n.d(e, 'bb', function () {
          return fi
        }),
        n.d(e, 'cb', function () {
          return Yn
        }),
        n.d(e, 'db', function () {
          return Un
        }),
        n.d(e, 'eb', function () {
          return zn
        }),
        n.d(e, 'fb', function () {
          return $n
        }),
        n.d(e, 'gb', function () {
          return qn
        }),
        n.d(e, 'hb', function () {
          return Hn
        }),
        n.d(e, 'ib', function () {
          return Wn
        }),
        n.d(e, 'jb', function () {
          return Bo
        }),
        n.d(e, 'kb', function () {
          return Dc
        }),
        n.d(e, 'lb', function () {
          return zo
        }),
        n.d(e, 'mb', function () {
          return Ho
        }),
        n.d(e, 'nb', function () {
          return Bn
        }),
        n.d(e, 'ob', function () {
          return F
        }),
        n.d(e, 'pb', function () {
          return Ls
        }),
        n.d(e, 'qb', function () {
          return Js
        }),
        n.d(e, 'rb', function () {
          return Zs
        }),
        n.d(e, 'sb', function () {
          return Uo
        }),
        n.d(e, 'tb', function () {
          return Ot
        }),
        n.d(e, 'ub', function () {
          return u
        }),
        n.d(e, 'vb', function () {
          return Vn
        }),
        n.d(e, 'wb', function () {
          return Es
        }),
        n.d(e, 'xb', function () {
          return _t
        }),
        n.d(e, 'yb', function () {
          return na
        }),
        n.d(e, 'zb', function () {
          return pr
        }),
        n.d(e, 'Ab', function () {
          return Vs
        }),
        n.d(e, 'Bb', function () {
          return yo
        }),
        n.d(e, 'Cb', function () {
          return Do
        }),
        n.d(e, 'Db', function () {
          return _o
        }),
        n.d(e, 'Eb', function () {
          return Al
        }),
        n.d(e, 'Fb', function () {
          return G
        }),
        n.d(e, 'Gb', function () {
          return tt
        }),
        n.d(e, 'Hb', function () {
          return g
        }),
        n.d(e, 'Ib', function () {
          return b
        }),
        n.d(e, 'Jb', function () {
          return Y
        }),
        n.d(e, 'Kb', function () {
          return et
        }),
        n.d(e, 'Lb', function () {
          return Hs
        }),
        n.d(e, 'Mb', function () {
          return Qs
        }),
        n.d(e, 'Nb', function () {
          return Ks
        }),
        n.d(e, 'Ob', function () {
          return Xs
        }),
        n.d(e, 'Pb', function () {
          return Gs
        }),
        n.d(e, 'Qb', function () {
          return $s
        }),
        n.d(e, 'Rb', function () {
          return Ys
        }),
        n.d(e, 'Sb', function () {
          return en
        }),
        n.d(e, 'Tb', function () {
          return Lo
        }),
        n.d(e, 'Ub', function () {
          return An
        }),
        n.d(e, 'Vb', function () {
          return nn
        }),
        n.d(e, 'Wb', function () {
          return Fl
        }),
        n.d(e, 'Xb', function () {
          return to
        }),
        n.d(e, 'Yb', function () {
          return Il
        }),
        n.d(e, 'Zb', function () {
          return _e
        }),
        n.d(e, 'ac', function () {
          return be
        }),
        n.d(e, 'bc', function () {
          return so
        }),
        n.d(e, 'cc', function () {
          return ul
        }),
        n.d(e, 'dc', function () {
          return hl
        }),
        n.d(e, 'ec', function () {
          return lo
        }),
        n.d(e, 'fc', function () {
          return ao
        }),
        n.d(e, 'gc', function () {
          return qs
        }),
        n.d(e, 'hc', function () {
          return ol
        }),
        n.d(e, 'ic', function () {
          return al
        }),
        n.d(e, 'jc', function () {
          return Sl
        }),
        n.d(e, 'kc', function () {
          return zs
        }),
        n.d(e, 'lc', function () {
          return Oi
        }),
        n.d(e, 'mc', function () {
          return Si
        }),
        n.d(e, 'nc', function () {
          return qt
        }),
        n.d(e, 'oc', function () {
          return bi
        }),
        n.d(e, 'pc', function () {
          return Z
        }),
        n.d(e, 'qc', function () {
          return Tl
        }),
        n.d(e, 'rc', function () {
          return Ol
        }),
        n.d(e, 'sc', function () {
          return bo
        }),
        n.d(e, 'tc', function () {
          return eo
        }),
        n.d(e, 'uc', function () {
          return Fo
        }),
        n.d(e, 'vc', function () {
          return Bs
        }),
        n.d(e, 'wc', function () {
          return Ll
        }),
        n.d(e, 'xc', function () {
          return Io
        }),
        n.d(e, 'yc', function () {
          return Po
        }),
        n.d(e, 'zc', function () {
          return Ro
        }),
        n.d(e, 'Ac', function () {
          return kl
        })
      var i = n('XNiG'),
        r = n('quSY'),
        s = n('HDdC'),
        o = n('VRyK'),
        a = n('w1tV')
      function l(t) {
        for (let e in t) if (t[e] === l) return e
        throw Error('Could not find renamed property on target object.')
      }
      function c(t, e) {
        for (const n in e)
          e.hasOwnProperty(n) && !t.hasOwnProperty(n) && (t[n] = e[n])
      }
      function u(t) {
        if ('string' == typeof t) return t
        if (Array.isArray(t)) return '[' + t.map(u).join(', ') + ']'
        if (null == t) return '' + t
        if (t.overriddenName) return '' + t.overriddenName
        if (t.name) return '' + t.name
        const e = t.toString()
        if (null == e) return '' + e
        const n = e.indexOf('\n')
        return -1 === n ? e : e.substring(0, n)
      }
      function h(t, e) {
        return null == t || '' === t
          ? null === e
            ? ''
            : e
          : null == e || '' === e
          ? t
          : t + ' ' + e
      }
      const d = l({ __forward_ref__: l })
      function p(t) {
        return (
          (t.__forward_ref__ = p),
          (t.toString = function () {
            return u(this())
          }),
          t
        )
      }
      function f(t) {
        return m(t) ? t() : t
      }
      function m(t) {
        return (
          'function' == typeof t &&
          t.hasOwnProperty(d) &&
          t.__forward_ref__ === p
        )
      }
      function g(t) {
        return {
          token: t.token,
          providedIn: t.providedIn || null,
          factory: t.factory,
          value: void 0,
        }
      }
      function b(t) {
        return {
          factory: t.factory,
          providers: t.providers || [],
          imports: t.imports || [],
        }
      }
      function _(t) {
        return y(t, w) || y(t, x)
      }
      function y(t, e) {
        return t.hasOwnProperty(e) ? t[e] : null
      }
      function v(t) {
        return t && (t.hasOwnProperty(C) || t.hasOwnProperty(S)) ? t[C] : null
      }
      const w = l({ '\u0275prov': l }),
        C = l({ '\u0275inj': l }),
        x = l({ ngInjectableDef: l }),
        S = l({ ngInjectorDef: l })
      var O = (function (t) {
        return (
          (t[(t.Default = 0)] = 'Default'),
          (t[(t.Host = 1)] = 'Host'),
          (t[(t.Self = 2)] = 'Self'),
          (t[(t.SkipSelf = 4)] = 'SkipSelf'),
          (t[(t.Optional = 8)] = 'Optional'),
          t
        )
      })({})
      let k
      function E(t) {
        const e = k
        return (k = t), e
      }
      function A(t, e, n) {
        const i = _(t)
        if (i && 'root' == i.providedIn)
          return void 0 === i.value ? (i.value = i.factory()) : i.value
        if (n & O.Optional) return null
        if (void 0 !== e) return e
        throw new Error(`Injector: NOT_FOUND [${u(t)}]`)
      }
      function T(t) {
        return { toString: t }.toString()
      }
      var j = (function (t) {
          return (
            (t[(t.OnPush = 0)] = 'OnPush'), (t[(t.Default = 1)] = 'Default'), t
          )
        })({}),
        I = (function (t) {
          return (
            (t[(t.Emulated = 0)] = 'Emulated'),
            (t[(t.None = 2)] = 'None'),
            (t[(t.ShadowDom = 3)] = 'ShadowDom'),
            t
          )
        })({})
      const P = 'undefined' != typeof globalThis && globalThis,
        R = 'undefined' != typeof window && window,
        D =
          'undefined' != typeof self &&
          'undefined' != typeof WorkerGlobalScope &&
          self instanceof WorkerGlobalScope &&
          self,
        L = 'undefined' != typeof global && global,
        F = P || L || R || D,
        N = {},
        M = [],
        V = l({ '\u0275cmp': l }),
        U = l({ '\u0275dir': l }),
        B = l({ '\u0275pipe': l }),
        z = l({ '\u0275mod': l }),
        H = l({ '\u0275loc': l }),
        q = l({ '\u0275fac': l }),
        W = l({ __NG_ELEMENT_ID__: l })
      let $ = 0
      function G(t) {
        return T(() => {
          const e = {},
            n = {
              type: t.type,
              providersResolver: null,
              decls: t.decls,
              vars: t.vars,
              factory: null,
              template: t.template || null,
              consts: t.consts || null,
              ngContentSelectors: t.ngContentSelectors,
              hostBindings: t.hostBindings || null,
              hostVars: t.hostVars || 0,
              hostAttrs: t.hostAttrs || null,
              contentQueries: t.contentQueries || null,
              declaredInputs: e,
              inputs: null,
              outputs: null,
              exportAs: t.exportAs || null,
              onPush: t.changeDetection === j.OnPush,
              directiveDefs: null,
              pipeDefs: null,
              selectors: t.selectors || M,
              viewQuery: t.viewQuery || null,
              features: t.features || null,
              data: t.data || {},
              encapsulation: t.encapsulation || I.Emulated,
              id: 'c',
              styles: t.styles || M,
              _: null,
              setInput: null,
              schemas: t.schemas || null,
              tView: null,
            },
            i = t.directives,
            r = t.features,
            s = t.pipes
          return (
            (n.id += $++),
            (n.inputs = J(t.inputs, e)),
            (n.outputs = J(t.outputs)),
            r && r.forEach((t) => t(n)),
            (n.directiveDefs = i
              ? () => ('function' == typeof i ? i() : i).map(Q)
              : null),
            (n.pipeDefs = s
              ? () => ('function' == typeof s ? s() : s).map(X)
              : null),
            n
          )
        })
      }
      function Q(t) {
        return (
          nt(t) ||
          (function (t) {
            return t[U] || null
          })(t)
        )
      }
      function X(t) {
        return (function (t) {
          return t[B] || null
        })(t)
      }
      const K = {}
      function Y(t) {
        const e = {
          type: t.type,
          bootstrap: t.bootstrap || M,
          declarations: t.declarations || M,
          imports: t.imports || M,
          exports: t.exports || M,
          transitiveCompileScopes: null,
          schemas: t.schemas || null,
          id: t.id || null,
        }
        return (
          null != t.id &&
            T(() => {
              K[t.id] = t.type
            }),
          e
        )
      }
      function Z(t, e) {
        return T(() => {
          const n = it(t, !0)
          ;(n.declarations = e.declarations || M),
            (n.imports = e.imports || M),
            (n.exports = e.exports || M)
        })
      }
      function J(t, e) {
        if (null == t) return N
        const n = {}
        for (const i in t)
          if (t.hasOwnProperty(i)) {
            let r = t[i],
              s = r
            Array.isArray(r) && ((s = r[1]), (r = r[0])),
              (n[r] = i),
              e && (e[r] = s)
          }
        return n
      }
      const tt = G
      function et(t) {
        return {
          type: t.type,
          name: t.name,
          factory: null,
          pure: !1 !== t.pure,
          onDestroy: t.type.prototype.ngOnDestroy || null,
        }
      }
      function nt(t) {
        return t[V] || null
      }
      function it(t, e) {
        const n = t[z] || null
        if (!n && !0 === e)
          throw new Error(`Type ${u(t)} does not have '\u0275mod' property.`)
        return n
      }
      const rt = 20,
        st = 10
      function ot(t) {
        return Array.isArray(t) && 'object' == typeof t[1]
      }
      function at(t) {
        return Array.isArray(t) && !0 === t[1]
      }
      function lt(t) {
        return 0 != (8 & t.flags)
      }
      function ct(t) {
        return 2 == (2 & t.flags)
      }
      function ut(t) {
        return 1 == (1 & t.flags)
      }
      function ht(t) {
        return null !== t.template
      }
      function dt(t, e) {
        return t.hasOwnProperty(q) ? t[q] : null
      }
      class pt extends Error {
        constructor(t, e) {
          super(
            (function (t, e) {
              return `${t ? `NG0${t}: ` : ''}${e}`
            })(t, e)
          ),
            (this.code = t)
        }
      }
      function ft(t) {
        return 'string' == typeof t ? t : null == t ? '' : String(t)
      }
      function mt(t) {
        return 'function' == typeof t
          ? t.name || t.toString()
          : 'object' == typeof t && null != t && 'function' == typeof t.type
          ? t.type.name || t.type.toString()
          : ft(t)
      }
      function gt(t, e) {
        const n = e ? ' in ' + e : ''
        throw new pt('201', `No provider for ${mt(t)} found${n}`)
      }
      class bt {
        constructor(t, e, n) {
          ;(this.previousValue = t),
            (this.currentValue = e),
            (this.firstChange = n)
        }
        isFirstChange() {
          return this.firstChange
        }
      }
      function _t() {
        return yt
      }
      function yt(t) {
        return t.type.prototype.ngOnChanges && (t.setInput = wt), vt
      }
      function vt() {
        const t = Ct(this),
          e = null == t ? void 0 : t.current
        if (e) {
          const n = t.previous
          if (n === N) t.previous = e
          else for (let t in e) n[t] = e[t]
          ;(t.current = null), this.ngOnChanges(e)
        }
      }
      function wt(t, e, n, i) {
        const r =
            Ct(t) ||
            (function (t, e) {
              return (t.__ngSimpleChanges__ = e)
            })(t, { previous: N, current: null }),
          s = r.current || (r.current = {}),
          o = r.previous,
          a = this.declaredInputs[n],
          l = o[a]
        ;(s[a] = new bt(l && l.currentValue, e, o === N)), (t[i] = e)
      }
      function Ct(t) {
        return t.__ngSimpleChanges__ || null
      }
      _t.ngInherit = !0
      const xt = 'http://www.w3.org/2000/svg'
      let St = void 0
      function Ot(t) {
        St = t
      }
      function kt(t) {
        return !!t.listen
      }
      const Et = {
        createRenderer: (t, e) =>
          void 0 !== St
            ? St
            : 'undefined' != typeof document
            ? document
            : void 0,
      }
      function At(t) {
        for (; Array.isArray(t); ) t = t[0]
        return t
      }
      function Tt(t, e) {
        return At(e[t])
      }
      function jt(t, e) {
        return At(e[t.index])
      }
      function It(t, e) {
        return t.data[e]
      }
      function Pt(t, e) {
        return t[e]
      }
      function Rt(t, e) {
        const n = e[t]
        return ot(n) ? n : n[0]
      }
      function Dt(t) {
        const e = (function (t) {
          return t.__ngContext__ || null
        })(t)
        return e ? (Array.isArray(e) ? e : e.lView) : null
      }
      function Lt(t) {
        return 4 == (4 & t[2])
      }
      function Ft(t) {
        return 128 == (128 & t[2])
      }
      function Nt(t, e) {
        return null == e ? null : t[e]
      }
      function Mt(t) {
        t[18] = 0
      }
      function Vt(t, e) {
        t[5] += e
        let n = t,
          i = t[3]
        for (
          ;
          null !== i && ((1 === e && 1 === n[5]) || (-1 === e && 0 === n[5]));

        )
          (i[5] += e), (n = i), (i = i[3])
      }
      const Ut = {
        lFrame: ue(null),
        bindingsEnabled: !0,
        isInCheckNoChangesMode: !1,
      }
      function Bt() {
        return Ut.bindingsEnabled
      }
      function zt() {
        return Ut.lFrame.lView
      }
      function Ht() {
        return Ut.lFrame.tView
      }
      function qt(t) {
        Ut.lFrame.contextLView = t
      }
      function Wt() {
        let t = $t()
        for (; null !== t && 64 === t.type; ) t = t.parent
        return t
      }
      function $t() {
        return Ut.lFrame.currentTNode
      }
      function Gt(t, e) {
        const n = Ut.lFrame
        ;(n.currentTNode = t), (n.isParent = e)
      }
      function Qt() {
        return Ut.lFrame.isParent
      }
      function Xt() {
        Ut.lFrame.isParent = !1
      }
      function Kt() {
        return Ut.isInCheckNoChangesMode
      }
      function Yt(t) {
        Ut.isInCheckNoChangesMode = t
      }
      function Zt() {
        const t = Ut.lFrame
        let e = t.bindingRootIndex
        return (
          -1 === e && (e = t.bindingRootIndex = t.tView.bindingStartIndex), e
        )
      }
      function Jt() {
        return Ut.lFrame.bindingIndex++
      }
      function te(t) {
        const e = Ut.lFrame,
          n = e.bindingIndex
        return (e.bindingIndex = e.bindingIndex + t), n
      }
      function ee(t, e) {
        const n = Ut.lFrame
        ;(n.bindingIndex = n.bindingRootIndex = t), ne(e)
      }
      function ne(t) {
        Ut.lFrame.currentDirectiveIndex = t
      }
      function ie(t) {
        const e = Ut.lFrame.currentDirectiveIndex
        return -1 === e ? null : t[e]
      }
      function re() {
        return Ut.lFrame.currentQueryIndex
      }
      function se(t) {
        Ut.lFrame.currentQueryIndex = t
      }
      function oe(t) {
        const e = t[1]
        return 2 === e.type ? e.declTNode : 1 === e.type ? t[6] : null
      }
      function ae(t, e, n) {
        if (n & O.SkipSelf) {
          let i = e,
            r = t
          for (
            ;
            (i = i.parent),
              !(
                null !== i ||
                n & O.Host ||
                ((i = oe(r)), null === i) ||
                ((r = r[15]), 10 & i.type)
              );

          );
          if (null === i) return !1
          ;(e = i), (t = r)
        }
        const i = (Ut.lFrame = ce())
        return (i.currentTNode = e), (i.lView = t), !0
      }
      function le(t) {
        const e = ce(),
          n = t[1]
        ;(Ut.lFrame = e),
          (e.currentTNode = n.firstChild),
          (e.lView = t),
          (e.tView = n),
          (e.contextLView = t),
          (e.bindingIndex = n.bindingStartIndex),
          (e.inI18n = !1)
      }
      function ce() {
        const t = Ut.lFrame,
          e = null === t ? null : t.child
        return null === e ? ue(t) : e
      }
      function ue(t) {
        const e = {
          currentTNode: null,
          isParent: !0,
          lView: null,
          tView: null,
          selectedIndex: -1,
          contextLView: null,
          elementDepthCount: 0,
          currentNamespace: null,
          currentDirectiveIndex: -1,
          bindingRootIndex: -1,
          bindingIndex: -1,
          currentQueryIndex: 0,
          parent: t,
          child: null,
          inI18n: !1,
        }
        return null !== t && (t.child = e), e
      }
      function he() {
        const t = Ut.lFrame
        return (
          (Ut.lFrame = t.parent), (t.currentTNode = null), (t.lView = null), t
        )
      }
      const de = he
      function pe() {
        const t = he()
        ;(t.isParent = !0),
          (t.tView = null),
          (t.selectedIndex = -1),
          (t.contextLView = null),
          (t.elementDepthCount = 0),
          (t.currentDirectiveIndex = -1),
          (t.currentNamespace = null),
          (t.bindingRootIndex = -1),
          (t.bindingIndex = -1),
          (t.currentQueryIndex = 0)
      }
      function fe() {
        return Ut.lFrame.selectedIndex
      }
      function me(t) {
        Ut.lFrame.selectedIndex = t
      }
      function ge() {
        const t = Ut.lFrame
        return It(t.tView, t.selectedIndex)
      }
      function be() {
        Ut.lFrame.currentNamespace = xt
      }
      function _e() {
        Ut.lFrame.currentNamespace = null
      }
      function ye(t, e) {
        for (let n = e.directiveStart, i = e.directiveEnd; n < i; n++) {
          const e = t.data[n].type.prototype,
            {
              ngAfterContentInit: i,
              ngAfterContentChecked: r,
              ngAfterViewInit: s,
              ngAfterViewChecked: o,
              ngOnDestroy: a,
            } = e
          i && (t.contentHooks || (t.contentHooks = [])).push(-n, i),
            r &&
              ((t.contentHooks || (t.contentHooks = [])).push(n, r),
              (t.contentCheckHooks || (t.contentCheckHooks = [])).push(n, r)),
            s && (t.viewHooks || (t.viewHooks = [])).push(-n, s),
            o &&
              ((t.viewHooks || (t.viewHooks = [])).push(n, o),
              (t.viewCheckHooks || (t.viewCheckHooks = [])).push(n, o)),
            null != a && (t.destroyHooks || (t.destroyHooks = [])).push(n, a)
        }
      }
      function ve(t, e, n) {
        xe(t, e, 3, n)
      }
      function we(t, e, n, i) {
        ;(3 & t[2]) === n && xe(t, e, n, i)
      }
      function Ce(t, e) {
        let n = t[2]
        ;(3 & n) === e && ((n &= 2047), (n += 1), (t[2] = n))
      }
      function xe(t, e, n, i) {
        const r = null != i ? i : -1
        let s = 0
        for (let o = void 0 !== i ? 65535 & t[18] : 0; o < e.length; o++)
          if ('number' == typeof e[o + 1]) {
            if (((s = e[o]), null != i && s >= i)) break
          } else
            e[o] < 0 && (t[18] += 65536),
              (s < r || -1 == r) &&
                (Se(t, n, e, o), (t[18] = (4294901760 & t[18]) + o + 2)),
              o++
      }
      function Se(t, e, n, i) {
        const r = n[i] < 0,
          s = n[i + 1],
          o = t[r ? -n[i] : n[i]]
        r
          ? t[2] >> 11 < t[18] >> 16 &&
            (3 & t[2]) === e &&
            ((t[2] += 2048), s.call(o))
          : s.call(o)
      }
      const Oe = -1
      class ke {
        constructor(t, e, n) {
          ;(this.factory = t),
            (this.resolving = !1),
            (this.canSeeViewProviders = e),
            (this.injectImpl = n)
        }
      }
      function Ee(t, e, n) {
        const i = kt(t)
        let r = 0
        for (; r < n.length; ) {
          const s = n[r]
          if ('number' == typeof s) {
            if (0 !== s) break
            r++
            const o = n[r++],
              a = n[r++],
              l = n[r++]
            i ? t.setAttribute(e, a, l, o) : e.setAttributeNS(o, a, l)
          } else {
            const o = s,
              a = n[++r]
            Te(o)
              ? i && t.setProperty(e, o, a)
              : i
              ? t.setAttribute(e, o, a)
              : e.setAttribute(o, a),
              r++
          }
        }
        return r
      }
      function Ae(t) {
        return 3 === t || 4 === t || 6 === t
      }
      function Te(t) {
        return 64 === t.charCodeAt(0)
      }
      function je(t, e) {
        if (null === e || 0 === e.length);
        else if (null === t || 0 === t.length) t = e.slice()
        else {
          let n = -1
          for (let i = 0; i < e.length; i++) {
            const r = e[i]
            'number' == typeof r
              ? (n = r)
              : 0 === n ||
                Ie(t, n, r, null, -1 === n || 2 === n ? e[++i] : null)
          }
        }
        return t
      }
      function Ie(t, e, n, i, r) {
        let s = 0,
          o = t.length
        if (-1 === e) o = -1
        else
          for (; s < t.length; ) {
            const n = t[s++]
            if ('number' == typeof n) {
              if (n === e) {
                o = -1
                break
              }
              if (n > e) {
                o = s - 1
                break
              }
            }
          }
        for (; s < t.length; ) {
          const e = t[s]
          if ('number' == typeof e) break
          if (e === n) {
            if (null === i) return void (null !== r && (t[s + 1] = r))
            if (i === t[s + 1]) return void (t[s + 2] = r)
          }
          s++, null !== i && s++, null !== r && s++
        }
        ;-1 !== o && (t.splice(o, 0, e), (s = o + 1)),
          t.splice(s++, 0, n),
          null !== i && t.splice(s++, 0, i),
          null !== r && t.splice(s++, 0, r)
      }
      function Pe(t) {
        return t !== Oe
      }
      function Re(t) {
        return 32767 & t
      }
      function De(t, e) {
        let n = t >> 16,
          i = e
        for (; n > 0; ) (i = i[15]), n--
        return i
      }
      let Le = !0
      function Fe(t) {
        const e = Le
        return (Le = t), e
      }
      let Ne = 0
      function Me(t, e) {
        const n = Ue(t, e)
        if (-1 !== n) return n
        const i = e[1]
        i.firstCreatePass &&
          ((t.injectorIndex = e.length),
          Ve(i.data, t),
          Ve(e, null),
          Ve(i.blueprint, null))
        const r = Be(t, e),
          s = t.injectorIndex
        if (Pe(r)) {
          const t = Re(r),
            n = De(r, e),
            i = n[1].data
          for (let r = 0; r < 8; r++) e[s + r] = n[t + r] | i[t + r]
        }
        return (e[s + 8] = r), s
      }
      function Ve(t, e) {
        t.push(0, 0, 0, 0, 0, 0, 0, 0, e)
      }
      function Ue(t, e) {
        return -1 === t.injectorIndex ||
          (t.parent && t.parent.injectorIndex === t.injectorIndex) ||
          null === e[t.injectorIndex + 8]
          ? -1
          : t.injectorIndex
      }
      function Be(t, e) {
        if (t.parent && -1 !== t.parent.injectorIndex)
          return t.parent.injectorIndex
        let n = 0,
          i = null,
          r = e
        for (; null !== r; ) {
          const t = r[1],
            e = t.type
          if (((i = 2 === e ? t.declTNode : 1 === e ? r[6] : null), null === i))
            return Oe
          if ((n++, (r = r[15]), -1 !== i.injectorIndex))
            return i.injectorIndex | (n << 16)
        }
        return Oe
      }
      function ze(t, e, n) {
        !(function (t, e, n) {
          let i
          'string' == typeof n
            ? (i = n.charCodeAt(0) || 0)
            : n.hasOwnProperty(W) && (i = n[W]),
            null == i && (i = n[W] = Ne++)
          const r = 255 & i,
            s = 1 << r,
            o = 64 & r,
            a = 32 & r,
            l = e.data
          128 & r
            ? o
              ? a
                ? (l[t + 7] |= s)
                : (l[t + 6] |= s)
              : a
              ? (l[t + 5] |= s)
              : (l[t + 4] |= s)
            : o
            ? a
              ? (l[t + 3] |= s)
              : (l[t + 2] |= s)
            : a
            ? (l[t + 1] |= s)
            : (l[t] |= s)
        })(t, e, n)
      }
      function He(t, e, n) {
        if (n & O.Optional) return t
        gt(e, 'NodeInjector')
      }
      function qe(t, e, n, i) {
        if (
          (n & O.Optional && void 0 === i && (i = null),
          0 == (n & (O.Self | O.Host)))
        ) {
          const r = t[9],
            s = E(void 0)
          try {
            return r ? r.get(e, i, n & O.Optional) : A(e, i, n & O.Optional)
          } finally {
            E(s)
          }
        }
        return He(i, e, n)
      }
      function We(t, e, n, i = O.Default, r) {
        if (null !== t) {
          const s = (function (t) {
            if ('string' == typeof t) return t.charCodeAt(0) || 0
            const e = t.hasOwnProperty(W) ? t[W] : void 0
            return 'number' == typeof e ? (e >= 0 ? 255 & e : Ge) : e
          })(n)
          if ('function' == typeof s) {
            if (!ae(e, t, i)) return i & O.Host ? He(r, n, i) : qe(e, n, i, r)
            try {
              const t = s()
              if (null != t || i & O.Optional) return t
              gt(n)
            } finally {
              de()
            }
          } else if ('number' == typeof s) {
            let r = null,
              o = Ue(t, e),
              a = Oe,
              l = i & O.Host ? e[16][6] : null
            for (
              (-1 === o || i & O.SkipSelf) &&
              ((a = -1 === o ? Be(t, e) : e[o + 8]),
              a !== Oe && Ze(i, !1)
                ? ((r = e[1]), (o = Re(a)), (e = De(a, e)))
                : (o = -1));
              -1 !== o;

            ) {
              const t = e[1]
              if (Ye(s, o, t.data)) {
                const t = Qe(o, e, n, r, i, l)
                if (t !== $e) return t
              }
              ;(a = e[o + 8]),
                a !== Oe && Ze(i, e[1].data[o + 8] === l) && Ye(s, o, e)
                  ? ((r = t), (o = Re(a)), (e = De(a, e)))
                  : (o = -1)
            }
          }
        }
        return qe(e, n, i, r)
      }
      const $e = {}
      function Ge() {
        return new Je(Wt(), zt())
      }
      function Qe(t, e, n, i, r, s) {
        const o = e[1],
          a = o.data[t + 8],
          l = Xe(
            a,
            o,
            n,
            null == i ? ct(a) && Le : i != o && 0 != (3 & a.type),
            r & O.Host && s === a
          )
        return null !== l ? Ke(e, o, l, a) : $e
      }
      function Xe(t, e, n, i, r) {
        const s = t.providerIndexes,
          o = e.data,
          a = 1048575 & s,
          l = t.directiveStart,
          c = s >> 20,
          u = r ? a + c : t.directiveEnd
        for (let h = i ? a : a + c; h < u; h++) {
          const t = o[h]
          if ((h < l && n === t) || (h >= l && t.type === n)) return h
        }
        if (r) {
          const t = o[l]
          if (t && ht(t) && t.type === n) return l
        }
        return null
      }
      function Ke(t, e, n, i) {
        let r = t[n]
        const s = e.data
        if (r instanceof ke) {
          const o = r
          o.resolving &&
            (function (t, e) {
              throw new pt('200', 'Circular dependency in DI detected for ' + t)
            })(mt(s[n]))
          const a = Fe(o.canSeeViewProviders)
          o.resolving = !0
          const l = o.injectImpl ? E(o.injectImpl) : null
          ae(t, i, O.Default)
          try {
            ;(r = t[n] = o.factory(void 0, s, t, i)),
              e.firstCreatePass &&
                n >= i.directiveStart &&
                (function (t, e, n) {
                  const {
                    ngOnChanges: i,
                    ngOnInit: r,
                    ngDoCheck: s,
                  } = e.type.prototype
                  if (i) {
                    const i = yt(e)
                    ;(n.preOrderHooks || (n.preOrderHooks = [])).push(t, i),
                      (
                        n.preOrderCheckHooks || (n.preOrderCheckHooks = [])
                      ).push(t, i)
                  }
                  r &&
                    (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - t, r),
                    s &&
                      ((n.preOrderHooks || (n.preOrderHooks = [])).push(t, s),
                      (
                        n.preOrderCheckHooks || (n.preOrderCheckHooks = [])
                      ).push(t, s))
                })(n, s[n], e)
          } finally {
            null !== l && E(l), Fe(a), (o.resolving = !1), de()
          }
        }
        return r
      }
      function Ye(t, e, n) {
        const i = 64 & t,
          r = 32 & t
        let s
        return (
          (s =
            128 & t
              ? i
                ? r
                  ? n[e + 7]
                  : n[e + 6]
                : r
                ? n[e + 5]
                : n[e + 4]
              : i
              ? r
                ? n[e + 3]
                : n[e + 2]
              : r
              ? n[e + 1]
              : n[e]),
          !!(s & (1 << t))
        )
      }
      function Ze(t, e) {
        return !(t & O.Self || (t & O.Host && e))
      }
      class Je {
        constructor(t, e) {
          ;(this._tNode = t), (this._lView = e)
        }
        get(t, e) {
          return We(this._tNode, this._lView, t, void 0, e)
        }
      }
      function tn(t) {
        const e = t
        if (m(t))
          return () => {
            const t = tn(f(e))
            return t ? t() : null
          }
        let n = dt(e)
        if (null === n) {
          const t = v(e)
          n = t && t.factory
        }
        return n || null
      }
      function en(t) {
        return T(() => {
          const e = t.prototype.constructor,
            n = e[q] || tn(e),
            i = Object.prototype
          let r = Object.getPrototypeOf(t.prototype).constructor
          for (; r && r !== i; ) {
            const t = r[q] || tn(r)
            if (t && t !== n) return t
            r = Object.getPrototypeOf(r)
          }
          return (t) => new t()
        })
      }
      function nn(t) {
        return (function (t, e) {
          if ('class' === e) return t.classes
          if ('style' === e) return t.styles
          const n = t.attrs
          if (n) {
            const t = n.length
            let i = 0
            for (; i < t; ) {
              const r = n[i]
              if (Ae(r)) break
              if (0 === r) i += 2
              else if ('number' == typeof r)
                for (i++; i < t && 'string' == typeof n[i]; ) i++
              else {
                if (r === e) return n[i + 1]
                i += 2
              }
            }
          }
          return null
        })(Wt(), t)
      }
      const rn = '__parameters__'
      function sn(t, e, n) {
        return T(() => {
          const i = (function (t) {
            return function (...e) {
              if (t) {
                const n = t(...e)
                for (const t in n) this[t] = n[t]
              }
            }
          })(e)
          function r(...t) {
            if (this instanceof r) return i.apply(this, t), this
            const e = new r(...t)
            return (n.annotation = e), n
            function n(t, n, i) {
              const r = t.hasOwnProperty(rn)
                ? t[rn]
                : Object.defineProperty(t, rn, { value: [] })[rn]
              for (; r.length <= i; ) r.push(null)
              return (r[i] = r[i] || []).push(e), t
            }
          }
          return (
            n && (r.prototype = Object.create(n.prototype)),
            (r.prototype.ngMetadataName = t),
            (r.annotationCls = r),
            r
          )
        })
      }
      class on {
        constructor(t, e) {
          ;(this._desc = t),
            (this.ngMetadataName = 'InjectionToken'),
            (this.ɵprov = void 0),
            'number' == typeof e
              ? (this.__NG_ELEMENT_ID__ = e)
              : void 0 !== e &&
                (this.ɵprov = g({
                  token: this,
                  providedIn: e.providedIn || 'root',
                  factory: e.factory,
                }))
        }
        toString() {
          return 'InjectionToken ' + this._desc
        }
      }
      const an = new on('AnalyzeForEntryComponents'),
        ln = Function
      function cn(t, e) {
        void 0 === e && (e = t)
        for (let n = 0; n < t.length; n++) {
          let i = t[n]
          Array.isArray(i)
            ? (e === t && (e = t.slice(0, n)), cn(i, e))
            : e !== t && e.push(i)
        }
        return e
      }
      function un(t, e) {
        t.forEach((t) => (Array.isArray(t) ? un(t, e) : e(t)))
      }
      function hn(t, e, n) {
        e >= t.length ? t.push(n) : t.splice(e, 0, n)
      }
      function dn(t, e) {
        return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0]
      }
      function pn(t, e) {
        const n = []
        for (let i = 0; i < t; i++) n.push(e)
        return n
      }
      function fn(t, e, n) {
        let i = gn(t, e)
        return (
          i >= 0
            ? (t[1 | i] = n)
            : ((i = ~i),
              (function (t, e, n, i) {
                let r = t.length
                if (r == e) t.push(n, i)
                else if (1 === r) t.push(i, t[0]), (t[0] = n)
                else {
                  for (r--, t.push(t[r - 1], t[r]); r > e; )
                    (t[r] = t[r - 2]), r--
                  ;(t[e] = n), (t[e + 1] = i)
                }
              })(t, i, e, n)),
          i
        )
      }
      function mn(t, e) {
        const n = gn(t, e)
        if (n >= 0) return t[1 | n]
      }
      function gn(t, e) {
        return (function (t, e, n) {
          let i = 0,
            r = t.length >> 1
          for (; r !== i; ) {
            const n = i + ((r - i) >> 1),
              s = t[n << 1]
            if (e === s) return n << 1
            s > e ? (r = n) : (i = n + 1)
          }
          return ~(r << 1)
        })(t, e)
      }
      const bn = sn('Inject', (t) => ({ token: t })),
        _n = sn('Optional'),
        yn = sn('Self'),
        vn = sn('SkipSelf'),
        wn = {},
        Cn = /\n/gm,
        xn = '__source',
        Sn = l({ provide: String, useValue: l })
      let On = void 0
      function kn(t) {
        const e = On
        return (On = t), e
      }
      function En(t, e = O.Default) {
        if (void 0 === On)
          throw new Error('inject() must be called from an injection context')
        return null === On
          ? A(t, void 0, e)
          : On.get(t, e & O.Optional ? null : void 0, e)
      }
      function An(t, e = O.Default) {
        return (k || En)(f(t), e)
      }
      const Tn = An
      function jn(t) {
        const e = []
        for (let n = 0; n < t.length; n++) {
          const i = f(t[n])
          if (Array.isArray(i)) {
            if (0 === i.length)
              throw new Error('Arguments array must have arguments.')
            let t = void 0,
              n = O.Default
            for (let e = 0; e < i.length; e++) {
              const r = i[e]
              r instanceof _n || 'Optional' === r.ngMetadataName || r === _n
                ? (n |= O.Optional)
                : r instanceof vn || 'SkipSelf' === r.ngMetadataName || r === vn
                ? (n |= O.SkipSelf)
                : r instanceof yn || 'Self' === r.ngMetadataName || r === yn
                ? (n |= O.Self)
                : (t = r instanceof bn || r === bn ? r.token : r)
            }
            e.push(An(t, n))
          } else e.push(An(i))
        }
        return e
      }
      let In
      function Pn(t) {
        var e
        return (
          (null ===
            (e = (function () {
              if (void 0 === In && ((In = null), F.trustedTypes))
                try {
                  In = F.trustedTypes.createPolicy('angular', {
                    createHTML: (t) => t,
                    createScript: (t) => t,
                    createScriptURL: (t) => t,
                  })
                } catch (e) {}
              return In
            })()) || void 0 === e
            ? void 0
            : e.createHTML(t)) || t
        )
      }
      class Rn {
        constructor(t) {
          this.changingThisBreaksApplicationSecurity = t
        }
        toString() {
          return (
            'SafeValue must use [property]=binding: ' +
            this.changingThisBreaksApplicationSecurity +
            ' (see https://g.co/ng/security#xss)'
          )
        }
      }
      class Dn extends Rn {
        getTypeName() {
          return 'HTML'
        }
      }
      class Ln extends Rn {
        getTypeName() {
          return 'Style'
        }
      }
      class Fn extends Rn {
        getTypeName() {
          return 'Script'
        }
      }
      class Nn extends Rn {
        getTypeName() {
          return 'URL'
        }
      }
      class Mn extends Rn {
        getTypeName() {
          return 'ResourceURL'
        }
      }
      function Vn(t) {
        return t instanceof Rn ? t.changingThisBreaksApplicationSecurity : t
      }
      function Un(t, e) {
        const n = Bn(t)
        if (null != n && n !== e) {
          if ('ResourceURL' === n && 'URL' === e) return !0
          throw new Error(
            `Required a safe ${e}, got a ${n} (see https://g.co/ng/security#xss)`
          )
        }
        return n === e
      }
      function Bn(t) {
        return (t instanceof Rn && t.getTypeName()) || null
      }
      function zn(t) {
        return new Dn(t)
      }
      function Hn(t) {
        return new Ln(t)
      }
      function qn(t) {
        return new Fn(t)
      }
      function Wn(t) {
        return new Nn(t)
      }
      function $n(t) {
        return new Mn(t)
      }
      class Gn {
        getInertBodyElement(t) {
          t = '<body><remove></remove>' + t
          try {
            const e = new window.DOMParser().parseFromString(Pn(t), 'text/html')
              .body
            return e.removeChild(e.firstChild), e
          } catch (e) {
            return null
          }
        }
      }
      class Qn {
        constructor(t) {
          if (
            ((this.defaultDoc = t),
            (this.inertDocument = this.defaultDoc.implementation.createHTMLDocument(
              'sanitization-inert'
            )),
            null == this.inertDocument.body)
          ) {
            const t = this.inertDocument.createElement('html')
            this.inertDocument.appendChild(t)
            const e = this.inertDocument.createElement('body')
            t.appendChild(e)
          }
        }
        getInertBodyElement(t) {
          const e = this.inertDocument.createElement('template')
          if ('content' in e) return (e.innerHTML = Pn(t)), e
          const n = this.inertDocument.createElement('body')
          return (
            (n.innerHTML = Pn(t)),
            this.defaultDoc.documentMode && this.stripCustomNsAttrs(n),
            n
          )
        }
        stripCustomNsAttrs(t) {
          const e = t.attributes
          for (let i = e.length - 1; 0 < i; i--) {
            const n = e.item(i).name
            ;('xmlns:ns1' !== n && 0 !== n.indexOf('ns1:')) ||
              t.removeAttribute(n)
          }
          let n = t.firstChild
          for (; n; )
            n.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(n),
              (n = n.nextSibling)
        }
      }
      const Xn = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi,
        Kn = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i
      function Yn(t) {
        return (t = String(t)).match(Xn) || t.match(Kn) ? t : 'unsafe:' + t
      }
      function Zn(t) {
        const e = {}
        for (const n of t.split(',')) e[n] = !0
        return e
      }
      function Jn(...t) {
        const e = {}
        for (const n of t) for (const t in n) n.hasOwnProperty(t) && (e[t] = !0)
        return e
      }
      const ti = Zn('area,br,col,hr,img,wbr'),
        ei = Zn('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr'),
        ni = Zn('rp,rt'),
        ii = Jn(ni, ei),
        ri = Jn(
          ti,
          Jn(
            ei,
            Zn(
              'address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'
            )
          ),
          Jn(
            ni,
            Zn(
              'a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'
            )
          ),
          ii
        ),
        si = Zn('background,cite,href,itemtype,longdesc,poster,src,xlink:href'),
        oi = Zn('srcset'),
        ai = Jn(
          si,
          oi,
          Zn(
            'abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width'
          ),
          Zn(
            'aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext'
          )
        ),
        li = Zn('script,style,template')
      class ci {
        constructor() {
          ;(this.sanitizedSomething = !1), (this.buf = [])
        }
        sanitizeChildren(t) {
          let e = t.firstChild,
            n = !0
          for (; e; )
            if (
              (e.nodeType === Node.ELEMENT_NODE
                ? (n = this.startElement(e))
                : e.nodeType === Node.TEXT_NODE
                ? this.chars(e.nodeValue)
                : (this.sanitizedSomething = !0),
              n && e.firstChild)
            )
              e = e.firstChild
            else
              for (; e; ) {
                e.nodeType === Node.ELEMENT_NODE && this.endElement(e)
                let t = this.checkClobberedElement(e, e.nextSibling)
                if (t) {
                  e = t
                  break
                }
                e = this.checkClobberedElement(e, e.parentNode)
              }
          return this.buf.join('')
        }
        startElement(t) {
          const e = t.nodeName.toLowerCase()
          if (!ri.hasOwnProperty(e))
            return (this.sanitizedSomething = !0), !li.hasOwnProperty(e)
          this.buf.push('<'), this.buf.push(e)
          const n = t.attributes
          for (let r = 0; r < n.length; r++) {
            const t = n.item(r),
              e = t.name,
              s = e.toLowerCase()
            if (!ai.hasOwnProperty(s)) {
              this.sanitizedSomething = !0
              continue
            }
            let o = t.value
            si[s] && (o = Yn(o)),
              oi[s] &&
                ((i = o),
                (o = (i = String(i))
                  .split(',')
                  .map((t) => Yn(t.trim()))
                  .join(', '))),
              this.buf.push(' ', e, '="', di(o), '"')
          }
          var i
          return this.buf.push('>'), !0
        }
        endElement(t) {
          const e = t.nodeName.toLowerCase()
          ri.hasOwnProperty(e) &&
            !ti.hasOwnProperty(e) &&
            (this.buf.push('</'), this.buf.push(e), this.buf.push('>'))
        }
        chars(t) {
          this.buf.push(di(t))
        }
        checkClobberedElement(t, e) {
          if (
            e &&
            (t.compareDocumentPosition(e) &
              Node.DOCUMENT_POSITION_CONTAINED_BY) ===
              Node.DOCUMENT_POSITION_CONTAINED_BY
          )
            throw new Error(
              'Failed to sanitize html because the element is clobbered: ' +
                t.outerHTML
            )
          return e
        }
      }
      const ui = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
        hi = /([^\#-~ |!])/g
      function di(t) {
        return t
          .replace(/&/g, '&amp;')
          .replace(ui, function (t) {
            return (
              '&#' +
              (1024 * (t.charCodeAt(0) - 55296) +
                (t.charCodeAt(1) - 56320) +
                65536) +
              ';'
            )
          })
          .replace(hi, function (t) {
            return '&#' + t.charCodeAt(0) + ';'
          })
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
      }
      let pi
      function fi(t, e) {
        let n = null
        try {
          pi =
            pi ||
            (function (t) {
              return (function () {
                try {
                  return !!new window.DOMParser().parseFromString(
                    Pn(''),
                    'text/html'
                  )
                } catch (t) {
                  return !1
                }
              })()
                ? new Gn()
                : new Qn(t)
            })(t)
          let i = e ? String(e) : ''
          n = pi.getInertBodyElement(i)
          let r = 5,
            s = i
          do {
            if (0 === r)
              throw new Error(
                'Failed to sanitize html because the input is unstable'
              )
            r--, (i = s), (s = n.innerHTML), (n = pi.getInertBodyElement(i))
          } while (i !== s)
          return new ci().sanitizeChildren(mi(n) || n)
        } finally {
          if (n) {
            const t = mi(n) || n
            for (; t.firstChild; ) t.removeChild(t.firstChild)
          }
        }
      }
      function mi(t) {
        return 'content' in t &&
          (function (t) {
            return t.nodeType === Node.ELEMENT_NODE && 'TEMPLATE' === t.nodeName
          })(t)
          ? t.content
          : null
      }
      var gi = (function (t) {
        return (
          (t[(t.NONE = 0)] = 'NONE'),
          (t[(t.HTML = 1)] = 'HTML'),
          (t[(t.STYLE = 2)] = 'STYLE'),
          (t[(t.SCRIPT = 3)] = 'SCRIPT'),
          (t[(t.URL = 4)] = 'URL'),
          (t[(t.RESOURCE_URL = 5)] = 'RESOURCE_URL'),
          t
        )
      })({})
      function bi(t) {
        const e = (function () {
          const t = zt()
          return t && t[12]
        })()
        return e
          ? e.sanitize(gi.URL, t) || ''
          : Un(t, 'URL')
          ? Vn(t)
          : Yn(ft(t))
      }
      function _i(t) {
        return t.ngDebugContext
      }
      function yi(t) {
        return t.ngOriginalError
      }
      function vi(t, ...e) {
        t.error(...e)
      }
      class wi {
        constructor() {
          this._console = console
        }
        handleError(t) {
          const e = this._findOriginalError(t),
            n = this._findContext(t),
            i = (function (t) {
              return t.ngErrorLogger || vi
            })(t)
          i(this._console, 'ERROR', t),
            e && i(this._console, 'ORIGINAL ERROR', e),
            n && i(this._console, 'ERROR CONTEXT', n)
        }
        _findContext(t) {
          return t ? (_i(t) ? _i(t) : this._findContext(yi(t))) : null
        }
        _findOriginalError(t) {
          let e = yi(t)
          for (; e && yi(e); ) e = yi(e)
          return e
        }
      }
      function Ci(t, e) {
        t.__ngContext__ = e
      }
      const xi = (() =>
        (
          ('undefined' != typeof requestAnimationFrame &&
            requestAnimationFrame) ||
          setTimeout
        ).bind(F))()
      function Si(t) {
        return { name: 'window', target: t.ownerDocument.defaultView }
      }
      function Oi(t) {
        return { name: 'body', target: t.ownerDocument.body }
      }
      function ki(t) {
        return t instanceof Function ? t() : t
      }
      var Ei = (function (t) {
        return (
          (t[(t.Important = 1)] = 'Important'),
          (t[(t.DashCase = 2)] = 'DashCase'),
          t
        )
      })({})
      function Ai(t, e) {
        return (void 0)(t, e)
      }
      function Ti(t) {
        const e = t[3]
        return at(e) ? e[3] : e
      }
      function ji(t) {
        return Pi(t[13])
      }
      function Ii(t) {
        return Pi(t[4])
      }
      function Pi(t) {
        for (; null !== t && !at(t); ) t = t[4]
        return t
      }
      function Ri(t, e, n, i, r) {
        if (null != i) {
          let s,
            o = !1
          at(i) ? (s = i) : ot(i) && ((o = !0), (i = i[0]))
          const a = At(i)
          0 === t && null !== n
            ? null == r
              ? Bi(e, n, a)
              : Ui(e, n, a, r || null, !0)
            : 1 === t && null !== n
            ? Ui(e, n, a, r || null, !0)
            : 2 === t
            ? (function (t, e, n) {
                const i = Hi(t, e)
                i &&
                  (function (t, e, n, i) {
                    kt(t) ? t.removeChild(e, n, i) : e.removeChild(n)
                  })(t, i, e, n)
              })(e, a, o)
            : 3 === t && e.destroyNode(a),
            null != s &&
              (function (t, e, n, i, r) {
                const s = n[7]
                s !== At(n) && Ri(e, t, i, s, r)
                for (let o = st; o < n.length; o++) {
                  const r = n[o]
                  Ki(r[1], r, t, e, i, s)
                }
              })(e, t, s, n, r)
        }
      }
      function Di(t, e, n) {
        return kt(t)
          ? t.createElement(e, n)
          : null === n
          ? t.createElement(e)
          : t.createElementNS(n, e)
      }
      function Li(t, e) {
        const n = t[9],
          i = n.indexOf(e),
          r = e[3]
        1024 & e[2] && ((e[2] &= -1025), Vt(r, -1)), n.splice(i, 1)
      }
      function Fi(t, e) {
        if (t.length <= st) return
        const n = st + e,
          i = t[n]
        if (i) {
          const s = i[17]
          null !== s && s !== t && Li(s, i), e > 0 && (t[n - 1][4] = i[4])
          const o = dn(t, st + e)
          Ki(i[1], (r = i), r[11], 2, null, null), (r[0] = null), (r[6] = null)
          const a = o[19]
          null !== a && a.detachView(o[1]),
            (i[3] = null),
            (i[4] = null),
            (i[2] &= -129)
        }
        var r
        return i
      }
      function Ni(t, e) {
        if (!(256 & e[2])) {
          const n = e[11]
          kt(n) && n.destroyNode && Ki(t, e, n, 3, null, null),
            (function (t) {
              let e = t[13]
              if (!e) return Mi(t[1], t)
              for (; e; ) {
                let n = null
                if (ot(e)) n = e[13]
                else {
                  const t = e[10]
                  t && (n = t)
                }
                if (!n) {
                  for (; e && !e[4] && e !== t; )
                    ot(e) && Mi(e[1], e), (e = e[3])
                  null === e && (e = t), ot(e) && Mi(e[1], e), (n = e && e[4])
                }
                e = n
              }
            })(e)
        }
      }
      function Mi(t, e) {
        if (!(256 & e[2])) {
          ;(e[2] &= -129),
            (e[2] |= 256),
            (function (t, e) {
              let n
              if (null != t && null != (n = t.destroyHooks))
                for (let i = 0; i < n.length; i += 2) {
                  const t = e[n[i]]
                  if (!(t instanceof ke)) {
                    const e = n[i + 1]
                    if (Array.isArray(e))
                      for (let n = 0; n < e.length; n += 2)
                        e[n + 1].call(t[e[n]])
                    else e.call(t)
                  }
                }
            })(t, e),
            (function (t, e) {
              const n = t.cleanup,
                i = e[7]
              let r = -1
              if (null !== n) {
                for (let t = 0; t < n.length - 1; t += 2)
                  if ('string' == typeof n[t]) {
                    const s = n[t + 1],
                      o = 'function' == typeof s ? s(e) : At(e[s]),
                      a = i[(r = n[t + 2])],
                      l = n[t + 3]
                    'boolean' == typeof l
                      ? o.removeEventListener(n[t], a, l)
                      : l >= 0
                      ? i[(r = l)]()
                      : i[(r = -l)].unsubscribe(),
                      (t += 2)
                  } else {
                    const e = i[(r = n[t + 1])]
                    n[t].call(e)
                  }
                if (null !== i)
                  for (let t = r + 1; t < i.length; t++) (0, i[t])()
                e[7] = null
              }
            })(t, e),
            1 === e[1].type && kt(e[11]) && e[11].destroy()
          const n = e[17]
          if (null !== n && at(e[3])) {
            n !== e[3] && Li(n, e)
            const i = e[19]
            null !== i && i.detachView(t)
          }
        }
      }
      function Vi(t, e, n) {
        return (function (t, e, n) {
          let i = e
          for (; null !== i && 40 & i.type; ) i = (e = i).parent
          if (null === i) return n[0]
          if (2 & i.flags) {
            const e = t.data[i.directiveStart].encapsulation
            if (e === I.None || e === I.Emulated) return null
          }
          return jt(i, n)
        })(t, e.parent, n)
      }
      function Ui(t, e, n, i, r) {
        kt(t) ? t.insertBefore(e, n, i, r) : e.insertBefore(n, i, r)
      }
      function Bi(t, e, n) {
        kt(t) ? t.appendChild(e, n) : e.appendChild(n)
      }
      function zi(t, e, n, i, r) {
        null !== i ? Ui(t, e, n, i, r) : Bi(t, e, n)
      }
      function Hi(t, e) {
        return kt(t) ? t.parentNode(e) : e.parentNode
      }
      function qi(t, e, n) {
        return Wi(t, e, n)
      }
      let Wi = function (t, e, n) {
        return 40 & t.type ? jt(t, n) : null
      }
      function $i(t, e, n, i) {
        const r = Vi(t, i, e),
          s = e[11],
          o = qi(i.parent || e[6], i, e)
        if (null != r)
          if (Array.isArray(n))
            for (let a = 0; a < n.length; a++) zi(s, r, n[a], o, !1)
          else zi(s, r, n, o, !1)
      }
      function Gi(t, e) {
        if (null !== e) {
          const n = e.type
          if (3 & n) return jt(e, t)
          if (4 & n) return Qi(-1, t[e.index])
          if (8 & n) {
            const n = e.child
            if (null !== n) return Gi(t, n)
            {
              const n = t[e.index]
              return at(n) ? Qi(-1, n) : At(n)
            }
          }
          if (32 & n) return Ai(e, t)() || At(t[e.index])
          {
            const n = t[16],
              i = n[6],
              r = Ti(n),
              s = i.projection[e.projection]
            return null != s ? Gi(r, s) : Gi(t, e.next)
          }
        }
        return null
      }
      function Qi(t, e) {
        const n = st + t + 1
        if (n < e.length) {
          const t = e[n],
            i = t[1].firstChild
          if (null !== i) return Gi(t, i)
        }
        return e[7]
      }
      function Xi(t, e, n, i, r, s, o) {
        for (; null != n; ) {
          const a = i[n.index],
            l = n.type
          if (
            (o && 0 === e && (a && Ci(At(a), i), (n.flags |= 4)),
            64 != (64 & n.flags))
          )
            if (8 & l) Xi(t, e, n.child, i, r, s, !1), Ri(e, t, r, a, s)
            else if (32 & l) {
              const o = Ai(n, i)
              let l
              for (; (l = o()); ) Ri(e, t, r, l, s)
              Ri(e, t, r, a, s)
            } else 16 & l ? Yi(t, e, i, n, r, s) : Ri(e, t, r, a, s)
          n = o ? n.projectionNext : n.next
        }
      }
      function Ki(t, e, n, i, r, s) {
        Xi(n, i, t.firstChild, e, r, s, !1)
      }
      function Yi(t, e, n, i, r, s) {
        const o = n[16],
          a = o[6].projection[i.projection]
        if (Array.isArray(a))
          for (let l = 0; l < a.length; l++) Ri(e, t, r, a[l], s)
        else Xi(t, e, a, o[3], r, s, !0)
      }
      function Zi(t, e, n) {
        kt(t) ? t.setAttribute(e, 'style', n) : (e.style.cssText = n)
      }
      function Ji(t, e, n) {
        kt(t)
          ? '' === n
            ? t.removeAttribute(e, 'class')
            : t.setAttribute(e, 'class', n)
          : (e.className = n)
      }
      function tr(t, e, n) {
        let i = t.length
        for (;;) {
          const r = t.indexOf(e, n)
          if (-1 === r) return r
          if (0 === r || t.charCodeAt(r - 1) <= 32) {
            const n = e.length
            if (r + n === i || t.charCodeAt(r + n) <= 32) return r
          }
          n = r + 1
        }
      }
      const er = 'ng-template'
      function nr(t, e, n) {
        let i = 0
        for (; i < t.length; ) {
          let r = t[i++]
          if (n && 'class' === r) {
            if (((r = t[i]), -1 !== tr(r.toLowerCase(), e, 0))) return !0
          } else if (1 === r) {
            for (; i < t.length && 'string' == typeof (r = t[i++]); )
              if (r.toLowerCase() === e) return !0
            return !1
          }
        }
        return !1
      }
      function ir(t) {
        return 4 === t.type && t.value !== er
      }
      function rr(t, e, n) {
        return e === (4 !== t.type || n ? t.value : er)
      }
      function sr(t, e, n) {
        let i = 4
        const r = t.attrs || [],
          s = (function (t) {
            for (let e = 0; e < t.length; e++) if (Ae(t[e])) return e
            return t.length
          })(r)
        let o = !1
        for (let a = 0; a < e.length; a++) {
          const l = e[a]
          if ('number' != typeof l) {
            if (!o)
              if (4 & i) {
                if (
                  ((i = 2 | (1 & i)),
                  ('' !== l && !rr(t, l, n)) || ('' === l && 1 === e.length))
                ) {
                  if (or(i)) return !1
                  o = !0
                }
              } else {
                const c = 8 & i ? l : e[++a]
                if (8 & i && null !== t.attrs) {
                  if (!nr(t.attrs, c, n)) {
                    if (or(i)) return !1
                    o = !0
                  }
                  continue
                }
                const u = ar(8 & i ? 'class' : l, r, ir(t), n)
                if (-1 === u) {
                  if (or(i)) return !1
                  o = !0
                  continue
                }
                if ('' !== c) {
                  let t
                  t = u > s ? '' : r[u + 1].toLowerCase()
                  const e = 8 & i ? t : null
                  if ((e && -1 !== tr(e, c, 0)) || (2 & i && c !== t)) {
                    if (or(i)) return !1
                    o = !0
                  }
                }
              }
          } else {
            if (!o && !or(i) && !or(l)) return !1
            if (o && or(l)) continue
            ;(o = !1), (i = l | (1 & i))
          }
        }
        return or(i) || o
      }
      function or(t) {
        return 0 == (1 & t)
      }
      function ar(t, e, n, i) {
        if (null === e) return -1
        let r = 0
        if (i || !n) {
          let n = !1
          for (; r < e.length; ) {
            const i = e[r]
            if (i === t) return r
            if (3 === i || 6 === i) n = !0
            else {
              if (1 === i || 2 === i) {
                let t = e[++r]
                for (; 'string' == typeof t; ) t = e[++r]
                continue
              }
              if (4 === i) break
              if (0 === i) {
                r += 4
                continue
              }
            }
            r += n ? 1 : 2
          }
          return -1
        }
        return (function (t, e) {
          let n = t.indexOf(4)
          if (n > -1)
            for (n++; n < t.length; ) {
              const i = t[n]
              if ('number' == typeof i) return -1
              if (i === e) return n
              n++
            }
          return -1
        })(e, t)
      }
      function lr(t, e, n = !1) {
        for (let i = 0; i < e.length; i++) if (sr(t, e[i], n)) return !0
        return !1
      }
      function cr(t, e) {
        t: for (let n = 0; n < e.length; n++) {
          const i = e[n]
          if (t.length === i.length) {
            for (let e = 0; e < t.length; e++) if (t[e] !== i[e]) continue t
            return !0
          }
        }
        return !1
      }
      function ur(t, e) {
        return t ? ':not(' + e.trim() + ')' : e
      }
      function hr(t) {
        let e = t[0],
          n = 1,
          i = 2,
          r = '',
          s = !1
        for (; n < t.length; ) {
          let o = t[n]
          if ('string' == typeof o)
            if (2 & i) {
              const e = t[++n]
              r += '[' + o + (e.length > 0 ? '="' + e + '"' : '') + ']'
            } else 8 & i ? (r += '.' + o) : 4 & i && (r += ' ' + o)
          else
            '' === r || or(o) || ((e += ur(s, r)), (r = '')),
              (i = o),
              (s = s || !or(i))
          n++
        }
        return '' !== r && (e += ur(s, r)), e
      }
      const dr = {}
      function pr(t) {
        fr(Ht(), zt(), fe() + t, Kt())
      }
      function fr(t, e, n, i) {
        if (!i)
          if (3 == (3 & e[2])) {
            const i = t.preOrderCheckHooks
            null !== i && ve(e, i, n)
          } else {
            const i = t.preOrderHooks
            null !== i && we(e, i, 0, n)
          }
        me(n)
      }
      function mr(t, e) {
        return (t << 17) | (e << 2)
      }
      function gr(t) {
        return (t >> 17) & 32767
      }
      function br(t) {
        return 2 | t
      }
      function _r(t) {
        return (131068 & t) >> 2
      }
      function yr(t, e) {
        return (-131069 & t) | (e << 2)
      }
      function vr(t) {
        return 1 | t
      }
      function wr(t, e) {
        const n = t.contentQueries
        if (null !== n)
          for (let i = 0; i < n.length; i += 2) {
            const r = n[i],
              s = n[i + 1]
            if (-1 !== s) {
              const n = t.data[s]
              se(r), n.contentQueries(2, e[s], s)
            }
          }
      }
      function Cr(t, e, n, i, r, s, o, a, l, c) {
        const u = e.blueprint.slice()
        return (
          (u[0] = r),
          (u[2] = 140 | i),
          Mt(u),
          (u[3] = u[15] = t),
          (u[8] = n),
          (u[10] = o || (t && t[10])),
          (u[11] = a || (t && t[11])),
          (u[12] = l || (t && t[12]) || null),
          (u[9] = c || (t && t[9]) || null),
          (u[6] = s),
          (u[16] = 2 == e.type ? t[16] : u),
          u
        )
      }
      function xr(t, e, n, i, r) {
        let s = t.data[e]
        if (null === s)
          (s = (function (t, e, n, i, r) {
            const s = $t(),
              o = Qt(),
              a = (t.data[e] = (function (t, e, n, i, r, s) {
                return {
                  type: n,
                  index: i,
                  insertBeforeIndex: null,
                  injectorIndex: e ? e.injectorIndex : -1,
                  directiveStart: -1,
                  directiveEnd: -1,
                  directiveStylingLast: -1,
                  propertyBindings: null,
                  flags: 0,
                  providerIndexes: 0,
                  value: r,
                  attrs: s,
                  mergedAttrs: null,
                  localNames: null,
                  initialInputs: void 0,
                  inputs: null,
                  outputs: null,
                  tViews: null,
                  next: null,
                  projectionNext: null,
                  child: null,
                  parent: e,
                  projection: null,
                  styles: null,
                  stylesWithoutHost: null,
                  residualStyles: void 0,
                  classes: null,
                  classesWithoutHost: null,
                  residualClasses: void 0,
                  classBindings: 0,
                  styleBindings: 0,
                }
              })(0, o ? s : s && s.parent, n, e, i, r))
            return (
              null === t.firstChild && (t.firstChild = a),
              null !== s &&
                (o
                  ? null == s.child && null !== a.parent && (s.child = a)
                  : null === s.next && (s.next = a)),
              a
            )
          })(t, e, n, i, r)),
            Ut.lFrame.inI18n && (s.flags |= 64)
        else if (64 & s.type) {
          ;(s.type = n), (s.value = i), (s.attrs = r)
          const t = (function () {
            const t = Ut.lFrame,
              e = t.currentTNode
            return t.isParent ? e : e.parent
          })()
          s.injectorIndex = null === t ? -1 : t.injectorIndex
        }
        return Gt(s, !0), s
      }
      function Sr(t, e, n, i) {
        if (0 === n) return -1
        const r = e.length
        for (let s = 0; s < n; s++)
          e.push(i), t.blueprint.push(i), t.data.push(null)
        return r
      }
      function Or(t, e, n) {
        le(e)
        try {
          const i = t.viewQuery
          null !== i && es(1, i, n)
          const r = t.template
          null !== r && Ar(t, e, r, 1, n),
            t.firstCreatePass && (t.firstCreatePass = !1),
            t.staticContentQueries && wr(t, e),
            t.staticViewQueries && es(2, t.viewQuery, n)
          const s = t.components
          null !== s &&
            (function (t, e) {
              for (let n = 0; n < e.length; n++) Kr(t, e[n])
            })(e, s)
        } catch (i) {
          throw (t.firstCreatePass && (t.incompleteFirstPass = !0), i)
        } finally {
          ;(e[2] &= -5), pe()
        }
      }
      function kr(t, e, n, i) {
        const r = e[2]
        if (256 == (256 & r)) return
        le(e)
        const s = Kt()
        try {
          Mt(e),
            (Ut.lFrame.bindingIndex = t.bindingStartIndex),
            null !== n && Ar(t, e, n, 2, i)
          const o = 3 == (3 & r)
          if (!s)
            if (o) {
              const n = t.preOrderCheckHooks
              null !== n && ve(e, n, null)
            } else {
              const n = t.preOrderHooks
              null !== n && we(e, n, 0, null), Ce(e, 0)
            }
          if (
            ((function (t) {
              for (let e = ji(t); null !== e; e = Ii(e)) {
                if (!e[2]) continue
                const t = e[9]
                for (let e = 0; e < t.length; e++) {
                  const n = t[e],
                    i = n[3]
                  0 == (1024 & n[2]) && Vt(i, 1), (n[2] |= 1024)
                }
              }
            })(e),
            (function (t) {
              for (let e = ji(t); null !== e; e = Ii(e))
                for (let t = st; t < e.length; t++) {
                  const n = e[t],
                    i = n[1]
                  Ft(n) && kr(i, n, i.template, n[8])
                }
            })(e),
            null !== t.contentQueries && wr(t, e),
            !s)
          )
            if (o) {
              const n = t.contentCheckHooks
              null !== n && ve(e, n)
            } else {
              const n = t.contentHooks
              null !== n && we(e, n, 1), Ce(e, 1)
            }
          !(function (t, e) {
            const n = t.hostBindingOpCodes
            if (null !== n)
              try {
                for (let t = 0; t < n.length; t++) {
                  const i = n[t]
                  if (i < 0) me(~i)
                  else {
                    const r = i,
                      s = n[++t],
                      o = n[++t]
                    ee(s, r), o(2, e[r])
                  }
                }
              } finally {
                me(-1)
              }
          })(t, e)
          const a = t.components
          null !== a &&
            (function (t, e) {
              for (let n = 0; n < e.length; n++) Qr(t, e[n])
            })(e, a)
          const l = t.viewQuery
          if ((null !== l && es(2, l, i), !s))
            if (o) {
              const n = t.viewCheckHooks
              null !== n && ve(e, n)
            } else {
              const n = t.viewHooks
              null !== n && we(e, n, 2), Ce(e, 2)
            }
          !0 === t.firstUpdatePass && (t.firstUpdatePass = !1),
            s || (e[2] &= -73),
            1024 & e[2] && ((e[2] &= -1025), Vt(e[3], -1))
        } finally {
          pe()
        }
      }
      function Er(t, e, n, i) {
        const r = e[10],
          s = !Kt(),
          o = Lt(e)
        try {
          s && !o && r.begin && r.begin(), o && Or(t, e, i), kr(t, e, n, i)
        } finally {
          s && !o && r.end && r.end()
        }
      }
      function Ar(t, e, n, i, r) {
        const s = fe()
        try {
          me(-1), 2 & i && e.length > rt && fr(t, e, rt, Kt()), n(i, r)
        } finally {
          me(s)
        }
      }
      function Tr(t, e, n) {
        if (lt(e)) {
          const i = e.directiveEnd
          for (let r = e.directiveStart; r < i; r++) {
            const e = t.data[r]
            e.contentQueries && e.contentQueries(1, n[r], r)
          }
        }
      }
      function jr(t, e, n) {
        Bt() &&
          ((function (t, e, n, i) {
            const r = n.directiveStart,
              s = n.directiveEnd
            t.firstCreatePass || Me(n, e), Ci(i, e)
            const o = n.initialInputs
            for (let a = r; a < s; a++) {
              const i = t.data[a],
                s = ht(i)
              s && qr(e, n, i)
              const l = Ke(e, t, a, n)
              Ci(l, e),
                null !== o && Wr(0, a - r, l, i, 0, o),
                s && (Rt(n.index, e)[8] = l)
            }
          })(t, e, n, jt(n, e)),
          128 == (128 & n.flags) &&
            (function (t, e, n) {
              const i = n.directiveStart,
                r = n.directiveEnd,
                s = n.index,
                o = Ut.lFrame.currentDirectiveIndex
              try {
                me(s)
                for (let n = i; n < r; n++) {
                  const i = t.data[n],
                    r = e[n]
                  ne(n),
                    (null === i.hostBindings &&
                      0 === i.hostVars &&
                      null === i.hostAttrs) ||
                      Vr(i, r)
                }
              } finally {
                me(-1), ne(o)
              }
            })(t, e, n))
      }
      function Ir(t, e, n = jt) {
        const i = e.localNames
        if (null !== i) {
          let r = e.index + 1
          for (let s = 0; s < i.length; s += 2) {
            const o = i[s + 1],
              a = -1 === o ? n(e, t) : t[o]
            t[r++] = a
          }
        }
      }
      function Pr(t) {
        const e = t.tView
        return null === e || e.incompleteFirstPass
          ? (t.tView = Rr(
              1,
              null,
              t.template,
              t.decls,
              t.vars,
              t.directiveDefs,
              t.pipeDefs,
              t.viewQuery,
              t.schemas,
              t.consts
            ))
          : e
      }
      function Rr(t, e, n, i, r, s, o, a, l, c) {
        const u = rt + i,
          h = u + r,
          d = (function (t, e) {
            const n = []
            for (let i = 0; i < e; i++) n.push(i < t ? null : dr)
            return n
          })(u, h),
          p = 'function' == typeof c ? c() : c
        return (d[1] = {
          type: t,
          blueprint: d,
          template: n,
          queries: null,
          viewQuery: a,
          declTNode: e,
          data: d.slice().fill(null, u),
          bindingStartIndex: u,
          expandoStartIndex: h,
          hostBindingOpCodes: null,
          firstCreatePass: !0,
          firstUpdatePass: !0,
          staticViewQueries: !1,
          staticContentQueries: !1,
          preOrderHooks: null,
          preOrderCheckHooks: null,
          contentHooks: null,
          contentCheckHooks: null,
          viewHooks: null,
          viewCheckHooks: null,
          destroyHooks: null,
          cleanup: null,
          contentQueries: null,
          components: null,
          directiveRegistry: 'function' == typeof s ? s() : s,
          pipeRegistry: 'function' == typeof o ? o() : o,
          firstChild: null,
          schemas: l,
          consts: p,
          incompleteFirstPass: !1,
        })
      }
      function Dr(t, e, n, i) {
        const r = is(e)
        null === n
          ? r.push(i)
          : (r.push(n), t.firstCreatePass && rs(t).push(i, r.length - 1))
      }
      function Lr(t, e, n) {
        for (let i in t)
          if (t.hasOwnProperty(i)) {
            const r = t[i]
            ;(n = null === n ? {} : n).hasOwnProperty(i)
              ? n[i].push(e, r)
              : (n[i] = [e, r])
          }
        return n
      }
      function Fr(t, e, n, i, r, s, o, a) {
        const l = jt(e, n)
        let c,
          u = e.inputs
        var h
        !a && null != u && (c = u[i])
          ? (as(t, n, c, i, r),
            ct(e) &&
              (function (t, e) {
                const n = Rt(e, t)
                16 & n[2] || (n[2] |= 64)
              })(n, e.index))
          : 3 & e.type &&
            ((i =
              'class' === (h = i)
                ? 'className'
                : 'for' === h
                ? 'htmlFor'
                : 'formaction' === h
                ? 'formAction'
                : 'innerHtml' === h
                ? 'innerHTML'
                : 'readonly' === h
                ? 'readOnly'
                : 'tabindex' === h
                ? 'tabIndex'
                : h),
            (r = null != o ? o(r, e.value || '', i) : r),
            kt(s)
              ? s.setProperty(l, i, r)
              : Te(i) || (l.setProperty ? l.setProperty(i, r) : (l[i] = r)))
      }
      function Nr(t, e, n, i) {
        let r = !1
        if (Bt()) {
          const s = (function (t, e, n) {
              const i = t.directiveRegistry
              let r = null
              if (i)
                for (let s = 0; s < i.length; s++) {
                  const o = i[s]
                  lr(n, o.selectors, !1) &&
                    (r || (r = []),
                    ze(Me(n, e), t, o.type),
                    ht(o) ? (Ur(t, n), r.unshift(o)) : r.push(o))
                }
              return r
            })(t, e, n),
            o = null === i ? null : { '': -1 }
          if (null !== s) {
            ;(r = !0), zr(n, t.data.length, s.length)
            for (let t = 0; t < s.length; t++) {
              const e = s[t]
              e.providersResolver && e.providersResolver(e)
            }
            let i = !1,
              a = !1,
              l = Sr(t, e, s.length, null)
            for (let r = 0; r < s.length; r++) {
              const c = s[r]
              ;(n.mergedAttrs = je(n.mergedAttrs, c.hostAttrs)),
                Hr(t, n, e, l, c),
                Br(l, c, o),
                null !== c.contentQueries && (n.flags |= 8),
                (null === c.hostBindings &&
                  null === c.hostAttrs &&
                  0 === c.hostVars) ||
                  (n.flags |= 128)
              const u = c.type.prototype
              !i &&
                (u.ngOnChanges || u.ngOnInit || u.ngDoCheck) &&
                ((t.preOrderHooks || (t.preOrderHooks = [])).push(n.index),
                (i = !0)),
                a ||
                  (!u.ngOnChanges && !u.ngDoCheck) ||
                  ((t.preOrderCheckHooks || (t.preOrderCheckHooks = [])).push(
                    n.index
                  ),
                  (a = !0)),
                l++
            }
            !(function (t, e) {
              const n = e.directiveEnd,
                i = t.data,
                r = e.attrs,
                s = []
              let o = null,
                a = null
              for (let l = e.directiveStart; l < n; l++) {
                const t = i[l],
                  n = t.inputs,
                  c = null === r || ir(e) ? null : $r(n, r)
                s.push(c), (o = Lr(n, l, o)), (a = Lr(t.outputs, l, a))
              }
              null !== o &&
                (o.hasOwnProperty('class') && (e.flags |= 16),
                o.hasOwnProperty('style') && (e.flags |= 32)),
                (e.initialInputs = s),
                (e.inputs = o),
                (e.outputs = a)
            })(t, n)
          }
          o &&
            (function (t, e, n) {
              if (e) {
                const i = (t.localNames = [])
                for (let t = 0; t < e.length; t += 2) {
                  const r = n[e[t + 1]]
                  if (null == r)
                    throw new pt(
                      '301',
                      `Export of name '${e[t + 1]}' not found!`
                    )
                  i.push(e[t], r)
                }
              }
            })(n, i, o)
        }
        return (n.mergedAttrs = je(n.mergedAttrs, n.attrs)), r
      }
      function Mr(t, e, n, i, r, s) {
        const o = s.hostBindings
        if (o) {
          let n = t.hostBindingOpCodes
          null === n && (n = t.hostBindingOpCodes = [])
          const s = ~e.index
          ;(function (t) {
            let e = t.length
            for (; e > 0; ) {
              const n = t[--e]
              if ('number' == typeof n && n < 0) return n
            }
            return 0
          })(n) != s && n.push(s),
            n.push(i, r, o)
        }
      }
      function Vr(t, e) {
        null !== t.hostBindings && t.hostBindings(1, e)
      }
      function Ur(t, e) {
        ;(e.flags |= 2), (t.components || (t.components = [])).push(e.index)
      }
      function Br(t, e, n) {
        if (n) {
          if (e.exportAs)
            for (let i = 0; i < e.exportAs.length; i++) n[e.exportAs[i]] = t
          ht(e) && (n[''] = t)
        }
      }
      function zr(t, e, n) {
        ;(t.flags |= 1),
          (t.directiveStart = e),
          (t.directiveEnd = e + n),
          (t.providerIndexes = e)
      }
      function Hr(t, e, n, i, r) {
        t.data[i] = r
        const s = r.factory || (r.factory = dt(r.type)),
          o = new ke(s, ht(r), null)
        ;(t.blueprint[i] = o),
          (n[i] = o),
          Mr(t, e, 0, i, Sr(t, n, r.hostVars, dr), r)
      }
      function qr(t, e, n) {
        const i = jt(e, t),
          r = Pr(n),
          s = t[10],
          o = Yr(
            t,
            Cr(
              t,
              r,
              null,
              n.onPush ? 64 : 16,
              i,
              e,
              s,
              s.createRenderer(i, n),
              null,
              null
            )
          )
        t[e.index] = o
      }
      function Wr(t, e, n, i, r, s) {
        const o = s[e]
        if (null !== o) {
          const t = i.setInput
          for (let e = 0; e < o.length; ) {
            const r = o[e++],
              s = o[e++],
              a = o[e++]
            null !== t ? i.setInput(n, a, r, s) : (n[s] = a)
          }
        }
      }
      function $r(t, e) {
        let n = null,
          i = 0
        for (; i < e.length; ) {
          const r = e[i]
          if (0 !== r)
            if (5 !== r) {
              if ('number' == typeof r) break
              t.hasOwnProperty(r) &&
                (null === n && (n = []), n.push(r, t[r], e[i + 1])),
                (i += 2)
            } else i += 2
          else i += 4
        }
        return n
      }
      function Gr(t, e, n, i) {
        return new Array(t, !0, !1, e, null, 0, i, n, null, null)
      }
      function Qr(t, e) {
        const n = Rt(e, t)
        if (Ft(n)) {
          const t = n[1]
          80 & n[2] ? kr(t, n, t.template, n[8]) : n[5] > 0 && Xr(n)
        }
      }
      function Xr(t) {
        for (let n = ji(t); null !== n; n = Ii(n))
          for (let t = st; t < n.length; t++) {
            const e = n[t]
            if (1024 & e[2]) {
              const t = e[1]
              kr(t, e, t.template, e[8])
            } else e[5] > 0 && Xr(e)
          }
        const e = t[1].components
        if (null !== e)
          for (let n = 0; n < e.length; n++) {
            const i = Rt(e[n], t)
            Ft(i) && i[5] > 0 && Xr(i)
          }
      }
      function Kr(t, e) {
        const n = Rt(e, t),
          i = n[1]
        !(function (t, e) {
          for (let n = e.length; n < t.blueprint.length; n++)
            e.push(t.blueprint[n])
        })(i, n),
          Or(i, n, n[8])
      }
      function Yr(t, e) {
        return t[13] ? (t[14][4] = e) : (t[13] = e), (t[14] = e), e
      }
      function Zr(t) {
        for (; t; ) {
          t[2] |= 64
          const e = Ti(t)
          if (0 != (512 & t[2]) && !e) return t
          t = e
        }
        return null
      }
      function Jr(t, e, n) {
        const i = e[10]
        i.begin && i.begin()
        try {
          kr(t, e, t.template, n)
        } catch (r) {
          throw (os(e, r), r)
        } finally {
          i.end && i.end()
        }
      }
      function ts(t) {
        !(function (t) {
          for (let e = 0; e < t.components.length; e++) {
            const n = t.components[e],
              i = Dt(n),
              r = i[1]
            Er(r, i, r.template, n)
          }
        })(t[8])
      }
      function es(t, e, n) {
        se(0), e(t, n)
      }
      const ns = (() => Promise.resolve(null))()
      function is(t) {
        return t[7] || (t[7] = [])
      }
      function rs(t) {
        return t.cleanup || (t.cleanup = [])
      }
      function ss(t, e, n) {
        return (
          (null === t || ht(t)) &&
            (n = (function (t) {
              for (; Array.isArray(t); ) {
                if ('object' == typeof t[1]) return t
                t = t[0]
              }
              return null
            })(n[e.index])),
          n[11]
        )
      }
      function os(t, e) {
        const n = t[9],
          i = n ? n.get(wi, null) : null
        i && i.handleError(e)
      }
      function as(t, e, n, i, r) {
        for (let s = 0; s < n.length; ) {
          const o = n[s++],
            a = n[s++],
            l = e[o],
            c = t.data[o]
          null !== c.setInput ? c.setInput(l, r, i, a) : (l[a] = r)
        }
      }
      function ls(t, e, n) {
        let i = n ? t.styles : null,
          r = n ? t.classes : null,
          s = 0
        if (null !== e)
          for (let o = 0; o < e.length; o++) {
            const t = e[o]
            'number' == typeof t
              ? (s = t)
              : 1 == s
              ? (r = h(r, t))
              : 2 == s && (i = h(i, t + ': ' + e[++o] + ';'))
          }
        n ? (t.styles = i) : (t.stylesWithoutHost = i),
          n ? (t.classes = r) : (t.classesWithoutHost = r)
      }
      const cs = new on('INJECTOR', -1)
      class us {
        get(t, e = wn) {
          if (e === wn) {
            const e = new Error(`NullInjectorError: No provider for ${u(t)}!`)
            throw ((e.name = 'NullInjectorError'), e)
          }
          return e
        }
      }
      const hs = new on('Set Injector scope.'),
        ds = {},
        ps = {},
        fs = []
      let ms = void 0
      function gs() {
        return void 0 === ms && (ms = new us()), ms
      }
      function bs(t, e = null, n = null, i) {
        return new _s(t, n, e || gs(), i)
      }
      class _s {
        constructor(t, e, n, i = null) {
          ;(this.parent = n),
            (this.records = new Map()),
            (this.injectorDefTypes = new Set()),
            (this.onDestroy = new Set()),
            (this._destroyed = !1)
          const r = []
          e && un(e, (n) => this.processProvider(n, t, e)),
            un([t], (t) => this.processInjectorType(t, [], r)),
            this.records.set(cs, ws(void 0, this))
          const s = this.records.get(hs)
          ;(this.scope = null != s ? s.value : null),
            (this.source = i || ('object' == typeof t ? null : u(t)))
        }
        get destroyed() {
          return this._destroyed
        }
        destroy() {
          this.assertNotDestroyed(), (this._destroyed = !0)
          try {
            this.onDestroy.forEach((t) => t.ngOnDestroy())
          } finally {
            this.records.clear(),
              this.onDestroy.clear(),
              this.injectorDefTypes.clear()
          }
        }
        get(t, e = wn, n = O.Default) {
          this.assertNotDestroyed()
          const i = kn(this)
          try {
            if (!(n & O.SkipSelf)) {
              let e = this.records.get(t)
              if (void 0 === e) {
                const n =
                  ('function' == typeof (r = t) ||
                    ('object' == typeof r && r instanceof on)) &&
                  _(t)
                ;(e = n && this.injectableDefInScope(n) ? ws(ys(t), ds) : null),
                  this.records.set(t, e)
              }
              if (null != e) return this.hydrate(t, e)
            }
            return (n & O.Self ? gs() : this.parent).get(
              t,
              (e = n & O.Optional && e === wn ? null : e)
            )
          } catch (s) {
            if ('NullInjectorError' === s.name) {
              if (
                ((s.ngTempTokenPath = s.ngTempTokenPath || []).unshift(u(t)), i)
              )
                throw s
              return (function (t, e, n, i) {
                const r = t.ngTempTokenPath
                throw (
                  (e[xn] && r.unshift(e[xn]),
                  (t.message = (function (t, e, n, i = null) {
                    t =
                      t && '\n' === t.charAt(0) && '\u0275' == t.charAt(1)
                        ? t.substr(2)
                        : t
                    let r = u(e)
                    if (Array.isArray(e)) r = e.map(u).join(' -> ')
                    else if ('object' == typeof e) {
                      let t = []
                      for (let n in e)
                        if (e.hasOwnProperty(n)) {
                          let i = e[n]
                          t.push(
                            n +
                              ':' +
                              ('string' == typeof i ? JSON.stringify(i) : u(i))
                          )
                        }
                      r = `{${t.join(', ')}}`
                    }
                    return `${n}${i ? '(' + i + ')' : ''}[${r}]: ${t.replace(
                      Cn,
                      '\n  '
                    )}`
                  })('\n' + t.message, r, n, i)),
                  (t.ngTokenPath = r),
                  (t.ngTempTokenPath = null),
                  t)
                )
              })(s, t, 'R3InjectorError', this.source)
            }
            throw s
          } finally {
            kn(i)
          }
          var r
        }
        _resolveInjectorDefTypes() {
          this.injectorDefTypes.forEach((t) => this.get(t))
        }
        toString() {
          const t = []
          return (
            this.records.forEach((e, n) => t.push(u(n))),
            `R3Injector[${t.join(', ')}]`
          )
        }
        assertNotDestroyed() {
          if (this._destroyed)
            throw new Error('Injector has already been destroyed.')
        }
        processInjectorType(t, e, n) {
          if (!(t = f(t))) return !1
          let i = v(t)
          const r = (null == i && t.ngModule) || void 0,
            s = void 0 === r ? t : r,
            o = -1 !== n.indexOf(s)
          if ((void 0 !== r && (i = v(r)), null == i)) return !1
          if (null != i.imports && !o) {
            let t
            n.push(s)
            try {
              un(i.imports, (i) => {
                this.processInjectorType(i, e, n) &&
                  (void 0 === t && (t = []), t.push(i))
              })
            } finally {
            }
            if (void 0 !== t)
              for (let e = 0; e < t.length; e++) {
                const { ngModule: n, providers: i } = t[e]
                un(i, (t) => this.processProvider(t, n, i || fs))
              }
          }
          this.injectorDefTypes.add(s), this.records.set(s, ws(i.factory, ds))
          const a = i.providers
          if (null != a && !o) {
            const e = t
            un(a, (t) => this.processProvider(t, e, a))
          }
          return void 0 !== r && void 0 !== t.providers
        }
        processProvider(t, e, n) {
          let i = xs((t = f(t))) ? t : f(t && t.provide)
          const r = (function (t, e, n) {
            return Cs(t) ? ws(void 0, t.useValue) : ws(vs(t), ds)
          })(t)
          if (xs(t) || !0 !== t.multi) this.records.get(i)
          else {
            let e = this.records.get(i)
            e ||
              ((e = ws(void 0, ds, !0)),
              (e.factory = () => jn(e.multi)),
              this.records.set(i, e)),
              (i = t),
              e.multi.push(t)
          }
          this.records.set(i, r)
        }
        hydrate(t, e) {
          var n
          return (
            e.value === ds && ((e.value = ps), (e.value = e.factory())),
            'object' == typeof e.value &&
              e.value &&
              null !== (n = e.value) &&
              'object' == typeof n &&
              'function' == typeof n.ngOnDestroy &&
              this.onDestroy.add(e.value),
            e.value
          )
        }
        injectableDefInScope(t) {
          return (
            !!t.providedIn &&
            ('string' == typeof t.providedIn
              ? 'any' === t.providedIn || t.providedIn === this.scope
              : this.injectorDefTypes.has(t.providedIn))
          )
        }
      }
      function ys(t) {
        const e = _(t),
          n = null !== e ? e.factory : dt(t)
        if (null !== n) return n
        const i = v(t)
        if (null !== i) return i.factory
        if (t instanceof on)
          throw new Error(`Token ${u(t)} is missing a \u0275prov definition.`)
        if (t instanceof Function)
          return (function (t) {
            const e = t.length
            if (e > 0) {
              const n = pn(e, '?')
              throw new Error(
                `Can't resolve all parameters for ${u(t)}: (${n.join(', ')}).`
              )
            }
            const n = (function (t) {
              const e = t && (t[w] || t[x])
              if (e) {
                const n = (function (t) {
                  if (t.hasOwnProperty('name')) return t.name
                  const e = ('' + t).match(/^function\s*([^\s(]+)/)
                  return null === e ? '' : e[1]
                })(t)
                return (
                  console.warn(
                    `DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`
                  ),
                  e
                )
              }
              return null
            })(t)
            return null !== n ? () => n.factory(t) : () => new t()
          })(t)
        throw new Error('unreachable')
      }
      function vs(t, e, n) {
        let i = void 0
        if (xs(t)) {
          const e = f(t)
          return dt(e) || ys(e)
        }
        if (Cs(t)) i = () => f(t.useValue)
        else if ((r = t) && r.useFactory)
          i = () => t.useFactory(...jn(t.deps || []))
        else if (
          (function (t) {
            return !(!t || !t.useExisting)
          })(t)
        )
          i = () => An(f(t.useExisting))
        else {
          const e = f(t && (t.useClass || t.provide))
          if (
            !(function (t) {
              return !!t.deps
            })(t)
          )
            return dt(e) || ys(e)
          i = () => new e(...jn(t.deps))
        }
        var r
        return i
      }
      function ws(t, e, n = !1) {
        return { factory: t, value: e, multi: n ? [] : void 0 }
      }
      function Cs(t) {
        return null !== t && 'object' == typeof t && Sn in t
      }
      function xs(t) {
        return 'function' == typeof t
      }
      const Ss = function (t, e, n) {
        return (function (t, e = null, n = null, i) {
          const r = bs(t, e, n, i)
          return r._resolveInjectorDefTypes(), r
        })({ name: n }, e, t, n)
      }
      let Os = (() => {
        class t {
          static create(t, e) {
            return Array.isArray(t)
              ? Ss(t, e, '')
              : Ss(t.providers, t.parent, t.name || '')
          }
        }
        return (
          (t.THROW_IF_NOT_FOUND = wn),
          (t.NULL = new us()),
          (t.ɵprov = g({ token: t, providedIn: 'any', factory: () => An(cs) })),
          (t.__NG_ELEMENT_ID__ = -1),
          t
        )
      })()
      function ks(t, e) {
        ye(Dt(t)[1], Wt())
      }
      function Es(t) {
        let e = Object.getPrototypeOf(t.type.prototype).constructor,
          n = !0
        const i = [t]
        for (; e; ) {
          let r = void 0
          if (ht(t)) r = e.ɵcmp || e.ɵdir
          else {
            if (e.ɵcmp) throw new Error('Directives cannot inherit Components')
            r = e.ɵdir
          }
          if (r) {
            if (n) {
              i.push(r)
              const e = t
              ;(e.inputs = As(t.inputs)),
                (e.declaredInputs = As(t.declaredInputs)),
                (e.outputs = As(t.outputs))
              const n = r.hostBindings
              n && Is(t, n)
              const s = r.viewQuery,
                o = r.contentQueries
              if (
                (s && Ts(t, s),
                o && js(t, o),
                c(t.inputs, r.inputs),
                c(t.declaredInputs, r.declaredInputs),
                c(t.outputs, r.outputs),
                ht(r) && r.data.animation)
              ) {
                const e = t.data
                e.animation = (e.animation || []).concat(r.data.animation)
              }
            }
            const e = r.features
            if (e)
              for (let i = 0; i < e.length; i++) {
                const r = e[i]
                r && r.ngInherit && r(t), r === Es && (n = !1)
              }
          }
          e = Object.getPrototypeOf(e)
        }
        !(function (t) {
          let e = 0,
            n = null
          for (let i = t.length - 1; i >= 0; i--) {
            const r = t[i]
            ;(r.hostVars = e += r.hostVars),
              (r.hostAttrs = je(r.hostAttrs, (n = je(n, r.hostAttrs))))
          }
        })(i)
      }
      function As(t) {
        return t === N ? {} : t === M ? [] : t
      }
      function Ts(t, e) {
        const n = t.viewQuery
        t.viewQuery = n
          ? (t, i) => {
              e(t, i), n(t, i)
            }
          : e
      }
      function js(t, e) {
        const n = t.contentQueries
        t.contentQueries = n
          ? (t, i, r) => {
              e(t, i, r), n(t, i, r)
            }
          : e
      }
      function Is(t, e) {
        const n = t.hostBindings
        t.hostBindings = n
          ? (t, i) => {
              e(t, i), n(t, i)
            }
          : e
      }
      let Ps = null
      function Rs() {
        if (!Ps) {
          const t = F.Symbol
          if (t && t.iterator) Ps = t.iterator
          else {
            const t = Object.getOwnPropertyNames(Map.prototype)
            for (let e = 0; e < t.length; ++e) {
              const n = t[e]
              'entries' !== n &&
                'size' !== n &&
                Map.prototype[n] === Map.prototype.entries &&
                (Ps = n)
            }
          }
        }
        return Ps
      }
      class Ds {
        constructor(t) {
          this.wrapped = t
        }
        static wrap(t) {
          return new Ds(t)
        }
        static unwrap(t) {
          return Ds.isWrapped(t) ? t.wrapped : t
        }
        static isWrapped(t) {
          return t instanceof Ds
        }
      }
      function Ls(t) {
        return (
          !!Fs(t) && (Array.isArray(t) || (!(t instanceof Map) && Rs() in t))
        )
      }
      function Fs(t) {
        return null !== t && ('function' == typeof t || 'object' == typeof t)
      }
      function Ns(t, e, n) {
        return (t[e] = n)
      }
      function Ms(t, e, n) {
        return !Object.is(t[e], n) && ((t[e] = n), !0)
      }
      function Vs(t, e, n, i) {
        const r = zt()
        return (
          Ms(r, Jt(), e) &&
            (Ht(),
            (function (t, e, n, i, r, s) {
              const o = jt(t, e)
              !(function (t, e, n, i, r, s, o) {
                if (null == s)
                  kt(t) ? t.removeAttribute(e, r, n) : e.removeAttribute(r)
                else {
                  const a = null == o ? ft(s) : o(s, i || '', r)
                  kt(t)
                    ? t.setAttribute(e, r, a, n)
                    : n
                    ? e.setAttributeNS(n, r, a)
                    : e.setAttribute(r, a)
                }
              })(e[11], o, s, t.value, n, i, r)
            })(ge(), r, t, e, n, i)),
          Vs
        )
      }
      function Us(t, e, n, i) {
        return Ms(t, Jt(), n) ? e + ft(n) + i : dr
      }
      function Bs(t, e, n, i, r, s, o, a) {
        const l = zt(),
          c = Ht(),
          u = t + rt,
          h = c.firstCreatePass
            ? (function (t, e, n, i, r, s, o, a, l) {
                const c = e.consts,
                  u = xr(e, t, 4, o || null, Nt(c, a))
                Nr(e, n, u, Nt(c, l)), ye(e, u)
                const h = (u.tViews = Rr(
                  2,
                  u,
                  i,
                  r,
                  s,
                  e.directiveRegistry,
                  e.pipeRegistry,
                  null,
                  e.schemas,
                  c
                ))
                return (
                  null !== e.queries &&
                    (e.queries.template(e, u),
                    (h.queries = e.queries.embeddedTView(u))),
                  u
                )
              })(u, c, l, e, n, i, r, s, o)
            : c.data[u]
        Gt(h, !1)
        const d = l[11].createComment('')
        $i(c, l, d, h),
          Ci(d, l),
          Yr(l, (l[u] = Gr(d, l, d, h))),
          ut(h) && jr(c, l, h),
          null != o && Ir(l, h, a)
      }
      function zs(t) {
        return Pt(Ut.lFrame.contextLView, rt + t)
      }
      function Hs(t, e = O.Default) {
        const n = zt()
        return null === n ? An(t, e) : We(Wt(), n, f(t), e)
      }
      function qs(t, e, n) {
        const i = zt()
        return Ms(i, Jt(), e) && Fr(Ht(), ge(), i, t, e, i[11], n, !1), qs
      }
      function Ws(t, e, n, i, r) {
        const s = r ? 'class' : 'style'
        as(t, n, e.inputs[s], s, i)
      }
      function $s(t, e, n, i) {
        const r = zt(),
          s = Ht(),
          o = rt + t,
          a = r[11],
          l = (r[o] = Di(a, e, Ut.lFrame.currentNamespace)),
          c = s.firstCreatePass
            ? (function (t, e, n, i, r, s, o) {
                const a = e.consts,
                  l = xr(e, t, 2, r, Nt(a, s))
                return (
                  Nr(e, n, l, Nt(a, o)),
                  null !== l.attrs && ls(l, l.attrs, !1),
                  null !== l.mergedAttrs && ls(l, l.mergedAttrs, !0),
                  null !== e.queries && e.queries.elementStart(e, l),
                  l
                )
              })(o, s, r, 0, e, n, i)
            : s.data[o]
        Gt(c, !0)
        const u = c.mergedAttrs
        null !== u && Ee(a, l, u)
        const h = c.classes
        null !== h && Ji(a, l, h)
        const d = c.styles
        null !== d && Zi(a, l, d),
          64 != (64 & c.flags) && $i(s, r, l, c),
          0 === Ut.lFrame.elementDepthCount && Ci(l, r),
          Ut.lFrame.elementDepthCount++,
          ut(c) && (jr(s, r, c), Tr(s, c, r)),
          null !== i && Ir(r, c)
      }
      function Gs() {
        let t = Wt()
        Qt() ? Xt() : ((t = t.parent), Gt(t, !1))
        const e = t
        Ut.lFrame.elementDepthCount--
        const n = Ht()
        n.firstCreatePass && (ye(n, t), lt(t) && n.queries.elementEnd(t)),
          null != e.classesWithoutHost &&
            (function (t) {
              return 0 != (16 & t.flags)
            })(e) &&
            Ws(n, e, zt(), e.classesWithoutHost, !0),
          null != e.stylesWithoutHost &&
            (function (t) {
              return 0 != (32 & t.flags)
            })(e) &&
            Ws(n, e, zt(), e.stylesWithoutHost, !1)
      }
      function Qs(t, e, n, i) {
        $s(t, e, n, i), Gs()
      }
      function Xs(t, e, n) {
        const i = zt(),
          r = Ht(),
          s = t + rt,
          o = r.firstCreatePass
            ? (function (t, e, n, i, r) {
                const s = e.consts,
                  o = Nt(s, i),
                  a = xr(e, t, 8, 'ng-container', o)
                return (
                  null !== o && ls(a, o, !0),
                  Nr(e, n, a, Nt(s, r)),
                  null !== e.queries && e.queries.elementStart(e, a),
                  a
                )
              })(s, r, i, e, n)
            : r.data[s]
        Gt(o, !0)
        const a = (i[s] = i[11].createComment(''))
        $i(r, i, a, o),
          Ci(a, i),
          ut(o) && (jr(r, i, o), Tr(r, o, i)),
          null != n && Ir(i, o)
      }
      function Ks() {
        let t = Wt()
        const e = Ht()
        Qt() ? Xt() : ((t = t.parent), Gt(t, !1)),
          e.firstCreatePass && (ye(e, t), lt(t) && e.queries.elementEnd(t))
      }
      function Ys() {
        return zt()
      }
      function Zs(t) {
        return !!t && 'function' == typeof t.then
      }
      function Js(t) {
        return !!t && 'function' == typeof t.subscribe
      }
      function to(t, e, n = !1, i) {
        const r = zt(),
          s = Ht(),
          o = Wt()
        return no(s, r, r[11], o, t, e, n, i), to
      }
      function eo(t, e, n = !1, i) {
        const r = Wt(),
          s = zt(),
          o = Ht()
        return no(o, s, ss(ie(o.data), r, s), r, t, e, n, i), eo
      }
      function no(t, e, n, i, r, s, o = !1, a) {
        const l = ut(i),
          c = t.firstCreatePass && rs(t),
          u = is(e)
        let h = !0
        if (3 & i.type) {
          const d = jt(i, e),
            p = a ? a(d) : N,
            f = p.target || d,
            m = u.length,
            g = a ? (t) => a(At(t[i.index])).target : i.index
          if (kt(n)) {
            let o = null
            if (
              (!a &&
                l &&
                (o = (function (t, e, n, i) {
                  const r = t.cleanup
                  if (null != r)
                    for (let s = 0; s < r.length - 1; s += 2) {
                      const t = r[s]
                      if (t === n && r[s + 1] === i) {
                        const t = e[7],
                          n = r[s + 2]
                        return t.length > n ? t[n] : null
                      }
                      'string' == typeof t && (s += 2)
                    }
                  return null
                })(t, e, r, i.index)),
              null !== o)
            )
              ((o.__ngLastListenerFn__ || o).__ngNextListenerFn__ = s),
                (o.__ngLastListenerFn__ = s),
                (h = !1)
            else {
              s = ro(i, e, s, !1)
              const t = n.listen(p.name || f, r, s)
              u.push(s, t), c && c.push(r, g, m, m + 1)
            }
          } else
            (s = ro(i, e, s, !0)),
              f.addEventListener(r, s, o),
              u.push(s),
              c && c.push(r, g, m, o)
        } else s = ro(i, e, s, !1)
        const d = i.outputs
        let p
        if (h && null !== d && (p = d[r])) {
          const t = p.length
          if (t)
            for (let n = 0; n < t; n += 2) {
              const t = e[p[n]][p[n + 1]].subscribe(s),
                o = u.length
              u.push(s, t), c && c.push(r, i.index, o, -(o + 1))
            }
        }
      }
      function io(t, e, n) {
        try {
          return !1 !== e(n)
        } catch (i) {
          return os(t, i), !1
        }
      }
      function ro(t, e, n, i) {
        return function r(s) {
          if (s === Function) return n
          const o = 2 & t.flags ? Rt(t.index, e) : e
          0 == (32 & e[2]) && Zr(o)
          let a = io(e, n, s),
            l = r.__ngNextListenerFn__
          for (; l; ) (a = io(e, l, s) && a), (l = l.__ngNextListenerFn__)
          return i && !1 === a && (s.preventDefault(), (s.returnValue = !1)), a
        }
      }
      function so(t = 1) {
        return (function (t) {
          return (Ut.lFrame.contextLView = (function (t, e) {
            for (; t > 0; ) (e = e[15]), t--
            return e
          })(t, Ut.lFrame.contextLView))[8]
        })(t)
      }
      function oo(t, e) {
        let n = null
        const i = (function (t) {
          const e = t.attrs
          if (null != e) {
            const t = e.indexOf(5)
            if (0 == (1 & t)) return e[t + 1]
          }
          return null
        })(t)
        for (let r = 0; r < e.length; r++) {
          const s = e[r]
          if ('*' !== s) {
            if (null === i ? lr(t, s, !0) : cr(i, s)) return r
          } else n = r
        }
        return n
      }
      function ao(t) {
        const e = zt()[16][6]
        if (!e.projection) {
          const n = (e.projection = pn(t ? t.length : 1, null)),
            i = n.slice()
          let r = e.child
          for (; null !== r; ) {
            const e = t ? oo(r, t) : 0
            null !== e &&
              (i[e] ? (i[e].projectionNext = r) : (n[e] = r), (i[e] = r)),
              (r = r.next)
          }
        }
      }
      function lo(t, e = 0, n) {
        const i = zt(),
          r = Ht(),
          s = xr(r, rt + t, 16, null, n || null)
        null === s.projection && (s.projection = e),
          Xt(),
          64 != (64 & s.flags) &&
            (function (t, e, n) {
              Yi(e[11], 0, e, n, Vi(t, n, e), qi(n.parent || e[6], n, e))
            })(r, i, s)
      }
      const co = []
      function uo(t, e, n, i, r) {
        const s = t[n + 1],
          o = null === e
        let a = i ? gr(s) : _r(s),
          l = !1
        for (; 0 !== a && (!1 === l || o); ) {
          const n = t[a + 1]
          ho(t[a], e) && ((l = !0), (t[a + 1] = i ? vr(n) : br(n))),
            (a = i ? gr(n) : _r(n))
        }
        l && (t[n + 1] = i ? br(s) : vr(s))
      }
      function ho(t, e) {
        return (
          null === t ||
          null == e ||
          (Array.isArray(t) ? t[1] : t) === e ||
          (!(!Array.isArray(t) || 'string' != typeof e) && gn(t, e) >= 0)
        )
      }
      const po = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 }
      function fo(t) {
        return t.substring(po.key, po.keyEnd)
      }
      function mo(t, e) {
        const n = po.textEnd
        return n === e
          ? -1
          : ((e = po.keyEnd = (function (t, e, n) {
              for (; e < n && t.charCodeAt(e) > 32; ) e++
              return e
            })(t, (po.key = e), n)),
            go(t, e, n))
      }
      function go(t, e, n) {
        for (; e < n && t.charCodeAt(e) <= 32; ) e++
        return e
      }
      function bo(t, e, n) {
        return wo(t, e, n, !1), bo
      }
      function _o(t, e) {
        return wo(t, e, null, !0), _o
      }
      function yo(t) {
        Co(fn, vo, t, !0)
      }
      function vo(t, e) {
        for (
          let n = (function (t) {
            return (
              (function (t) {
                ;(po.key = 0),
                  (po.keyEnd = 0),
                  (po.value = 0),
                  (po.valueEnd = 0),
                  (po.textEnd = t.length)
              })(t),
              mo(t, go(t, 0, po.textEnd))
            )
          })(e);
          n >= 0;
          n = mo(e, n)
        )
          fn(t, fo(e), !0)
      }
      function wo(t, e, n, i) {
        const r = zt(),
          s = Ht(),
          o = te(2)
        s.firstUpdatePass && So(s, t, o, i),
          e !== dr &&
            Ms(r, o, e) &&
            Eo(
              s,
              s.data[fe()],
              r,
              r[11],
              t,
              (r[o + 1] = (function (t, e) {
                return (
                  null == t ||
                    ('string' == typeof e
                      ? (t += e)
                      : 'object' == typeof t && (t = u(Vn(t)))),
                  t
                )
              })(e, n)),
              i,
              o
            )
      }
      function Co(t, e, n, i) {
        const r = Ht(),
          s = te(2)
        r.firstUpdatePass && So(r, null, s, i)
        const o = zt()
        if (n !== dr && Ms(o, s, n)) {
          const a = r.data[fe()]
          if (jo(a, i) && !xo(r, s)) {
            let t = i ? a.classesWithoutHost : a.stylesWithoutHost
            null !== t && (n = h(t, n || '')), Ws(r, a, o, n, i)
          } else
            !(function (t, e, n, i, r, s, o, a) {
              r === dr && (r = co)
              let l = 0,
                c = 0,
                u = 0 < r.length ? r[0] : null,
                h = 0 < s.length ? s[0] : null
              for (; null !== u || null !== h; ) {
                const d = l < r.length ? r[l + 1] : void 0,
                  p = c < s.length ? s[c + 1] : void 0
                let f = null,
                  m = void 0
                u === h
                  ? ((l += 2), (c += 2), d !== p && ((f = h), (m = p)))
                  : null === h || (null !== u && u < h)
                  ? ((l += 2), (f = u))
                  : ((c += 2), (f = h), (m = p)),
                  null !== f && Eo(t, e, n, i, f, m, o, a),
                  (u = l < r.length ? r[l] : null),
                  (h = c < s.length ? s[c] : null)
              }
            })(
              r,
              a,
              o,
              o[11],
              o[s + 1],
              (o[s + 1] = (function (t, e, n) {
                if (null == n || '' === n) return co
                const i = [],
                  r = Vn(n)
                if (Array.isArray(r))
                  for (let s = 0; s < r.length; s++) t(i, r[s], !0)
                else if ('object' == typeof r)
                  for (const s in r) r.hasOwnProperty(s) && t(i, s, r[s])
                else 'string' == typeof r && e(i, r)
                return i
              })(t, e, n)),
              i,
              s
            )
        }
      }
      function xo(t, e) {
        return e >= t.expandoStartIndex
      }
      function So(t, e, n, i) {
        const r = t.data
        if (null === r[n + 1]) {
          const s = r[fe()],
            o = xo(t, n)
          jo(s, i) && null === e && !o && (e = !1),
            (e = (function (t, e, n, i) {
              const r = ie(t)
              let s = i ? e.residualClasses : e.residualStyles
              if (null === r)
                0 === (i ? e.classBindings : e.styleBindings) &&
                  ((n = ko((n = Oo(null, t, e, n, i)), e.attrs, i)), (s = null))
              else {
                const o = e.directiveStylingLast
                if (-1 === o || t[o] !== r)
                  if (((n = Oo(r, t, e, n, i)), null === s)) {
                    let n = (function (t, e, n) {
                      const i = n ? e.classBindings : e.styleBindings
                      if (0 !== _r(i)) return t[gr(i)]
                    })(t, e, i)
                    void 0 !== n &&
                      Array.isArray(n) &&
                      ((n = Oo(null, t, e, n[1], i)),
                      (n = ko(n, e.attrs, i)),
                      (function (t, e, n, i) {
                        t[gr(n ? e.classBindings : e.styleBindings)] = i
                      })(t, e, i, n))
                  } else
                    s = (function (t, e, n) {
                      let i = void 0
                      const r = e.directiveEnd
                      for (let s = 1 + e.directiveStylingLast; s < r; s++)
                        i = ko(i, t[s].hostAttrs, n)
                      return ko(i, e.attrs, n)
                    })(t, e, i)
              }
              return (
                void 0 !== s &&
                  (i ? (e.residualClasses = s) : (e.residualStyles = s)),
                n
              )
            })(r, s, e, i)),
            (function (t, e, n, i, r, s) {
              let o = s ? e.classBindings : e.styleBindings,
                a = gr(o),
                l = _r(o)
              t[i] = n
              let c,
                u = !1
              if (Array.isArray(n)) {
                const t = n
                ;(c = t[1]), (null === c || gn(t, c) > 0) && (u = !0)
              } else c = n
              if (r)
                if (0 !== l) {
                  const e = gr(t[a + 1])
                  ;(t[i + 1] = mr(e, a)),
                    0 !== e && (t[e + 1] = yr(t[e + 1], i)),
                    (t[a + 1] = (131071 & t[a + 1]) | (i << 17))
                } else
                  (t[i + 1] = mr(a, 0)),
                    0 !== a && (t[a + 1] = yr(t[a + 1], i)),
                    (a = i)
              else
                (t[i + 1] = mr(l, 0)),
                  0 === a ? (a = i) : (t[l + 1] = yr(t[l + 1], i)),
                  (l = i)
              u && (t[i + 1] = br(t[i + 1])),
                uo(t, c, i, !0),
                uo(t, c, i, !1),
                (function (t, e, n, i, r) {
                  const s = r ? t.residualClasses : t.residualStyles
                  null != s &&
                    'string' == typeof e &&
                    gn(s, e) >= 0 &&
                    (n[i + 1] = vr(n[i + 1]))
                })(e, c, t, i, s),
                (o = mr(a, l)),
                s ? (e.classBindings = o) : (e.styleBindings = o)
            })(r, s, e, n, o, i)
        }
      }
      function Oo(t, e, n, i, r) {
        let s = null
        const o = n.directiveEnd
        let a = n.directiveStylingLast
        for (
          -1 === a ? (a = n.directiveStart) : a++;
          a < o && ((s = e[a]), (i = ko(i, s.hostAttrs, r)), s !== t);

        )
          a++
        return null !== t && (n.directiveStylingLast = a), i
      }
      function ko(t, e, n) {
        const i = n ? 1 : 2
        let r = -1
        if (null !== e)
          for (let s = 0; s < e.length; s++) {
            const o = e[s]
            'number' == typeof o
              ? (r = o)
              : r === i &&
                (Array.isArray(t) || (t = void 0 === t ? [] : ['', t]),
                fn(t, o, !!n || e[++s]))
          }
        return void 0 === t ? null : t
      }
      function Eo(t, e, n, i, r, s, o, a) {
        if (!(3 & e.type)) return
        const l = t.data,
          c = l[a + 1]
        To(1 == (1 & c) ? Ao(l, e, n, r, _r(c), o) : void 0) ||
          (To(s) || (2 == (2 & c) && (s = Ao(l, null, n, r, a, o))),
          (function (t, e, n, i, r) {
            const s = kt(t)
            if (e)
              r
                ? s
                  ? t.addClass(n, i)
                  : n.classList.add(i)
                : s
                ? t.removeClass(n, i)
                : n.classList.remove(i)
            else {
              let e = -1 === i.indexOf('-') ? void 0 : Ei.DashCase
              if (null == r)
                s ? t.removeStyle(n, i, e) : n.style.removeProperty(i)
              else {
                const o = 'string' == typeof r && r.endsWith('!important')
                o && ((r = r.slice(0, -10)), (e |= Ei.Important)),
                  s
                    ? t.setStyle(n, i, r, e)
                    : n.style.setProperty(i, r, o ? 'important' : '')
              }
            }
          })(i, o, Tt(fe(), n), r, s))
      }
      function Ao(t, e, n, i, r, s) {
        const o = null === e
        let a = void 0
        for (; r > 0; ) {
          const e = t[r],
            s = Array.isArray(e),
            l = s ? e[1] : e,
            c = null === l
          let u = n[r + 1]
          u === dr && (u = c ? co : void 0)
          let h = c ? mn(u, i) : l === i ? u : void 0
          if ((s && !To(h) && (h = mn(e, i)), To(h) && ((a = h), o))) return a
          const d = t[r + 1]
          r = o ? gr(d) : _r(d)
        }
        if (null !== e) {
          let t = s ? e.residualClasses : e.residualStyles
          null != t && (a = mn(t, i))
        }
        return a
      }
      function To(t) {
        return void 0 !== t
      }
      function jo(t, e) {
        return 0 != (t.flags & (e ? 16 : 32))
      }
      function Io(t, e = '') {
        const n = zt(),
          i = Ht(),
          r = t + rt,
          s = i.firstCreatePass ? xr(i, r, 1, e, null) : i.data[r],
          o = (n[r] = (function (t, e) {
            return kt(t) ? t.createText(e) : t.createTextNode(e)
          })(n[11], e))
        $i(i, n, o, s), Gt(s, !1)
      }
      function Po(t) {
        return Ro('', t, ''), Po
      }
      function Ro(t, e, n) {
        const i = zt(),
          r = Us(i, t, e, n)
        return (
          r !== dr &&
            (function (t, e, n) {
              const i = Tt(e, t)
              !(function (t, e, n) {
                kt(t) ? t.setValue(e, n) : (e.textContent = n)
              })(t[11], i, n)
            })(i, fe(), r),
          Ro
        )
      }
      function Do(t, e, n) {
        Co(fn, vo, Us(zt(), t, e, n), !0)
      }
      function Lo(t, e, n) {
        const i = zt()
        return Ms(i, Jt(), e) && Fr(Ht(), ge(), i, t, e, i[11], n, !0), Lo
      }
      function Fo(t, e, n) {
        const i = zt()
        if (Ms(i, Jt(), e)) {
          const r = Ht(),
            s = ge()
          Fr(r, s, i, t, e, ss(ie(r.data), s, i), n, !0)
        }
        return Fo
      }
      const No = void 0
      var Mo = [
        'en',
        [['a', 'p'], ['AM', 'PM'], No],
        [['AM', 'PM'], No, No],
        [
          ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
          ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
          [
            'Sunday',
            'Monday',
            'Tuesday',
            'Wednesday',
            'Thursday',
            'Friday',
            'Saturday',
          ],
          ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
        ],
        No,
        [
          ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
          [
            'Jan',
            'Feb',
            'Mar',
            'Apr',
            'May',
            'Jun',
            'Jul',
            'Aug',
            'Sep',
            'Oct',
            'Nov',
            'Dec',
          ],
          [
            'January',
            'February',
            'March',
            'April',
            'May',
            'June',
            'July',
            'August',
            'September',
            'October',
            'November',
            'December',
          ],
        ],
        No,
        [
          ['B', 'A'],
          ['BC', 'AD'],
          ['Before Christ', 'Anno Domini'],
        ],
        0,
        [6, 0],
        ['M/d/yy', 'MMM d, y', 'MMMM d, y', 'EEEE, MMMM d, y'],
        ['h:mm a', 'h:mm:ss a', 'h:mm:ss a z', 'h:mm:ss a zzzz'],
        ['{1}, {0}', No, "{1} 'at' {0}", No],
        [
          '.',
          ',',
          ';',
          '%',
          '+',
          '-',
          'E',
          '\xd7',
          '\u2030',
          '\u221e',
          'NaN',
          ':',
        ],
        ['#,##0.###', '#,##0%', '\xa4#,##0.00', '#E0'],
        'USD',
        '$',
        'US Dollar',
        {},
        'ltr',
        function (t) {
          let e = Math.floor(Math.abs(t)),
            n = t.toString().replace(/^[^.]*\.?/, '').length
          return 1 === e && 0 === n ? 1 : 5
        },
      ]
      let Vo = {}
      function Uo(t, e, n) {
        'string' != typeof e && ((n = e), (e = t[Wo.LocaleId])),
          (e = e.toLowerCase().replace(/_/g, '-')),
          (Vo[e] = t),
          n && (Vo[e][Wo.ExtraData] = n)
      }
      function Bo(t) {
        const e = (function (t) {
          return t.toLowerCase().replace(/_/g, '-')
        })(t)
        let n = qo(e)
        if (n) return n
        const i = e.split('-')[0]
        if (((n = qo(i)), n)) return n
        if ('en' === i) return Mo
        throw new Error(`Missing locale data for the locale "${t}".`)
      }
      function zo(t) {
        return Bo(t)[Wo.CurrencyCode] || null
      }
      function Ho(t) {
        return Bo(t)[Wo.PluralCase]
      }
      function qo(t) {
        return (
          t in Vo ||
            (Vo[t] =
              F.ng &&
              F.ng.common &&
              F.ng.common.locales &&
              F.ng.common.locales[t]),
          Vo[t]
        )
      }
      var Wo = (function (t) {
        return (
          (t[(t.LocaleId = 0)] = 'LocaleId'),
          (t[(t.DayPeriodsFormat = 1)] = 'DayPeriodsFormat'),
          (t[(t.DayPeriodsStandalone = 2)] = 'DayPeriodsStandalone'),
          (t[(t.DaysFormat = 3)] = 'DaysFormat'),
          (t[(t.DaysStandalone = 4)] = 'DaysStandalone'),
          (t[(t.MonthsFormat = 5)] = 'MonthsFormat'),
          (t[(t.MonthsStandalone = 6)] = 'MonthsStandalone'),
          (t[(t.Eras = 7)] = 'Eras'),
          (t[(t.FirstDayOfWeek = 8)] = 'FirstDayOfWeek'),
          (t[(t.WeekendRange = 9)] = 'WeekendRange'),
          (t[(t.DateFormat = 10)] = 'DateFormat'),
          (t[(t.TimeFormat = 11)] = 'TimeFormat'),
          (t[(t.DateTimeFormat = 12)] = 'DateTimeFormat'),
          (t[(t.NumberSymbols = 13)] = 'NumberSymbols'),
          (t[(t.NumberFormats = 14)] = 'NumberFormats'),
          (t[(t.CurrencyCode = 15)] = 'CurrencyCode'),
          (t[(t.CurrencySymbol = 16)] = 'CurrencySymbol'),
          (t[(t.CurrencyName = 17)] = 'CurrencyName'),
          (t[(t.Currencies = 18)] = 'Currencies'),
          (t[(t.Directionality = 19)] = 'Directionality'),
          (t[(t.PluralCase = 20)] = 'PluralCase'),
          (t[(t.ExtraData = 21)] = 'ExtraData'),
          t
        )
      })({})
      const $o = 'en-US'
      let Go = $o
      function Qo(t) {
        var e, n
        ;(n = 'Expected localeId to be defined'),
          null == (e = t) &&
            (function (t, e, n, i) {
              throw new Error(
                'ASSERTION ERROR: ' + t + ` [Expected=> null != ${e} <=Actual]`
              )
            })(n, e),
          'string' == typeof t && (Go = t.toLowerCase().replace(/_/g, '-'))
      }
      function Xo(t, e, n, i, r) {
        if (((t = f(t)), Array.isArray(t)))
          for (let s = 0; s < t.length; s++) Xo(t[s], e, n, i, r)
        else {
          const s = Ht(),
            o = zt()
          let a = xs(t) ? t : f(t.provide),
            l = vs(t)
          const c = Wt(),
            u = 1048575 & c.providerIndexes,
            h = c.directiveStart,
            d = c.providerIndexes >> 20
          if (xs(t) || !t.multi) {
            const i = new ke(l, r, Hs),
              p = Zo(a, e, r ? u : u + d, h)
            ;-1 === p
              ? (ze(Me(c, o), s, a),
                Ko(s, t, e.length),
                e.push(a),
                c.directiveStart++,
                c.directiveEnd++,
                r && (c.providerIndexes += 1048576),
                n.push(i),
                o.push(i))
              : ((n[p] = i), (o[p] = i))
          } else {
            const p = Zo(a, e, u + d, h),
              f = Zo(a, e, u, u + d),
              m = p >= 0 && n[p],
              g = f >= 0 && n[f]
            if ((r && !g) || (!r && !m)) {
              ze(Me(c, o), s, a)
              const u = (function (t, e, n, i, r) {
                const s = new ke(t, n, Hs)
                return (
                  (s.multi = []),
                  (s.index = e),
                  (s.componentProviders = 0),
                  Yo(s, r, i && !n),
                  s
                )
              })(r ? ta : Jo, n.length, r, i, l)
              !r && g && (n[f].providerFactory = u),
                Ko(s, t, e.length, 0),
                e.push(a),
                c.directiveStart++,
                c.directiveEnd++,
                r && (c.providerIndexes += 1048576),
                n.push(u),
                o.push(u)
            } else Ko(s, t, p > -1 ? p : f, Yo(n[r ? f : p], l, !r && i))
            !r && i && g && n[f].componentProviders++
          }
        }
      }
      function Ko(t, e, n, i) {
        const r = xs(e)
        if (r || e.useClass) {
          const s = (e.useClass || e).prototype.ngOnDestroy
          if (s) {
            const o = t.destroyHooks || (t.destroyHooks = [])
            if (!r && e.multi) {
              const t = o.indexOf(n)
              ;-1 === t ? o.push(n, [i, s]) : o[t + 1].push(i, s)
            } else o.push(n, s)
          }
        }
      }
      function Yo(t, e, n) {
        return n && t.componentProviders++, t.multi.push(e) - 1
      }
      function Zo(t, e, n, i) {
        for (let r = n; r < i; r++) if (e[r] === t) return r
        return -1
      }
      function Jo(t, e, n, i) {
        return ea(this.multi, [])
      }
      function ta(t, e, n, i) {
        const r = this.multi
        let s
        if (this.providerFactory) {
          const t = this.providerFactory.componentProviders,
            e = Ke(n, n[1], this.providerFactory.index, i)
          ;(s = e.slice(0, t)), ea(r, s)
          for (let n = t; n < e.length; n++) s.push(e[n])
        } else (s = []), ea(r, s)
        return s
      }
      function ea(t, e) {
        for (let n = 0; n < t.length; n++) e.push((0, t[n])())
        return e
      }
      function na(t, e = []) {
        return (n) => {
          n.providersResolver = (n, i) =>
            (function (t, e, n) {
              const i = Ht()
              if (i.firstCreatePass) {
                const r = ht(t)
                Xo(n, i.data, i.blueprint, r, !0),
                  Xo(e, i.data, i.blueprint, r, !1)
              }
            })(n, i ? i(t) : t, e)
        }
      }
      class ia {}
      class ra {
        resolveComponentFactory(t) {
          throw (function (t) {
            const e = Error(
              `No component factory found for ${u(
                t
              )}. Did you add it to @NgModule.entryComponents?`
            )
            return (e.ngComponent = t), e
          })(t)
        }
      }
      let sa = (() => {
        class t {}
        return (t.NULL = new ra()), t
      })()
      function oa(...t) {}
      function aa(t, e) {
        return new ca(jt(t, e))
      }
      const la = function () {
        return aa(Wt(), zt())
      }
      let ca = (() => {
        class t {
          constructor(t) {
            this.nativeElement = t
          }
        }
        return (t.__NG_ELEMENT_ID__ = la), t
      })()
      class ua {}
      let ha = (() => {
        class t {}
        return (t.__NG_ELEMENT_ID__ = () => da()), t
      })()
      const da = function () {
        const t = zt(),
          e = Rt(Wt().index, t)
        return (function (t) {
          return t[11]
        })(ot(e) ? e : t)
      }
      let pa = (() => {
        class t {}
        return (
          (t.ɵprov = g({ token: t, providedIn: 'root', factory: () => null })),
          t
        )
      })()
      class fa {
        constructor(t) {
          ;(this.full = t),
            (this.major = t.split('.')[0]),
            (this.minor = t.split('.')[1]),
            (this.patch = t.split('.').slice(2).join('.'))
        }
      }
      const ma = new fa('11.0.5')
      class ga {
        constructor() {}
        supports(t) {
          return Ls(t)
        }
        create(t) {
          return new _a(t)
        }
      }
      const ba = (t, e) => e
      class _a {
        constructor(t) {
          ;(this.length = 0),
            (this._linkedRecords = null),
            (this._unlinkedRecords = null),
            (this._previousItHead = null),
            (this._itHead = null),
            (this._itTail = null),
            (this._additionsHead = null),
            (this._additionsTail = null),
            (this._movesHead = null),
            (this._movesTail = null),
            (this._removalsHead = null),
            (this._removalsTail = null),
            (this._identityChangesHead = null),
            (this._identityChangesTail = null),
            (this._trackByFn = t || ba)
        }
        forEachItem(t) {
          let e
          for (e = this._itHead; null !== e; e = e._next) t(e)
        }
        forEachOperation(t) {
          let e = this._itHead,
            n = this._removalsHead,
            i = 0,
            r = null
          for (; e || n; ) {
            const s = !n || (e && e.currentIndex < Ca(n, i, r)) ? e : n,
              o = Ca(s, i, r),
              a = s.currentIndex
            if (s === n) i--, (n = n._nextRemoved)
            else if (((e = e._next), null == s.previousIndex)) i++
            else {
              r || (r = [])
              const t = o - i,
                e = a - i
              if (t != e) {
                for (let n = 0; n < t; n++) {
                  const i = n < r.length ? r[n] : (r[n] = 0),
                    s = i + n
                  e <= s && s < t && (r[n] = i + 1)
                }
                r[s.previousIndex] = e - t
              }
            }
            o !== a && t(s, o, a)
          }
        }
        forEachPreviousItem(t) {
          let e
          for (e = this._previousItHead; null !== e; e = e._nextPrevious) t(e)
        }
        forEachAddedItem(t) {
          let e
          for (e = this._additionsHead; null !== e; e = e._nextAdded) t(e)
        }
        forEachMovedItem(t) {
          let e
          for (e = this._movesHead; null !== e; e = e._nextMoved) t(e)
        }
        forEachRemovedItem(t) {
          let e
          for (e = this._removalsHead; null !== e; e = e._nextRemoved) t(e)
        }
        forEachIdentityChange(t) {
          let e
          for (
            e = this._identityChangesHead;
            null !== e;
            e = e._nextIdentityChange
          )
            t(e)
        }
        diff(t) {
          if ((null == t && (t = []), !Ls(t)))
            throw new Error(
              `Error trying to diff '${u(
                t
              )}'. Only arrays and iterables are allowed`
            )
          return this.check(t) ? this : null
        }
        onDestroy() {}
        check(t) {
          this._reset()
          let e,
            n,
            i,
            r = this._itHead,
            s = !1
          if (Array.isArray(t)) {
            this.length = t.length
            for (let e = 0; e < this.length; e++)
              (n = t[e]),
                (i = this._trackByFn(e, n)),
                null !== r && Object.is(r.trackById, i)
                  ? (s && (r = this._verifyReinsertion(r, n, i, e)),
                    Object.is(r.item, n) || this._addIdentityChange(r, n))
                  : ((r = this._mismatch(r, n, i, e)), (s = !0)),
                (r = r._next)
          } else
            (e = 0),
              (function (t, e) {
                if (Array.isArray(t)) for (let n = 0; n < t.length; n++) e(t[n])
                else {
                  const n = t[Rs()]()
                  let i
                  for (; !(i = n.next()).done; ) e(i.value)
                }
              })(t, (t) => {
                ;(i = this._trackByFn(e, t)),
                  null !== r && Object.is(r.trackById, i)
                    ? (s && (r = this._verifyReinsertion(r, t, i, e)),
                      Object.is(r.item, t) || this._addIdentityChange(r, t))
                    : ((r = this._mismatch(r, t, i, e)), (s = !0)),
                  (r = r._next),
                  e++
              }),
              (this.length = e)
          return this._truncate(r), (this.collection = t), this.isDirty
        }
        get isDirty() {
          return (
            null !== this._additionsHead ||
            null !== this._movesHead ||
            null !== this._removalsHead ||
            null !== this._identityChangesHead
          )
        }
        _reset() {
          if (this.isDirty) {
            let t
            for (
              t = this._previousItHead = this._itHead;
              null !== t;
              t = t._next
            )
              t._nextPrevious = t._next
            for (t = this._additionsHead; null !== t; t = t._nextAdded)
              t.previousIndex = t.currentIndex
            for (
              this._additionsHead = this._additionsTail = null,
                t = this._movesHead;
              null !== t;
              t = t._nextMoved
            )
              t.previousIndex = t.currentIndex
            ;(this._movesHead = this._movesTail = null),
              (this._removalsHead = this._removalsTail = null),
              (this._identityChangesHead = this._identityChangesTail = null)
          }
        }
        _mismatch(t, e, n, i) {
          let r
          return (
            null === t ? (r = this._itTail) : ((r = t._prev), this._remove(t)),
            null !==
            (t =
              null === this._linkedRecords
                ? null
                : this._linkedRecords.get(n, i))
              ? (Object.is(t.item, e) || this._addIdentityChange(t, e),
                this._moveAfter(t, r, i))
              : null !==
                (t =
                  null === this._unlinkedRecords
                    ? null
                    : this._unlinkedRecords.get(n, null))
              ? (Object.is(t.item, e) || this._addIdentityChange(t, e),
                this._reinsertAfter(t, r, i))
              : (t = this._addAfter(new ya(e, n), r, i)),
            t
          )
        }
        _verifyReinsertion(t, e, n, i) {
          let r =
            null === this._unlinkedRecords
              ? null
              : this._unlinkedRecords.get(n, null)
          return (
            null !== r
              ? (t = this._reinsertAfter(r, t._prev, i))
              : t.currentIndex != i &&
                ((t.currentIndex = i), this._addToMoves(t, i)),
            t
          )
        }
        _truncate(t) {
          for (; null !== t; ) {
            const e = t._next
            this._addToRemovals(this._unlink(t)), (t = e)
          }
          null !== this._unlinkedRecords && this._unlinkedRecords.clear(),
            null !== this._additionsTail &&
              (this._additionsTail._nextAdded = null),
            null !== this._movesTail && (this._movesTail._nextMoved = null),
            null !== this._itTail && (this._itTail._next = null),
            null !== this._removalsTail &&
              (this._removalsTail._nextRemoved = null),
            null !== this._identityChangesTail &&
              (this._identityChangesTail._nextIdentityChange = null)
        }
        _reinsertAfter(t, e, n) {
          null !== this._unlinkedRecords && this._unlinkedRecords.remove(t)
          const i = t._prevRemoved,
            r = t._nextRemoved
          return (
            null === i ? (this._removalsHead = r) : (i._nextRemoved = r),
            null === r ? (this._removalsTail = i) : (r._prevRemoved = i),
            this._insertAfter(t, e, n),
            this._addToMoves(t, n),
            t
          )
        }
        _moveAfter(t, e, n) {
          return (
            this._unlink(t),
            this._insertAfter(t, e, n),
            this._addToMoves(t, n),
            t
          )
        }
        _addAfter(t, e, n) {
          return (
            this._insertAfter(t, e, n),
            (this._additionsTail =
              null === this._additionsTail
                ? (this._additionsHead = t)
                : (this._additionsTail._nextAdded = t)),
            t
          )
        }
        _insertAfter(t, e, n) {
          const i = null === e ? this._itHead : e._next
          return (
            (t._next = i),
            (t._prev = e),
            null === i ? (this._itTail = t) : (i._prev = t),
            null === e ? (this._itHead = t) : (e._next = t),
            null === this._linkedRecords && (this._linkedRecords = new wa()),
            this._linkedRecords.put(t),
            (t.currentIndex = n),
            t
          )
        }
        _remove(t) {
          return this._addToRemovals(this._unlink(t))
        }
        _unlink(t) {
          null !== this._linkedRecords && this._linkedRecords.remove(t)
          const e = t._prev,
            n = t._next
          return (
            null === e ? (this._itHead = n) : (e._next = n),
            null === n ? (this._itTail = e) : (n._prev = e),
            t
          )
        }
        _addToMoves(t, e) {
          return (
            t.previousIndex === e ||
              (this._movesTail =
                null === this._movesTail
                  ? (this._movesHead = t)
                  : (this._movesTail._nextMoved = t)),
            t
          )
        }
        _addToRemovals(t) {
          return (
            null === this._unlinkedRecords &&
              (this._unlinkedRecords = new wa()),
            this._unlinkedRecords.put(t),
            (t.currentIndex = null),
            (t._nextRemoved = null),
            null === this._removalsTail
              ? ((this._removalsTail = this._removalsHead = t),
                (t._prevRemoved = null))
              : ((t._prevRemoved = this._removalsTail),
                (this._removalsTail = this._removalsTail._nextRemoved = t)),
            t
          )
        }
        _addIdentityChange(t, e) {
          return (
            (t.item = e),
            (this._identityChangesTail =
              null === this._identityChangesTail
                ? (this._identityChangesHead = t)
                : (this._identityChangesTail._nextIdentityChange = t)),
            t
          )
        }
      }
      class ya {
        constructor(t, e) {
          ;(this.item = t),
            (this.trackById = e),
            (this.currentIndex = null),
            (this.previousIndex = null),
            (this._nextPrevious = null),
            (this._prev = null),
            (this._next = null),
            (this._prevDup = null),
            (this._nextDup = null),
            (this._prevRemoved = null),
            (this._nextRemoved = null),
            (this._nextAdded = null),
            (this._nextMoved = null),
            (this._nextIdentityChange = null)
        }
      }
      class va {
        constructor() {
          ;(this._head = null), (this._tail = null)
        }
        add(t) {
          null === this._head
            ? ((this._head = this._tail = t),
              (t._nextDup = null),
              (t._prevDup = null))
            : ((this._tail._nextDup = t),
              (t._prevDup = this._tail),
              (t._nextDup = null),
              (this._tail = t))
        }
        get(t, e) {
          let n
          for (n = this._head; null !== n; n = n._nextDup)
            if (
              (null === e || e <= n.currentIndex) &&
              Object.is(n.trackById, t)
            )
              return n
          return null
        }
        remove(t) {
          const e = t._prevDup,
            n = t._nextDup
          return (
            null === e ? (this._head = n) : (e._nextDup = n),
            null === n ? (this._tail = e) : (n._prevDup = e),
            null === this._head
          )
        }
      }
      class wa {
        constructor() {
          this.map = new Map()
        }
        put(t) {
          const e = t.trackById
          let n = this.map.get(e)
          n || ((n = new va()), this.map.set(e, n)), n.add(t)
        }
        get(t, e) {
          const n = this.map.get(t)
          return n ? n.get(t, e) : null
        }
        remove(t) {
          const e = t.trackById
          return this.map.get(e).remove(t) && this.map.delete(e), t
        }
        get isEmpty() {
          return 0 === this.map.size
        }
        clear() {
          this.map.clear()
        }
      }
      function Ca(t, e, n) {
        const i = t.previousIndex
        if (null === i) return i
        let r = 0
        return n && i < n.length && (r = n[i]), i + e + r
      }
      class xa {
        constructor() {}
        supports(t) {
          return t instanceof Map || Fs(t)
        }
        create() {
          return new Sa()
        }
      }
      class Sa {
        constructor() {
          ;(this._records = new Map()),
            (this._mapHead = null),
            (this._appendAfter = null),
            (this._previousMapHead = null),
            (this._changesHead = null),
            (this._changesTail = null),
            (this._additionsHead = null),
            (this._additionsTail = null),
            (this._removalsHead = null),
            (this._removalsTail = null)
        }
        get isDirty() {
          return (
            null !== this._additionsHead ||
            null !== this._changesHead ||
            null !== this._removalsHead
          )
        }
        forEachItem(t) {
          let e
          for (e = this._mapHead; null !== e; e = e._next) t(e)
        }
        forEachPreviousItem(t) {
          let e
          for (e = this._previousMapHead; null !== e; e = e._nextPrevious) t(e)
        }
        forEachChangedItem(t) {
          let e
          for (e = this._changesHead; null !== e; e = e._nextChanged) t(e)
        }
        forEachAddedItem(t) {
          let e
          for (e = this._additionsHead; null !== e; e = e._nextAdded) t(e)
        }
        forEachRemovedItem(t) {
          let e
          for (e = this._removalsHead; null !== e; e = e._nextRemoved) t(e)
        }
        diff(t) {
          if (t) {
            if (!(t instanceof Map || Fs(t)))
              throw new Error(
                `Error trying to diff '${u(
                  t
                )}'. Only maps and objects are allowed`
              )
          } else t = new Map()
          return this.check(t) ? this : null
        }
        onDestroy() {}
        check(t) {
          this._reset()
          let e = this._mapHead
          if (
            ((this._appendAfter = null),
            this._forEach(t, (t, n) => {
              if (e && e.key === n)
                this._maybeAddToChanges(e, t),
                  (this._appendAfter = e),
                  (e = e._next)
              else {
                const i = this._getOrCreateRecordForKey(n, t)
                e = this._insertBeforeOrAppend(e, i)
              }
            }),
            e)
          ) {
            e._prev && (e._prev._next = null), (this._removalsHead = e)
            for (let t = e; null !== t; t = t._nextRemoved)
              t === this._mapHead && (this._mapHead = null),
                this._records.delete(t.key),
                (t._nextRemoved = t._next),
                (t.previousValue = t.currentValue),
                (t.currentValue = null),
                (t._prev = null),
                (t._next = null)
          }
          return (
            this._changesTail && (this._changesTail._nextChanged = null),
            this._additionsTail && (this._additionsTail._nextAdded = null),
            this.isDirty
          )
        }
        _insertBeforeOrAppend(t, e) {
          if (t) {
            const n = t._prev
            return (
              (e._next = t),
              (e._prev = n),
              (t._prev = e),
              n && (n._next = e),
              t === this._mapHead && (this._mapHead = e),
              (this._appendAfter = t),
              t
            )
          }
          return (
            this._appendAfter
              ? ((this._appendAfter._next = e), (e._prev = this._appendAfter))
              : (this._mapHead = e),
            (this._appendAfter = e),
            null
          )
        }
        _getOrCreateRecordForKey(t, e) {
          if (this._records.has(t)) {
            const n = this._records.get(t)
            this._maybeAddToChanges(n, e)
            const i = n._prev,
              r = n._next
            return (
              i && (i._next = r),
              r && (r._prev = i),
              (n._next = null),
              (n._prev = null),
              n
            )
          }
          const n = new Oa(t)
          return (
            this._records.set(t, n),
            (n.currentValue = e),
            this._addToAdditions(n),
            n
          )
        }
        _reset() {
          if (this.isDirty) {
            let t
            for (
              this._previousMapHead = this._mapHead, t = this._previousMapHead;
              null !== t;
              t = t._next
            )
              t._nextPrevious = t._next
            for (t = this._changesHead; null !== t; t = t._nextChanged)
              t.previousValue = t.currentValue
            for (t = this._additionsHead; null != t; t = t._nextAdded)
              t.previousValue = t.currentValue
            ;(this._changesHead = this._changesTail = null),
              (this._additionsHead = this._additionsTail = null),
              (this._removalsHead = null)
          }
        }
        _maybeAddToChanges(t, e) {
          Object.is(e, t.currentValue) ||
            ((t.previousValue = t.currentValue),
            (t.currentValue = e),
            this._addToChanges(t))
        }
        _addToAdditions(t) {
          null === this._additionsHead
            ? (this._additionsHead = this._additionsTail = t)
            : ((this._additionsTail._nextAdded = t), (this._additionsTail = t))
        }
        _addToChanges(t) {
          null === this._changesHead
            ? (this._changesHead = this._changesTail = t)
            : ((this._changesTail._nextChanged = t), (this._changesTail = t))
        }
        _forEach(t, e) {
          t instanceof Map
            ? t.forEach(e)
            : Object.keys(t).forEach((n) => e(t[n], n))
        }
      }
      class Oa {
        constructor(t) {
          ;(this.key = t),
            (this.previousValue = null),
            (this.currentValue = null),
            (this._nextPrevious = null),
            (this._next = null),
            (this._prev = null),
            (this._nextAdded = null),
            (this._nextRemoved = null),
            (this._nextChanged = null)
        }
      }
      let ka = (() => {
          class t {
            constructor(t) {
              this.factories = t
            }
            static create(e, n) {
              if (null != n) {
                const t = n.factories.slice()
                e = e.concat(t)
              }
              return new t(e)
            }
            static extend(e) {
              return {
                provide: t,
                useFactory: (n) => {
                  if (!n)
                    throw new Error(
                      'Cannot extend IterableDiffers without a parent injector'
                    )
                  return t.create(e, n)
                },
                deps: [[t, new vn(), new _n()]],
              }
            }
            find(t) {
              const e = this.factories.find((e) => e.supports(t))
              if (null != e) return e
              throw new Error(
                `Cannot find a differ supporting object '${t}' of type '${
                  ((n = t), n.name || typeof n)
                }'`
              )
              var n
            }
          }
          return (
            (t.ɵprov = g({
              token: t,
              providedIn: 'root',
              factory: () => new t([new ga()]),
            })),
            t
          )
        })(),
        Ea = (() => {
          class t {
            constructor(t) {
              this.factories = t
            }
            static create(e, n) {
              if (n) {
                const t = n.factories.slice()
                e = e.concat(t)
              }
              return new t(e)
            }
            static extend(e) {
              return {
                provide: t,
                useFactory: (n) => {
                  if (!n)
                    throw new Error(
                      'Cannot extend KeyValueDiffers without a parent injector'
                    )
                  return t.create(e, n)
                },
                deps: [[t, new vn(), new _n()]],
              }
            }
            find(t) {
              const e = this.factories.find((e) => e.supports(t))
              if (e) return e
              throw new Error(`Cannot find a differ supporting object '${t}'`)
            }
          }
          return (
            (t.ɵprov = g({
              token: t,
              providedIn: 'root',
              factory: () => new t([new xa()]),
            })),
            t
          )
        })()
      function Aa(t, e, n, i, r = !1) {
        for (; null !== n; ) {
          const s = e[n.index]
          if ((null !== s && i.push(At(s)), at(s)))
            for (let t = st; t < s.length; t++) {
              const e = s[t],
                n = e[1].firstChild
              null !== n && Aa(e[1], e, n, i)
            }
          const o = n.type
          if (8 & o) Aa(t, e, n.child, i)
          else if (32 & o) {
            const t = Ai(n, e)
            let r
            for (; (r = t()); ) i.push(r)
          } else if (16 & o) {
            const t = e[16],
              r = t[6].projection[n.projection]
            if (Array.isArray(r)) i.push(...r)
            else {
              const e = Ti(t)
              Aa(e[1], e, r, i, !0)
            }
          }
          n = r ? n.projectionNext : n.next
        }
        return i
      }
      class Ta {
        constructor(t, e) {
          ;(this._lView = t),
            (this._cdRefInjectingView = e),
            (this._appRef = null),
            (this._viewContainerRef = null)
        }
        get rootNodes() {
          const t = this._lView,
            e = t[1]
          return Aa(e, t, e.firstChild, [])
        }
        get context() {
          return this._lView[8]
        }
        get destroyed() {
          return 256 == (256 & this._lView[2])
        }
        destroy() {
          if (this._appRef) this._appRef.detachView(this)
          else if (this._viewContainerRef) {
            const t = this._viewContainerRef.indexOf(this)
            t > -1 && this._viewContainerRef.detach(t),
              (this._viewContainerRef = null)
          }
          Ni(this._lView[1], this._lView)
        }
        onDestroy(t) {
          Dr(this._lView[1], this._lView, null, t)
        }
        markForCheck() {
          Zr(this._cdRefInjectingView || this._lView)
        }
        detach() {
          this._lView[2] &= -129
        }
        reattach() {
          this._lView[2] |= 128
        }
        detectChanges() {
          Jr(this._lView[1], this._lView, this.context)
        }
        checkNoChanges() {
          !(function (t, e, n) {
            Yt(!0)
            try {
              Jr(t, e, n)
            } finally {
              Yt(!1)
            }
          })(this._lView[1], this._lView, this.context)
        }
        attachToViewContainerRef(t) {
          if (this._appRef)
            throw new Error(
              'This view is already attached directly to the ApplicationRef!'
            )
          this._viewContainerRef = t
        }
        detachFromAppRef() {
          var t
          ;(this._appRef = null),
            Ki(this._lView[1], (t = this._lView), t[11], 2, null, null)
        }
        attachToAppRef(t) {
          if (this._viewContainerRef)
            throw new Error('This view is already attached to a ViewContainer!')
          this._appRef = t
        }
      }
      class ja extends Ta {
        constructor(t) {
          super(t), (this._view = t)
        }
        detectChanges() {
          ts(this._view)
        }
        checkNoChanges() {
          !(function (t) {
            Yt(!0)
            try {
              ts(t)
            } finally {
              Yt(!1)
            }
          })(this._view)
        }
        get context() {
          return null
        }
      }
      const Ia = Ra
      let Pa = (() => {
        class t {}
        return (t.__NG_ELEMENT_ID__ = Ia), (t.__ChangeDetectorRef__ = !0), t
      })()
      function Ra(t = !1) {
        return (function (t, e, n) {
          if (!n && ct(t)) {
            const n = Rt(t.index, e)
            return new Ta(n, n)
          }
          return 47 & t.type ? new Ta(e[16], e) : null
        })(Wt(), zt(), t)
      }
      const Da = [new xa()],
        La = new ka([new ga()]),
        Fa = new Ea(Da),
        Na = function () {
          return Ba(Wt(), zt())
        }
      let Ma = (() => {
        class t {}
        return (t.__NG_ELEMENT_ID__ = Na), t
      })()
      const Va = Ma,
        Ua = class extends Va {
          constructor(t, e, n) {
            super(),
              (this._declarationLView = t),
              (this._declarationTContainer = e),
              (this.elementRef = n)
          }
          createEmbeddedView(t) {
            const e = this._declarationTContainer.tViews,
              n = Cr(
                this._declarationLView,
                e,
                t,
                16,
                null,
                e.declTNode,
                null,
                null,
                null,
                null
              )
            n[17] = this._declarationLView[this._declarationTContainer.index]
            const i = this._declarationLView[19]
            return (
              null !== i && (n[19] = i.createEmbeddedView(e)),
              Or(e, n, t),
              new Ta(n)
            )
          }
        }
      function Ba(t, e) {
        return 4 & t.type ? new Ua(e, t, aa(t, e)) : null
      }
      class za {}
      class Ha {}
      const qa = function () {
        return Ka(Wt(), zt())
      }
      let Wa = (() => {
        class t {}
        return (t.__NG_ELEMENT_ID__ = qa), t
      })()
      const $a = Wa,
        Ga = class extends $a {
          constructor(t, e, n) {
            super(),
              (this._lContainer = t),
              (this._hostTNode = e),
              (this._hostLView = n)
          }
          get element() {
            return aa(this._hostTNode, this._hostLView)
          }
          get injector() {
            return new Je(this._hostTNode, this._hostLView)
          }
          get parentInjector() {
            const t = Be(this._hostTNode, this._hostLView)
            if (Pe(t)) {
              const e = De(t, this._hostLView),
                n = Re(t)
              return new Je(e[1].data[n + 8], e)
            }
            return new Je(null, this._hostLView)
          }
          clear() {
            for (; this.length > 0; ) this.remove(this.length - 1)
          }
          get(t) {
            const e = Qa(this._lContainer)
            return (null !== e && e[t]) || null
          }
          get length() {
            return this._lContainer.length - st
          }
          createEmbeddedView(t, e, n) {
            const i = t.createEmbeddedView(e || {})
            return this.insert(i, n), i
          }
          createComponent(t, e, n, i, r) {
            const s = n || this.parentInjector
            if (!r && null == t.ngModule && s) {
              const t = s.get(za, null)
              t && (r = t)
            }
            const o = t.create(s, i, void 0, r)
            return this.insert(o.hostView, e), o
          }
          insert(t, e) {
            const n = t._lView,
              i = n[1]
            if (at(n[3])) {
              const e = this.indexOf(t)
              if (-1 !== e) this.detach(e)
              else {
                const e = n[3],
                  i = new Ga(e, e[6], e[3])
                i.detach(i.indexOf(t))
              }
            }
            const r = this._adjustIndex(e),
              s = this._lContainer
            !(function (t, e, n, i) {
              const r = st + i,
                s = n.length
              i > 0 && (n[r - 1][4] = e),
                i < s - st
                  ? ((e[4] = n[r]), hn(n, st + i, e))
                  : (n.push(e), (e[4] = null)),
                (e[3] = n)
              const o = e[17]
              null !== o &&
                n !== o &&
                (function (t, e) {
                  const n = t[9]
                  e[16] !== e[3][3][16] && (t[2] = !0),
                    null === n ? (t[9] = [e]) : n.push(e)
                })(o, e)
              const a = e[19]
              null !== a && a.insertView(t), (e[2] |= 128)
            })(i, n, s, r)
            const o = Qi(r, s),
              a = n[11],
              l = Hi(a, s[7])
            return (
              null !== l &&
                (function (t, e, n, i, r, s) {
                  ;(i[0] = r), (i[6] = e), Ki(t, i, n, 1, r, s)
                })(i, s[6], a, n, l, o),
              t.attachToViewContainerRef(this),
              hn(Xa(s), r, t),
              t
            )
          }
          move(t, e) {
            return this.insert(t, e)
          }
          indexOf(t) {
            const e = Qa(this._lContainer)
            return null !== e ? e.indexOf(t) : -1
          }
          remove(t) {
            const e = this._adjustIndex(t, -1),
              n = Fi(this._lContainer, e)
            n && (dn(Xa(this._lContainer), e), Ni(n[1], n))
          }
          detach(t) {
            const e = this._adjustIndex(t, -1),
              n = Fi(this._lContainer, e)
            return n && null != dn(Xa(this._lContainer), e) ? new Ta(n) : null
          }
          _adjustIndex(t, e = 0) {
            return null == t ? this.length + e : t
          }
        }
      function Qa(t) {
        return t[8]
      }
      function Xa(t) {
        return t[8] || (t[8] = [])
      }
      function Ka(t, e) {
        let n
        const i = e[t.index]
        if (at(i)) n = i
        else {
          let r
          if (8 & t.type) r = At(i)
          else {
            const n = e[11]
            r = n.createComment('')
            const i = jt(t, e)
            Ui(
              n,
              Hi(n, i),
              r,
              (function (t, e) {
                return kt(t) ? t.nextSibling(e) : e.nextSibling
              })(n, i),
              !1
            )
          }
          ;(e[t.index] = n = Gr(i, e, r, t)), Yr(e, n)
        }
        return new Ga(n, t, e)
      }
      const Ya = {}
      class Za extends sa {
        constructor(t) {
          super(), (this.ngModule = t)
        }
        resolveComponentFactory(t) {
          const e = nt(t)
          return new el(e, this.ngModule)
        }
      }
      function Ja(t) {
        const e = []
        for (let n in t)
          t.hasOwnProperty(n) && e.push({ propName: t[n], templateName: n })
        return e
      }
      const tl = new on('SCHEDULER_TOKEN', {
        providedIn: 'root',
        factory: () => xi,
      })
      class el extends ia {
        constructor(t, e) {
          super(),
            (this.componentDef = t),
            (this.ngModule = e),
            (this.componentType = t.type),
            (this.selector = t.selectors.map(hr).join(',')),
            (this.ngContentSelectors = t.ngContentSelectors
              ? t.ngContentSelectors
              : []),
            (this.isBoundToModule = !!e)
        }
        get inputs() {
          return Ja(this.componentDef.inputs)
        }
        get outputs() {
          return Ja(this.componentDef.outputs)
        }
        create(t, e, n, i) {
          const r = (i = i || this.ngModule)
              ? (function (t, e) {
                  return {
                    get: (n, i, r) => {
                      const s = t.get(n, Ya, r)
                      return s !== Ya || i === Ya ? s : e.get(n, i, r)
                    },
                  }
                })(t, i.injector)
              : t,
            s = r.get(ua, Et),
            o = r.get(pa, null),
            a = s.createRenderer(null, this.componentDef),
            l = this.componentDef.selectors[0][0] || 'div',
            c = n
              ? (function (t, e, n) {
                  if (kt(t)) return t.selectRootElement(e, n === I.ShadowDom)
                  let i = 'string' == typeof e ? t.querySelector(e) : e
                  return (i.textContent = ''), i
                })(a, n, this.componentDef.encapsulation)
              : Di(
                  s.createRenderer(null, this.componentDef),
                  l,
                  (function (t) {
                    const e = t.toLowerCase()
                    return 'svg' === e
                      ? xt
                      : 'math' === e
                      ? 'http://www.w3.org/1998/MathML/'
                      : null
                  })(l)
                ),
            u = this.componentDef.onPush ? 576 : 528,
            h = {
              components: [],
              scheduler: xi,
              clean: ns,
              playerHandler: null,
              flags: 0,
            },
            d = Rr(0, null, null, 1, 0, null, null, null, null, null),
            p = Cr(null, d, h, u, null, null, s, a, o, r)
          let f, m
          le(p)
          try {
            const t = (function (t, e, n, i, r, s) {
              const o = n[1]
              n[20] = t
              const a = xr(o, 20, 2, '#host', null),
                l = (a.mergedAttrs = e.hostAttrs)
              null !== l &&
                (ls(a, l, !0),
                null !== t &&
                  (Ee(r, t, l),
                  null !== a.classes && Ji(r, t, a.classes),
                  null !== a.styles && Zi(r, t, a.styles)))
              const c = i.createRenderer(t, e),
                u = Cr(
                  n,
                  Pr(e),
                  null,
                  e.onPush ? 64 : 16,
                  n[20],
                  a,
                  i,
                  c,
                  null,
                  null
                )
              return (
                o.firstCreatePass &&
                  (ze(Me(a, n), o, e.type), Ur(o, a), zr(a, n.length, 1)),
                Yr(n, u),
                (n[20] = u)
              )
            })(c, this.componentDef, p, s, a)
            if (c)
              if (n) Ee(a, c, ['ng-version', ma.full])
              else {
                const { attrs: t, classes: e } = (function (t) {
                  const e = [],
                    n = []
                  let i = 1,
                    r = 2
                  for (; i < t.length; ) {
                    let s = t[i]
                    if ('string' == typeof s)
                      2 === r
                        ? '' !== s && e.push(s, t[++i])
                        : 8 === r && n.push(s)
                    else {
                      if (!or(r)) break
                      r = s
                    }
                    i++
                  }
                  return { attrs: e, classes: n }
                })(this.componentDef.selectors[0])
                t && Ee(a, c, t), e && e.length > 0 && Ji(a, c, e.join(' '))
              }
            if (((m = It(d, rt)), void 0 !== e)) {
              const t = (m.projection = [])
              for (let n = 0; n < this.ngContentSelectors.length; n++) {
                const i = e[n]
                t.push(null != i ? Array.from(i) : null)
              }
            }
            ;(f = (function (t, e, n, i, r) {
              const s = n[1],
                o = (function (t, e, n) {
                  const i = Wt()
                  t.firstCreatePass &&
                    (n.providersResolver && n.providersResolver(n),
                    Hr(t, i, e, Sr(t, e, 1, null), n))
                  const r = Ke(e, t, i.directiveStart, i)
                  Ci(r, e)
                  const s = jt(i, e)
                  return s && Ci(s, e), r
                })(s, n, e)
              if (
                (i.components.push(o),
                (t[8] = o),
                r && r.forEach((t) => t(o, e)),
                e.contentQueries)
              ) {
                const t = Wt()
                e.contentQueries(1, o, t.directiveStart)
              }
              const a = Wt()
              return (
                !s.firstCreatePass ||
                  (null === e.hostBindings && null === e.hostAttrs) ||
                  (me(a.index),
                  Mr(n[1], a, 0, a.directiveStart, a.directiveEnd, e),
                  Vr(e, o)),
                o
              )
            })(t, this.componentDef, p, h, [ks])),
              Or(d, p, null)
          } finally {
            pe()
          }
          return new nl(this.componentType, f, aa(m, p), p, m)
        }
      }
      class nl extends class {} {
        constructor(t, e, n, i, r) {
          super(),
            (this.location = n),
            (this._rootLView = i),
            (this._tNode = r),
            (this.instance = e),
            (this.hostView = this.changeDetectorRef = new ja(i)),
            (this.componentType = t)
        }
        get injector() {
          return new Je(this._tNode, this._rootLView)
        }
        destroy() {
          this.hostView.destroy()
        }
        onDestroy(t) {
          this.hostView.onDestroy(t)
        }
      }
      const il = new Map()
      class rl extends za {
        constructor(t, e) {
          super(),
            (this._parent = e),
            (this._bootstrapComponents = []),
            (this.injector = this),
            (this.destroyCbs = []),
            (this.componentFactoryResolver = new Za(this))
          const n = it(t),
            i = t[H] || null
          i && Qo(i),
            (this._bootstrapComponents = ki(n.bootstrap)),
            (this._r3Injector = bs(
              t,
              e,
              [
                { provide: za, useValue: this },
                { provide: sa, useValue: this.componentFactoryResolver },
              ],
              u(t)
            )),
            this._r3Injector._resolveInjectorDefTypes(),
            (this.instance = this.get(t))
        }
        get(t, e = Os.THROW_IF_NOT_FOUND, n = O.Default) {
          return t === Os || t === za || t === cs
            ? this
            : this._r3Injector.get(t, e, n)
        }
        destroy() {
          const t = this._r3Injector
          !t.destroyed && t.destroy(),
            this.destroyCbs.forEach((t) => t()),
            (this.destroyCbs = null)
        }
        onDestroy(t) {
          this.destroyCbs.push(t)
        }
      }
      class sl extends Ha {
        constructor(t) {
          super(),
            (this.moduleType = t),
            null !== it(t) &&
              (function (t) {
                const e = new Set()
                !(function t(n) {
                  const i = it(n, !0),
                    r = i.id
                  null !== r &&
                    ((function (t, e, n) {
                      if (e && e !== n)
                        throw new Error(
                          `Duplicate module registered for ${t} - ${u(
                            e
                          )} vs ${u(e.name)}`
                        )
                    })(r, il.get(r), n),
                    il.set(r, n))
                  const s = ki(i.imports)
                  for (const o of s) e.has(o) || (e.add(o), t(o))
                })(t)
              })(t)
        }
        create(t) {
          return new rl(this.moduleType, t)
        }
      }
      function ol(t, e, n, i) {
        return cl(zt(), Zt(), t, e, n, i)
      }
      function al(t, e, n, i, r) {
        return (function (t, e, n, i, r, s, o) {
          const a = e + n
          return (function (t, e, n, i) {
            const r = Ms(t, e, n)
            return Ms(t, e + 1, i) || r
          })(t, a, r, s)
            ? Ns(t, a + 2, o ? i.call(o, r, s) : i(r, s))
            : ll(t, a + 2)
        })(zt(), Zt(), t, e, n, i, r)
      }
      function ll(t, e) {
        const n = t[e]
        return n === dr ? void 0 : n
      }
      function cl(t, e, n, i, r, s) {
        const o = e + n
        return Ms(t, o, r)
          ? Ns(t, o + 1, s ? i.call(s, r) : i(r))
          : ll(t, o + 1)
      }
      function ul(t, e) {
        const n = Ht()
        let i
        const r = t + rt
        n.firstCreatePass
          ? ((i = (function (t, e) {
              if (e)
                for (let n = e.length - 1; n >= 0; n--) {
                  const i = e[n]
                  if (t === i.name) return i
                }
              throw new pt('302', `The pipe '${t}' could not be found!`)
            })(e, n.pipeRegistry)),
            (n.data[r] = i),
            i.onDestroy &&
              (n.destroyHooks || (n.destroyHooks = [])).push(r, i.onDestroy))
          : (i = n.data[r])
        const s = i.factory || (i.factory = dt(i.type)),
          o = E(Hs)
        try {
          const t = Fe(!1),
            e = s()
          return (
            Fe(t),
            (function (t, e, n, i) {
              n >= t.data.length &&
                ((t.data[n] = null), (t.blueprint[n] = null)),
                (e[n] = i)
            })(n, zt(), r, e),
            e
          )
        } finally {
          E(o)
        }
      }
      function hl(t, e, n) {
        const i = t + rt,
          r = zt(),
          s = Pt(r, i)
        return (function (t, e) {
          return (
            Ds.isWrapped(e) &&
              ((e = Ds.unwrap(e)), (t[Ut.lFrame.bindingIndex] = dr)),
            e
          )
        })(
          r,
          (function (t, e) {
            return t[1].data[e].pure
          })(r, i)
            ? cl(r, Zt(), e, s.transform, n, s)
            : s.transform(n)
        )
      }
      const dl = class extends i.a {
        constructor(t = !1) {
          super(), (this.__isAsync = t)
        }
        emit(t) {
          super.next(t)
        }
        subscribe(t, e, n) {
          let i,
            s = (t) => null,
            o = () => null
          t && 'object' == typeof t
            ? ((i = this.__isAsync
                ? (e) => {
                    setTimeout(() => t.next(e))
                  }
                : (e) => {
                    t.next(e)
                  }),
              t.error &&
                (s = this.__isAsync
                  ? (e) => {
                      setTimeout(() => t.error(e))
                    }
                  : (e) => {
                      t.error(e)
                    }),
              t.complete &&
                (o = this.__isAsync
                  ? () => {
                      setTimeout(() => t.complete())
                    }
                  : () => {
                      t.complete()
                    }))
            : ((i = this.__isAsync
                ? (e) => {
                    setTimeout(() => t(e))
                  }
                : (e) => {
                    t(e)
                  }),
              e &&
                (s = this.__isAsync
                  ? (t) => {
                      setTimeout(() => e(t))
                    }
                  : (t) => {
                      e(t)
                    }),
              n &&
                (o = this.__isAsync
                  ? () => {
                      setTimeout(() => n())
                    }
                  : () => {
                      n()
                    }))
          const a = super.subscribe(i, s, o)
          return t instanceof r.a && t.add(a), a
        }
      }
      function pl() {
        return this._results[Rs()]()
      }
      class fl {
        constructor() {
          ;(this.dirty = !0),
            (this._results = []),
            (this.changes = new dl()),
            (this.length = 0)
          const t = Rs(),
            e = fl.prototype
          e[t] || (e[t] = pl)
        }
        map(t) {
          return this._results.map(t)
        }
        filter(t) {
          return this._results.filter(t)
        }
        find(t) {
          return this._results.find(t)
        }
        reduce(t, e) {
          return this._results.reduce(t, e)
        }
        forEach(t) {
          this._results.forEach(t)
        }
        some(t) {
          return this._results.some(t)
        }
        toArray() {
          return this._results.slice()
        }
        toString() {
          return this._results.toString()
        }
        reset(t) {
          ;(this._results = cn(t)),
            (this.dirty = !1),
            (this.length = this._results.length),
            (this.last = this._results[this.length - 1]),
            (this.first = this._results[0])
        }
        notifyOnChanges() {
          this.changes.emit(this)
        }
        setDirty() {
          this.dirty = !0
        }
        destroy() {
          this.changes.complete(), this.changes.unsubscribe()
        }
      }
      class ml {
        constructor(t) {
          ;(this.queryList = t), (this.matches = null)
        }
        clone() {
          return new ml(this.queryList)
        }
        setDirty() {
          this.queryList.setDirty()
        }
      }
      class gl {
        constructor(t = []) {
          this.queries = t
        }
        createEmbeddedView(t) {
          const e = t.queries
          if (null !== e) {
            const n =
                null !== t.contentQueries ? t.contentQueries[0] : e.length,
              i = []
            for (let t = 0; t < n; t++) {
              const n = e.getByIndex(t)
              i.push(this.queries[n.indexInDeclarationView].clone())
            }
            return new gl(i)
          }
          return null
        }
        insertView(t) {
          this.dirtyQueriesWithMatches(t)
        }
        detachView(t) {
          this.dirtyQueriesWithMatches(t)
        }
        dirtyQueriesWithMatches(t) {
          for (let e = 0; e < this.queries.length; e++)
            null !== Dl(t, e).matches && this.queries[e].setDirty()
        }
      }
      class bl {
        constructor(t, e, n, i = null) {
          ;(this.predicate = t),
            (this.descendants = e),
            (this.isStatic = n),
            (this.read = i)
        }
      }
      class _l {
        constructor(t = []) {
          this.queries = t
        }
        elementStart(t, e) {
          for (let n = 0; n < this.queries.length; n++)
            this.queries[n].elementStart(t, e)
        }
        elementEnd(t) {
          for (let e = 0; e < this.queries.length; e++)
            this.queries[e].elementEnd(t)
        }
        embeddedTView(t) {
          let e = null
          for (let n = 0; n < this.length; n++) {
            const i = null !== e ? e.length : 0,
              r = this.getByIndex(n).embeddedTView(t, i)
            r &&
              ((r.indexInDeclarationView = n),
              null !== e ? e.push(r) : (e = [r]))
          }
          return null !== e ? new _l(e) : null
        }
        template(t, e) {
          for (let n = 0; n < this.queries.length; n++)
            this.queries[n].template(t, e)
        }
        getByIndex(t) {
          return this.queries[t]
        }
        get length() {
          return this.queries.length
        }
        track(t) {
          this.queries.push(t)
        }
      }
      class yl {
        constructor(t, e = -1) {
          ;(this.metadata = t),
            (this.matches = null),
            (this.indexInDeclarationView = -1),
            (this.crossesNgTemplate = !1),
            (this._appliesToNextNode = !0),
            (this._declarationNodeIndex = e)
        }
        elementStart(t, e) {
          this.isApplyingToNode(e) && this.matchTNode(t, e)
        }
        elementEnd(t) {
          this._declarationNodeIndex === t.index &&
            (this._appliesToNextNode = !1)
        }
        template(t, e) {
          this.elementStart(t, e)
        }
        embeddedTView(t, e) {
          return this.isApplyingToNode(t)
            ? ((this.crossesNgTemplate = !0),
              this.addMatch(-t.index, e),
              new yl(this.metadata))
            : null
        }
        isApplyingToNode(t) {
          if (this._appliesToNextNode && !1 === this.metadata.descendants) {
            const e = this._declarationNodeIndex
            let n = t.parent
            for (; null !== n && 8 & n.type && n.index !== e; ) n = n.parent
            return e === (null !== n ? n.index : -1)
          }
          return this._appliesToNextNode
        }
        matchTNode(t, e) {
          const n = this.metadata.predicate
          if (Array.isArray(n))
            for (let i = 0; i < n.length; i++) {
              const r = n[i]
              this.matchTNodeWithReadOption(t, e, vl(e, r)),
                this.matchTNodeWithReadOption(t, e, Xe(e, t, r, !1, !1))
            }
          else
            n === Ma
              ? 4 & e.type && this.matchTNodeWithReadOption(t, e, -1)
              : this.matchTNodeWithReadOption(t, e, Xe(e, t, n, !1, !1))
        }
        matchTNodeWithReadOption(t, e, n) {
          if (null !== n) {
            const i = this.metadata.read
            if (null !== i)
              if (i === ca || i === Wa || (i === Ma && 4 & e.type))
                this.addMatch(e.index, -2)
              else {
                const n = Xe(e, t, i, !1, !1)
                null !== n && this.addMatch(e.index, n)
              }
            else this.addMatch(e.index, n)
          }
        }
        addMatch(t, e) {
          null === this.matches
            ? (this.matches = [t, e])
            : this.matches.push(t, e)
        }
      }
      function vl(t, e) {
        const n = t.localNames
        if (null !== n)
          for (let i = 0; i < n.length; i += 2) if (n[i] === e) return n[i + 1]
        return null
      }
      function wl(t, e, n, i) {
        return -1 === n
          ? (function (t, e) {
              return 11 & t.type ? aa(t, e) : 4 & t.type ? Ba(t, e) : null
            })(e, t)
          : -2 === n
          ? (function (t, e, n) {
              return n === ca
                ? aa(e, t)
                : n === Ma
                ? Ba(e, t)
                : n === Wa
                ? Ka(e, t)
                : void 0
            })(t, e, i)
          : Ke(t, t[1], n, e)
      }
      function Cl(t, e, n, i) {
        const r = e[19].queries[i]
        if (null === r.matches) {
          const i = t.data,
            s = n.matches,
            o = []
          for (let t = 0; t < s.length; t += 2) {
            const r = s[t]
            o.push(r < 0 ? null : wl(e, i[r], s[t + 1], n.metadata.read))
          }
          r.matches = o
        }
        return r.matches
      }
      function xl(t, e, n, i) {
        const r = t.queries.getByIndex(n),
          s = r.matches
        if (null !== s) {
          const o = Cl(t, e, r, n)
          for (let t = 0; t < s.length; t += 2) {
            const n = s[t]
            if (n > 0) i.push(o[t / 2])
            else {
              const r = s[t + 1],
                o = e[-n]
              for (let t = st; t < o.length; t++) {
                const e = o[t]
                e[17] === e[3] && xl(e[1], e, r, i)
              }
              if (null !== o[9]) {
                const t = o[9]
                for (let e = 0; e < t.length; e++) {
                  const n = t[e]
                  xl(n[1], n, r, i)
                }
              }
            }
          }
        }
        return i
      }
      function Sl(t) {
        const e = zt(),
          n = Ht(),
          i = re()
        se(i + 1)
        const r = Dl(n, i)
        if (t.dirty && Lt(e) === r.metadata.isStatic) {
          if (null === r.matches) t.reset([])
          else {
            const s = r.crossesNgTemplate ? xl(n, e, i, []) : Cl(n, e, r, i)
            t.reset(s), t.notifyOnChanges()
          }
          return !0
        }
        return !1
      }
      function Ol(t, e, n) {
        El(Ht(), zt(), t, e, n, !0)
      }
      function kl(t, e, n) {
        El(Ht(), zt(), t, e, n, !1)
      }
      function El(t, e, n, i, r, s) {
        t.firstCreatePass &&
          (Rl(t, new bl(n, i, s, r), -1), s && (t.staticViewQueries = !0)),
          Pl(t, e)
      }
      function Al(t, e, n, i) {
        jl(Ht(), zt(), e, n, i, !1, Wt(), t)
      }
      function Tl(t, e, n, i) {
        jl(Ht(), zt(), e, n, i, !0, Wt(), t)
      }
      function jl(t, e, n, i, r, s, o, a) {
        t.firstCreatePass &&
          (Rl(t, new bl(n, i, s, r), o.index),
          (function (t, e) {
            const n = t.contentQueries || (t.contentQueries = [])
            e !== (n.length ? n[n.length - 1] : -1) &&
              n.push(t.queries.length - 1, e)
          })(t, a),
          s && (t.staticContentQueries = !0)),
          Pl(t, e)
      }
      function Il() {
        return (t = zt()), (e = re()), t[19].queries[e].queryList
        var t, e
      }
      function Pl(t, e) {
        const n = new fl()
        Dr(t, e, n, n.destroy),
          null === e[19] && (e[19] = new gl()),
          e[19].queries.push(new ml(n))
      }
      function Rl(t, e, n) {
        null === t.queries && (t.queries = new _l()),
          t.queries.track(new yl(e, n))
      }
      function Dl(t, e) {
        return t.queries.getByIndex(e)
      }
      function Ll(t, e) {
        return Ba(t, e)
      }
      function Fl(t = O.Default) {
        const e = Ra(!0)
        if (null != e || t & O.Optional) return e
        gt('ChangeDetectorRef')
      }
      const Nl = new on('Application Initializer')
      let Ml = (() => {
        class t {
          constructor(t) {
            ;(this.appInits = t),
              (this.resolve = oa),
              (this.reject = oa),
              (this.initialized = !1),
              (this.done = !1),
              (this.donePromise = new Promise((t, e) => {
                ;(this.resolve = t), (this.reject = e)
              }))
          }
          runInitializers() {
            if (this.initialized) return
            const t = [],
              e = () => {
                ;(this.done = !0), this.resolve()
              }
            if (this.appInits)
              for (let n = 0; n < this.appInits.length; n++) {
                const e = this.appInits[n]()
                Zs(e) && t.push(e)
              }
            Promise.all(t)
              .then(() => {
                e()
              })
              .catch((t) => {
                this.reject(t)
              }),
              0 === t.length && e(),
              (this.initialized = !0)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(An(Nl, 8))
          }),
          (t.ɵprov = g({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      const Vl = new on('AppId'),
        Ul = {
          provide: Vl,
          useFactory: function () {
            return `${Bl()}${Bl()}${Bl()}`
          },
          deps: [],
        }
      function Bl() {
        return String.fromCharCode(97 + Math.floor(25 * Math.random()))
      }
      const zl = new on('Platform Initializer'),
        Hl = new on('Platform ID'),
        ql = new on('appBootstrapListener')
      let Wl = (() => {
        class t {
          log(t) {
            console.log(t)
          }
          warn(t) {
            console.warn(t)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵprov = g({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      const $l = new on('LocaleId'),
        Gl = new on('DefaultCurrencyCode')
      class Ql {
        constructor(t, e) {
          ;(this.ngModuleFactory = t), (this.componentFactories = e)
        }
      }
      const Xl = function (t) {
          return new sl(t)
        },
        Kl = Xl,
        Yl = function (t) {
          return Promise.resolve(Xl(t))
        },
        Zl = function (t) {
          const e = Xl(t),
            n = ki(it(t).declarations).reduce((t, e) => {
              const n = nt(e)
              return n && t.push(new el(n)), t
            }, [])
          return new Ql(e, n)
        },
        Jl = Zl,
        tc = function (t) {
          return Promise.resolve(Zl(t))
        }
      let ec = (() => {
        class t {
          constructor() {
            ;(this.compileModuleSync = Kl),
              (this.compileModuleAsync = Yl),
              (this.compileModuleAndAllComponentsSync = Jl),
              (this.compileModuleAndAllComponentsAsync = tc)
          }
          clearCache() {}
          clearCacheFor(t) {}
          getModuleId(t) {}
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵprov = g({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      const nc = (() => Promise.resolve(0))()
      function ic(t) {
        'undefined' == typeof Zone
          ? nc.then(() => {
              t && t.apply(null, null)
            })
          : Zone.current.scheduleMicroTask('scheduleMicrotask', t)
      }
      class rc {
        constructor({
          enableLongStackTrace: t = !1,
          shouldCoalesceEventChangeDetection: e = !1,
        }) {
          if (
            ((this.hasPendingMacrotasks = !1),
            (this.hasPendingMicrotasks = !1),
            (this.isStable = !0),
            (this.onUnstable = new dl(!1)),
            (this.onMicrotaskEmpty = new dl(!1)),
            (this.onStable = new dl(!1)),
            (this.onError = new dl(!1)),
            'undefined' == typeof Zone)
          )
            throw new Error('In this configuration Angular requires Zone.js')
          Zone.assertZonePatched()
          const n = this
          ;(n._nesting = 0),
            (n._outer = n._inner = Zone.current),
            Zone.TaskTrackingZoneSpec &&
              (n._inner = n._inner.fork(new Zone.TaskTrackingZoneSpec())),
            t &&
              Zone.longStackTraceZoneSpec &&
              (n._inner = n._inner.fork(Zone.longStackTraceZoneSpec)),
            (n.shouldCoalesceEventChangeDetection = e),
            (n.lastRequestAnimationFrameId = -1),
            (n.nativeRequestAnimationFrame = (function () {
              let t = F.requestAnimationFrame,
                e = F.cancelAnimationFrame
              if ('undefined' != typeof Zone && t && e) {
                const n = t[Zone.__symbol__('OriginalDelegate')]
                n && (t = n)
                const i = e[Zone.__symbol__('OriginalDelegate')]
                i && (e = i)
              }
              return {
                nativeRequestAnimationFrame: t,
                nativeCancelAnimationFrame: e,
              }
            })().nativeRequestAnimationFrame),
            (function (t) {
              const e =
                !!t.shouldCoalesceEventChangeDetection &&
                t.nativeRequestAnimationFrame &&
                (() => {
                  !(function (t) {
                    ;-1 === t.lastRequestAnimationFrameId &&
                      ((t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(
                        F,
                        () => {
                          t.fakeTopEventTask ||
                            (t.fakeTopEventTask = Zone.root.scheduleEventTask(
                              'fakeTopEventTask',
                              () => {
                                ;(t.lastRequestAnimationFrameId = -1),
                                  ac(t),
                                  oc(t)
                              },
                              void 0,
                              () => {},
                              () => {}
                            )),
                            t.fakeTopEventTask.invoke()
                        }
                      )),
                      ac(t))
                  })(t)
                })
              t._inner = t._inner.fork({
                name: 'angular',
                properties: { isAngularZone: !0, maybeDelayChangeDetection: e },
                onInvokeTask: (n, i, r, s, o, a) => {
                  try {
                    return lc(t), n.invokeTask(r, s, o, a)
                  } finally {
                    e && 'eventTask' === s.type && e(), cc(t)
                  }
                },
                onInvoke: (e, n, i, r, s, o, a) => {
                  try {
                    return lc(t), e.invoke(i, r, s, o, a)
                  } finally {
                    cc(t)
                  }
                },
                onHasTask: (e, n, i, r) => {
                  e.hasTask(i, r),
                    n === i &&
                      ('microTask' == r.change
                        ? ((t._hasPendingMicrotasks = r.microTask),
                          ac(t),
                          oc(t))
                        : 'macroTask' == r.change &&
                          (t.hasPendingMacrotasks = r.macroTask))
                },
                onHandleError: (e, n, i, r) => (
                  e.handleError(i, r),
                  t.runOutsideAngular(() => t.onError.emit(r)),
                  !1
                ),
              })
            })(n)
        }
        static isInAngularZone() {
          return !0 === Zone.current.get('isAngularZone')
        }
        static assertInAngularZone() {
          if (!rc.isInAngularZone())
            throw new Error('Expected to be in Angular Zone, but it is not!')
        }
        static assertNotInAngularZone() {
          if (rc.isInAngularZone())
            throw new Error('Expected to not be in Angular Zone, but it is!')
        }
        run(t, e, n) {
          return this._inner.run(t, e, n)
        }
        runTask(t, e, n, i) {
          const r = this._inner,
            s = r.scheduleEventTask('NgZoneEvent: ' + i, t, sc, oa, oa)
          try {
            return r.runTask(s, e, n)
          } finally {
            r.cancelTask(s)
          }
        }
        runGuarded(t, e, n) {
          return this._inner.runGuarded(t, e, n)
        }
        runOutsideAngular(t) {
          return this._outer.run(t)
        }
      }
      const sc = {}
      function oc(t) {
        if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable)
          try {
            t._nesting++, t.onMicrotaskEmpty.emit(null)
          } finally {
            if ((t._nesting--, !t.hasPendingMicrotasks))
              try {
                t.runOutsideAngular(() => t.onStable.emit(null))
              } finally {
                t.isStable = !0
              }
          }
      }
      function ac(t) {
        t.hasPendingMicrotasks = !!(
          t._hasPendingMicrotasks ||
          (t.shouldCoalesceEventChangeDetection &&
            -1 !== t.lastRequestAnimationFrameId)
        )
      }
      function lc(t) {
        t._nesting++, t.isStable && ((t.isStable = !1), t.onUnstable.emit(null))
      }
      function cc(t) {
        t._nesting--, oc(t)
      }
      class uc {
        constructor() {
          ;(this.hasPendingMicrotasks = !1),
            (this.hasPendingMacrotasks = !1),
            (this.isStable = !0),
            (this.onUnstable = new dl()),
            (this.onMicrotaskEmpty = new dl()),
            (this.onStable = new dl()),
            (this.onError = new dl())
        }
        run(t, e, n) {
          return t.apply(e, n)
        }
        runGuarded(t, e, n) {
          return t.apply(e, n)
        }
        runOutsideAngular(t) {
          return t()
        }
        runTask(t, e, n, i) {
          return t.apply(e, n)
        }
      }
      let hc = (() => {
          class t {
            constructor(t) {
              ;(this._ngZone = t),
                (this._pendingCount = 0),
                (this._isZoneStable = !0),
                (this._didWork = !1),
                (this._callbacks = []),
                (this.taskTrackingZone = null),
                this._watchAngularEvents(),
                t.run(() => {
                  this.taskTrackingZone =
                    'undefined' == typeof Zone
                      ? null
                      : Zone.current.get('TaskTrackingZone')
                })
            }
            _watchAngularEvents() {
              this._ngZone.onUnstable.subscribe({
                next: () => {
                  ;(this._didWork = !0), (this._isZoneStable = !1)
                },
              }),
                this._ngZone.runOutsideAngular(() => {
                  this._ngZone.onStable.subscribe({
                    next: () => {
                      rc.assertNotInAngularZone(),
                        ic(() => {
                          ;(this._isZoneStable = !0),
                            this._runCallbacksIfReady()
                        })
                    },
                  })
                })
            }
            increasePendingRequestCount() {
              return (
                (this._pendingCount += 1),
                (this._didWork = !0),
                this._pendingCount
              )
            }
            decreasePendingRequestCount() {
              if (((this._pendingCount -= 1), this._pendingCount < 0))
                throw new Error('pending async requests below zero')
              return this._runCallbacksIfReady(), this._pendingCount
            }
            isStable() {
              return (
                this._isZoneStable &&
                0 === this._pendingCount &&
                !this._ngZone.hasPendingMacrotasks
              )
            }
            _runCallbacksIfReady() {
              if (this.isStable())
                ic(() => {
                  for (; 0 !== this._callbacks.length; ) {
                    let t = this._callbacks.pop()
                    clearTimeout(t.timeoutId), t.doneCb(this._didWork)
                  }
                  this._didWork = !1
                })
              else {
                let t = this.getPendingTasks()
                ;(this._callbacks = this._callbacks.filter(
                  (e) =>
                    !e.updateCb ||
                    !e.updateCb(t) ||
                    (clearTimeout(e.timeoutId), !1)
                )),
                  (this._didWork = !0)
              }
            }
            getPendingTasks() {
              return this.taskTrackingZone
                ? this.taskTrackingZone.macroTasks.map((t) => ({
                    source: t.source,
                    creationLocation: t.creationLocation,
                    data: t.data,
                  }))
                : []
            }
            addCallback(t, e, n) {
              let i = -1
              e &&
                e > 0 &&
                (i = setTimeout(() => {
                  ;(this._callbacks = this._callbacks.filter(
                    (t) => t.timeoutId !== i
                  )),
                    t(this._didWork, this.getPendingTasks())
                }, e)),
                this._callbacks.push({ doneCb: t, timeoutId: i, updateCb: n })
            }
            whenStable(t, e, n) {
              if (n && !this.taskTrackingZone)
                throw new Error(
                  'Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?'
                )
              this.addCallback(t, e, n), this._runCallbacksIfReady()
            }
            getPendingRequestCount() {
              return this._pendingCount
            }
            findProviders(t, e, n) {
              return []
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(An(rc))
            }),
            (t.ɵprov = g({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        dc = (() => {
          class t {
            constructor() {
              ;(this._applications = new Map()), gc.addToWindow(this)
            }
            registerApplication(t, e) {
              this._applications.set(t, e)
            }
            unregisterApplication(t) {
              this._applications.delete(t)
            }
            unregisterAllApplications() {
              this._applications.clear()
            }
            getTestability(t) {
              return this._applications.get(t) || null
            }
            getAllTestabilities() {
              return Array.from(this._applications.values())
            }
            getAllRootElements() {
              return Array.from(this._applications.keys())
            }
            findTestabilityInTree(t, e = !0) {
              return gc.findTestabilityInTree(this, t, e)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵprov = g({ token: t, factory: t.ɵfac })),
            t
          )
        })()
      class pc {
        addToWindow(t) {}
        findTestabilityInTree(t, e, n) {
          return null
        }
      }
      function fc(t) {
        gc = t
      }
      let mc,
        gc = new pc(),
        bc = !0,
        _c = !1
      function yc() {
        return (_c = !0), bc
      }
      function vc() {
        if (_c) throw new Error('Cannot enable prod mode after platform setup.')
        bc = !1
      }
      const wc = new on('AllowMultipleToken')
      class Cc {
        constructor(t, e) {
          ;(this.name = t), (this.token = e)
        }
      }
      function xc(t, e, n = []) {
        const i = 'Platform: ' + e,
          r = new on(i)
        return (e = []) => {
          let s = Sc()
          if (!s || s.injector.get(wc, !1))
            if (t) t(n.concat(e).concat({ provide: r, useValue: !0 }))
            else {
              const t = n
                .concat(e)
                .concat(
                  { provide: r, useValue: !0 },
                  { provide: hs, useValue: 'platform' }
                )
              !(function (t) {
                if (mc && !mc.destroyed && !mc.injector.get(wc, !1))
                  throw new Error(
                    'There can be only one platform. Destroy the previous one to create a new one.'
                  )
                mc = t.get(Oc)
                const e = t.get(zl, null)
                e && e.forEach((t) => t())
              })(Os.create({ providers: t, name: i }))
            }
          return (function (t) {
            const e = Sc()
            if (!e) throw new Error('No platform exists!')
            if (!e.injector.get(t, null))
              throw new Error(
                'A platform with a different configuration has been created. Please destroy it first.'
              )
            return e
          })(r)
        }
      }
      function Sc() {
        return mc && !mc.destroyed ? mc : null
      }
      let Oc = (() => {
        class t {
          constructor(t) {
            ;(this._injector = t),
              (this._modules = []),
              (this._destroyListeners = []),
              (this._destroyed = !1)
          }
          bootstrapModuleFactory(t, e) {
            const n = (function (t, e) {
                let n
                return (
                  (n =
                    'noop' === t
                      ? new uc()
                      : ('zone.js' === t ? void 0 : t) ||
                        new rc({
                          enableLongStackTrace: yc(),
                          shouldCoalesceEventChangeDetection: e,
                        })),
                  n
                )
              })(e ? e.ngZone : void 0, (e && e.ngZoneEventCoalescing) || !1),
              i = [{ provide: rc, useValue: n }]
            return n.run(() => {
              const e = Os.create({
                  providers: i,
                  parent: this.injector,
                  name: t.moduleType.name,
                }),
                r = t.create(e),
                s = r.injector.get(wi, null)
              if (!s)
                throw new Error(
                  'No ErrorHandler. Is platform module (BrowserModule) included?'
                )
              return (
                n.runOutsideAngular(() => {
                  const t = n.onError.subscribe({
                    next: (t) => {
                      s.handleError(t)
                    },
                  })
                  r.onDestroy(() => {
                    Ac(this._modules, r), t.unsubscribe()
                  })
                }),
                (function (t, e, n) {
                  try {
                    const i = n()
                    return Zs(i)
                      ? i.catch((n) => {
                          throw (e.runOutsideAngular(() => t.handleError(n)), n)
                        })
                      : i
                  } catch (i) {
                    throw (e.runOutsideAngular(() => t.handleError(i)), i)
                  }
                })(s, n, () => {
                  const t = r.injector.get(Ml)
                  return (
                    t.runInitializers(),
                    t.donePromise.then(
                      () => (
                        Qo(r.injector.get($l, $o) || $o),
                        this._moduleDoBootstrap(r),
                        r
                      )
                    )
                  )
                })
              )
            })
          }
          bootstrapModule(t, e = []) {
            const n = kc({}, e)
            return (function (t, e, n) {
              const i = new sl(n)
              return Promise.resolve(i)
            })(0, 0, t).then((t) => this.bootstrapModuleFactory(t, n))
          }
          _moduleDoBootstrap(t) {
            const e = t.injector.get(Ec)
            if (t._bootstrapComponents.length > 0)
              t._bootstrapComponents.forEach((t) => e.bootstrap(t))
            else {
              if (!t.instance.ngDoBootstrap)
                throw new Error(
                  `The module ${u(
                    t.instance.constructor
                  )} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`
                )
              t.instance.ngDoBootstrap(e)
            }
            this._modules.push(t)
          }
          onDestroy(t) {
            this._destroyListeners.push(t)
          }
          get injector() {
            return this._injector
          }
          destroy() {
            if (this._destroyed)
              throw new Error('The platform has already been destroyed!')
            this._modules.slice().forEach((t) => t.destroy()),
              this._destroyListeners.forEach((t) => t()),
              (this._destroyed = !0)
          }
          get destroyed() {
            return this._destroyed
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(An(Os))
          }),
          (t.ɵprov = g({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      function kc(t, e) {
        return Array.isArray(e)
          ? e.reduce(kc, t)
          : Object.assign(Object.assign({}, t), e)
      }
      let Ec = (() => {
        class t {
          constructor(t, e, n, i, r, l) {
            ;(this._zone = t),
              (this._console = e),
              (this._injector = n),
              (this._exceptionHandler = i),
              (this._componentFactoryResolver = r),
              (this._initStatus = l),
              (this._bootstrapListeners = []),
              (this._views = []),
              (this._runningTick = !1),
              (this._stable = !0),
              (this.componentTypes = []),
              (this.components = []),
              (this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe(
                {
                  next: () => {
                    this._zone.run(() => {
                      this.tick()
                    })
                  },
                }
              ))
            const c = new s.a((t) => {
                ;(this._stable =
                  this._zone.isStable &&
                  !this._zone.hasPendingMacrotasks &&
                  !this._zone.hasPendingMicrotasks),
                  this._zone.runOutsideAngular(() => {
                    t.next(this._stable), t.complete()
                  })
              }),
              u = new s.a((t) => {
                let e
                this._zone.runOutsideAngular(() => {
                  e = this._zone.onStable.subscribe(() => {
                    rc.assertNotInAngularZone(),
                      ic(() => {
                        this._stable ||
                          this._zone.hasPendingMacrotasks ||
                          this._zone.hasPendingMicrotasks ||
                          ((this._stable = !0), t.next(!0))
                      })
                  })
                })
                const n = this._zone.onUnstable.subscribe(() => {
                  rc.assertInAngularZone(),
                    this._stable &&
                      ((this._stable = !1),
                      this._zone.runOutsideAngular(() => {
                        t.next(!1)
                      }))
                })
                return () => {
                  e.unsubscribe(), n.unsubscribe()
                }
              })
            this.isStable = Object(o.a)(c, u.pipe(Object(a.a)()))
          }
          bootstrap(t, e) {
            if (!this._initStatus.done)
              throw new Error(
                'Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.'
              )
            let n
            ;(n =
              t instanceof ia
                ? t
                : this._componentFactoryResolver.resolveComponentFactory(t)),
              this.componentTypes.push(n.componentType)
            const i = n.isBoundToModule ? void 0 : this._injector.get(za),
              r = n.create(Os.NULL, [], e || n.selector, i),
              s = r.location.nativeElement,
              o = r.injector.get(hc, null),
              a = o && r.injector.get(dc)
            return (
              o && a && a.registerApplication(s, o),
              r.onDestroy(() => {
                this.detachView(r.hostView),
                  Ac(this.components, r),
                  a && a.unregisterApplication(s)
              }),
              this._loadComponent(r),
              yc() &&
                this._console.log(
                  'Angular is running in development mode. Call enableProdMode() to enable production mode.'
                ),
              r
            )
          }
          tick() {
            if (this._runningTick)
              throw new Error('ApplicationRef.tick is called recursively')
            try {
              this._runningTick = !0
              for (let t of this._views) t.detectChanges()
            } catch (t) {
              this._zone.runOutsideAngular(() =>
                this._exceptionHandler.handleError(t)
              )
            } finally {
              this._runningTick = !1
            }
          }
          attachView(t) {
            const e = t
            this._views.push(e), e.attachToAppRef(this)
          }
          detachView(t) {
            const e = t
            Ac(this._views, e), e.detachFromAppRef()
          }
          _loadComponent(t) {
            this.attachView(t.hostView),
              this.tick(),
              this.components.push(t),
              this._injector
                .get(ql, [])
                .concat(this._bootstrapListeners)
                .forEach((e) => e(t))
          }
          ngOnDestroy() {
            this._views.slice().forEach((t) => t.destroy()),
              this._onMicrotaskEmptySubscription.unsubscribe()
          }
          get viewCount() {
            return this._views.length
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(An(rc), An(Wl), An(Os), An(wi), An(sa), An(Ml))
          }),
          (t.ɵprov = g({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      function Ac(t, e) {
        const n = t.indexOf(e)
        n > -1 && t.splice(n, 1)
      }
      class Tc {}
      class jc {}
      const Ic = { factoryPathPrefix: '', factoryPathSuffix: '.ngfactory' }
      let Pc = (() => {
        class t {
          constructor(t, e) {
            ;(this._compiler = t), (this._config = e || Ic)
          }
          load(t) {
            return this.loadAndCompile(t)
          }
          loadAndCompile(t) {
            let [e, i] = t.split('#')
            return (
              void 0 === i && (i = 'default'),
              n('F1In')(e)
                .then((t) => t[i])
                .then((t) => Rc(t, e, i))
                .then((t) => this._compiler.compileModuleAsync(t))
            )
          }
          loadFactory(t) {
            let [e, i] = t.split('#'),
              r = 'NgFactory'
            return (
              void 0 === i && ((i = 'default'), (r = '')),
              n('F1In')(
                this._config.factoryPathPrefix +
                  e +
                  this._config.factoryPathSuffix
              )
                .then((t) => t[i + r])
                .then((t) => Rc(t, e, i))
            )
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(An(ec), An(jc, 8))
          }),
          (t.ɵprov = g({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      function Rc(t, e, n) {
        if (!t) throw new Error(`Cannot find '${n}' in '${e}'`)
        return t
      }
      const Dc = function (t) {
          return null
        },
        Lc = xc(null, 'core', [
          { provide: Hl, useValue: 'unknown' },
          { provide: Oc, deps: [Os] },
          { provide: dc, deps: [] },
          { provide: Wl, deps: [] },
        ]),
        Fc = [
          { provide: Ec, useClass: Ec, deps: [rc, Wl, Os, wi, sa, Ml] },
          {
            provide: tl,
            deps: [rc],
            useFactory: function (t) {
              let e = []
              return (
                t.onStable.subscribe(() => {
                  for (; e.length; ) e.pop()()
                }),
                function (t) {
                  e.push(t)
                }
              )
            },
          },
          { provide: Ml, useClass: Ml, deps: [[new _n(), Nl]] },
          { provide: ec, useClass: ec, deps: [] },
          Ul,
          {
            provide: ka,
            useFactory: function () {
              return La
            },
            deps: [],
          },
          {
            provide: Ea,
            useFactory: function () {
              return Fa
            },
            deps: [],
          },
          {
            provide: $l,
            useFactory: function (t) {
              return (
                Qo(
                  (t =
                    t ||
                    ('undefined' != typeof $localize && $localize.locale) ||
                    $o)
                ),
                t
              )
            },
            deps: [[new bn($l), new _n(), new vn()]],
          },
          { provide: Gl, useValue: 'USD' },
        ]
      let Nc = (() => {
        class t {
          constructor(t) {}
        }
        return (
          (t.ɵmod = Y({ type: t })),
          (t.ɵinj = b({
            factory: function (e) {
              return new (e || t)(An(Ec))
            },
            providers: Fc,
          })),
          t
        )
      })()
    },
    g5Dd: function (t, e) {
      !(function (t) {
        'use strict'
        ;(e.encode = function (e) {
          var n,
            i = new Uint8Array(e),
            r = i.length,
            s = ''
          for (n = 0; n < r; n += 3)
            (s += t[i[n] >> 2]),
              (s += t[((3 & i[n]) << 4) | (i[n + 1] >> 4)]),
              (s += t[((15 & i[n + 1]) << 2) | (i[n + 2] >> 6)]),
              (s += t[63 & i[n + 2]])
          return (
            r % 3 == 2
              ? (s = s.substring(0, s.length - 1) + '=')
              : r % 3 == 1 && (s = s.substring(0, s.length - 2) + '=='),
            s
          )
        }),
          (e.decode = function (e) {
            var n,
              i,
              r,
              s,
              o,
              a = 0.75 * e.length,
              l = e.length,
              c = 0
            '=' === e[e.length - 1] && (a--, '=' === e[e.length - 2] && a--)
            var u = new ArrayBuffer(a),
              h = new Uint8Array(u)
            for (n = 0; n < l; n += 4)
              (i = t.indexOf(e[n])),
                (r = t.indexOf(e[n + 1])),
                (s = t.indexOf(e[n + 2])),
                (o = t.indexOf(e[n + 3])),
                (h[c++] = (i << 2) | (r >> 4)),
                (h[c++] = ((15 & r) << 4) | (s >> 2)),
                (h[c++] = ((3 & s) << 6) | (63 & o))
            return u
          })
      })('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/')
    },
    gFX4: function (t, e, n) {
      var i = n('zJ60'),
        r = n('Uwu7'),
        s = n('eOtv'),
        o = n('NOtv')('socket.io-client')
      t.exports = e = l
      var a = (e.managers = {})
      function l(t, e) {
        'object' == typeof t && ((e = t), (t = void 0)), (e = e || {})
        var n,
          r = i(t),
          l = r.source,
          c = r.id
        return (
          e.forceNew ||
          e['force new connection'] ||
          !1 === e.multiplex ||
          (a[c] && r.path in a[c].nsps)
            ? (o('ignoring socket cache for %s', l), (n = s(l, e)))
            : (a[c] || (o('new io instance for %s', l), (a[c] = s(l, e))),
              (n = a[c])),
          r.query && !e.query && (e.query = r.query),
          n.socket(r.path, e)
        )
      }
      ;(e.protocol = r.protocol),
        (e.connect = l),
        (e.Manager = n('eOtv')),
        (e.Socket = n('KFGy'))
    },
    gRHU: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return s
      })
      var i = n('2fFW'),
        r = n('NJ4a')
      const s = {
        closed: !0,
        next(t) {},
        error(t) {
          if (i.a.useDeprecatedSynchronousErrorHandling) throw t
          Object(r.a)(t)
        },
        complete() {},
      }
    },
    iBb4: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return c
      })
      var i = n('+rOU'),
        r = n('yXgJ'),
        s = n('ZL+G'),
        o = n('cPJY'),
        a = n('fXoL'),
        l = n('rDax')
      let c = (() => {
        class t {
          constructor(t, e, n) {
            ;(this.overlay = t),
              (this.parentInjector = e),
              (this.overlogConfig = n)
          }
          show(t, e) {
            this.overlogConfig = Object.assign({}, this.overlogConfig, e)
            const n = this.getPositionStrategy(),
              o = this.overlay.create({ positionStrategy: n }),
              a = new s.a(o)
            this.lastOverlog = a
            const l = this.getInjector(t, a, this.parentInjector),
              c = new i.a(r.a, null, l)
            return o.attach(c), a
          }
          showFrom(t, e) {
            const n = this.getConnectedPosition(e),
              o = this.overlay.create({ positionStrategy: n }),
              a = new s.a(o)
            this.lastOverlog = a
            const l = this.getInjector(t, a, this.parentInjector),
              c = new i.a(r.a, null, l)
            return o.attach(c), a
          }
          getConnectedPosition(t) {
            return this.overlay
              .position()
              .flexibleConnectedTo(t)
              .withFlexibleDimensions(!1)
              .withPush(!0)
              .withPositions(o.d)
          }
          getPositionStrategy() {
            return this.overlay
              .position()
              .global()
              .top(this.getPosition())
              .right(this.overlogConfig.position.right + 'px')
          }
          getPosition() {
            return (
              (this.lastOverlog && this.lastOverlog.isVisible()
                ? this.lastOverlog.getPosition().bottom
                : this.overlogConfig.position.top) + 'px'
            )
          }
          getInjector(t, e, n) {
            const r = new WeakMap()
            return r.set(o.b, t), r.set(s.a, e), new i.c(n, r)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(a.Ub(l.c), a.Ub(a.r), a.Ub(o.a))
          }),
          (t.ɵprov = a.Hb({ token: t, factory: t.ɵfac, providedIn: 'root' })),
          t
        )
      })()
    },
    itXk: function (t, e, n) {
      'use strict'
      n.d(e, 'b', function () {
        return c
      }),
        n.d(e, 'a', function () {
          return u
        })
      var i = n('z+Ro'),
        r = n('DH7j'),
        s = n('l7GE'),
        o = n('ZUHj'),
        a = n('yCtX')
      const l = {}
      function c(...t) {
        let e = null,
          n = null
        return (
          Object(i.a)(t[t.length - 1]) && (n = t.pop()),
          'function' == typeof t[t.length - 1] && (e = t.pop()),
          1 === t.length && Object(r.a)(t[0]) && (t = t[0]),
          Object(a.a)(t, n).lift(new u(e))
        )
      }
      class u {
        constructor(t) {
          this.resultSelector = t
        }
        call(t, e) {
          return e.subscribe(new h(t, this.resultSelector))
        }
      }
      class h extends s.a {
        constructor(t, e) {
          super(t),
            (this.resultSelector = e),
            (this.active = 0),
            (this.values = []),
            (this.observables = [])
        }
        _next(t) {
          this.values.push(l), this.observables.push(t)
        }
        _complete() {
          const t = this.observables,
            e = t.length
          if (0 === e) this.destination.complete()
          else {
            ;(this.active = e), (this.toRespond = e)
            for (let n = 0; n < e; n++) {
              const e = t[n]
              this.add(Object(o.a)(this, e, e, n))
            }
          }
        }
        notifyComplete(t) {
          0 == (this.active -= 1) && this.destination.complete()
        }
        notifyNext(t, e, n, i, r) {
          const s = this.values,
            o = this.toRespond
              ? s[n] === l
                ? --this.toRespond
                : this.toRespond
              : 0
          ;(s[n] = e),
            0 === o &&
              (this.resultSelector
                ? this._tryResultSelector(s)
                : this.destination.next(s.slice()))
        }
        _tryResultSelector(t) {
          let e
          try {
            e = this.resultSelector.apply(this, t)
          } catch (n) {
            return void this.destination.error(n)
          }
          this.destination.next(e)
        }
      }
    },
    jZKg: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return s
      })
      var i = n('HDdC'),
        r = n('quSY')
      function s(t, e) {
        return new i.a((n) => {
          const i = new r.a()
          let s = 0
          return (
            i.add(
              e.schedule(function () {
                s !== t.length
                  ? (n.next(t[s++]), n.closed || i.add(this.schedule()))
                  : n.complete()
              })
            ),
            i
          )
        })
      }
    },
    jhN1: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return N
      }),
        n.d(e, 'b', function () {
          return I
        }),
        n.d(e, 'c', function () {
          return L
        }),
        n.d(e, 'd', function () {
          return w
        })
      var i = n('ofXK'),
        r = n('fXoL')
      class s extends i.s {
        constructor() {
          super()
        }
        supportsDOMEvents() {
          return !0
        }
      }
      class o extends s {
        static makeCurrent() {
          Object(i.w)(new o())
        }
        getProperty(t, e) {
          return t[e]
        }
        log(t) {
          window.console && window.console.log && window.console.log(t)
        }
        logGroup(t) {
          window.console && window.console.group && window.console.group(t)
        }
        logGroupEnd() {
          window.console && window.console.groupEnd && window.console.groupEnd()
        }
        onAndCancel(t, e, n) {
          return (
            t.addEventListener(e, n, !1),
            () => {
              t.removeEventListener(e, n, !1)
            }
          )
        }
        dispatchEvent(t, e) {
          t.dispatchEvent(e)
        }
        remove(t) {
          return t.parentNode && t.parentNode.removeChild(t), t
        }
        getValue(t) {
          return t.value
        }
        createElement(t, e) {
          return (e = e || this.getDefaultDocument()).createElement(t)
        }
        createHtmlDocument() {
          return document.implementation.createHTMLDocument('fakeTitle')
        }
        getDefaultDocument() {
          return document
        }
        isElementNode(t) {
          return t.nodeType === Node.ELEMENT_NODE
        }
        isShadowRoot(t) {
          return t instanceof DocumentFragment
        }
        getGlobalEventTarget(t, e) {
          return 'window' === e
            ? window
            : 'document' === e
            ? t
            : 'body' === e
            ? t.body
            : null
        }
        getHistory() {
          return window.history
        }
        getLocation() {
          return window.location
        }
        getBaseHref(t) {
          const e =
            l || ((l = document.querySelector('base')), l)
              ? l.getAttribute('href')
              : null
          return null == e
            ? null
            : ((n = e),
              a || (a = document.createElement('a')),
              a.setAttribute('href', n),
              '/' === a.pathname.charAt(0) ? a.pathname : '/' + a.pathname)
          var n
        }
        resetBaseElement() {
          l = null
        }
        getUserAgent() {
          return window.navigator.userAgent
        }
        performanceNow() {
          return window.performance && window.performance.now
            ? window.performance.now()
            : new Date().getTime()
        }
        supportsCookies() {
          return !0
        }
        getCookie(t) {
          return Object(i.v)(document.cookie, t)
        }
      }
      let a,
        l = null
      const c = new r.q('TRANSITION_ID'),
        u = [
          {
            provide: r.d,
            useFactory: function (t, e, n) {
              return () => {
                n.get(r.e).donePromise.then(() => {
                  const n = Object(i.u)()
                  Array.prototype.slice
                    .apply(e.querySelectorAll('style[ng-transition]'))
                    .filter((e) => e.getAttribute('ng-transition') === t)
                    .forEach((t) => n.remove(t))
                })
              }
            },
            deps: [c, i.d, r.r],
            multi: !0,
          },
        ]
      class h {
        static init() {
          Object(r.X)(new h())
        }
        addToWindow(t) {
          ;(r.ob.getAngularTestability = (e, n = !0) => {
            const i = t.findTestabilityInTree(e, n)
            if (null == i)
              throw new Error('Could not find testability for element.')
            return i
          }),
            (r.ob.getAllAngularTestabilities = () => t.getAllTestabilities()),
            (r.ob.getAllAngularRootElements = () => t.getAllRootElements()),
            r.ob.frameworkStabilizers || (r.ob.frameworkStabilizers = []),
            r.ob.frameworkStabilizers.push((t) => {
              const e = r.ob.getAllAngularTestabilities()
              let n = e.length,
                i = !1
              const s = function (e) {
                ;(i = i || e), n--, 0 == n && t(i)
              }
              e.forEach(function (t) {
                t.whenStable(s)
              })
            })
        }
        findTestabilityInTree(t, e, n) {
          if (null == e) return null
          const r = t.getTestability(e)
          return null != r
            ? r
            : n
            ? Object(i.u)().isShadowRoot(e)
              ? this.findTestabilityInTree(t, e.host, !0)
              : this.findTestabilityInTree(t, e.parentElement, !0)
            : null
        }
      }
      const d = new r.q('EventManagerPlugins')
      let p = (() => {
        class t {
          constructor(t, e) {
            ;(this._zone = e),
              (this._eventNameToPlugin = new Map()),
              t.forEach((t) => (t.manager = this)),
              (this._plugins = t.slice().reverse())
          }
          addEventListener(t, e, n) {
            return this._findPluginFor(e).addEventListener(t, e, n)
          }
          addGlobalEventListener(t, e, n) {
            return this._findPluginFor(e).addGlobalEventListener(t, e, n)
          }
          getZone() {
            return this._zone
          }
          _findPluginFor(t) {
            const e = this._eventNameToPlugin.get(t)
            if (e) return e
            const n = this._plugins
            for (let i = 0; i < n.length; i++) {
              const e = n[i]
              if (e.supports(t)) return this._eventNameToPlugin.set(t, e), e
            }
            throw new Error('No event manager plugin found for event ' + t)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(r.Ub(d), r.Ub(r.z))
          }),
          (t.ɵprov = r.Hb({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      class f {
        constructor(t) {
          this._doc = t
        }
        addGlobalEventListener(t, e, n) {
          const r = Object(i.u)().getGlobalEventTarget(this._doc, t)
          if (!r)
            throw new Error(`Unsupported event target ${r} for event ${e}`)
          return this.addEventListener(r, e, n)
        }
      }
      let m = (() => {
          class t {
            constructor() {
              this._stylesSet = new Set()
            }
            addStyles(t) {
              const e = new Set()
              t.forEach((t) => {
                this._stylesSet.has(t) || (this._stylesSet.add(t), e.add(t))
              }),
                this.onStylesAdded(e)
            }
            onStylesAdded(t) {}
            getAllStyles() {
              return Array.from(this._stylesSet)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵprov = r.Hb({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        g = (() => {
          class t extends m {
            constructor(t) {
              super(),
                (this._doc = t),
                (this._hostNodes = new Set()),
                (this._styleNodes = new Set()),
                this._hostNodes.add(t.head)
            }
            _addStylesToHost(t, e) {
              t.forEach((t) => {
                const n = this._doc.createElement('style')
                ;(n.textContent = t), this._styleNodes.add(e.appendChild(n))
              })
            }
            addHost(t) {
              this._addStylesToHost(this._stylesSet, t), this._hostNodes.add(t)
            }
            removeHost(t) {
              this._hostNodes.delete(t)
            }
            onStylesAdded(t) {
              this._hostNodes.forEach((e) => this._addStylesToHost(t, e))
            }
            ngOnDestroy() {
              this._styleNodes.forEach((t) => Object(i.u)().remove(t))
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(r.Ub(i.d))
            }),
            (t.ɵprov = r.Hb({ token: t, factory: t.ɵfac })),
            t
          )
        })()
      const b = {
          svg: 'http://www.w3.org/2000/svg',
          xhtml: 'http://www.w3.org/1999/xhtml',
          xlink: 'http://www.w3.org/1999/xlink',
          xml: 'http://www.w3.org/XML/1998/namespace',
          xmlns: 'http://www.w3.org/2000/xmlns/',
        },
        _ = /%COMP%/g
      function y(t, e, n) {
        for (let i = 0; i < e.length; i++) {
          let r = e[i]
          Array.isArray(r) ? y(t, r, n) : ((r = r.replace(_, t)), n.push(r))
        }
        return n
      }
      function v(t) {
        return (e) => {
          if ('__ngUnwrap__' === e) return t
          !1 === t(e) && (e.preventDefault(), (e.returnValue = !1))
        }
      }
      let w = (() => {
        class t {
          constructor(t, e, n) {
            ;(this.eventManager = t),
              (this.sharedStylesHost = e),
              (this.appId = n),
              (this.rendererByCompId = new Map()),
              (this.defaultRenderer = new C(t))
          }
          createRenderer(t, e) {
            if (!t || !e) return this.defaultRenderer
            switch (e.encapsulation) {
              case r.Q.Emulated: {
                let n = this.rendererByCompId.get(e.id)
                return (
                  n ||
                    ((n = new x(
                      this.eventManager,
                      this.sharedStylesHost,
                      e,
                      this.appId
                    )),
                    this.rendererByCompId.set(e.id, n)),
                  n.applyToHost(t),
                  n
                )
              }
              case 1:
              case r.Q.ShadowDom:
                return new S(this.eventManager, this.sharedStylesHost, t, e)
              default:
                if (!this.rendererByCompId.has(e.id)) {
                  const t = y(e.id, e.styles, [])
                  this.sharedStylesHost.addStyles(t),
                    this.rendererByCompId.set(e.id, this.defaultRenderer)
                }
                return this.defaultRenderer
            }
          }
          begin() {}
          end() {}
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(r.Ub(p), r.Ub(g), r.Ub(r.c))
          }),
          (t.ɵprov = r.Hb({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      class C {
        constructor(t) {
          ;(this.eventManager = t), (this.data = Object.create(null))
        }
        destroy() {}
        createElement(t, e) {
          return e
            ? document.createElementNS(b[e] || e, t)
            : document.createElement(t)
        }
        createComment(t) {
          return document.createComment(t)
        }
        createText(t) {
          return document.createTextNode(t)
        }
        appendChild(t, e) {
          t.appendChild(e)
        }
        insertBefore(t, e, n) {
          t && t.insertBefore(e, n)
        }
        removeChild(t, e) {
          t && t.removeChild(e)
        }
        selectRootElement(t, e) {
          let n = 'string' == typeof t ? document.querySelector(t) : t
          if (!n)
            throw new Error(`The selector "${t}" did not match any elements`)
          return e || (n.textContent = ''), n
        }
        parentNode(t) {
          return t.parentNode
        }
        nextSibling(t) {
          return t.nextSibling
        }
        setAttribute(t, e, n, i) {
          if (i) {
            e = i + ':' + e
            const r = b[i]
            r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n)
          } else t.setAttribute(e, n)
        }
        removeAttribute(t, e, n) {
          if (n) {
            const i = b[n]
            i ? t.removeAttributeNS(i, e) : t.removeAttribute(`${n}:${e}`)
          } else t.removeAttribute(e)
        }
        addClass(t, e) {
          t.classList.add(e)
        }
        removeClass(t, e) {
          t.classList.remove(e)
        }
        setStyle(t, e, n, i) {
          i & (r.G.DashCase | r.G.Important)
            ? t.style.setProperty(e, n, i & r.G.Important ? 'important' : '')
            : (t.style[e] = n)
        }
        removeStyle(t, e, n) {
          n & r.G.DashCase ? t.style.removeProperty(e) : (t.style[e] = '')
        }
        setProperty(t, e, n) {
          t[e] = n
        }
        setValue(t, e) {
          t.nodeValue = e
        }
        listen(t, e, n) {
          return 'string' == typeof t
            ? this.eventManager.addGlobalEventListener(t, e, v(n))
            : this.eventManager.addEventListener(t, e, v(n))
        }
      }
      class x extends C {
        constructor(t, e, n, i) {
          super(t), (this.component = n)
          const r = y(i + '-' + n.id, n.styles, [])
          e.addStyles(r),
            (this.contentAttr = '_ngcontent-%COMP%'.replace(_, i + '-' + n.id)),
            (this.hostAttr = '_nghost-%COMP%'.replace(_, i + '-' + n.id))
        }
        applyToHost(t) {
          super.setAttribute(t, this.hostAttr, '')
        }
        createElement(t, e) {
          const n = super.createElement(t, e)
          return super.setAttribute(n, this.contentAttr, ''), n
        }
      }
      class S extends C {
        constructor(t, e, n, i) {
          super(t),
            (this.sharedStylesHost = e),
            (this.hostEl = n),
            (this.shadowRoot = n.attachShadow({ mode: 'open' })),
            this.sharedStylesHost.addHost(this.shadowRoot)
          const r = y(i.id, i.styles, [])
          for (let s = 0; s < r.length; s++) {
            const t = document.createElement('style')
            ;(t.textContent = r[s]), this.shadowRoot.appendChild(t)
          }
        }
        nodeOrShadowRoot(t) {
          return t === this.hostEl ? this.shadowRoot : t
        }
        destroy() {
          this.sharedStylesHost.removeHost(this.shadowRoot)
        }
        appendChild(t, e) {
          return super.appendChild(this.nodeOrShadowRoot(t), e)
        }
        insertBefore(t, e, n) {
          return super.insertBefore(this.nodeOrShadowRoot(t), e, n)
        }
        removeChild(t, e) {
          return super.removeChild(this.nodeOrShadowRoot(t), e)
        }
        parentNode(t) {
          return this.nodeOrShadowRoot(
            super.parentNode(this.nodeOrShadowRoot(t))
          )
        }
      }
      let O = (() => {
        class t extends f {
          constructor(t) {
            super(t)
          }
          supports(t) {
            return !0
          }
          addEventListener(t, e, n) {
            return (
              t.addEventListener(e, n, !1),
              () => this.removeEventListener(t, e, n)
            )
          }
          removeEventListener(t, e, n) {
            return t.removeEventListener(e, n)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(r.Ub(i.d))
          }),
          (t.ɵprov = r.Hb({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      const k = ['alt', 'control', 'meta', 'shift'],
        E = {
          '\b': 'Backspace',
          '\t': 'Tab',
          '\x7f': 'Delete',
          '\x1b': 'Escape',
          Del: 'Delete',
          Esc: 'Escape',
          Left: 'ArrowLeft',
          Right: 'ArrowRight',
          Up: 'ArrowUp',
          Down: 'ArrowDown',
          Menu: 'ContextMenu',
          Scroll: 'ScrollLock',
          Win: 'OS',
        },
        A = {
          A: '1',
          B: '2',
          C: '3',
          D: '4',
          E: '5',
          F: '6',
          G: '7',
          H: '8',
          I: '9',
          J: '*',
          K: '+',
          M: '-',
          N: '.',
          O: '/',
          '`': '0',
          '\x90': 'NumLock',
        },
        T = {
          alt: (t) => t.altKey,
          control: (t) => t.ctrlKey,
          meta: (t) => t.metaKey,
          shift: (t) => t.shiftKey,
        }
      let j = (() => {
          class t extends f {
            constructor(t) {
              super(t)
            }
            supports(e) {
              return null != t.parseEventName(e)
            }
            addEventListener(e, n, r) {
              const s = t.parseEventName(n),
                o = t.eventCallback(s.fullKey, r, this.manager.getZone())
              return this.manager
                .getZone()
                .runOutsideAngular(() =>
                  Object(i.u)().onAndCancel(e, s.domEventName, o)
                )
            }
            static parseEventName(e) {
              const n = e.toLowerCase().split('.'),
                i = n.shift()
              if (0 === n.length || ('keydown' !== i && 'keyup' !== i))
                return null
              const r = t._normalizeKey(n.pop())
              let s = ''
              if (
                (k.forEach((t) => {
                  const e = n.indexOf(t)
                  e > -1 && (n.splice(e, 1), (s += t + '.'))
                }),
                (s += r),
                0 != n.length || 0 === r.length)
              )
                return null
              const o = {}
              return (o.domEventName = i), (o.fullKey = s), o
            }
            static getEventFullKey(t) {
              let e = '',
                n = (function (t) {
                  let e = t.key
                  if (null == e) {
                    if (((e = t.keyIdentifier), null == e))
                      return 'Unidentified'
                    e.startsWith('U+') &&
                      ((e = String.fromCharCode(parseInt(e.substring(2), 16))),
                      3 === t.location && A.hasOwnProperty(e) && (e = A[e]))
                  }
                  return E[e] || e
                })(t)
              return (
                (n = n.toLowerCase()),
                ' ' === n ? (n = 'space') : '.' === n && (n = 'dot'),
                k.forEach((i) => {
                  i != n && (0, T[i])(t) && (e += i + '.')
                }),
                (e += n),
                e
              )
            }
            static eventCallback(e, n, i) {
              return (r) => {
                t.getEventFullKey(r) === e && i.runGuarded(() => n(r))
              }
            }
            static _normalizeKey(t) {
              switch (t) {
                case 'esc':
                  return 'escape'
                default:
                  return t
              }
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(r.Ub(i.d))
            }),
            (t.ɵprov = r.Hb({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        I = (() => {
          class t {}
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵprov = Object(r.Hb)({
              factory: function () {
                return Object(r.Ub)(R)
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })()
      function P(t) {
        return new R(t.get(i.d))
      }
      let R = (() => {
        class t extends I {
          constructor(t) {
            super(), (this._doc = t)
          }
          sanitize(t, e) {
            if (null == e) return null
            switch (t) {
              case r.I.NONE:
                return e
              case r.I.HTML:
                return Object(r.db)(e, 'HTML')
                  ? Object(r.vb)(e)
                  : Object(r.bb)(this._doc, String(e))
              case r.I.STYLE:
                return Object(r.db)(e, 'Style') ? Object(r.vb)(e) : e
              case r.I.SCRIPT:
                if (Object(r.db)(e, 'Script')) return Object(r.vb)(e)
                throw new Error('unsafe value used in a script context')
              case r.I.URL:
                return (
                  Object(r.nb)(e),
                  Object(r.db)(e, 'URL')
                    ? Object(r.vb)(e)
                    : Object(r.cb)(String(e))
                )
              case r.I.RESOURCE_URL:
                if (Object(r.db)(e, 'ResourceURL')) return Object(r.vb)(e)
                throw new Error(
                  'unsafe value used in a resource URL context (see https://g.co/ng/security#xss)'
                )
              default:
                throw new Error(
                  `Unexpected SecurityContext ${t} (see https://g.co/ng/security#xss)`
                )
            }
          }
          bypassSecurityTrustHtml(t) {
            return Object(r.eb)(t)
          }
          bypassSecurityTrustStyle(t) {
            return Object(r.hb)(t)
          }
          bypassSecurityTrustScript(t) {
            return Object(r.gb)(t)
          }
          bypassSecurityTrustUrl(t) {
            return Object(r.ib)(t)
          }
          bypassSecurityTrustResourceUrl(t) {
            return Object(r.fb)(t)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(r.Ub(i.d))
          }),
          (t.ɵprov = Object(r.Hb)({
            factory: function () {
              return P(Object(r.Ub)(r.o))
            },
            token: t,
            providedIn: 'root',
          })),
          t
        )
      })()
      const D = [
          { provide: r.B, useValue: i.t },
          {
            provide: r.C,
            useValue: function () {
              o.makeCurrent(), h.init()
            },
            multi: !0,
          },
          {
            provide: i.d,
            useFactory: function () {
              return Object(r.tb)(document), document
            },
            deps: [],
          },
        ],
        L = Object(r.R)(r.W, 'browser', D),
        F = [
          [],
          { provide: r.Z, useValue: 'root' },
          {
            provide: r.m,
            useFactory: function () {
              return new r.m()
            },
            deps: [],
          },
          { provide: d, useClass: O, multi: !0, deps: [i.d, r.z, r.B] },
          { provide: d, useClass: j, multi: !0, deps: [i.d] },
          [],
          { provide: w, useClass: w, deps: [p, g, r.c] },
          { provide: r.F, useExisting: w },
          { provide: m, useExisting: g },
          { provide: g, useClass: g, deps: [i.d] },
          { provide: r.M, useClass: r.M, deps: [r.z] },
          { provide: p, useClass: p, deps: [d, r.z] },
          [],
        ]
      let N = (() => {
        class t {
          constructor(t) {
            if (t)
              throw new Error(
                'BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.'
              )
          }
          static withServerTransition(e) {
            return {
              ngModule: t,
              providers: [
                { provide: r.c, useValue: e.appId },
                { provide: c, useExisting: r.c },
                u,
              ],
            }
          }
        }
        return (
          (t.ɵmod = r.Jb({ type: t })),
          (t.ɵinj = r.Ib({
            factory: function (e) {
              return new (e || t)(r.Ub(t, 12))
            },
            providers: F,
            imports: [i.c, r.f],
          })),
          t
        )
      })()
      'undefined' != typeof window && window
    },
    kJWO: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return i
      })
      const i = (() =>
        ('function' == typeof Symbol && Symbol.observable) || '@@observable')()
    },
    kSER: function (t, e) {
      t.exports = function (t, e) {
        for (var n = [], i = (e = e || 0) || 0; i < t.length; i++)
          n[i - e] = t[i]
        return n
      }
    },
    kmnG: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return X
      }),
        n.d(e, 'b', function () {
          return N
        }),
        n.d(e, 'c', function () {
          return K
        }),
        n.d(e, 'd', function () {
          return V
        }),
        n.d(e, 'e', function () {
          return Y
        }),
        n.d(e, 'f', function () {
          return B
        })
      var i = n('GU7r'),
        r = n('ofXK'),
        s = n('fXoL'),
        o = n('FKr1'),
        a = n('8LU1'),
        l = n('XNiG'),
        c = n('VRyK'),
        u = n('xgIS'),
        h = n('JX91'),
        d = n('1G5W'),
        p = n('IzEk'),
        f = n('R0Ic'),
        m = n('R1ws'),
        g = n('cH1L'),
        b = n('nLfN')
      const _ = ['underline'],
        y = ['connectionContainer'],
        v = ['inputContainer'],
        w = ['label']
      function C(t, e) {
        1 & t &&
          (s.Ob(0),
          s.Qb(1, 'div', 14),
          s.Mb(2, 'div', 15),
          s.Mb(3, 'div', 16),
          s.Mb(4, 'div', 17),
          s.Pb(),
          s.Qb(5, 'div', 18),
          s.Mb(6, 'div', 15),
          s.Mb(7, 'div', 16),
          s.Mb(8, 'div', 17),
          s.Pb(),
          s.Nb())
      }
      function x(t, e) {
        1 & t && (s.Qb(0, 'div', 19), s.ec(1, 1), s.Pb())
      }
      function S(t, e) {
        if (
          (1 & t &&
            (s.Ob(0), s.ec(1, 2), s.Qb(2, 'span'), s.xc(3), s.Pb(), s.Nb()),
          2 & t)
        ) {
          const t = s.bc(2)
          s.zb(3), s.yc(t._control.placeholder)
        }
      }
      function O(t, e) {
        1 & t && s.ec(0, 3, ['*ngSwitchCase', 'true'])
      }
      function k(t, e) {
        1 & t && (s.Qb(0, 'span', 23), s.xc(1, ' *'), s.Pb())
      }
      function E(t, e) {
        if (1 & t) {
          const t = s.Rb()
          s.Qb(0, 'label', 20, 21),
            s.Xb('cdkObserveContent', function () {
              return s.nc(t), s.bc().updateOutlineGap()
            }),
            s.vc(2, S, 4, 1, 'ng-container', 12),
            s.vc(3, O, 1, 0, 'ng-content', 12),
            s.vc(4, k, 2, 0, 'span', 22),
            s.Pb()
        }
        if (2 & t) {
          const t = s.bc()
          s.Db('mat-empty', t._control.empty && !t._shouldAlwaysFloat())(
            'mat-form-field-empty',
            t._control.empty && !t._shouldAlwaysFloat()
          )('mat-accent', 'accent' == t.color)('mat-warn', 'warn' == t.color),
            s.gc('cdkObserveContentDisabled', 'outline' != t.appearance)(
              'id',
              t._labelId
            )('ngSwitch', t._hasLabel()),
            s.Ab('for', t._control.id)('aria-owns', t._control.id),
            s.zb(2),
            s.gc('ngSwitchCase', !1),
            s.zb(1),
            s.gc('ngSwitchCase', !0),
            s.zb(1),
            s.gc(
              'ngIf',
              !t.hideRequiredMarker &&
                t._control.required &&
                !t._control.disabled
            )
        }
      }
      function A(t, e) {
        1 & t && (s.Qb(0, 'div', 24), s.ec(1, 4), s.Pb())
      }
      function T(t, e) {
        if (
          (1 & t && (s.Qb(0, 'div', 25, 26), s.Mb(2, 'span', 27), s.Pb()),
          2 & t)
        ) {
          const t = s.bc()
          s.zb(2),
            s.Db('mat-accent', 'accent' == t.color)(
              'mat-warn',
              'warn' == t.color
            )
        }
      }
      function j(t, e) {
        if ((1 & t && (s.Qb(0, 'div'), s.ec(1, 5), s.Pb()), 2 & t)) {
          const t = s.bc()
          s.gc('@transitionMessages', t._subscriptAnimationState)
        }
      }
      function I(t, e) {
        if ((1 & t && (s.Qb(0, 'div', 31), s.xc(1), s.Pb()), 2 & t)) {
          const t = s.bc(2)
          s.gc('id', t._hintLabelId), s.zb(1), s.yc(t.hintLabel)
        }
      }
      function P(t, e) {
        if (
          (1 & t &&
            (s.Qb(0, 'div', 28),
            s.vc(1, I, 2, 2, 'div', 29),
            s.ec(2, 6),
            s.Mb(3, 'div', 30),
            s.ec(4, 7),
            s.Pb()),
          2 & t)
        ) {
          const t = s.bc()
          s.gc('@transitionMessages', t._subscriptAnimationState),
            s.zb(1),
            s.gc('ngIf', t.hintLabel)
        }
      }
      const R = [
          '*',
          [['', 'matPrefix', '']],
          [['mat-placeholder']],
          [['mat-label']],
          [['', 'matSuffix', '']],
          [['mat-error']],
          [['mat-hint', 3, 'align', 'end']],
          [['mat-hint', 'align', 'end']],
        ],
        D = [
          '*',
          '[matPrefix]',
          'mat-placeholder',
          'mat-label',
          '[matSuffix]',
          'mat-error',
          "mat-hint:not([align='end'])",
          "mat-hint[align='end']",
        ]
      let L = 0
      const F = new s.q('MatError')
      let N = (() => {
        class t {
          constructor() {
            this.id = 'mat-error-' + L++
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵdir = s.Gb({
            type: t,
            selectors: [['mat-error']],
            hostAttrs: ['role', 'alert', 1, 'mat-error'],
            hostVars: 1,
            hostBindings: function (t, e) {
              2 & t && s.Ab('id', e.id)
            },
            inputs: { id: 'id' },
            features: [s.yb([{ provide: F, useExisting: t }])],
          })),
          t
        )
      })()
      const M = {
        transitionMessages: Object(f.n)('transitionMessages', [
          Object(f.k)(
            'enter',
            Object(f.l)({ opacity: 1, transform: 'translateY(0%)' })
          ),
          Object(f.m)('void => enter', [
            Object(f.l)({ opacity: 0, transform: 'translateY(-100%)' }),
            Object(f.e)('300ms cubic-bezier(0.55, 0, 0.55, 0.2)'),
          ]),
        ]),
      }
      let V = (() => {
        class t {}
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵdir = s.Gb({ type: t })),
          t
        )
      })()
      const U = new s.q('MatHint')
      let B = (() => {
          class t {}
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵdir = s.Gb({ type: t, selectors: [['mat-label']] })),
            t
          )
        })(),
        z = (() => {
          class t {}
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵdir = s.Gb({ type: t, selectors: [['mat-placeholder']] })),
            t
          )
        })()
      const H = new s.q('MatPrefix'),
        q = new s.q('MatSuffix')
      let W = 0
      class $ {
        constructor(t) {
          this._elementRef = t
        }
      }
      const G = Object(o.o)($, 'primary'),
        Q = new s.q('MAT_FORM_FIELD_DEFAULT_OPTIONS'),
        X = new s.q('MatFormField')
      let K = (() => {
          class t extends G {
            constructor(t, e, n, i, r, s, o, a) {
              super(t),
                (this._elementRef = t),
                (this._changeDetectorRef = e),
                (this._dir = i),
                (this._defaults = r),
                (this._platform = s),
                (this._ngZone = o),
                (this._outlineGapCalculationNeededImmediately = !1),
                (this._outlineGapCalculationNeededOnStable = !1),
                (this._destroyed = new l.a()),
                (this._showAlwaysAnimate = !1),
                (this._subscriptAnimationState = ''),
                (this._hintLabel = ''),
                (this._hintLabelId = 'mat-hint-' + W++),
                (this._labelId = 'mat-form-field-label-' + W++),
                (this.floatLabel = this._getDefaultFloatLabelState()),
                (this._animationsEnabled = 'NoopAnimations' !== a),
                (this.appearance = r && r.appearance ? r.appearance : 'legacy'),
                (this._hideRequiredMarker =
                  !(!r || null == r.hideRequiredMarker) && r.hideRequiredMarker)
            }
            get appearance() {
              return this._appearance
            }
            set appearance(t) {
              const e = this._appearance
              ;(this._appearance =
                t || (this._defaults && this._defaults.appearance) || 'legacy'),
                'outline' === this._appearance &&
                  e !== t &&
                  (this._outlineGapCalculationNeededOnStable = !0)
            }
            get hideRequiredMarker() {
              return this._hideRequiredMarker
            }
            set hideRequiredMarker(t) {
              this._hideRequiredMarker = Object(a.b)(t)
            }
            _shouldAlwaysFloat() {
              return 'always' === this.floatLabel && !this._showAlwaysAnimate
            }
            _canLabelFloat() {
              return 'never' !== this.floatLabel
            }
            get hintLabel() {
              return this._hintLabel
            }
            set hintLabel(t) {
              ;(this._hintLabel = t), this._processHints()
            }
            get floatLabel() {
              return 'legacy' !== this.appearance &&
                'never' === this._floatLabel
                ? 'auto'
                : this._floatLabel
            }
            set floatLabel(t) {
              t !== this._floatLabel &&
                ((this._floatLabel = t || this._getDefaultFloatLabelState()),
                this._changeDetectorRef.markForCheck())
            }
            get _control() {
              return (
                this._explicitFormFieldControl ||
                this._controlNonStatic ||
                this._controlStatic
              )
            }
            set _control(t) {
              this._explicitFormFieldControl = t
            }
            getLabelId() {
              return this._hasFloatingLabel() ? this._labelId : null
            }
            getConnectedOverlayOrigin() {
              return this._connectionContainerRef || this._elementRef
            }
            ngAfterContentInit() {
              this._validateControlChild()
              const t = this._control
              t.controlType &&
                this._elementRef.nativeElement.classList.add(
                  'mat-form-field-type-' + t.controlType
                ),
                t.stateChanges.pipe(Object(h.a)(null)).subscribe(() => {
                  this._validatePlaceholders(),
                    this._syncDescribedByIds(),
                    this._changeDetectorRef.markForCheck()
                }),
                t.ngControl &&
                  t.ngControl.valueChanges &&
                  t.ngControl.valueChanges
                    .pipe(Object(d.a)(this._destroyed))
                    .subscribe(() => this._changeDetectorRef.markForCheck()),
                this._ngZone.runOutsideAngular(() => {
                  this._ngZone.onStable
                    .pipe(Object(d.a)(this._destroyed))
                    .subscribe(() => {
                      this._outlineGapCalculationNeededOnStable &&
                        this.updateOutlineGap()
                    })
                }),
                Object(c.a)(
                  this._prefixChildren.changes,
                  this._suffixChildren.changes
                ).subscribe(() => {
                  ;(this._outlineGapCalculationNeededOnStable = !0),
                    this._changeDetectorRef.markForCheck()
                }),
                this._hintChildren.changes
                  .pipe(Object(h.a)(null))
                  .subscribe(() => {
                    this._processHints(), this._changeDetectorRef.markForCheck()
                  }),
                this._errorChildren.changes
                  .pipe(Object(h.a)(null))
                  .subscribe(() => {
                    this._syncDescribedByIds(),
                      this._changeDetectorRef.markForCheck()
                  }),
                this._dir &&
                  this._dir.change
                    .pipe(Object(d.a)(this._destroyed))
                    .subscribe(() => {
                      'function' == typeof requestAnimationFrame
                        ? this._ngZone.runOutsideAngular(() => {
                            requestAnimationFrame(() => this.updateOutlineGap())
                          })
                        : this.updateOutlineGap()
                    })
            }
            ngAfterContentChecked() {
              this._validateControlChild(),
                this._outlineGapCalculationNeededImmediately &&
                  this.updateOutlineGap()
            }
            ngAfterViewInit() {
              ;(this._subscriptAnimationState = 'enter'),
                this._changeDetectorRef.detectChanges()
            }
            ngOnDestroy() {
              this._destroyed.next(), this._destroyed.complete()
            }
            _shouldForward(t) {
              const e = this._control ? this._control.ngControl : null
              return e && e[t]
            }
            _hasPlaceholder() {
              return !!(
                (this._control && this._control.placeholder) ||
                this._placeholderChild
              )
            }
            _hasLabel() {
              return !(!this._labelChildNonStatic && !this._labelChildStatic)
            }
            _shouldLabelFloat() {
              return (
                this._canLabelFloat() &&
                ((this._control && this._control.shouldLabelFloat) ||
                  this._shouldAlwaysFloat())
              )
            }
            _hideControlPlaceholder() {
              return (
                ('legacy' === this.appearance && !this._hasLabel()) ||
                (this._hasLabel() && !this._shouldLabelFloat())
              )
            }
            _hasFloatingLabel() {
              return (
                this._hasLabel() ||
                ('legacy' === this.appearance && this._hasPlaceholder())
              )
            }
            _getDisplayedMessages() {
              return this._errorChildren &&
                this._errorChildren.length > 0 &&
                this._control.errorState
                ? 'error'
                : 'hint'
            }
            _animateAndLockLabel() {
              this._hasFloatingLabel() &&
                this._canLabelFloat() &&
                (this._animationsEnabled &&
                  this._label &&
                  ((this._showAlwaysAnimate = !0),
                  Object(u.a)(this._label.nativeElement, 'transitionend')
                    .pipe(Object(p.a)(1))
                    .subscribe(() => {
                      this._showAlwaysAnimate = !1
                    })),
                (this.floatLabel = 'always'),
                this._changeDetectorRef.markForCheck())
            }
            _validatePlaceholders() {}
            _processHints() {
              this._validateHints(), this._syncDescribedByIds()
            }
            _validateHints() {}
            _getDefaultFloatLabelState() {
              return (this._defaults && this._defaults.floatLabel) || 'auto'
            }
            _syncDescribedByIds() {
              if (this._control) {
                let t = []
                if (
                  (this._control.userAriaDescribedBy &&
                    'string' == typeof this._control.userAriaDescribedBy &&
                    t.push(...this._control.userAriaDescribedBy.split(' ')),
                  'hint' === this._getDisplayedMessages())
                ) {
                  const e = this._hintChildren
                      ? this._hintChildren.find((t) => 'start' === t.align)
                      : null,
                    n = this._hintChildren
                      ? this._hintChildren.find((t) => 'end' === t.align)
                      : null
                  e
                    ? t.push(e.id)
                    : this._hintLabel && t.push(this._hintLabelId),
                    n && t.push(n.id)
                } else
                  this._errorChildren &&
                    t.push(...this._errorChildren.map((t) => t.id))
                this._control.setDescribedByIds(t)
              }
            }
            _validateControlChild() {}
            updateOutlineGap() {
              const t = this._label ? this._label.nativeElement : null
              if (
                'outline' !== this.appearance ||
                !t ||
                !t.children.length ||
                !t.textContent.trim()
              )
                return
              if (!this._platform.isBrowser) return
              if (!this._isAttachedToDOM())
                return void (this._outlineGapCalculationNeededImmediately = !0)
              let e = 0,
                n = 0
              const i = this._connectionContainerRef.nativeElement,
                r = i.querySelectorAll('.mat-form-field-outline-start'),
                s = i.querySelectorAll('.mat-form-field-outline-gap')
              if (this._label && this._label.nativeElement.children.length) {
                const r = i.getBoundingClientRect()
                if (0 === r.width && 0 === r.height)
                  return (
                    (this._outlineGapCalculationNeededOnStable = !0),
                    void (this._outlineGapCalculationNeededImmediately = !1)
                  )
                const s = this._getStartEnd(r),
                  o = t.children,
                  a = this._getStartEnd(o[0].getBoundingClientRect())
                let l = 0
                for (let t = 0; t < o.length; t++) l += o[t].offsetWidth
                ;(e = Math.abs(a - s) - 5), (n = l > 0 ? 0.75 * l + 10 : 0)
              }
              for (let o = 0; o < r.length; o++) r[o].style.width = e + 'px'
              for (let o = 0; o < s.length; o++) s[o].style.width = n + 'px'
              this._outlineGapCalculationNeededOnStable = this._outlineGapCalculationNeededImmediately = !1
            }
            _getStartEnd(t) {
              return this._dir && 'rtl' === this._dir.value ? t.right : t.left
            }
            _isAttachedToDOM() {
              const t = this._elementRef.nativeElement
              if (t.getRootNode) {
                const e = t.getRootNode()
                return e && e !== t
              }
              return document.documentElement.contains(t)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                s.Lb(s.l),
                s.Lb(s.h),
                s.Lb(s.l),
                s.Lb(g.b, 8),
                s.Lb(Q, 8),
                s.Lb(b.a),
                s.Lb(s.z),
                s.Lb(m.a, 8)
              )
            }),
            (t.ɵcmp = s.Fb({
              type: t,
              selectors: [['mat-form-field']],
              contentQueries: function (t, e, n) {
                if (
                  (1 & t &&
                    (s.Eb(n, V, !0),
                    s.qc(n, V, !0),
                    s.Eb(n, B, !0),
                    s.qc(n, B, !0),
                    s.Eb(n, z, !0),
                    s.Eb(n, F, !0),
                    s.Eb(n, U, !0),
                    s.Eb(n, H, !0),
                    s.Eb(n, q, !0)),
                  2 & t)
                ) {
                  let t
                  s.jc((t = s.Yb())) && (e._controlNonStatic = t.first),
                    s.jc((t = s.Yb())) && (e._controlStatic = t.first),
                    s.jc((t = s.Yb())) && (e._labelChildNonStatic = t.first),
                    s.jc((t = s.Yb())) && (e._labelChildStatic = t.first),
                    s.jc((t = s.Yb())) && (e._placeholderChild = t.first),
                    s.jc((t = s.Yb())) && (e._errorChildren = t),
                    s.jc((t = s.Yb())) && (e._hintChildren = t),
                    s.jc((t = s.Yb())) && (e._prefixChildren = t),
                    s.jc((t = s.Yb())) && (e._suffixChildren = t)
                }
              },
              viewQuery: function (t, e) {
                if (
                  (1 & t &&
                    (s.Ac(_, !0), s.rc(y, !0), s.Ac(v, !0), s.Ac(w, !0)),
                  2 & t)
                ) {
                  let t
                  s.jc((t = s.Yb())) && (e.underlineRef = t.first),
                    s.jc((t = s.Yb())) && (e._connectionContainerRef = t.first),
                    s.jc((t = s.Yb())) && (e._inputContainerRef = t.first),
                    s.jc((t = s.Yb())) && (e._label = t.first)
                }
              },
              hostAttrs: [1, 'mat-form-field'],
              hostVars: 44,
              hostBindings: function (t, e) {
                2 & t &&
                  s.Db(
                    'mat-form-field-appearance-standard',
                    'standard' == e.appearance
                  )('mat-form-field-appearance-fill', 'fill' == e.appearance)(
                    'mat-form-field-appearance-outline',
                    'outline' == e.appearance
                  )(
                    'mat-form-field-appearance-legacy',
                    'legacy' == e.appearance
                  )('mat-form-field-invalid', e._control.errorState)(
                    'mat-form-field-can-float',
                    e._canLabelFloat()
                  )('mat-form-field-should-float', e._shouldLabelFloat())(
                    'mat-form-field-has-label',
                    e._hasFloatingLabel()
                  )(
                    'mat-form-field-hide-placeholder',
                    e._hideControlPlaceholder()
                  )('mat-form-field-disabled', e._control.disabled)(
                    'mat-form-field-autofilled',
                    e._control.autofilled
                  )('mat-focused', e._control.focused)(
                    'mat-accent',
                    'accent' == e.color
                  )('mat-warn', 'warn' == e.color)(
                    'ng-untouched',
                    e._shouldForward('untouched')
                  )('ng-touched', e._shouldForward('touched'))(
                    'ng-pristine',
                    e._shouldForward('pristine')
                  )('ng-dirty', e._shouldForward('dirty'))(
                    'ng-valid',
                    e._shouldForward('valid')
                  )('ng-invalid', e._shouldForward('invalid'))(
                    'ng-pending',
                    e._shouldForward('pending')
                  )('_mat-animation-noopable', !e._animationsEnabled)
              },
              inputs: {
                color: 'color',
                floatLabel: 'floatLabel',
                appearance: 'appearance',
                hideRequiredMarker: 'hideRequiredMarker',
                hintLabel: 'hintLabel',
              },
              exportAs: ['matFormField'],
              features: [s.yb([{ provide: X, useExisting: t }]), s.wb],
              ngContentSelectors: D,
              decls: 15,
              vars: 8,
              consts: [
                [1, 'mat-form-field-wrapper'],
                [1, 'mat-form-field-flex', 3, 'click'],
                ['connectionContainer', ''],
                [4, 'ngIf'],
                ['class', 'mat-form-field-prefix', 4, 'ngIf'],
                [1, 'mat-form-field-infix'],
                ['inputContainer', ''],
                [1, 'mat-form-field-label-wrapper'],
                [
                  'class',
                  'mat-form-field-label',
                  3,
                  'cdkObserveContentDisabled',
                  'id',
                  'mat-empty',
                  'mat-form-field-empty',
                  'mat-accent',
                  'mat-warn',
                  'ngSwitch',
                  'cdkObserveContent',
                  4,
                  'ngIf',
                ],
                ['class', 'mat-form-field-suffix', 4, 'ngIf'],
                ['class', 'mat-form-field-underline', 4, 'ngIf'],
                [1, 'mat-form-field-subscript-wrapper', 3, 'ngSwitch'],
                [4, 'ngSwitchCase'],
                ['class', 'mat-form-field-hint-wrapper', 4, 'ngSwitchCase'],
                [1, 'mat-form-field-outline'],
                [1, 'mat-form-field-outline-start'],
                [1, 'mat-form-field-outline-gap'],
                [1, 'mat-form-field-outline-end'],
                [1, 'mat-form-field-outline', 'mat-form-field-outline-thick'],
                [1, 'mat-form-field-prefix'],
                [
                  1,
                  'mat-form-field-label',
                  3,
                  'cdkObserveContentDisabled',
                  'id',
                  'ngSwitch',
                  'cdkObserveContent',
                ],
                ['label', ''],
                [
                  'class',
                  'mat-placeholder-required mat-form-field-required-marker',
                  'aria-hidden',
                  'true',
                  4,
                  'ngIf',
                ],
                [
                  'aria-hidden',
                  'true',
                  1,
                  'mat-placeholder-required',
                  'mat-form-field-required-marker',
                ],
                [1, 'mat-form-field-suffix'],
                [1, 'mat-form-field-underline'],
                ['underline', ''],
                [1, 'mat-form-field-ripple'],
                [1, 'mat-form-field-hint-wrapper'],
                ['class', 'mat-hint', 3, 'id', 4, 'ngIf'],
                [1, 'mat-form-field-hint-spacer'],
                [1, 'mat-hint', 3, 'id'],
              ],
              template: function (t, e) {
                1 & t &&
                  (s.fc(R),
                  s.Qb(0, 'div', 0),
                  s.Qb(1, 'div', 1, 2),
                  s.Xb('click', function (t) {
                    return (
                      e._control.onContainerClick &&
                      e._control.onContainerClick(t)
                    )
                  }),
                  s.vc(3, C, 9, 0, 'ng-container', 3),
                  s.vc(4, x, 2, 0, 'div', 4),
                  s.Qb(5, 'div', 5, 6),
                  s.ec(7),
                  s.Qb(8, 'span', 7),
                  s.vc(9, E, 5, 16, 'label', 8),
                  s.Pb(),
                  s.Pb(),
                  s.vc(10, A, 2, 0, 'div', 9),
                  s.Pb(),
                  s.vc(11, T, 3, 4, 'div', 10),
                  s.Qb(12, 'div', 11),
                  s.vc(13, j, 2, 1, 'div', 12),
                  s.vc(14, P, 5, 2, 'div', 13),
                  s.Pb(),
                  s.Pb()),
                  2 & t &&
                    (s.zb(3),
                    s.gc('ngIf', 'outline' == e.appearance),
                    s.zb(1),
                    s.gc('ngIf', e._prefixChildren.length),
                    s.zb(5),
                    s.gc('ngIf', e._hasFloatingLabel()),
                    s.zb(1),
                    s.gc('ngIf', e._suffixChildren.length),
                    s.zb(1),
                    s.gc('ngIf', 'outline' != e.appearance),
                    s.zb(1),
                    s.gc('ngSwitch', e._getDisplayedMessages()),
                    s.zb(1),
                    s.gc('ngSwitchCase', 'error'),
                    s.zb(1),
                    s.gc('ngSwitchCase', 'hint'))
              },
              directives: [r.k, r.l, r.m, i.a],
              styles: [
                '.mat-form-field{display:inline-block;position:relative;text-align:left}[dir=rtl] .mat-form-field{text-align:right}.mat-form-field-wrapper{position:relative}.mat-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-form-field-prefix,.mat-form-field-suffix{white-space:nowrap;flex:none;position:relative}.mat-form-field-infix{display:block;position:relative;flex:auto;min-width:0;width:180px}.cdk-high-contrast-active .mat-form-field-infix{border-image:linear-gradient(transparent, transparent)}.mat-form-field-label-wrapper{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;overflow:hidden;pointer-events:none}[dir=rtl] .mat-form-field-label-wrapper{left:auto;right:0}.mat-form-field-label{position:absolute;left:0;font:inherit;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),width 400ms cubic-bezier(0.25, 0.8, 0.25, 1);display:none}[dir=rtl] .mat-form-field-label{transform-origin:100% 0;left:auto;right:0}.mat-form-field-empty.mat-form-field-label,.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{display:block}.mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:block;transition:none}.mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-can-float .mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:block}.mat-form-field-label:not(.mat-form-field-empty){transition:none}.mat-form-field-underline{position:absolute;width:100%;pointer-events:none;transform:scale3d(1, 1.0001, 1)}.mat-form-field-ripple{position:absolute;left:0;width:100%;transform-origin:50%;transform:scaleX(0.5);opacity:0;transition:background-color 300ms cubic-bezier(0.55, 0, 0.55, 0.2)}.mat-form-field.mat-focused .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple{opacity:1;transform:scaleX(1);transition:transform 300ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 300ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-subscript-wrapper{position:absolute;box-sizing:border-box;width:100%;overflow:hidden}.mat-form-field-subscript-wrapper .mat-icon,.mat-form-field-label-wrapper .mat-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.mat-form-field-hint-wrapper{display:flex}.mat-form-field-hint-spacer{flex:1 0 1em}.mat-error{display:block}.mat-form-field-control-wrapper{position:relative}.mat-form-field-hint-end{order:1}.mat-form-field._mat-animation-noopable .mat-form-field-label,.mat-form-field._mat-animation-noopable .mat-form-field-ripple{transition:none}\n',
                '.mat-form-field-appearance-fill .mat-form-field-flex{border-radius:4px 4px 0 0;padding:.75em .75em 0 .75em}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-flex{outline:solid 1px}.mat-form-field-appearance-fill .mat-form-field-underline::before{content:"";display:block;position:absolute;bottom:0;height:1px;width:100%}.mat-form-field-appearance-fill .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-fill:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-fill._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}.mat-form-field-appearance-fill .mat-form-field-subscript-wrapper{padding:0 1em}\n',
                '.mat-input-element{font:inherit;background:transparent;color:currentColor;border:none;outline:none;padding:0;margin:0;width:100%;max-width:100%;vertical-align:bottom;text-align:inherit}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element::-ms-clear,.mat-input-element::-ms-reveal{display:none}.mat-input-element,.mat-input-element::-webkit-search-cancel-button,.mat-input-element::-webkit-search-decoration,.mat-input-element::-webkit-search-results-button,.mat-input-element::-webkit-search-results-decoration{-webkit-appearance:none}.mat-input-element::-webkit-contacts-auto-fill-button,.mat-input-element::-webkit-caps-lock-indicator,.mat-input-element::-webkit-credentials-auto-fill-button{visibility:hidden}.mat-input-element[type=date],.mat-input-element[type=datetime],.mat-input-element[type=datetime-local],.mat-input-element[type=month],.mat-input-element[type=week],.mat-input-element[type=time]{line-height:1}.mat-input-element[type=date]::after,.mat-input-element[type=datetime]::after,.mat-input-element[type=datetime-local]::after,.mat-input-element[type=month]::after,.mat-input-element[type=week]::after,.mat-input-element[type=time]::after{content:" ";white-space:pre;width:1px}.mat-input-element::-webkit-inner-spin-button,.mat-input-element::-webkit-calendar-picker-indicator,.mat-input-element::-webkit-clear-button{font-size:.75em}.mat-input-element::placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-moz-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-moz-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-webkit-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-webkit-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element:-ms-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element:-ms-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-form-field-hide-placeholder .mat-input-element::placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}textarea.mat-input-element{resize:vertical;overflow:auto}textarea.mat-input-element.cdk-textarea-autosize{resize:none}textarea.mat-input-element{padding:2px 0;margin:-2px 0}select.mat-input-element{-moz-appearance:none;-webkit-appearance:none;position:relative;background-color:transparent;display:inline-flex;box-sizing:border-box;padding-top:1em;top:-1em;margin-bottom:-1em}select.mat-input-element::-ms-expand{display:none}select.mat-input-element::-moz-focus-inner{border:0}select.mat-input-element:not(:disabled){cursor:pointer}select.mat-input-element::-ms-value{color:inherit;background:none}.mat-focused .cdk-high-contrast-active select.mat-input-element::-ms-value{color:inherit}.mat-form-field-type-mat-native-select .mat-form-field-infix::after{content:"";width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;position:absolute;top:50%;right:0;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-form-field-type-mat-native-select .mat-form-field-infix::after{right:auto;left:0}.mat-form-field-type-mat-native-select .mat-input-element{padding-right:15px}[dir=rtl] .mat-form-field-type-mat-native-select .mat-input-element{padding-right:0;padding-left:15px}.mat-form-field-type-mat-native-select .mat-form-field-label-wrapper{max-width:calc(100% - 10px)}.mat-form-field-type-mat-native-select.mat-form-field-appearance-outline .mat-form-field-infix::after{margin-top:-5px}.mat-form-field-type-mat-native-select.mat-form-field-appearance-fill .mat-form-field-infix::after{margin-top:-10px}\n',
                '.mat-form-field-appearance-legacy .mat-form-field-label{transform:perspective(100px);-ms-transform:none}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon{width:1em}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button{font:inherit;vertical-align:baseline}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button .mat-icon{font-size:inherit}.mat-form-field-appearance-legacy .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-legacy .mat-form-field-ripple{top:0;height:2px;overflow:hidden}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-legacy.mat-form-field-invalid:not(.mat-focused) .mat-form-field-ripple{height:1px}\n',
                '.mat-form-field-appearance-outline .mat-form-field-wrapper{margin:.25em 0}.mat-form-field-appearance-outline .mat-form-field-flex{padding:0 .75em 0 .75em;margin-top:-0.25em;position:relative}.mat-form-field-appearance-outline .mat-form-field-prefix,.mat-form-field-appearance-outline .mat-form-field-suffix{top:.25em}.mat-form-field-appearance-outline .mat-form-field-outline{display:flex;position:absolute;top:.25em;left:0;right:0;bottom:0;pointer-events:none}.mat-form-field-appearance-outline .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-end{border:1px solid currentColor;min-width:5px}.mat-form-field-appearance-outline .mat-form-field-outline-start{border-radius:5px 0 0 5px;border-right-style:none}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-start{border-right-style:solid;border-left-style:none;border-radius:0 5px 5px 0}.mat-form-field-appearance-outline .mat-form-field-outline-end{border-radius:0 5px 5px 0;border-left-style:none;flex-grow:1}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-end{border-left-style:solid;border-right-style:none;border-radius:5px 0 0 5px}.mat-form-field-appearance-outline .mat-form-field-outline-gap{border-radius:.000001px;border:1px solid currentColor;border-left-style:none;border-right-style:none}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-outline-gap{border-top-color:transparent}.mat-form-field-appearance-outline .mat-form-field-outline-thick{opacity:0}.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-gap{border-width:2px}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline{opacity:0;transition:opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline{opacity:0;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{padding:0 1em}.mat-form-field-appearance-outline._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-start,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-end,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-gap{transition:none}\n',
                '.mat-form-field-appearance-standard .mat-form-field-flex{padding-top:.75em}.mat-form-field-appearance-standard .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-standard .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-ripple{height:0;border-top:2px}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-standard:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-standard._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}\n',
              ],
              encapsulation: 2,
              data: { animation: [M.transitionMessages] },
              changeDetection: 0,
            })),
            t
          )
        })(),
        Y = (() => {
          class t {}
          return (
            (t.ɵmod = s.Jb({ type: t })),
            (t.ɵinj = s.Ib({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[r.c, o.d, i.c], o.d],
            })),
            t
          )
        })()
    },
    l7GE: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return r
      })
      var i = n('7o/Q')
      class r extends i.a {
        notifyNext(t, e, n, i, r) {
          this.destination.next(e)
        }
        notifyError(t, e) {
          this.destination.error(t)
        }
        notifyComplete(t) {
          this.destination.complete()
        }
      }
    },
    lJxs: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return r
      })
      var i = n('7o/Q')
      function r(t, e) {
        return function (n) {
          if ('function' != typeof t)
            throw new TypeError(
              'argument is not a function. Are you looking for `mapTo()`?'
            )
          return n.lift(new s(t, e))
        }
      }
      class s {
        constructor(t, e) {
          ;(this.project = t), (this.thisArg = e)
        }
        call(t, e) {
          return e.subscribe(new o(t, this.project, this.thisArg))
        }
      }
      class o extends i.a {
        constructor(t, e, n) {
          super(t),
            (this.project = e),
            (this.count = 0),
            (this.thisArg = n || this)
        }
        _next(t) {
          let e
          try {
            e = this.project.call(this.thisArg, t, this.count++)
          } catch (n) {
            return void this.destination.error(n)
          }
          this.destination.next(e)
        }
      }
    },
    lKxJ: function (t, e, n) {
      ;(t.exports = n('2pII')), (t.exports.parser = n('Wm4p'))
    },
    luTP: function (t, e) {
      var n = {}.toString
      t.exports =
        Array.isArray ||
        function (t) {
          return '[object Array]' == n.call(t)
        }
    },
    lv48: function (t, e, n) {
      function i(t) {
        var n
        function i() {
          if (i.enabled) {
            var t = i,
              r = +new Date(),
              s = r - (n || r)
            ;(t.diff = s), (t.prev = n), (t.curr = r), (n = r)
            for (var o = new Array(arguments.length), a = 0; a < o.length; a++)
              o[a] = arguments[a]
            ;(o[0] = e.coerce(o[0])), 'string' != typeof o[0] && o.unshift('%O')
            var l = 0
            ;(o[0] = o[0].replace(/%([a-zA-Z%])/g, function (n, i) {
              if ('%%' === n) return n
              l++
              var r = e.formatters[i]
              return (
                'function' == typeof r &&
                  ((n = r.call(t, o[l])), o.splice(l, 1), l--),
                n
              )
            })),
              e.formatArgs.call(t, o)
            var c = i.log || e.log || console.log.bind(console)
            c.apply(t, o)
          }
        }
        return (
          (i.namespace = t),
          (i.enabled = e.enabled(t)),
          (i.useColors = e.useColors()),
          (i.color = (function (t) {
            var n,
              i = 0
            for (n in t) (i = (i << 5) - i + t.charCodeAt(n)), (i |= 0)
            return e.colors[Math.abs(i) % e.colors.length]
          })(t)),
          (i.destroy = r),
          'function' == typeof e.init && e.init(i),
          e.instances.push(i),
          i
        )
      }
      function r() {
        var t = e.instances.indexOf(this)
        return -1 !== t && (e.instances.splice(t, 1), !0)
      }
      ;((e = t.exports = i.debug = i.default = i).coerce = function (t) {
        return t instanceof Error ? t.stack || t.message : t
      }),
        (e.disable = function () {
          e.enable('')
        }),
        (e.enable = function (t) {
          var n
          e.save(t), (e.names = []), (e.skips = [])
          var i = ('string' == typeof t ? t : '').split(/[\s,]+/),
            r = i.length
          for (n = 0; n < r; n++)
            i[n] &&
              ('-' === (t = i[n].replace(/\*/g, '.*?'))[0]
                ? e.skips.push(new RegExp('^' + t.substr(1) + '$'))
                : e.names.push(new RegExp('^' + t + '$')))
          for (n = 0; n < e.instances.length; n++) {
            var s = e.instances[n]
            s.enabled = e.enabled(s.namespace)
          }
        }),
        (e.enabled = function (t) {
          if ('*' === t[t.length - 1]) return !0
          var n, i
          for (n = 0, i = e.skips.length; n < i; n++)
            if (e.skips[n].test(t)) return !1
          for (n = 0, i = e.names.length; n < i; n++)
            if (e.names[n].test(t)) return !0
          return !1
        }),
        (e.humanize = n('FGiv')),
        (e.instances = []),
        (e.names = []),
        (e.skips = []),
        (e.formatters = {})
    },
    mrSG: function (t, e, n) {
      'use strict'
      function i(t, e, n, i) {
        return new (n || (n = Promise))(function (r, s) {
          function o(t) {
            try {
              l(i.next(t))
            } catch (e) {
              s(e)
            }
          }
          function a(t) {
            try {
              l(i.throw(t))
            } catch (e) {
              s(e)
            }
          }
          function l(t) {
            var e
            t.done
              ? r(t.value)
              : ((e = t.value),
                e instanceof n
                  ? e
                  : new n(function (t) {
                      t(e)
                    })).then(o, a)
          }
          l((i = i.apply(t, e || [])).next())
        })
      }
      n.d(e, 'a', function () {
        return i
      })
    },
    n6bG: function (t, e, n) {
      'use strict'
      function i(t) {
        return 'function' == typeof t
      }
      n.d(e, 'a', function () {
        return i
      })
    },
    nLfN: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return u
      }),
        n.d(e, 'b', function () {
          return h
        }),
        n.d(e, 'c', function () {
          return m
        }),
        n.d(e, 'd', function () {
          return f
        }),
        n.d(e, 'e', function () {
          return d
        }),
        n.d(e, 'f', function () {
          return p
        })
      var i = n('fXoL'),
        r = n('ofXK')
      let s
      try {
        s = 'undefined' != typeof Intl && Intl.v8BreakIterator
      } catch (g) {
        s = !1
      }
      let o,
        a,
        l,
        c,
        u = (() => {
          class t {
            constructor(t) {
              ;(this._platformId = t),
                (this.isBrowser = this._platformId
                  ? Object(r.r)(this._platformId)
                  : 'object' == typeof document && !!document),
                (this.EDGE =
                  this.isBrowser && /(edge)/i.test(navigator.userAgent)),
                (this.TRIDENT =
                  this.isBrowser &&
                  /(msie|trident)/i.test(navigator.userAgent)),
                (this.BLINK =
                  this.isBrowser &&
                  !(!window.chrome && !s) &&
                  'undefined' != typeof CSS &&
                  !this.EDGE &&
                  !this.TRIDENT),
                (this.WEBKIT =
                  this.isBrowser &&
                  /AppleWebKit/i.test(navigator.userAgent) &&
                  !this.BLINK &&
                  !this.EDGE &&
                  !this.TRIDENT),
                (this.IOS =
                  this.isBrowser &&
                  /iPad|iPhone|iPod/.test(navigator.userAgent) &&
                  !('MSStream' in window)),
                (this.FIREFOX =
                  this.isBrowser &&
                  /(firefox|minefield)/i.test(navigator.userAgent)),
                (this.ANDROID =
                  this.isBrowser &&
                  /android/i.test(navigator.userAgent) &&
                  !this.TRIDENT),
                (this.SAFARI =
                  this.isBrowser &&
                  /safari/i.test(navigator.userAgent) &&
                  this.WEBKIT)
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Ub(i.B))
            }),
            (t.ɵprov = Object(i.Hb)({
              factory: function () {
                return new t(Object(i.Ub)(i.B))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        h = (() => {
          class t {}
          return (
            (t.ɵmod = i.Jb({ type: t })),
            (t.ɵinj = i.Ib({
              factory: function (e) {
                return new (e || t)()
              },
            })),
            t
          )
        })()
      function d(t) {
        return (function () {
          if (null == o && 'undefined' != typeof window)
            try {
              window.addEventListener(
                'test',
                null,
                Object.defineProperty({}, 'passive', { get: () => (o = !0) })
              )
            } finally {
              o = o || !1
            }
          return o
        })()
          ? t
          : !!t.capture
      }
      function p() {
        if (null == l)
          if (
            (('object' == typeof document && document) || (l = !1),
            'scrollBehavior' in document.documentElement.style)
          )
            l = !0
          else {
            const t = Element.prototype.scrollTo
            l = !!t && !/\{\s*\[native code\]\s*\}/.test(t.toString())
          }
        return l
      }
      function f() {
        if ('object' != typeof document || !document) return 0
        if (null == a) {
          const t = document.createElement('div'),
            e = t.style
          ;(t.dir = 'rtl'),
            (e.width = '1px'),
            (e.overflow = 'auto'),
            (e.visibility = 'hidden'),
            (e.pointerEvents = 'none'),
            (e.position = 'absolute')
          const n = document.createElement('div'),
            i = n.style
          ;(i.width = '2px'),
            (i.height = '1px'),
            t.appendChild(n),
            document.body.appendChild(t),
            (a = 0),
            0 === t.scrollLeft &&
              ((t.scrollLeft = 1), (a = 0 === t.scrollLeft ? 1 : 2)),
            t.parentNode.removeChild(t)
        }
        return a
      }
      function m(t) {
        if (
          (function () {
            if (null == c) {
              const t = 'undefined' != typeof document ? document.head : null
              c = !(!t || (!t.createShadowRoot && !t.attachShadow))
            }
            return c
          })()
        ) {
          const e = t.getRootNode ? t.getRootNode() : null
          if (
            'undefined' != typeof ShadowRoot &&
            ShadowRoot &&
            e instanceof ShadowRoot
          )
            return e
        }
        return null
      }
    },
    nYR2: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return s
      })
      var i = n('7o/Q'),
        r = n('quSY')
      function s(t) {
        return (e) => e.lift(new o(t))
      }
      class o {
        constructor(t) {
          this.callback = t
        }
        call(t, e) {
          return e.subscribe(new a(t, this.callback))
        }
      }
      class a extends i.a {
        constructor(t, e) {
          super(t), this.add(new r.a(e))
        }
      }
    },
    ngJS: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return i
      })
      const i = (t) => (e) => {
        for (let n = 0, i = t.length; n < i && !e.closed; n++) e.next(t[n])
        e.complete()
      }
    },
    oB13: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return u
      })
      var i = n('XNiG'),
        r = n('HDdC'),
        s = (n('7o/Q'), n('quSY')),
        o = n('x+ZX')
      class a extends r.a {
        constructor(t, e) {
          super(),
            (this.source = t),
            (this.subjectFactory = e),
            (this._refCount = 0),
            (this._isComplete = !1)
        }
        _subscribe(t) {
          return this.getSubject().subscribe(t)
        }
        getSubject() {
          const t = this._subject
          return (
            (t && !t.isStopped) || (this._subject = this.subjectFactory()),
            this._subject
          )
        }
        connect() {
          let t = this._connection
          return (
            t ||
              ((this._isComplete = !1),
              (t = this._connection = new s.a()),
              t.add(this.source.subscribe(new c(this.getSubject(), this))),
              t.closed && ((this._connection = null), (t = s.a.EMPTY))),
            t
          )
        }
        refCount() {
          return Object(o.a)()(this)
        }
      }
      const l = (() => {
        const t = a.prototype
        return {
          operator: { value: null },
          _refCount: { value: 0, writable: !0 },
          _subject: { value: null, writable: !0 },
          _connection: { value: null, writable: !0 },
          _subscribe: { value: t._subscribe },
          _isComplete: { value: t._isComplete, writable: !0 },
          getSubject: { value: t.getSubject },
          connect: { value: t.connect },
          refCount: { value: t.refCount },
        }
      })()
      class c extends i.b {
        constructor(t, e) {
          super(t), (this.connectable = e)
        }
        _error(t) {
          this._unsubscribe(), super._error(t)
        }
        _complete() {
          ;(this.connectable._isComplete = !0),
            this._unsubscribe(),
            super._complete()
        }
        _unsubscribe() {
          const t = this.connectable
          if (t) {
            this.connectable = null
            const e = t._connection
            ;(t._refCount = 0),
              (t._subject = null),
              (t._connection = null),
              e && e.unsubscribe()
          }
        }
      }
      function u(t, e) {
        return function (n) {
          let i
          if (
            ((i =
              'function' == typeof t
                ? t
                : function () {
                    return t
                  }),
            'function' == typeof e)
          )
            return n.lift(new h(i, e))
          const r = Object.create(n, l)
          return (r.source = n), (r.subjectFactory = i), r
        }
      }
      class h {
        constructor(t, e) {
          ;(this.subjectFactory = t), (this.selector = e)
        }
        call(t, e) {
          const { selector: n } = this,
            i = this.subjectFactory(),
            r = n(i).subscribe(t)
          return r.add(e.subscribe(i)), r
        }
      }
    },
    'oIG/': function (t, e) {
      var n,
        i,
        r,
        s = String.fromCharCode
      function o(t) {
        for (var e, n, i = [], r = 0, s = t.length; r < s; )
          (e = t.charCodeAt(r++)) >= 55296 && e <= 56319 && r < s
            ? 56320 == (64512 & (n = t.charCodeAt(r++)))
              ? i.push(((1023 & e) << 10) + (1023 & n) + 65536)
              : (i.push(e), r--)
            : i.push(e)
        return i
      }
      function a(t, e) {
        if (t >= 55296 && t <= 57343) {
          if (e)
            throw Error(
              'Lone surrogate U+' +
                t.toString(16).toUpperCase() +
                ' is not a scalar value'
            )
          return !1
        }
        return !0
      }
      function l(t, e) {
        return s(((t >> e) & 63) | 128)
      }
      function c(t, e) {
        if (0 == (4294967168 & t)) return s(t)
        var n = ''
        return (
          0 == (4294965248 & t)
            ? (n = s(((t >> 6) & 31) | 192))
            : 0 == (4294901760 & t)
            ? (a(t, e) || (t = 65533),
              (n = s(((t >> 12) & 15) | 224)),
              (n += l(t, 6)))
            : 0 == (4292870144 & t) &&
              ((n = s(((t >> 18) & 7) | 240)), (n += l(t, 12)), (n += l(t, 6))),
          n + s((63 & t) | 128)
        )
      }
      function u() {
        if (r >= i) throw Error('Invalid byte index')
        var t = 255 & n[r]
        if ((r++, 128 == (192 & t))) return 63 & t
        throw Error('Invalid continuation byte')
      }
      function h(t) {
        var e, s
        if (r > i) throw Error('Invalid byte index')
        if (r == i) return !1
        if (((e = 255 & n[r]), r++, 0 == (128 & e))) return e
        if (192 == (224 & e)) {
          if ((s = ((31 & e) << 6) | u()) >= 128) return s
          throw Error('Invalid continuation byte')
        }
        if (224 == (240 & e)) {
          if ((s = ((15 & e) << 12) | (u() << 6) | u()) >= 2048)
            return a(s, t) ? s : 65533
          throw Error('Invalid continuation byte')
        }
        if (
          240 == (248 & e) &&
          (s = ((7 & e) << 18) | (u() << 12) | (u() << 6) | u()) >= 65536 &&
          s <= 1114111
        )
          return s
        throw Error('Invalid UTF-8 detected')
      }
      t.exports = {
        version: '2.1.2',
        encode: function (t, e) {
          for (
            var n = !1 !== (e = e || {}).strict,
              i = o(t),
              r = i.length,
              s = -1,
              a = '';
            ++s < r;

          )
            a += c(i[s], n)
          return a
        },
        decode: function (t, e) {
          var a = !1 !== (e = e || {}).strict
          ;(n = o(t)), (i = n.length), (r = 0)
          for (var l, c = []; !1 !== (l = h(a)); ) c.push(l)
          return (function (t) {
            for (var e, n = t.length, i = -1, r = ''; ++i < n; )
              (e = t[i]) > 65535 &&
                ((r += s((((e -= 65536) >>> 10) & 1023) | 55296)),
                (e = 56320 | (1023 & e))),
                (r += s(e))
            return r
          })(c)
        },
      }
    },
    ofXK: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return v
      }),
        n.d(e, 'b', function () {
          return $
        }),
        n.d(e, 'c', function () {
          return G
        }),
        n.d(e, 'd', function () {
          return l
        }),
        n.d(e, 'e', function () {
          return C
        }),
        n.d(e, 'f', function () {
          return h
        }),
        n.d(e, 'g', function () {
          return x
        }),
        n.d(e, 'h', function () {
          return _
        }),
        n.d(e, 'i', function () {
          return I
        }),
        n.d(e, 'j', function () {
          return R
        }),
        n.d(e, 'k', function () {
          return L
        }),
        n.d(e, 'l', function () {
          return V
        }),
        n.d(e, 'm', function () {
          return U
        }),
        n.d(e, 'n', function () {
          return B
        }),
        n.d(e, 'o', function () {
          return w
        }),
        n.d(e, 'p', function () {
          return c
        }),
        n.d(e, 'q', function () {
          return K
        }),
        n.d(e, 'r', function () {
          return X
        }),
        n.d(e, 's', function () {
          return a
        }),
        n.d(e, 't', function () {
          return Q
        }),
        n.d(e, 'u', function () {
          return s
        }),
        n.d(e, 'v', function () {
          return j
        }),
        n.d(e, 'w', function () {
          return o
        })
      var i = n('fXoL')
      let r = null
      function s() {
        return r
      }
      function o(t) {
        r || (r = t)
      }
      class a {}
      const l = new i.q('DocumentToken')
      let c = (() => {
        class t {}
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵprov = Object(i.Hb)({
            factory: u,
            token: t,
            providedIn: 'platform',
          })),
          t
        )
      })()
      function u() {
        return Object(i.Ub)(d)
      }
      const h = new i.q('Location Initialized')
      let d = (() => {
        class t extends c {
          constructor(t) {
            super(), (this._doc = t), this._init()
          }
          _init() {
            ;(this.location = s().getLocation()),
              (this._history = s().getHistory())
          }
          getBaseHrefFromDOM() {
            return s().getBaseHref(this._doc)
          }
          onPopState(t) {
            s()
              .getGlobalEventTarget(this._doc, 'window')
              .addEventListener('popstate', t, !1)
          }
          onHashChange(t) {
            s()
              .getGlobalEventTarget(this._doc, 'window')
              .addEventListener('hashchange', t, !1)
          }
          get href() {
            return this.location.href
          }
          get protocol() {
            return this.location.protocol
          }
          get hostname() {
            return this.location.hostname
          }
          get port() {
            return this.location.port
          }
          get pathname() {
            return this.location.pathname
          }
          get search() {
            return this.location.search
          }
          get hash() {
            return this.location.hash
          }
          set pathname(t) {
            this.location.pathname = t
          }
          pushState(t, e, n) {
            p() ? this._history.pushState(t, e, n) : (this.location.hash = n)
          }
          replaceState(t, e, n) {
            p() ? this._history.replaceState(t, e, n) : (this.location.hash = n)
          }
          forward() {
            this._history.forward()
          }
          back() {
            this._history.back()
          }
          getState() {
            return this._history.state
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Ub(l))
          }),
          (t.ɵprov = Object(i.Hb)({
            factory: f,
            token: t,
            providedIn: 'platform',
          })),
          t
        )
      })()
      function p() {
        return !!window.history.pushState
      }
      function f() {
        return new d(Object(i.Ub)(l))
      }
      function m(t, e) {
        if (0 == t.length) return e
        if (0 == e.length) return t
        let n = 0
        return (
          t.endsWith('/') && n++,
          e.startsWith('/') && n++,
          2 == n ? t + e.substring(1) : 1 == n ? t + e : t + '/' + e
        )
      }
      function g(t) {
        const e = t.match(/#|\?|$/),
          n = (e && e.index) || t.length
        return t.slice(0, n - ('/' === t[n - 1] ? 1 : 0)) + t.slice(n)
      }
      function b(t) {
        return t && '?' !== t[0] ? '?' + t : t
      }
      let _ = (() => {
        class t {}
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵprov = Object(i.Hb)({
            factory: y,
            token: t,
            providedIn: 'root',
          })),
          t
        )
      })()
      function y(t) {
        const e = Object(i.Ub)(l).location
        return new w(Object(i.Ub)(c), (e && e.origin) || '')
      }
      const v = new i.q('appBaseHref')
      let w = (() => {
          class t extends _ {
            constructor(t, e) {
              if (
                (super(),
                (this._platformLocation = t),
                null == e && (e = this._platformLocation.getBaseHrefFromDOM()),
                null == e)
              )
                throw new Error(
                  'No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.'
                )
              this._baseHref = e
            }
            onPopState(t) {
              this._platformLocation.onPopState(t),
                this._platformLocation.onHashChange(t)
            }
            getBaseHref() {
              return this._baseHref
            }
            prepareExternalUrl(t) {
              return m(this._baseHref, t)
            }
            path(t = !1) {
              const e =
                  this._platformLocation.pathname +
                  b(this._platformLocation.search),
                n = this._platformLocation.hash
              return n && t ? `${e}${n}` : e
            }
            pushState(t, e, n, i) {
              const r = this.prepareExternalUrl(n + b(i))
              this._platformLocation.pushState(t, e, r)
            }
            replaceState(t, e, n, i) {
              const r = this.prepareExternalUrl(n + b(i))
              this._platformLocation.replaceState(t, e, r)
            }
            forward() {
              this._platformLocation.forward()
            }
            back() {
              this._platformLocation.back()
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Ub(c), i.Ub(v, 8))
            }),
            (t.ɵprov = i.Hb({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        C = (() => {
          class t extends _ {
            constructor(t, e) {
              super(),
                (this._platformLocation = t),
                (this._baseHref = ''),
                null != e && (this._baseHref = e)
            }
            onPopState(t) {
              this._platformLocation.onPopState(t),
                this._platformLocation.onHashChange(t)
            }
            getBaseHref() {
              return this._baseHref
            }
            path(t = !1) {
              let e = this._platformLocation.hash
              return null == e && (e = '#'), e.length > 0 ? e.substring(1) : e
            }
            prepareExternalUrl(t) {
              const e = m(this._baseHref, t)
              return e.length > 0 ? '#' + e : e
            }
            pushState(t, e, n, i) {
              let r = this.prepareExternalUrl(n + b(i))
              0 == r.length && (r = this._platformLocation.pathname),
                this._platformLocation.pushState(t, e, r)
            }
            replaceState(t, e, n, i) {
              let r = this.prepareExternalUrl(n + b(i))
              0 == r.length && (r = this._platformLocation.pathname),
                this._platformLocation.replaceState(t, e, r)
            }
            forward() {
              this._platformLocation.forward()
            }
            back() {
              this._platformLocation.back()
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Ub(c), i.Ub(v, 8))
            }),
            (t.ɵprov = i.Hb({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        x = (() => {
          class t {
            constructor(t, e) {
              ;(this._subject = new i.n()),
                (this._urlChangeListeners = []),
                (this._platformStrategy = t)
              const n = this._platformStrategy.getBaseHref()
              ;(this._platformLocation = e),
                (this._baseHref = g(O(n))),
                this._platformStrategy.onPopState((t) => {
                  this._subject.emit({
                    url: this.path(!0),
                    pop: !0,
                    state: t.state,
                    type: t.type,
                  })
                })
            }
            path(t = !1) {
              return this.normalize(this._platformStrategy.path(t))
            }
            getState() {
              return this._platformLocation.getState()
            }
            isCurrentPathEqualTo(t, e = '') {
              return this.path() == this.normalize(t + b(e))
            }
            normalize(e) {
              return t.stripTrailingSlash(
                (function (t, e) {
                  return t && e.startsWith(t) ? e.substring(t.length) : e
                })(this._baseHref, O(e))
              )
            }
            prepareExternalUrl(t) {
              return (
                t && '/' !== t[0] && (t = '/' + t),
                this._platformStrategy.prepareExternalUrl(t)
              )
            }
            go(t, e = '', n = null) {
              this._platformStrategy.pushState(n, '', t, e),
                this._notifyUrlChangeListeners(
                  this.prepareExternalUrl(t + b(e)),
                  n
                )
            }
            replaceState(t, e = '', n = null) {
              this._platformStrategy.replaceState(n, '', t, e),
                this._notifyUrlChangeListeners(
                  this.prepareExternalUrl(t + b(e)),
                  n
                )
            }
            forward() {
              this._platformStrategy.forward()
            }
            back() {
              this._platformStrategy.back()
            }
            onUrlChange(t) {
              this._urlChangeListeners.push(t),
                this._urlChangeSubscription ||
                  (this._urlChangeSubscription = this.subscribe((t) => {
                    this._notifyUrlChangeListeners(t.url, t.state)
                  }))
            }
            _notifyUrlChangeListeners(t = '', e) {
              this._urlChangeListeners.forEach((n) => n(t, e))
            }
            subscribe(t, e, n) {
              return this._subject.subscribe({ next: t, error: e, complete: n })
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Ub(_), i.Ub(c))
            }),
            (t.normalizeQueryParams = b),
            (t.joinWithSlash = m),
            (t.stripTrailingSlash = g),
            (t.ɵprov = Object(i.Hb)({
              factory: S,
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })()
      function S() {
        return new x(Object(i.Ub)(_), Object(i.Ub)(c))
      }
      function O(t) {
        return t.replace(/\/index.html$/, '')
      }
      var k = (function (t) {
        return (
          (t[(t.Zero = 0)] = 'Zero'),
          (t[(t.One = 1)] = 'One'),
          (t[(t.Two = 2)] = 'Two'),
          (t[(t.Few = 3)] = 'Few'),
          (t[(t.Many = 4)] = 'Many'),
          (t[(t.Other = 5)] = 'Other'),
          t
        )
      })({})
      const E = i.mb
      class A {}
      let T = (() => {
        class t extends A {
          constructor(t) {
            super(), (this.locale = t)
          }
          getPluralCategory(t, e) {
            switch (E(e || this.locale)(t)) {
              case k.Zero:
                return 'zero'
              case k.One:
                return 'one'
              case k.Two:
                return 'two'
              case k.Few:
                return 'few'
              case k.Many:
                return 'many'
              default:
                return 'other'
            }
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Ub(i.u))
          }),
          (t.ɵprov = i.Hb({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      function j(t, e) {
        e = encodeURIComponent(e)
        for (const n of t.split(';')) {
          const t = n.indexOf('='),
            [i, r] = -1 == t ? [n, ''] : [n.slice(0, t), n.slice(t + 1)]
          if (i.trim() === e) return decodeURIComponent(r)
        }
        return null
      }
      let I = (() => {
        class t {
          constructor(t, e, n, i) {
            ;(this._iterableDiffers = t),
              (this._keyValueDiffers = e),
              (this._ngEl = n),
              (this._renderer = i),
              (this._iterableDiffer = null),
              (this._keyValueDiffer = null),
              (this._initialClasses = []),
              (this._rawClass = null)
          }
          set klass(t) {
            this._removeClasses(this._initialClasses),
              (this._initialClasses =
                'string' == typeof t ? t.split(/\s+/) : []),
              this._applyClasses(this._initialClasses),
              this._applyClasses(this._rawClass)
          }
          set ngClass(t) {
            this._removeClasses(this._rawClass),
              this._applyClasses(this._initialClasses),
              (this._iterableDiffer = null),
              (this._keyValueDiffer = null),
              (this._rawClass = 'string' == typeof t ? t.split(/\s+/) : t),
              this._rawClass &&
                (Object(i.pb)(this._rawClass)
                  ? (this._iterableDiffer = this._iterableDiffers
                      .find(this._rawClass)
                      .create())
                  : (this._keyValueDiffer = this._keyValueDiffers
                      .find(this._rawClass)
                      .create()))
          }
          ngDoCheck() {
            if (this._iterableDiffer) {
              const t = this._iterableDiffer.diff(this._rawClass)
              t && this._applyIterableChanges(t)
            } else if (this._keyValueDiffer) {
              const t = this._keyValueDiffer.diff(this._rawClass)
              t && this._applyKeyValueChanges(t)
            }
          }
          _applyKeyValueChanges(t) {
            t.forEachAddedItem((t) => this._toggleClass(t.key, t.currentValue)),
              t.forEachChangedItem((t) =>
                this._toggleClass(t.key, t.currentValue)
              ),
              t.forEachRemovedItem((t) => {
                t.previousValue && this._toggleClass(t.key, !1)
              })
          }
          _applyIterableChanges(t) {
            t.forEachAddedItem((t) => {
              if ('string' != typeof t.item)
                throw new Error(
                  'NgClass can only toggle CSS classes expressed as strings, got ' +
                    Object(i.ub)(t.item)
                )
              this._toggleClass(t.item, !0)
            }),
              t.forEachRemovedItem((t) => this._toggleClass(t.item, !1))
          }
          _applyClasses(t) {
            t &&
              (Array.isArray(t) || t instanceof Set
                ? t.forEach((t) => this._toggleClass(t, !0))
                : Object.keys(t).forEach((e) => this._toggleClass(e, !!t[e])))
          }
          _removeClasses(t) {
            t &&
              (Array.isArray(t) || t instanceof Set
                ? t.forEach((t) => this._toggleClass(t, !1))
                : Object.keys(t).forEach((t) => this._toggleClass(t, !1)))
          }
          _toggleClass(t, e) {
            ;(t = t.trim()) &&
              t.split(/\s+/g).forEach((t) => {
                e
                  ? this._renderer.addClass(this._ngEl.nativeElement, t)
                  : this._renderer.removeClass(this._ngEl.nativeElement, t)
              })
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Lb(i.s), i.Lb(i.t), i.Lb(i.l), i.Lb(i.E))
          }),
          (t.ɵdir = i.Gb({
            type: t,
            selectors: [['', 'ngClass', '']],
            inputs: { klass: ['class', 'klass'], ngClass: 'ngClass' },
          })),
          t
        )
      })()
      class P {
        constructor(t, e, n, i) {
          ;(this.$implicit = t),
            (this.ngForOf = e),
            (this.index = n),
            (this.count = i)
        }
        get first() {
          return 0 === this.index
        }
        get last() {
          return this.index === this.count - 1
        }
        get even() {
          return this.index % 2 == 0
        }
        get odd() {
          return !this.even
        }
      }
      let R = (() => {
        class t {
          constructor(t, e, n) {
            ;(this._viewContainer = t),
              (this._template = e),
              (this._differs = n),
              (this._ngForOf = null),
              (this._ngForOfDirty = !0),
              (this._differ = null)
          }
          set ngForOf(t) {
            ;(this._ngForOf = t), (this._ngForOfDirty = !0)
          }
          set ngForTrackBy(t) {
            this._trackByFn = t
          }
          get ngForTrackBy() {
            return this._trackByFn
          }
          set ngForTemplate(t) {
            t && (this._template = t)
          }
          ngDoCheck() {
            if (this._ngForOfDirty) {
              this._ngForOfDirty = !1
              const n = this._ngForOf
              if (!this._differ && n)
                try {
                  this._differ = this._differs.find(n).create(this.ngForTrackBy)
                } catch (e) {
                  throw new Error(
                    `Cannot find a differ supporting object '${n}' of type '${
                      ((t = n), t.name || typeof t)
                    }'. NgFor only supports binding to Iterables such as Arrays.`
                  )
                }
            }
            var t
            if (this._differ) {
              const t = this._differ.diff(this._ngForOf)
              t && this._applyChanges(t)
            }
          }
          _applyChanges(t) {
            const e = []
            t.forEachOperation((t, n, i) => {
              if (null == t.previousIndex) {
                const n = this._viewContainer.createEmbeddedView(
                    this._template,
                    new P(null, this._ngForOf, -1, -1),
                    null === i ? void 0 : i
                  ),
                  r = new D(t, n)
                e.push(r)
              } else if (null == i)
                this._viewContainer.remove(null === n ? void 0 : n)
              else if (null !== n) {
                const r = this._viewContainer.get(n)
                this._viewContainer.move(r, i)
                const s = new D(t, r)
                e.push(s)
              }
            })
            for (let n = 0; n < e.length; n++)
              this._perViewChange(e[n].view, e[n].record)
            for (let n = 0, i = this._viewContainer.length; n < i; n++) {
              const t = this._viewContainer.get(n)
              ;(t.context.index = n),
                (t.context.count = i),
                (t.context.ngForOf = this._ngForOf)
            }
            t.forEachIdentityChange((t) => {
              this._viewContainer.get(t.currentIndex).context.$implicit = t.item
            })
          }
          _perViewChange(t, e) {
            t.context.$implicit = e.item
          }
          static ngTemplateContextGuard(t, e) {
            return !0
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Lb(i.P), i.Lb(i.L), i.Lb(i.s))
          }),
          (t.ɵdir = i.Gb({
            type: t,
            selectors: [['', 'ngFor', '', 'ngForOf', '']],
            inputs: {
              ngForOf: 'ngForOf',
              ngForTrackBy: 'ngForTrackBy',
              ngForTemplate: 'ngForTemplate',
            },
          })),
          t
        )
      })()
      class D {
        constructor(t, e) {
          ;(this.record = t), (this.view = e)
        }
      }
      let L = (() => {
        class t {
          constructor(t, e) {
            ;(this._viewContainer = t),
              (this._context = new F()),
              (this._thenTemplateRef = null),
              (this._elseTemplateRef = null),
              (this._thenViewRef = null),
              (this._elseViewRef = null),
              (this._thenTemplateRef = e)
          }
          set ngIf(t) {
            ;(this._context.$implicit = this._context.ngIf = t),
              this._updateView()
          }
          set ngIfThen(t) {
            N('ngIfThen', t),
              (this._thenTemplateRef = t),
              (this._thenViewRef = null),
              this._updateView()
          }
          set ngIfElse(t) {
            N('ngIfElse', t),
              (this._elseTemplateRef = t),
              (this._elseViewRef = null),
              this._updateView()
          }
          _updateView() {
            this._context.$implicit
              ? this._thenViewRef ||
                (this._viewContainer.clear(),
                (this._elseViewRef = null),
                this._thenTemplateRef &&
                  (this._thenViewRef = this._viewContainer.createEmbeddedView(
                    this._thenTemplateRef,
                    this._context
                  )))
              : this._elseViewRef ||
                (this._viewContainer.clear(),
                (this._thenViewRef = null),
                this._elseTemplateRef &&
                  (this._elseViewRef = this._viewContainer.createEmbeddedView(
                    this._elseTemplateRef,
                    this._context
                  )))
          }
          static ngTemplateContextGuard(t, e) {
            return !0
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(i.Lb(i.P), i.Lb(i.L))
          }),
          (t.ɵdir = i.Gb({
            type: t,
            selectors: [['', 'ngIf', '']],
            inputs: {
              ngIf: 'ngIf',
              ngIfThen: 'ngIfThen',
              ngIfElse: 'ngIfElse',
            },
          })),
          t
        )
      })()
      class F {
        constructor() {
          ;(this.$implicit = null), (this.ngIf = null)
        }
      }
      function N(t, e) {
        if (e && !e.createEmbeddedView)
          throw new Error(
            `${t} must be a TemplateRef, but received '${Object(i.ub)(e)}'.`
          )
      }
      class M {
        constructor(t, e) {
          ;(this._viewContainerRef = t),
            (this._templateRef = e),
            (this._created = !1)
        }
        create() {
          ;(this._created = !0),
            this._viewContainerRef.createEmbeddedView(this._templateRef)
        }
        destroy() {
          ;(this._created = !1), this._viewContainerRef.clear()
        }
        enforceState(t) {
          t && !this._created
            ? this.create()
            : !t && this._created && this.destroy()
        }
      }
      let V = (() => {
          class t {
            constructor() {
              ;(this._defaultUsed = !1),
                (this._caseCount = 0),
                (this._lastCaseCheckIndex = 0),
                (this._lastCasesMatched = !1)
            }
            set ngSwitch(t) {
              ;(this._ngSwitch = t),
                0 === this._caseCount && this._updateDefaultCases(!0)
            }
            _addCase() {
              return this._caseCount++
            }
            _addDefault(t) {
              this._defaultViews || (this._defaultViews = []),
                this._defaultViews.push(t)
            }
            _matchCase(t) {
              const e = t == this._ngSwitch
              return (
                (this._lastCasesMatched = this._lastCasesMatched || e),
                this._lastCaseCheckIndex++,
                this._lastCaseCheckIndex === this._caseCount &&
                  (this._updateDefaultCases(!this._lastCasesMatched),
                  (this._lastCaseCheckIndex = 0),
                  (this._lastCasesMatched = !1)),
                e
              )
            }
            _updateDefaultCases(t) {
              if (this._defaultViews && t !== this._defaultUsed) {
                this._defaultUsed = t
                for (let e = 0; e < this._defaultViews.length; e++)
                  this._defaultViews[e].enforceState(t)
              }
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)()
            }),
            (t.ɵdir = i.Gb({
              type: t,
              selectors: [['', 'ngSwitch', '']],
              inputs: { ngSwitch: 'ngSwitch' },
            })),
            t
          )
        })(),
        U = (() => {
          class t {
            constructor(t, e, n) {
              ;(this.ngSwitch = n), n._addCase(), (this._view = new M(t, e))
            }
            ngDoCheck() {
              this._view.enforceState(
                this.ngSwitch._matchCase(this.ngSwitchCase)
              )
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Lb(i.P), i.Lb(i.L), i.Lb(V, 1))
            }),
            (t.ɵdir = i.Gb({
              type: t,
              selectors: [['', 'ngSwitchCase', '']],
              inputs: { ngSwitchCase: 'ngSwitchCase' },
            })),
            t
          )
        })(),
        B = (() => {
          class t {
            constructor(t, e, n) {
              n._addDefault(new M(t, e))
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Lb(i.P), i.Lb(i.L), i.Lb(V, 1))
            }),
            (t.ɵdir = i.Gb({
              type: t,
              selectors: [['', 'ngSwitchDefault', '']],
            })),
            t
          )
        })()
      class z {
        createSubscription(t, e) {
          return t.subscribe({
            next: e,
            error: (t) => {
              throw t
            },
          })
        }
        dispose(t) {
          t.unsubscribe()
        }
        onDestroy(t) {
          t.unsubscribe()
        }
      }
      class H {
        createSubscription(t, e) {
          return t.then(e, (t) => {
            throw t
          })
        }
        dispose(t) {}
        onDestroy(t) {}
      }
      const q = new H(),
        W = new z()
      let $ = (() => {
          class t {
            constructor(t) {
              ;(this._ref = t),
                (this._latestValue = null),
                (this._subscription = null),
                (this._obj = null),
                (this._strategy = null)
            }
            ngOnDestroy() {
              this._subscription && this._dispose()
            }
            transform(t) {
              return this._obj
                ? t !== this._obj
                  ? (this._dispose(), this.transform(t))
                  : this._latestValue
                : (t && this._subscribe(t), this._latestValue)
            }
            _subscribe(t) {
              ;(this._obj = t),
                (this._strategy = this._selectStrategy(t)),
                (this._subscription = this._strategy.createSubscription(
                  t,
                  (e) => this._updateLatestValue(t, e)
                ))
            }
            _selectStrategy(e) {
              if (Object(i.rb)(e)) return q
              if (Object(i.qb)(e)) return W
              throw (
                ((n = t),
                Error(
                  `InvalidPipeArgument: '${e}' for pipe '${Object(i.ub)(n)}'`
                ))
              )
              var n
            }
            _dispose() {
              this._strategy.dispose(this._subscription),
                (this._latestValue = null),
                (this._subscription = null),
                (this._obj = null)
            }
            _updateLatestValue(t, e) {
              t === this._obj &&
                ((this._latestValue = e), this._ref.markForCheck())
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Wb())
            }),
            (t.ɵpipe = i.Kb({ name: 'async', type: t, pure: !1 })),
            t
          )
        })(),
        G = (() => {
          class t {}
          return (
            (t.ɵmod = i.Jb({ type: t })),
            (t.ɵinj = i.Ib({
              factory: function (e) {
                return new (e || t)()
              },
              providers: [{ provide: A, useClass: T }],
            })),
            t
          )
        })()
      const Q = 'browser'
      function X(t) {
        return t === Q
      }
      let K = (() => {
        class t {}
        return (
          (t.ɵprov = Object(i.Hb)({
            token: t,
            providedIn: 'root',
            factory: () => new Y(Object(i.Ub)(l), window, Object(i.Ub)(i.m)),
          })),
          t
        )
      })()
      class Y {
        constructor(t, e, n) {
          ;(this.document = t),
            (this.window = e),
            (this.errorHandler = n),
            (this.offset = () => [0, 0])
        }
        setOffset(t) {
          this.offset = Array.isArray(t) ? () => t : t
        }
        getScrollPosition() {
          return this.supportsScrolling()
            ? [this.window.pageXOffset, this.window.pageYOffset]
            : [0, 0]
        }
        scrollToPosition(t) {
          this.supportsScrolling() && this.window.scrollTo(t[0], t[1])
        }
        scrollToAnchor(t) {
          if (this.supportsScrolling()) {
            const e =
              this.document.getElementById(t) ||
              this.document.getElementsByName(t)[0]
            e && this.scrollToElement(e)
          }
        }
        setHistoryScrollRestoration(t) {
          if (this.supportScrollRestoration()) {
            const e = this.window.history
            e && e.scrollRestoration && (e.scrollRestoration = t)
          }
        }
        scrollToElement(t) {
          const e = t.getBoundingClientRect(),
            n = e.left + this.window.pageXOffset,
            i = e.top + this.window.pageYOffset,
            r = this.offset()
          this.window.scrollTo(n - r[0], i - r[1])
        }
        supportScrollRestoration() {
          try {
            if (!this.supportsScrolling()) return !1
            const t =
              Z(this.window.history) ||
              Z(Object.getPrototypeOf(this.window.history))
            return !(!t || (!t.writable && !t.set))
          } catch (t) {
            return !1
          }
        }
        supportsScrolling() {
          try {
            return (
              !!this.window &&
              !!this.window.scrollTo &&
              'pageXOffset' in this.window
            )
          } catch (t) {
            return !1
          }
        }
      }
      function Z(t) {
        return Object.getOwnPropertyDescriptor(t, 'scrollRestoration')
      }
    },
    pLZG: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return r
      })
      var i = n('7o/Q')
      function r(t, e) {
        return function (n) {
          return n.lift(new s(t, e))
        }
      }
      class s {
        constructor(t, e) {
          ;(this.predicate = t), (this.thisArg = e)
        }
        call(t, e) {
          return e.subscribe(new o(t, this.predicate, this.thisArg))
        }
      }
      class o extends i.a {
        constructor(t, e, n) {
          super(t), (this.predicate = e), (this.thisArg = n), (this.count = 0)
        }
        _next(t) {
          let e
          try {
            e = this.predicate.call(this.thisArg, t, this.count++)
          } catch (n) {
            return void this.destination.error(n)
          }
          e && this.destination.next(t)
        }
      }
    },
    qGlh: function (t, e) {
      t.exports = function (t) {
        return (
          (n && Buffer.isBuffer(t)) ||
          (i &&
            (t instanceof ArrayBuffer ||
              (function (t) {
                return 'function' == typeof ArrayBuffer.isView
                  ? ArrayBuffer.isView(t)
                  : t.buffer instanceof ArrayBuffer
              })(t)))
        )
      }
      var n =
          'function' == typeof Buffer && 'function' == typeof Buffer.isBuffer,
        i = 'function' == typeof ArrayBuffer
    },
    quSY: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return a
      })
      var i = n('DH7j'),
        r = n('XoHu'),
        s = n('n6bG')
      const o = (() => {
        function t(t) {
          return (
            Error.call(this),
            (this.message = t
              ? `${t.length} errors occurred during unsubscription:\n${t
                  .map((t, e) => `${e + 1}) ${t.toString()}`)
                  .join('\n  ')}`
              : ''),
            (this.name = 'UnsubscriptionError'),
            (this.errors = t),
            this
          )
        }
        return (t.prototype = Object.create(Error.prototype)), t
      })()
      let a = (() => {
        class t {
          constructor(t) {
            ;(this.closed = !1),
              (this._parentOrParents = null),
              (this._subscriptions = null),
              t && (this._unsubscribe = t)
          }
          unsubscribe() {
            let e
            if (this.closed) return
            let {
              _parentOrParents: n,
              _unsubscribe: a,
              _subscriptions: c,
            } = this
            if (
              ((this.closed = !0),
              (this._parentOrParents = null),
              (this._subscriptions = null),
              n instanceof t)
            )
              n.remove(this)
            else if (null !== n)
              for (let t = 0; t < n.length; ++t) n[t].remove(this)
            if (Object(s.a)(a))
              try {
                a.call(this)
              } catch (u) {
                e = u instanceof o ? l(u.errors) : [u]
              }
            if (Object(i.a)(c)) {
              let t = -1,
                n = c.length
              for (; ++t < n; ) {
                const n = c[t]
                if (Object(r.a)(n))
                  try {
                    n.unsubscribe()
                  } catch (u) {
                    ;(e = e || []),
                      u instanceof o ? (e = e.concat(l(u.errors))) : e.push(u)
                  }
              }
            }
            if (e) throw new o(e)
          }
          add(e) {
            let n = e
            if (!e) return t.EMPTY
            switch (typeof e) {
              case 'function':
                n = new t(e)
              case 'object':
                if (
                  n === this ||
                  n.closed ||
                  'function' != typeof n.unsubscribe
                )
                  return n
                if (this.closed) return n.unsubscribe(), n
                if (!(n instanceof t)) {
                  const e = n
                  ;(n = new t()), (n._subscriptions = [e])
                }
                break
              default:
                throw new Error(
                  'unrecognized teardown ' + e + ' added to Subscription.'
                )
            }
            let { _parentOrParents: i } = n
            if (null === i) n._parentOrParents = this
            else if (i instanceof t) {
              if (i === this) return n
              n._parentOrParents = [i, this]
            } else {
              if (-1 !== i.indexOf(this)) return n
              i.push(this)
            }
            const r = this._subscriptions
            return null === r ? (this._subscriptions = [n]) : r.push(n), n
          }
          remove(t) {
            const e = this._subscriptions
            if (e) {
              const n = e.indexOf(t)
              ;-1 !== n && e.splice(n, 1)
            }
          }
        }
        var e
        return (t.EMPTY = (((e = new t()).closed = !0), e)), t
      })()
      function l(t) {
        return t.reduce((t, e) => t.concat(e instanceof o ? e.errors : e), [])
      }
    },
    rDax: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return X
      }),
        n.d(e, 'b', function () {
          return Q
        }),
        n.d(e, 'c', function () {
          return W
        }),
        n.d(e, 'd', function () {
          return Y
        })
      var i = n('vxfF'),
        r = n('fXoL'),
        s = n('nLfN'),
        o = n('cH1L'),
        a = n('ofXK'),
        l = n('8LU1'),
        c = n('+rOU'),
        u = n('XNiG'),
        h = n('quSY'),
        d = n('VRyK'),
        p = n('IzEk'),
        f = n('1G5W'),
        m = n('7o/Q')
      class g {
        constructor(t, e) {
          ;(this.predicate = t), (this.inclusive = e)
        }
        call(t, e) {
          return e.subscribe(new b(t, this.predicate, this.inclusive))
        }
      }
      class b extends m.a {
        constructor(t, e, n) {
          super(t), (this.predicate = e), (this.inclusive = n), (this.index = 0)
        }
        _next(t) {
          const e = this.destination
          let n
          try {
            n = this.predicate(t, this.index++)
          } catch (i) {
            return void e.error(i)
          }
          this.nextOrComplete(t, n)
        }
        nextOrComplete(t, e) {
          const n = this.destination
          Boolean(e) ? n.next(t) : (this.inclusive && n.next(t), n.complete())
        }
      }
      var _ = n('FtGj')
      class y {
        constructor(t, e) {
          ;(this._viewportRuler = t),
            (this._previousHTMLStyles = { top: '', left: '' }),
            (this._isEnabled = !1),
            (this._document = e)
        }
        attach() {}
        enable() {
          if (this._canBeEnabled()) {
            const t = this._document.documentElement
            ;(this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition()),
              (this._previousHTMLStyles.left = t.style.left || ''),
              (this._previousHTMLStyles.top = t.style.top || ''),
              (t.style.left = Object(l.c)(-this._previousScrollPosition.left)),
              (t.style.top = Object(l.c)(-this._previousScrollPosition.top)),
              t.classList.add('cdk-global-scrollblock'),
              (this._isEnabled = !0)
          }
        }
        disable() {
          if (this._isEnabled) {
            const t = this._document.documentElement,
              e = t.style,
              n = this._document.body.style,
              i = e.scrollBehavior || '',
              r = n.scrollBehavior || ''
            ;(this._isEnabled = !1),
              (e.left = this._previousHTMLStyles.left),
              (e.top = this._previousHTMLStyles.top),
              t.classList.remove('cdk-global-scrollblock'),
              (e.scrollBehavior = n.scrollBehavior = 'auto'),
              window.scroll(
                this._previousScrollPosition.left,
                this._previousScrollPosition.top
              ),
              (e.scrollBehavior = i),
              (n.scrollBehavior = r)
          }
        }
        _canBeEnabled() {
          if (
            this._document.documentElement.classList.contains(
              'cdk-global-scrollblock'
            ) ||
            this._isEnabled
          )
            return !1
          const t = this._document.body,
            e = this._viewportRuler.getViewportSize()
          return t.scrollHeight > e.height || t.scrollWidth > e.width
        }
      }
      class v {
        constructor(t, e, n, i) {
          ;(this._scrollDispatcher = t),
            (this._ngZone = e),
            (this._viewportRuler = n),
            (this._config = i),
            (this._scrollSubscription = null),
            (this._detach = () => {
              this.disable(),
                this._overlayRef.hasAttached() &&
                  this._ngZone.run(() => this._overlayRef.detach())
            })
        }
        attach(t) {
          this._overlayRef = t
        }
        enable() {
          if (this._scrollSubscription) return
          const t = this._scrollDispatcher.scrolled(0)
          this._config && this._config.threshold && this._config.threshold > 1
            ? ((this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top),
              (this._scrollSubscription = t.subscribe(() => {
                const t = this._viewportRuler.getViewportScrollPosition().top
                Math.abs(t - this._initialScrollPosition) >
                this._config.threshold
                  ? this._detach()
                  : this._overlayRef.updatePosition()
              })))
            : (this._scrollSubscription = t.subscribe(this._detach))
        }
        disable() {
          this._scrollSubscription &&
            (this._scrollSubscription.unsubscribe(),
            (this._scrollSubscription = null))
        }
        detach() {
          this.disable(), (this._overlayRef = null)
        }
      }
      class w {
        enable() {}
        disable() {}
        attach() {}
      }
      function C(t, e) {
        return e.some(
          (e) =>
            t.bottom < e.top ||
            t.top > e.bottom ||
            t.right < e.left ||
            t.left > e.right
        )
      }
      function x(t, e) {
        return e.some(
          (e) =>
            t.top < e.top ||
            t.bottom > e.bottom ||
            t.left < e.left ||
            t.right > e.right
        )
      }
      class S {
        constructor(t, e, n, i) {
          ;(this._scrollDispatcher = t),
            (this._viewportRuler = e),
            (this._ngZone = n),
            (this._config = i),
            (this._scrollSubscription = null)
        }
        attach(t) {
          this._overlayRef = t
        }
        enable() {
          this._scrollSubscription ||
            (this._scrollSubscription = this._scrollDispatcher
              .scrolled(this._config ? this._config.scrollThrottle : 0)
              .subscribe(() => {
                if (
                  (this._overlayRef.updatePosition(),
                  this._config && this._config.autoClose)
                ) {
                  const t = this._overlayRef.overlayElement.getBoundingClientRect(),
                    {
                      width: e,
                      height: n,
                    } = this._viewportRuler.getViewportSize()
                  C(t, [
                    {
                      width: e,
                      height: n,
                      bottom: n,
                      right: e,
                      top: 0,
                      left: 0,
                    },
                  ]) &&
                    (this.disable(),
                    this._ngZone.run(() => this._overlayRef.detach()))
                }
              }))
        }
        disable() {
          this._scrollSubscription &&
            (this._scrollSubscription.unsubscribe(),
            (this._scrollSubscription = null))
        }
        detach() {
          this.disable(), (this._overlayRef = null)
        }
      }
      let O = (() => {
        class t {
          constructor(t, e, n, i) {
            ;(this._scrollDispatcher = t),
              (this._viewportRuler = e),
              (this._ngZone = n),
              (this.noop = () => new w()),
              (this.close = (t) =>
                new v(
                  this._scrollDispatcher,
                  this._ngZone,
                  this._viewportRuler,
                  t
                )),
              (this.block = () => new y(this._viewportRuler, this._document)),
              (this.reposition = (t) =>
                new S(
                  this._scrollDispatcher,
                  this._viewportRuler,
                  this._ngZone,
                  t
                )),
              (this._document = i)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(r.Ub(i.c), r.Ub(i.e), r.Ub(r.z), r.Ub(a.d))
          }),
          (t.ɵprov = Object(r.Hb)({
            factory: function () {
              return new t(
                Object(r.Ub)(i.c),
                Object(r.Ub)(i.e),
                Object(r.Ub)(r.z),
                Object(r.Ub)(a.d)
              )
            },
            token: t,
            providedIn: 'root',
          })),
          t
        )
      })()
      class k {
        constructor(t) {
          if (
            ((this.scrollStrategy = new w()),
            (this.panelClass = ''),
            (this.hasBackdrop = !1),
            (this.backdropClass = 'cdk-overlay-dark-backdrop'),
            (this.disposeOnNavigation = !1),
            t)
          ) {
            const e = Object.keys(t)
            for (const n of e) void 0 !== t[n] && (this[n] = t[n])
          }
        }
      }
      class E {
        constructor(t, e, n, i, r) {
          ;(this.offsetX = n),
            (this.offsetY = i),
            (this.panelClass = r),
            (this.originX = t.originX),
            (this.originY = t.originY),
            (this.overlayX = e.overlayX),
            (this.overlayY = e.overlayY)
        }
      }
      class A {
        constructor(t, e) {
          ;(this.connectionPair = t), (this.scrollableViewProperties = e)
        }
      }
      let T = (() => {
          class t {
            constructor(t) {
              ;(this._attachedOverlays = []), (this._document = t)
            }
            ngOnDestroy() {
              this.detach()
            }
            add(t) {
              this.remove(t), this._attachedOverlays.push(t)
            }
            remove(t) {
              const e = this._attachedOverlays.indexOf(t)
              e > -1 && this._attachedOverlays.splice(e, 1),
                0 === this._attachedOverlays.length && this.detach()
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(r.Ub(a.d))
            }),
            (t.ɵprov = Object(r.Hb)({
              factory: function () {
                return new t(Object(r.Ub)(a.d))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        j = (() => {
          class t extends T {
            constructor(t) {
              super(t),
                (this._keydownListener = (t) => {
                  const e = this._attachedOverlays
                  for (let n = e.length - 1; n > -1; n--)
                    if (e[n]._keydownEvents.observers.length > 0) {
                      e[n]._keydownEvents.next(t)
                      break
                    }
                })
            }
            add(t) {
              super.add(t),
                this._isAttached ||
                  (this._document.body.addEventListener(
                    'keydown',
                    this._keydownListener
                  ),
                  (this._isAttached = !0))
            }
            detach() {
              this._isAttached &&
                (this._document.body.removeEventListener(
                  'keydown',
                  this._keydownListener
                ),
                (this._isAttached = !1))
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(r.Ub(a.d))
            }),
            (t.ɵprov = Object(r.Hb)({
              factory: function () {
                return new t(Object(r.Ub)(a.d))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        I = (() => {
          class t extends T {
            constructor(t, e) {
              super(t),
                (this._platform = e),
                (this._cursorStyleIsSet = !1),
                (this._clickListener = (t) => {
                  const e = t.composedPath ? t.composedPath()[0] : t.target,
                    n = this._attachedOverlays.slice()
                  for (let i = n.length - 1; i > -1; i--) {
                    const r = n[i]
                    if (
                      !(r._outsidePointerEvents.observers.length < 1) &&
                      r.hasAttached()
                    ) {
                      if (r.overlayElement.contains(e)) break
                      r._outsidePointerEvents.next(t)
                    }
                  }
                })
            }
            add(t) {
              super.add(t),
                this._isAttached ||
                  (this._document.body.addEventListener(
                    'click',
                    this._clickListener,
                    !0
                  ),
                  this._document.body.addEventListener(
                    'contextmenu',
                    this._clickListener,
                    !0
                  ),
                  this._platform.IOS &&
                    !this._cursorStyleIsSet &&
                    ((this._cursorOriginalValue = this._document.body.style.cursor),
                    (this._document.body.style.cursor = 'pointer'),
                    (this._cursorStyleIsSet = !0)),
                  (this._isAttached = !0))
            }
            detach() {
              this._isAttached &&
                (this._document.body.removeEventListener(
                  'click',
                  this._clickListener,
                  !0
                ),
                this._document.body.removeEventListener(
                  'contextmenu',
                  this._clickListener,
                  !0
                ),
                this._platform.IOS &&
                  this._cursorStyleIsSet &&
                  ((this._document.body.style.cursor = this._cursorOriginalValue),
                  (this._cursorStyleIsSet = !1)),
                (this._isAttached = !1))
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(r.Ub(a.d), r.Ub(s.a))
            }),
            (t.ɵprov = Object(r.Hb)({
              factory: function () {
                return new t(Object(r.Ub)(a.d), Object(r.Ub)(s.a))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })()
      const P = !(
        'undefined' == typeof window ||
        !window ||
        (!window.__karma__ && !window.jasmine)
      )
      let R = (() => {
        class t {
          constructor(t, e) {
            ;(this._platform = e), (this._document = t)
          }
          ngOnDestroy() {
            const t = this._containerElement
            t && t.parentNode && t.parentNode.removeChild(t)
          }
          getContainerElement() {
            return (
              this._containerElement || this._createContainer(),
              this._containerElement
            )
          }
          _createContainer() {
            const t = 'cdk-overlay-container'
            if (this._platform.isBrowser || P) {
              const e = this._document.querySelectorAll(
                `.${t}[platform="server"], .${t}[platform="test"]`
              )
              for (let t = 0; t < e.length; t++)
                e[t].parentNode.removeChild(e[t])
            }
            const e = this._document.createElement('div')
            e.classList.add(t),
              P
                ? e.setAttribute('platform', 'test')
                : this._platform.isBrowser ||
                  e.setAttribute('platform', 'server'),
              this._document.body.appendChild(e),
              (this._containerElement = e)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(r.Ub(a.d), r.Ub(s.a))
          }),
          (t.ɵprov = Object(r.Hb)({
            factory: function () {
              return new t(Object(r.Ub)(a.d), Object(r.Ub)(s.a))
            },
            token: t,
            providedIn: 'root',
          })),
          t
        )
      })()
      class D {
        constructor(t, e, n, i, r, s, o, a, l) {
          ;(this._portalOutlet = t),
            (this._host = e),
            (this._pane = n),
            (this._config = i),
            (this._ngZone = r),
            (this._keyboardDispatcher = s),
            (this._document = o),
            (this._location = a),
            (this._outsideClickDispatcher = l),
            (this._backdropElement = null),
            (this._backdropClick = new u.a()),
            (this._attachments = new u.a()),
            (this._detachments = new u.a()),
            (this._locationChanges = h.a.EMPTY),
            (this._backdropClickHandler = (t) => this._backdropClick.next(t)),
            (this._keydownEvents = new u.a()),
            (this._outsidePointerEvents = new u.a()),
            i.scrollStrategy &&
              ((this._scrollStrategy = i.scrollStrategy),
              this._scrollStrategy.attach(this)),
            (this._positionStrategy = i.positionStrategy)
        }
        get overlayElement() {
          return this._pane
        }
        get backdropElement() {
          return this._backdropElement
        }
        get hostElement() {
          return this._host
        }
        attach(t) {
          let e = this._portalOutlet.attach(t)
          return (
            !this._host.parentElement &&
              this._previousHostParent &&
              this._previousHostParent.appendChild(this._host),
            this._positionStrategy && this._positionStrategy.attach(this),
            this._updateStackingOrder(),
            this._updateElementSize(),
            this._updateElementDirection(),
            this._scrollStrategy && this._scrollStrategy.enable(),
            this._ngZone.onStable.pipe(Object(p.a)(1)).subscribe(() => {
              this.hasAttached() && this.updatePosition()
            }),
            this._togglePointerEvents(!0),
            this._config.hasBackdrop && this._attachBackdrop(),
            this._config.panelClass &&
              this._toggleClasses(this._pane, this._config.panelClass, !0),
            this._attachments.next(),
            this._keyboardDispatcher.add(this),
            this._config.disposeOnNavigation &&
              (this._locationChanges = this._location.subscribe(() =>
                this.dispose()
              )),
            this._outsideClickDispatcher.add(this),
            e
          )
        }
        detach() {
          if (!this.hasAttached()) return
          this.detachBackdrop(),
            this._togglePointerEvents(!1),
            this._positionStrategy &&
              this._positionStrategy.detach &&
              this._positionStrategy.detach(),
            this._scrollStrategy && this._scrollStrategy.disable()
          const t = this._portalOutlet.detach()
          return (
            this._detachments.next(),
            this._keyboardDispatcher.remove(this),
            this._detachContentWhenStable(),
            this._locationChanges.unsubscribe(),
            this._outsideClickDispatcher.remove(this),
            t
          )
        }
        dispose() {
          const t = this.hasAttached()
          this._positionStrategy && this._positionStrategy.dispose(),
            this._disposeScrollStrategy(),
            this.detachBackdrop(),
            this._locationChanges.unsubscribe(),
            this._keyboardDispatcher.remove(this),
            this._portalOutlet.dispose(),
            this._attachments.complete(),
            this._backdropClick.complete(),
            this._keydownEvents.complete(),
            this._outsidePointerEvents.complete(),
            this._outsideClickDispatcher.remove(this),
            this._host &&
              this._host.parentNode &&
              (this._host.parentNode.removeChild(this._host),
              (this._host = null)),
            (this._previousHostParent = this._pane = null),
            t && this._detachments.next(),
            this._detachments.complete()
        }
        hasAttached() {
          return this._portalOutlet.hasAttached()
        }
        backdropClick() {
          return this._backdropClick
        }
        attachments() {
          return this._attachments
        }
        detachments() {
          return this._detachments
        }
        keydownEvents() {
          return this._keydownEvents
        }
        outsidePointerEvents() {
          return this._outsidePointerEvents
        }
        getConfig() {
          return this._config
        }
        updatePosition() {
          this._positionStrategy && this._positionStrategy.apply()
        }
        updatePositionStrategy(t) {
          t !== this._positionStrategy &&
            (this._positionStrategy && this._positionStrategy.dispose(),
            (this._positionStrategy = t),
            this.hasAttached() && (t.attach(this), this.updatePosition()))
        }
        updateSize(t) {
          ;(this._config = Object.assign(Object.assign({}, this._config), t)),
            this._updateElementSize()
        }
        setDirection(t) {
          ;(this._config = Object.assign(Object.assign({}, this._config), {
            direction: t,
          })),
            this._updateElementDirection()
        }
        addPanelClass(t) {
          this._pane && this._toggleClasses(this._pane, t, !0)
        }
        removePanelClass(t) {
          this._pane && this._toggleClasses(this._pane, t, !1)
        }
        getDirection() {
          const t = this._config.direction
          return t ? ('string' == typeof t ? t : t.value) : 'ltr'
        }
        updateScrollStrategy(t) {
          t !== this._scrollStrategy &&
            (this._disposeScrollStrategy(),
            (this._scrollStrategy = t),
            this.hasAttached() && (t.attach(this), t.enable()))
        }
        _updateElementDirection() {
          this._host.setAttribute('dir', this.getDirection())
        }
        _updateElementSize() {
          if (!this._pane) return
          const t = this._pane.style
          ;(t.width = Object(l.c)(this._config.width)),
            (t.height = Object(l.c)(this._config.height)),
            (t.minWidth = Object(l.c)(this._config.minWidth)),
            (t.minHeight = Object(l.c)(this._config.minHeight)),
            (t.maxWidth = Object(l.c)(this._config.maxWidth)),
            (t.maxHeight = Object(l.c)(this._config.maxHeight))
        }
        _togglePointerEvents(t) {
          this._pane.style.pointerEvents = t ? 'auto' : 'none'
        }
        _attachBackdrop() {
          const t = 'cdk-overlay-backdrop-showing'
          ;(this._backdropElement = this._document.createElement('div')),
            this._backdropElement.classList.add('cdk-overlay-backdrop'),
            this._config.backdropClass &&
              this._toggleClasses(
                this._backdropElement,
                this._config.backdropClass,
                !0
              ),
            this._host.parentElement.insertBefore(
              this._backdropElement,
              this._host
            ),
            this._backdropElement.addEventListener(
              'click',
              this._backdropClickHandler
            ),
            'undefined' != typeof requestAnimationFrame
              ? this._ngZone.runOutsideAngular(() => {
                  requestAnimationFrame(() => {
                    this._backdropElement &&
                      this._backdropElement.classList.add(t)
                  })
                })
              : this._backdropElement.classList.add(t)
        }
        _updateStackingOrder() {
          this._host.nextSibling &&
            this._host.parentNode.appendChild(this._host)
        }
        detachBackdrop() {
          let t,
            e = this._backdropElement
          if (!e) return
          let n = () => {
            e &&
              (e.removeEventListener('click', this._backdropClickHandler),
              e.removeEventListener('transitionend', n),
              e.parentNode && e.parentNode.removeChild(e)),
              this._backdropElement == e && (this._backdropElement = null),
              this._config.backdropClass &&
                this._toggleClasses(e, this._config.backdropClass, !1),
              clearTimeout(t)
          }
          e.classList.remove('cdk-overlay-backdrop-showing'),
            this._ngZone.runOutsideAngular(() => {
              e.addEventListener('transitionend', n)
            }),
            (e.style.pointerEvents = 'none'),
            (t = this._ngZone.runOutsideAngular(() => setTimeout(n, 500)))
        }
        _toggleClasses(t, e, n) {
          const i = t.classList
          Object(l.a)(e).forEach((t) => {
            t && (n ? i.add(t) : i.remove(t))
          })
        }
        _detachContentWhenStable() {
          this._ngZone.runOutsideAngular(() => {
            const t = this._ngZone.onStable
              .pipe(
                Object(f.a)(Object(d.a)(this._attachments, this._detachments))
              )
              .subscribe(() => {
                ;(this._pane &&
                  this._host &&
                  0 !== this._pane.children.length) ||
                  (this._pane &&
                    this._config.panelClass &&
                    this._toggleClasses(
                      this._pane,
                      this._config.panelClass,
                      !1
                    ),
                  this._host &&
                    this._host.parentElement &&
                    ((this._previousHostParent = this._host.parentElement),
                    this._previousHostParent.removeChild(this._host)),
                  t.unsubscribe())
              })
          })
        }
        _disposeScrollStrategy() {
          const t = this._scrollStrategy
          t && (t.disable(), t.detach && t.detach())
        }
      }
      const L = 'cdk-overlay-connected-position-bounding-box',
        F = /([A-Za-z%]+)$/
      class N {
        constructor(t, e, n, i, r) {
          ;(this._viewportRuler = e),
            (this._document = n),
            (this._platform = i),
            (this._overlayContainer = r),
            (this._lastBoundingBoxSize = { width: 0, height: 0 }),
            (this._isPushed = !1),
            (this._canPush = !0),
            (this._growAfterOpen = !1),
            (this._hasFlexibleDimensions = !0),
            (this._positionLocked = !1),
            (this._viewportMargin = 0),
            (this._scrollables = []),
            (this._preferredPositions = []),
            (this._positionChanges = new u.a()),
            (this._resizeSubscription = h.a.EMPTY),
            (this._offsetX = 0),
            (this._offsetY = 0),
            (this._appliedPanelClasses = []),
            (this.positionChanges = this._positionChanges),
            this.setOrigin(t)
        }
        get positions() {
          return this._preferredPositions
        }
        attach(t) {
          this._validatePositions(),
            t.hostElement.classList.add(L),
            (this._overlayRef = t),
            (this._boundingBox = t.hostElement),
            (this._pane = t.overlayElement),
            (this._isDisposed = !1),
            (this._isInitialRender = !0),
            (this._lastPosition = null),
            this._resizeSubscription.unsubscribe(),
            (this._resizeSubscription = this._viewportRuler
              .change()
              .subscribe(() => {
                ;(this._isInitialRender = !0), this.apply()
              }))
        }
        apply() {
          if (this._isDisposed || !this._platform.isBrowser) return
          if (
            !this._isInitialRender &&
            this._positionLocked &&
            this._lastPosition
          )
            return void this.reapplyLastPosition()
          this._clearPanelClasses(),
            this._resetOverlayElementStyles(),
            this._resetBoundingBoxStyles(),
            (this._viewportRect = this._getNarrowedViewportRect()),
            (this._originRect = this._getOriginRect()),
            (this._overlayRect = this._pane.getBoundingClientRect())
          const t = this._originRect,
            e = this._overlayRect,
            n = this._viewportRect,
            i = []
          let r
          for (let s of this._preferredPositions) {
            let o = this._getOriginPoint(t, s),
              a = this._getOverlayPoint(o, e, s),
              l = this._getOverlayFit(a, e, n, s)
            if (l.isCompletelyWithinViewport)
              return (this._isPushed = !1), void this._applyPosition(s, o)
            this._canFitWithFlexibleDimensions(l, a, n)
              ? i.push({
                  position: s,
                  origin: o,
                  overlayRect: e,
                  boundingBoxRect: this._calculateBoundingBoxRect(o, s),
                })
              : (!r || r.overlayFit.visibleArea < l.visibleArea) &&
                (r = {
                  overlayFit: l,
                  overlayPoint: a,
                  originPoint: o,
                  position: s,
                  overlayRect: e,
                })
          }
          if (i.length) {
            let t = null,
              e = -1
            for (const n of i) {
              const i =
                n.boundingBoxRect.width *
                n.boundingBoxRect.height *
                (n.position.weight || 1)
              i > e && ((e = i), (t = n))
            }
            return (
              (this._isPushed = !1),
              void this._applyPosition(t.position, t.origin)
            )
          }
          if (this._canPush)
            return (
              (this._isPushed = !0),
              void this._applyPosition(r.position, r.originPoint)
            )
          this._applyPosition(r.position, r.originPoint)
        }
        detach() {
          this._clearPanelClasses(),
            (this._lastPosition = null),
            (this._previousPushAmount = null),
            this._resizeSubscription.unsubscribe()
        }
        dispose() {
          this._isDisposed ||
            (this._boundingBox &&
              M(this._boundingBox.style, {
                top: '',
                left: '',
                right: '',
                bottom: '',
                height: '',
                width: '',
                alignItems: '',
                justifyContent: '',
              }),
            this._pane && this._resetOverlayElementStyles(),
            this._overlayRef &&
              this._overlayRef.hostElement.classList.remove(L),
            this.detach(),
            this._positionChanges.complete(),
            (this._overlayRef = this._boundingBox = null),
            (this._isDisposed = !0))
        }
        reapplyLastPosition() {
          if (
            !this._isDisposed &&
            (!this._platform || this._platform.isBrowser)
          ) {
            ;(this._originRect = this._getOriginRect()),
              (this._overlayRect = this._pane.getBoundingClientRect()),
              (this._viewportRect = this._getNarrowedViewportRect())
            const t = this._lastPosition || this._preferredPositions[0],
              e = this._getOriginPoint(this._originRect, t)
            this._applyPosition(t, e)
          }
        }
        withScrollableContainers(t) {
          return (this._scrollables = t), this
        }
        withPositions(t) {
          return (
            (this._preferredPositions = t),
            -1 === t.indexOf(this._lastPosition) && (this._lastPosition = null),
            this._validatePositions(),
            this
          )
        }
        withViewportMargin(t) {
          return (this._viewportMargin = t), this
        }
        withFlexibleDimensions(t = !0) {
          return (this._hasFlexibleDimensions = t), this
        }
        withGrowAfterOpen(t = !0) {
          return (this._growAfterOpen = t), this
        }
        withPush(t = !0) {
          return (this._canPush = t), this
        }
        withLockedPosition(t = !0) {
          return (this._positionLocked = t), this
        }
        setOrigin(t) {
          return (this._origin = t), this
        }
        withDefaultOffsetX(t) {
          return (this._offsetX = t), this
        }
        withDefaultOffsetY(t) {
          return (this._offsetY = t), this
        }
        withTransformOriginOn(t) {
          return (this._transformOriginSelector = t), this
        }
        _getOriginPoint(t, e) {
          let n, i
          if ('center' == e.originX) n = t.left + t.width / 2
          else {
            const i = this._isRtl() ? t.right : t.left,
              r = this._isRtl() ? t.left : t.right
            n = 'start' == e.originX ? i : r
          }
          return (
            (i =
              'center' == e.originY
                ? t.top + t.height / 2
                : 'top' == e.originY
                ? t.top
                : t.bottom),
            { x: n, y: i }
          )
        }
        _getOverlayPoint(t, e, n) {
          let i, r
          return (
            (i =
              'center' == n.overlayX
                ? -e.width / 2
                : 'start' === n.overlayX
                ? this._isRtl()
                  ? -e.width
                  : 0
                : this._isRtl()
                ? 0
                : -e.width),
            (r =
              'center' == n.overlayY
                ? -e.height / 2
                : 'top' == n.overlayY
                ? 0
                : -e.height),
            { x: t.x + i, y: t.y + r }
          )
        }
        _getOverlayFit(t, e, n, i) {
          let { x: r, y: s } = t,
            o = this._getOffset(i, 'x'),
            a = this._getOffset(i, 'y')
          o && (r += o), a && (s += a)
          let l = 0 - s,
            c = s + e.height - n.height,
            u = this._subtractOverflows(e.width, 0 - r, r + e.width - n.width),
            h = this._subtractOverflows(e.height, l, c),
            d = u * h
          return {
            visibleArea: d,
            isCompletelyWithinViewport: e.width * e.height === d,
            fitsInViewportVertically: h === e.height,
            fitsInViewportHorizontally: u == e.width,
          }
        }
        _canFitWithFlexibleDimensions(t, e, n) {
          if (this._hasFlexibleDimensions) {
            const i = n.bottom - e.y,
              r = n.right - e.x,
              s = V(this._overlayRef.getConfig().minHeight),
              o = V(this._overlayRef.getConfig().minWidth),
              a = t.fitsInViewportHorizontally || (null != o && o <= r)
            return (t.fitsInViewportVertically || (null != s && s <= i)) && a
          }
          return !1
        }
        _pushOverlayOnScreen(t, e, n) {
          if (this._previousPushAmount && this._positionLocked)
            return {
              x: t.x + this._previousPushAmount.x,
              y: t.y + this._previousPushAmount.y,
            }
          const i = this._viewportRect,
            r = Math.max(t.x + e.width - i.width, 0),
            s = Math.max(t.y + e.height - i.height, 0),
            o = Math.max(i.top - n.top - t.y, 0),
            a = Math.max(i.left - n.left - t.x, 0)
          let l = 0,
            c = 0
          return (
            (l =
              e.width <= i.width
                ? a || -r
                : t.x < this._viewportMargin
                ? i.left - n.left - t.x
                : 0),
            (c =
              e.height <= i.height
                ? o || -s
                : t.y < this._viewportMargin
                ? i.top - n.top - t.y
                : 0),
            (this._previousPushAmount = { x: l, y: c }),
            { x: t.x + l, y: t.y + c }
          )
        }
        _applyPosition(t, e) {
          if (
            (this._setTransformOrigin(t),
            this._setOverlayElementStyles(e, t),
            this._setBoundingBoxStyles(e, t),
            t.panelClass && this._addPanelClasses(t.panelClass),
            (this._lastPosition = t),
            this._positionChanges.observers.length)
          ) {
            const e = this._getScrollVisibility(),
              n = new A(t, e)
            this._positionChanges.next(n)
          }
          this._isInitialRender = !1
        }
        _setTransformOrigin(t) {
          if (!this._transformOriginSelector) return
          const e = this._boundingBox.querySelectorAll(
            this._transformOriginSelector
          )
          let n,
            i = t.overlayY
          n =
            'center' === t.overlayX
              ? 'center'
              : this._isRtl()
              ? 'start' === t.overlayX
                ? 'right'
                : 'left'
              : 'start' === t.overlayX
              ? 'left'
              : 'right'
          for (let r = 0; r < e.length; r++)
            e[r].style.transformOrigin = `${n} ${i}`
        }
        _calculateBoundingBoxRect(t, e) {
          const n = this._viewportRect,
            i = this._isRtl()
          let r, s, o, a, l, c
          if ('top' === e.overlayY)
            (s = t.y), (r = n.height - s + this._viewportMargin)
          else if ('bottom' === e.overlayY)
            (o = n.height - t.y + 2 * this._viewportMargin),
              (r = n.height - o + this._viewportMargin)
          else {
            const e = Math.min(n.bottom - t.y + n.top, t.y),
              i = this._lastBoundingBoxSize.height
            ;(r = 2 * e),
              (s = t.y - e),
              r > i &&
                !this._isInitialRender &&
                !this._growAfterOpen &&
                (s = t.y - i / 2)
          }
          if (('end' === e.overlayX && !i) || ('start' === e.overlayX && i))
            (c = n.width - t.x + this._viewportMargin),
              (a = t.x - this._viewportMargin)
          else if (
            ('start' === e.overlayX && !i) ||
            ('end' === e.overlayX && i)
          )
            (l = t.x), (a = n.right - t.x)
          else {
            const e = Math.min(n.right - t.x + n.left, t.x),
              i = this._lastBoundingBoxSize.width
            ;(a = 2 * e),
              (l = t.x - e),
              a > i &&
                !this._isInitialRender &&
                !this._growAfterOpen &&
                (l = t.x - i / 2)
          }
          return { top: s, left: l, bottom: o, right: c, width: a, height: r }
        }
        _setBoundingBoxStyles(t, e) {
          const n = this._calculateBoundingBoxRect(t, e)
          this._isInitialRender ||
            this._growAfterOpen ||
            ((n.height = Math.min(n.height, this._lastBoundingBoxSize.height)),
            (n.width = Math.min(n.width, this._lastBoundingBoxSize.width)))
          const i = {}
          if (this._hasExactPosition())
            (i.top = i.left = '0'),
              (i.bottom = i.right = i.maxHeight = i.maxWidth = ''),
              (i.width = i.height = '100%')
          else {
            const t = this._overlayRef.getConfig().maxHeight,
              r = this._overlayRef.getConfig().maxWidth
            ;(i.height = Object(l.c)(n.height)),
              (i.top = Object(l.c)(n.top)),
              (i.bottom = Object(l.c)(n.bottom)),
              (i.width = Object(l.c)(n.width)),
              (i.left = Object(l.c)(n.left)),
              (i.right = Object(l.c)(n.right)),
              (i.alignItems =
                'center' === e.overlayX
                  ? 'center'
                  : 'end' === e.overlayX
                  ? 'flex-end'
                  : 'flex-start'),
              (i.justifyContent =
                'center' === e.overlayY
                  ? 'center'
                  : 'bottom' === e.overlayY
                  ? 'flex-end'
                  : 'flex-start'),
              t && (i.maxHeight = Object(l.c)(t)),
              r && (i.maxWidth = Object(l.c)(r))
          }
          ;(this._lastBoundingBoxSize = n), M(this._boundingBox.style, i)
        }
        _resetBoundingBoxStyles() {
          M(this._boundingBox.style, {
            top: '0',
            left: '0',
            right: '0',
            bottom: '0',
            height: '',
            width: '',
            alignItems: '',
            justifyContent: '',
          })
        }
        _resetOverlayElementStyles() {
          M(this._pane.style, {
            top: '',
            left: '',
            bottom: '',
            right: '',
            position: '',
            transform: '',
          })
        }
        _setOverlayElementStyles(t, e) {
          const n = {},
            i = this._hasExactPosition(),
            r = this._hasFlexibleDimensions,
            s = this._overlayRef.getConfig()
          if (i) {
            const i = this._viewportRuler.getViewportScrollPosition()
            M(n, this._getExactOverlayY(e, t, i)),
              M(n, this._getExactOverlayX(e, t, i))
          } else n.position = 'static'
          let o = '',
            a = this._getOffset(e, 'x'),
            c = this._getOffset(e, 'y')
          a && (o += `translateX(${a}px) `),
            c && (o += `translateY(${c}px)`),
            (n.transform = o.trim()),
            s.maxHeight &&
              (i
                ? (n.maxHeight = Object(l.c)(s.maxHeight))
                : r && (n.maxHeight = '')),
            s.maxWidth &&
              (i
                ? (n.maxWidth = Object(l.c)(s.maxWidth))
                : r && (n.maxWidth = '')),
            M(this._pane.style, n)
        }
        _getExactOverlayY(t, e, n) {
          let i = { top: '', bottom: '' },
            r = this._getOverlayPoint(e, this._overlayRect, t)
          this._isPushed &&
            (r = this._pushOverlayOnScreen(r, this._overlayRect, n))
          let s = this._overlayContainer
            .getContainerElement()
            .getBoundingClientRect().top
          return (
            (r.y -= s),
            'bottom' === t.overlayY
              ? (i.bottom =
                  this._document.documentElement.clientHeight -
                  (r.y + this._overlayRect.height) +
                  'px')
              : (i.top = Object(l.c)(r.y)),
            i
          )
        }
        _getExactOverlayX(t, e, n) {
          let i,
            r = { left: '', right: '' },
            s = this._getOverlayPoint(e, this._overlayRect, t)
          return (
            this._isPushed &&
              (s = this._pushOverlayOnScreen(s, this._overlayRect, n)),
            (i = this._isRtl()
              ? 'end' === t.overlayX
                ? 'left'
                : 'right'
              : 'end' === t.overlayX
              ? 'right'
              : 'left'),
            'right' === i
              ? (r.right =
                  this._document.documentElement.clientWidth -
                  (s.x + this._overlayRect.width) +
                  'px')
              : (r.left = Object(l.c)(s.x)),
            r
          )
        }
        _getScrollVisibility() {
          const t = this._getOriginRect(),
            e = this._pane.getBoundingClientRect(),
            n = this._scrollables.map((t) =>
              t.getElementRef().nativeElement.getBoundingClientRect()
            )
          return {
            isOriginClipped: x(t, n),
            isOriginOutsideView: C(t, n),
            isOverlayClipped: x(e, n),
            isOverlayOutsideView: C(e, n),
          }
        }
        _subtractOverflows(t, ...e) {
          return e.reduce((t, e) => t - Math.max(e, 0), t)
        }
        _getNarrowedViewportRect() {
          const t = this._document.documentElement.clientWidth,
            e = this._document.documentElement.clientHeight,
            n = this._viewportRuler.getViewportScrollPosition()
          return {
            top: n.top + this._viewportMargin,
            left: n.left + this._viewportMargin,
            right: n.left + t - this._viewportMargin,
            bottom: n.top + e - this._viewportMargin,
            width: t - 2 * this._viewportMargin,
            height: e - 2 * this._viewportMargin,
          }
        }
        _isRtl() {
          return 'rtl' === this._overlayRef.getDirection()
        }
        _hasExactPosition() {
          return !this._hasFlexibleDimensions || this._isPushed
        }
        _getOffset(t, e) {
          return 'x' === e
            ? null == t.offsetX
              ? this._offsetX
              : t.offsetX
            : null == t.offsetY
            ? this._offsetY
            : t.offsetY
        }
        _validatePositions() {}
        _addPanelClasses(t) {
          this._pane &&
            Object(l.a)(t).forEach((t) => {
              '' !== t &&
                -1 === this._appliedPanelClasses.indexOf(t) &&
                (this._appliedPanelClasses.push(t), this._pane.classList.add(t))
            })
        }
        _clearPanelClasses() {
          this._pane &&
            (this._appliedPanelClasses.forEach((t) => {
              this._pane.classList.remove(t)
            }),
            (this._appliedPanelClasses = []))
        }
        _getOriginRect() {
          const t = this._origin
          if (t instanceof r.l) return t.nativeElement.getBoundingClientRect()
          if (t instanceof Element) return t.getBoundingClientRect()
          const e = t.width || 0,
            n = t.height || 0
          return {
            top: t.y,
            bottom: t.y + n,
            left: t.x,
            right: t.x + e,
            height: n,
            width: e,
          }
        }
      }
      function M(t, e) {
        for (let n in e) e.hasOwnProperty(n) && (t[n] = e[n])
        return t
      }
      function V(t) {
        if ('number' != typeof t && null != t) {
          const [e, n] = t.split(F)
          return n && 'px' !== n ? null : parseFloat(e)
        }
        return t || null
      }
      class U {
        constructor(t, e, n, i, r, s, o) {
          ;(this._preferredPositions = []),
            (this._positionStrategy = new N(n, i, r, s, o)
              .withFlexibleDimensions(!1)
              .withPush(!1)
              .withViewportMargin(0)),
            this.withFallbackPosition(t, e),
            (this.onPositionChange = this._positionStrategy.positionChanges)
        }
        get positions() {
          return this._preferredPositions
        }
        attach(t) {
          ;(this._overlayRef = t),
            this._positionStrategy.attach(t),
            this._direction &&
              (t.setDirection(this._direction), (this._direction = null))
        }
        dispose() {
          this._positionStrategy.dispose()
        }
        detach() {
          this._positionStrategy.detach()
        }
        apply() {
          this._positionStrategy.apply()
        }
        recalculateLastPosition() {
          this._positionStrategy.reapplyLastPosition()
        }
        withScrollableContainers(t) {
          this._positionStrategy.withScrollableContainers(t)
        }
        withFallbackPosition(t, e, n, i) {
          const r = new E(t, e, n, i)
          return (
            this._preferredPositions.push(r),
            this._positionStrategy.withPositions(this._preferredPositions),
            this
          )
        }
        withDirection(t) {
          return (
            this._overlayRef
              ? this._overlayRef.setDirection(t)
              : (this._direction = t),
            this
          )
        }
        withOffsetX(t) {
          return this._positionStrategy.withDefaultOffsetX(t), this
        }
        withOffsetY(t) {
          return this._positionStrategy.withDefaultOffsetY(t), this
        }
        withLockedPosition(t) {
          return this._positionStrategy.withLockedPosition(t), this
        }
        withPositions(t) {
          return (
            (this._preferredPositions = t.slice()),
            this._positionStrategy.withPositions(this._preferredPositions),
            this
          )
        }
        setOrigin(t) {
          return this._positionStrategy.setOrigin(t), this
        }
      }
      const B = 'cdk-global-overlay-wrapper'
      class z {
        constructor() {
          ;(this._cssPosition = 'static'),
            (this._topOffset = ''),
            (this._bottomOffset = ''),
            (this._leftOffset = ''),
            (this._rightOffset = ''),
            (this._alignItems = ''),
            (this._justifyContent = ''),
            (this._width = ''),
            (this._height = '')
        }
        attach(t) {
          const e = t.getConfig()
          ;(this._overlayRef = t),
            this._width && !e.width && t.updateSize({ width: this._width }),
            this._height && !e.height && t.updateSize({ height: this._height }),
            t.hostElement.classList.add(B),
            (this._isDisposed = !1)
        }
        top(t = '') {
          return (
            (this._bottomOffset = ''),
            (this._topOffset = t),
            (this._alignItems = 'flex-start'),
            this
          )
        }
        left(t = '') {
          return (
            (this._rightOffset = ''),
            (this._leftOffset = t),
            (this._justifyContent = 'flex-start'),
            this
          )
        }
        bottom(t = '') {
          return (
            (this._topOffset = ''),
            (this._bottomOffset = t),
            (this._alignItems = 'flex-end'),
            this
          )
        }
        right(t = '') {
          return (
            (this._leftOffset = ''),
            (this._rightOffset = t),
            (this._justifyContent = 'flex-end'),
            this
          )
        }
        width(t = '') {
          return (
            this._overlayRef
              ? this._overlayRef.updateSize({ width: t })
              : (this._width = t),
            this
          )
        }
        height(t = '') {
          return (
            this._overlayRef
              ? this._overlayRef.updateSize({ height: t })
              : (this._height = t),
            this
          )
        }
        centerHorizontally(t = '') {
          return this.left(t), (this._justifyContent = 'center'), this
        }
        centerVertically(t = '') {
          return this.top(t), (this._alignItems = 'center'), this
        }
        apply() {
          if (!this._overlayRef || !this._overlayRef.hasAttached()) return
          const t = this._overlayRef.overlayElement.style,
            e = this._overlayRef.hostElement.style,
            n = this._overlayRef.getConfig(),
            { width: i, height: r, maxWidth: s, maxHeight: o } = n,
            a = !(
              ('100%' !== i && '100vw' !== i) ||
              (s && '100%' !== s && '100vw' !== s)
            ),
            l = !(
              ('100%' !== r && '100vh' !== r) ||
              (o && '100%' !== o && '100vh' !== o)
            )
          ;(t.position = this._cssPosition),
            (t.marginLeft = a ? '0' : this._leftOffset),
            (t.marginTop = l ? '0' : this._topOffset),
            (t.marginBottom = this._bottomOffset),
            (t.marginRight = this._rightOffset),
            a
              ? (e.justifyContent = 'flex-start')
              : 'center' === this._justifyContent
              ? (e.justifyContent = 'center')
              : 'rtl' === this._overlayRef.getConfig().direction
              ? 'flex-start' === this._justifyContent
                ? (e.justifyContent = 'flex-end')
                : 'flex-end' === this._justifyContent &&
                  (e.justifyContent = 'flex-start')
              : (e.justifyContent = this._justifyContent),
            (e.alignItems = l ? 'flex-start' : this._alignItems)
        }
        dispose() {
          if (this._isDisposed || !this._overlayRef) return
          const t = this._overlayRef.overlayElement.style,
            e = this._overlayRef.hostElement,
            n = e.style
          e.classList.remove(B),
            (n.justifyContent = n.alignItems = t.marginTop = t.marginBottom = t.marginLeft = t.marginRight = t.position =
              ''),
            (this._overlayRef = null),
            (this._isDisposed = !0)
        }
      }
      let H = (() => {
          class t {
            constructor(t, e, n, i) {
              ;(this._viewportRuler = t),
                (this._document = e),
                (this._platform = n),
                (this._overlayContainer = i)
            }
            global() {
              return new z()
            }
            connectedTo(t, e, n) {
              return new U(
                e,
                n,
                t,
                this._viewportRuler,
                this._document,
                this._platform,
                this._overlayContainer
              )
            }
            flexibleConnectedTo(t) {
              return new N(
                t,
                this._viewportRuler,
                this._document,
                this._platform,
                this._overlayContainer
              )
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(r.Ub(i.e), r.Ub(a.d), r.Ub(s.a), r.Ub(R))
            }),
            (t.ɵprov = Object(r.Hb)({
              factory: function () {
                return new t(
                  Object(r.Ub)(i.e),
                  Object(r.Ub)(a.d),
                  Object(r.Ub)(s.a),
                  Object(r.Ub)(R)
                )
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        q = 0,
        W = (() => {
          class t {
            constructor(t, e, n, i, r, s, o, a, l, c, u) {
              ;(this.scrollStrategies = t),
                (this._overlayContainer = e),
                (this._componentFactoryResolver = n),
                (this._positionBuilder = i),
                (this._keyboardDispatcher = r),
                (this._injector = s),
                (this._ngZone = o),
                (this._document = a),
                (this._directionality = l),
                (this._location = c),
                (this._outsideClickDispatcher = u)
            }
            create(t) {
              const e = this._createHostElement(),
                n = this._createPaneElement(e),
                i = this._createPortalOutlet(n),
                r = new k(t)
              return (
                (r.direction = r.direction || this._directionality.value),
                new D(
                  i,
                  e,
                  n,
                  r,
                  this._ngZone,
                  this._keyboardDispatcher,
                  this._document,
                  this._location,
                  this._outsideClickDispatcher
                )
              )
            }
            position() {
              return this._positionBuilder
            }
            _createPaneElement(t) {
              const e = this._document.createElement('div')
              return (
                (e.id = 'cdk-overlay-' + q++),
                e.classList.add('cdk-overlay-pane'),
                t.appendChild(e),
                e
              )
            }
            _createHostElement() {
              const t = this._document.createElement('div')
              return (
                this._overlayContainer.getContainerElement().appendChild(t), t
              )
            }
            _createPortalOutlet(t) {
              return (
                this._appRef || (this._appRef = this._injector.get(r.g)),
                new c.b(
                  t,
                  this._componentFactoryResolver,
                  this._appRef,
                  this._injector,
                  this._document
                )
              )
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                r.Ub(O),
                r.Ub(R),
                r.Ub(r.j),
                r.Ub(H),
                r.Ub(j),
                r.Ub(r.r),
                r.Ub(r.z),
                r.Ub(a.d),
                r.Ub(o.b),
                r.Ub(a.g),
                r.Ub(I)
              )
            }),
            (t.ɵprov = r.Hb({ token: t, factory: t.ɵfac })),
            t
          )
        })()
      const $ = [
          {
            originX: 'start',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'top',
          },
          {
            originX: 'start',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'bottom',
          },
          {
            originX: 'end',
            originY: 'top',
            overlayX: 'end',
            overlayY: 'bottom',
          },
          {
            originX: 'end',
            originY: 'bottom',
            overlayX: 'end',
            overlayY: 'top',
          },
        ],
        G = new r.q('cdk-connected-overlay-scroll-strategy')
      let Q = (() => {
          class t {
            constructor(t) {
              this.elementRef = t
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(r.Lb(r.l))
            }),
            (t.ɵdir = r.Gb({
              type: t,
              selectors: [
                ['', 'cdk-overlay-origin', ''],
                ['', 'overlay-origin', ''],
                ['', 'cdkOverlayOrigin', ''],
              ],
              exportAs: ['cdkOverlayOrigin'],
            })),
            t
          )
        })(),
        X = (() => {
          class t {
            constructor(t, e, n, i, s) {
              ;(this._overlay = t),
                (this._dir = s),
                (this._hasBackdrop = !1),
                (this._lockPosition = !1),
                (this._growAfterOpen = !1),
                (this._flexibleDimensions = !1),
                (this._push = !1),
                (this._backdropSubscription = h.a.EMPTY),
                (this._attachSubscription = h.a.EMPTY),
                (this._detachSubscription = h.a.EMPTY),
                (this._positionSubscription = h.a.EMPTY),
                (this.viewportMargin = 0),
                (this.open = !1),
                (this.disableClose = !1),
                (this.backdropClick = new r.n()),
                (this.positionChange = new r.n()),
                (this.attach = new r.n()),
                (this.detach = new r.n()),
                (this.overlayKeydown = new r.n()),
                (this.overlayOutsideClick = new r.n()),
                (this._templatePortal = new c.e(e, n)),
                (this._scrollStrategyFactory = i),
                (this.scrollStrategy = this._scrollStrategyFactory())
            }
            get offsetX() {
              return this._offsetX
            }
            set offsetX(t) {
              ;(this._offsetX = t),
                this._position && this._updatePositionStrategy(this._position)
            }
            get offsetY() {
              return this._offsetY
            }
            set offsetY(t) {
              ;(this._offsetY = t),
                this._position && this._updatePositionStrategy(this._position)
            }
            get hasBackdrop() {
              return this._hasBackdrop
            }
            set hasBackdrop(t) {
              this._hasBackdrop = Object(l.b)(t)
            }
            get lockPosition() {
              return this._lockPosition
            }
            set lockPosition(t) {
              this._lockPosition = Object(l.b)(t)
            }
            get flexibleDimensions() {
              return this._flexibleDimensions
            }
            set flexibleDimensions(t) {
              this._flexibleDimensions = Object(l.b)(t)
            }
            get growAfterOpen() {
              return this._growAfterOpen
            }
            set growAfterOpen(t) {
              this._growAfterOpen = Object(l.b)(t)
            }
            get push() {
              return this._push
            }
            set push(t) {
              this._push = Object(l.b)(t)
            }
            get overlayRef() {
              return this._overlayRef
            }
            get dir() {
              return this._dir ? this._dir.value : 'ltr'
            }
            ngOnDestroy() {
              this._attachSubscription.unsubscribe(),
                this._detachSubscription.unsubscribe(),
                this._backdropSubscription.unsubscribe(),
                this._positionSubscription.unsubscribe(),
                this._overlayRef && this._overlayRef.dispose()
            }
            ngOnChanges(t) {
              this._position &&
                (this._updatePositionStrategy(this._position),
                this._overlayRef.updateSize({
                  width: this.width,
                  minWidth: this.minWidth,
                  height: this.height,
                  minHeight: this.minHeight,
                }),
                t.origin && this.open && this._position.apply()),
                t.open &&
                  (this.open ? this._attachOverlay() : this._detachOverlay())
            }
            _createOverlay() {
              ;(this.positions && this.positions.length) || (this.positions = $)
              const t = (this._overlayRef = this._overlay.create(
                this._buildConfig()
              ))
              ;(this._attachSubscription = t
                .attachments()
                .subscribe(() => this.attach.emit())),
                (this._detachSubscription = t
                  .detachments()
                  .subscribe(() => this.detach.emit())),
                t.keydownEvents().subscribe((t) => {
                  this.overlayKeydown.next(t),
                    t.keyCode !== _.e ||
                      this.disableClose ||
                      Object(_.o)(t) ||
                      (t.preventDefault(), this._detachOverlay())
                }),
                this._overlayRef.outsidePointerEvents().subscribe((t) => {
                  this.overlayOutsideClick.next(t)
                })
            }
            _buildConfig() {
              const t = (this._position =
                  this.positionStrategy || this._createPositionStrategy()),
                e = new k({
                  direction: this._dir,
                  positionStrategy: t,
                  scrollStrategy: this.scrollStrategy,
                  hasBackdrop: this.hasBackdrop,
                })
              return (
                (this.width || 0 === this.width) && (e.width = this.width),
                (this.height || 0 === this.height) && (e.height = this.height),
                (this.minWidth || 0 === this.minWidth) &&
                  (e.minWidth = this.minWidth),
                (this.minHeight || 0 === this.minHeight) &&
                  (e.minHeight = this.minHeight),
                this.backdropClass && (e.backdropClass = this.backdropClass),
                this.panelClass && (e.panelClass = this.panelClass),
                e
              )
            }
            _updatePositionStrategy(t) {
              const e = this.positions.map((t) => ({
                originX: t.originX,
                originY: t.originY,
                overlayX: t.overlayX,
                overlayY: t.overlayY,
                offsetX: t.offsetX || this.offsetX,
                offsetY: t.offsetY || this.offsetY,
                panelClass: t.panelClass || void 0,
              }))
              return t
                .setOrigin(this.origin.elementRef)
                .withPositions(e)
                .withFlexibleDimensions(this.flexibleDimensions)
                .withPush(this.push)
                .withGrowAfterOpen(this.growAfterOpen)
                .withViewportMargin(this.viewportMargin)
                .withLockedPosition(this.lockPosition)
                .withTransformOriginOn(this.transformOriginSelector)
            }
            _createPositionStrategy() {
              const t = this._overlay
                .position()
                .flexibleConnectedTo(this.origin.elementRef)
              return this._updatePositionStrategy(t), t
            }
            _attachOverlay() {
              this._overlayRef
                ? (this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop)
                : this._createOverlay(),
                this._overlayRef.hasAttached() ||
                  this._overlayRef.attach(this._templatePortal),
                this.hasBackdrop
                  ? (this._backdropSubscription = this._overlayRef
                      .backdropClick()
                      .subscribe((t) => {
                        this.backdropClick.emit(t)
                      }))
                  : this._backdropSubscription.unsubscribe(),
                this._positionSubscription.unsubscribe(),
                this.positionChange.observers.length > 0 &&
                  (this._positionSubscription = this._position.positionChanges
                    .pipe(
                      (function (t, e = !1) {
                        return (n) => n.lift(new g(t, e))
                      })(() => this.positionChange.observers.length > 0)
                    )
                    .subscribe((t) => {
                      this.positionChange.emit(t),
                        0 === this.positionChange.observers.length &&
                          this._positionSubscription.unsubscribe()
                    }))
            }
            _detachOverlay() {
              this._overlayRef && this._overlayRef.detach(),
                this._backdropSubscription.unsubscribe(),
                this._positionSubscription.unsubscribe()
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                r.Lb(W),
                r.Lb(r.L),
                r.Lb(r.P),
                r.Lb(G),
                r.Lb(o.b, 8)
              )
            }),
            (t.ɵdir = r.Gb({
              type: t,
              selectors: [
                ['', 'cdk-connected-overlay', ''],
                ['', 'connected-overlay', ''],
                ['', 'cdkConnectedOverlay', ''],
              ],
              inputs: {
                viewportMargin: [
                  'cdkConnectedOverlayViewportMargin',
                  'viewportMargin',
                ],
                open: ['cdkConnectedOverlayOpen', 'open'],
                disableClose: [
                  'cdkConnectedOverlayDisableClose',
                  'disableClose',
                ],
                scrollStrategy: [
                  'cdkConnectedOverlayScrollStrategy',
                  'scrollStrategy',
                ],
                offsetX: ['cdkConnectedOverlayOffsetX', 'offsetX'],
                offsetY: ['cdkConnectedOverlayOffsetY', 'offsetY'],
                hasBackdrop: ['cdkConnectedOverlayHasBackdrop', 'hasBackdrop'],
                lockPosition: [
                  'cdkConnectedOverlayLockPosition',
                  'lockPosition',
                ],
                flexibleDimensions: [
                  'cdkConnectedOverlayFlexibleDimensions',
                  'flexibleDimensions',
                ],
                growAfterOpen: [
                  'cdkConnectedOverlayGrowAfterOpen',
                  'growAfterOpen',
                ],
                push: ['cdkConnectedOverlayPush', 'push'],
                positions: ['cdkConnectedOverlayPositions', 'positions'],
                origin: ['cdkConnectedOverlayOrigin', 'origin'],
                positionStrategy: [
                  'cdkConnectedOverlayPositionStrategy',
                  'positionStrategy',
                ],
                width: ['cdkConnectedOverlayWidth', 'width'],
                height: ['cdkConnectedOverlayHeight', 'height'],
                minWidth: ['cdkConnectedOverlayMinWidth', 'minWidth'],
                minHeight: ['cdkConnectedOverlayMinHeight', 'minHeight'],
                backdropClass: [
                  'cdkConnectedOverlayBackdropClass',
                  'backdropClass',
                ],
                panelClass: ['cdkConnectedOverlayPanelClass', 'panelClass'],
                transformOriginSelector: [
                  'cdkConnectedOverlayTransformOriginOn',
                  'transformOriginSelector',
                ],
              },
              outputs: {
                backdropClick: 'backdropClick',
                positionChange: 'positionChange',
                attach: 'attach',
                detach: 'detach',
                overlayKeydown: 'overlayKeydown',
                overlayOutsideClick: 'overlayOutsideClick',
              },
              exportAs: ['cdkConnectedOverlay'],
              features: [r.xb],
            })),
            t
          )
        })()
      const K = {
        provide: G,
        deps: [W],
        useFactory: function (t) {
          return () => t.scrollStrategies.reposition()
        },
      }
      let Y = (() => {
        class t {}
        return (
          (t.ɵmod = r.Jb({ type: t })),
          (t.ɵinj = r.Ib({
            factory: function (e) {
              return new (e || t)()
            },
            providers: [W, K],
            imports: [[o.a, c.d, i.d], i.d],
          })),
          t
        )
      })()
    },
    t7Mq: function (t, e, n) {
      'use strict'
      var i = n('0ujj')
      n.d(e, 'a', function () {
        return i.a
      })
      var r = n('iBb4')
      n.d(e, 'b', function () {
        return r.a
      }),
        n('ZL+G'),
        n('cPJY'),
        n('yXgJ')
    },
    tyNb: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return H
      }),
        n.d(e, 'b', function () {
          return pn
        }),
        n.d(e, 'c', function () {
          return fn
        }),
        n.d(e, 'd', function () {
          return kn
        }),
        n.d(e, 'e', function () {
          return gn
        })
      var i = n('ofXK'),
        r = n('fXoL'),
        s = n('LRne'),
        o = n('Cfvw'),
        a = n('2Vo4'),
        l = n('itXk'),
        c = n('HDdC')
      const u = (() => {
        function t() {
          return (
            Error.call(this),
            (this.message = 'no elements in sequence'),
            (this.name = 'EmptyError'),
            this
          )
        }
        return (t.prototype = Object.create(Error.prototype)), t
      })()
      var h = n('NXyV'),
        d = n('EY2u'),
        p = n('XNiG'),
        f = n('lJxs'),
        m = n('0EUg'),
        g = n('pLZG'),
        b = n('7o/Q'),
        _ = n('4I5i')
      function y(t) {
        return function (e) {
          return 0 === t ? Object(d.b)() : e.lift(new v(t))
        }
      }
      class v {
        constructor(t) {
          if (((this.total = t), this.total < 0)) throw new _.a()
        }
        call(t, e) {
          return e.subscribe(new w(t, this.total))
        }
      }
      class w extends b.a {
        constructor(t, e) {
          super(t),
            (this.total = e),
            (this.ring = new Array()),
            (this.count = 0)
        }
        _next(t) {
          const e = this.ring,
            n = this.total,
            i = this.count++
          e.length < n ? e.push(t) : (e[i % n] = t)
        }
        _complete() {
          const t = this.destination
          let e = this.count
          if (e > 0) {
            const n = this.count >= this.total ? this.total : this.count,
              i = this.ring
            for (let r = 0; r < n; r++) {
              const r = e++ % n
              t.next(i[r])
            }
          }
          t.complete()
        }
      }
      function C(t = O) {
        return (e) => e.lift(new x(t))
      }
      class x {
        constructor(t) {
          this.errorFactory = t
        }
        call(t, e) {
          return e.subscribe(new S(t, this.errorFactory))
        }
      }
      class S extends b.a {
        constructor(t, e) {
          super(t), (this.errorFactory = e), (this.hasValue = !1)
        }
        _next(t) {
          ;(this.hasValue = !0), this.destination.next(t)
        }
        _complete() {
          if (this.hasValue) return this.destination.complete()
          {
            let e
            try {
              e = this.errorFactory()
            } catch (t) {
              e = t
            }
            this.destination.error(e)
          }
        }
      }
      function O() {
        return new u()
      }
      function k(t = null) {
        return (e) => e.lift(new E(t))
      }
      class E {
        constructor(t) {
          this.defaultValue = t
        }
        call(t, e) {
          return e.subscribe(new A(t, this.defaultValue))
        }
      }
      class A extends b.a {
        constructor(t, e) {
          super(t), (this.defaultValue = e), (this.isEmpty = !0)
        }
        _next(t) {
          ;(this.isEmpty = !1), this.destination.next(t)
        }
        _complete() {
          this.isEmpty && this.destination.next(this.defaultValue),
            this.destination.complete()
        }
      }
      var T = n('SpAZ'),
        j = n('eIep'),
        I = n('IzEk'),
        P = n('JX91')
      class R {
        constructor(t, e, n = !1) {
          ;(this.accumulator = t), (this.seed = e), (this.hasSeed = n)
        }
        call(t, e) {
          return e.subscribe(
            new D(t, this.accumulator, this.seed, this.hasSeed)
          )
        }
      }
      class D extends b.a {
        constructor(t, e, n, i) {
          super(t),
            (this.accumulator = e),
            (this._seed = n),
            (this.hasSeed = i),
            (this.index = 0)
        }
        get seed() {
          return this._seed
        }
        set seed(t) {
          ;(this.hasSeed = !0), (this._seed = t)
        }
        _next(t) {
          if (this.hasSeed) return this._tryNext(t)
          ;(this.seed = t), this.destination.next(t)
        }
        _tryNext(t) {
          const e = this.index++
          let n
          try {
            n = this.accumulator(this.seed, t, e)
          } catch (i) {
            this.destination.error(i)
          }
          ;(this.seed = n), this.destination.next(n)
        }
      }
      var L = n('JIr8'),
        F = n('bOdf')
      function N(t, e) {
        const n = arguments.length >= 2
        return (i) =>
          i.pipe(
            t ? Object(g.a)((e, n) => t(e, n, i)) : T.a,
            Object(I.a)(1),
            n ? k(e) : C(() => new u())
          )
      }
      var M = n('5+tZ'),
        V = n('vkgz'),
        U = n('nYR2'),
        B = n('bHdf')
      class z {
        constructor(t, e) {
          ;(this.id = t), (this.url = e)
        }
      }
      class H extends z {
        constructor(t, e, n = 'imperative', i = null) {
          super(t, e), (this.navigationTrigger = n), (this.restoredState = i)
        }
        toString() {
          return `NavigationStart(id: ${this.id}, url: '${this.url}')`
        }
      }
      class q extends z {
        constructor(t, e, n) {
          super(t, e), (this.urlAfterRedirects = n)
        }
        toString() {
          return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`
        }
      }
      class W extends z {
        constructor(t, e, n) {
          super(t, e), (this.reason = n)
        }
        toString() {
          return `NavigationCancel(id: ${this.id}, url: '${this.url}')`
        }
      }
      class $ extends z {
        constructor(t, e, n) {
          super(t, e), (this.error = n)
        }
        toString() {
          return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`
        }
      }
      class G extends z {
        constructor(t, e, n, i) {
          super(t, e), (this.urlAfterRedirects = n), (this.state = i)
        }
        toString() {
          return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
        }
      }
      class Q extends z {
        constructor(t, e, n, i) {
          super(t, e), (this.urlAfterRedirects = n), (this.state = i)
        }
        toString() {
          return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
        }
      }
      class X extends z {
        constructor(t, e, n, i, r) {
          super(t, e),
            (this.urlAfterRedirects = n),
            (this.state = i),
            (this.shouldActivate = r)
        }
        toString() {
          return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`
        }
      }
      class K extends z {
        constructor(t, e, n, i) {
          super(t, e), (this.urlAfterRedirects = n), (this.state = i)
        }
        toString() {
          return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
        }
      }
      class Y extends z {
        constructor(t, e, n, i) {
          super(t, e), (this.urlAfterRedirects = n), (this.state = i)
        }
        toString() {
          return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
        }
      }
      class Z {
        constructor(t) {
          this.route = t
        }
        toString() {
          return `RouteConfigLoadStart(path: ${this.route.path})`
        }
      }
      class J {
        constructor(t) {
          this.route = t
        }
        toString() {
          return `RouteConfigLoadEnd(path: ${this.route.path})`
        }
      }
      class tt {
        constructor(t) {
          this.snapshot = t
        }
        toString() {
          return `ChildActivationStart(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ''
          }')`
        }
      }
      class et {
        constructor(t) {
          this.snapshot = t
        }
        toString() {
          return `ChildActivationEnd(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ''
          }')`
        }
      }
      class nt {
        constructor(t) {
          this.snapshot = t
        }
        toString() {
          return `ActivationStart(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ''
          }')`
        }
      }
      class it {
        constructor(t) {
          this.snapshot = t
        }
        toString() {
          return `ActivationEnd(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ''
          }')`
        }
      }
      class rt {
        constructor(t, e, n) {
          ;(this.routerEvent = t), (this.position = e), (this.anchor = n)
        }
        toString() {
          return `Scroll(anchor: '${this.anchor}', position: '${
            this.position ? `${this.position[0]}, ${this.position[1]}` : null
          }')`
        }
      }
      const st = 'primary'
      class ot {
        constructor(t) {
          this.params = t || {}
        }
        has(t) {
          return Object.prototype.hasOwnProperty.call(this.params, t)
        }
        get(t) {
          if (this.has(t)) {
            const e = this.params[t]
            return Array.isArray(e) ? e[0] : e
          }
          return null
        }
        getAll(t) {
          if (this.has(t)) {
            const e = this.params[t]
            return Array.isArray(e) ? e : [e]
          }
          return []
        }
        get keys() {
          return Object.keys(this.params)
        }
      }
      function at(t) {
        return new ot(t)
      }
      function lt(t) {
        const e = Error('NavigationCancelingError: ' + t)
        return (e.ngNavigationCancelingError = !0), e
      }
      function ct(t, e, n) {
        const i = n.path.split('/')
        if (i.length > t.length) return null
        if ('full' === n.pathMatch && (e.hasChildren() || i.length < t.length))
          return null
        const r = {}
        for (let s = 0; s < i.length; s++) {
          const e = i[s],
            n = t[s]
          if (e.startsWith(':')) r[e.substring(1)] = n
          else if (e !== n.path) return null
        }
        return { consumed: t.slice(0, i.length), posParams: r }
      }
      function ut(t, e) {
        const n = Object.keys(t),
          i = Object.keys(e)
        if (!n || !i || n.length != i.length) return !1
        let r
        for (let s = 0; s < n.length; s++)
          if (((r = n[s]), !ht(t[r], e[r]))) return !1
        return !0
      }
      function ht(t, e) {
        if (Array.isArray(t) && Array.isArray(e)) {
          if (t.length !== e.length) return !1
          const n = [...t].sort(),
            i = [...e].sort()
          return n.every((t, e) => i[e] === t)
        }
        return t === e
      }
      function dt(t) {
        return Array.prototype.concat.apply([], t)
      }
      function pt(t) {
        return t.length > 0 ? t[t.length - 1] : null
      }
      function ft(t, e) {
        for (const n in t) t.hasOwnProperty(n) && e(t[n], n)
      }
      function mt(t) {
        return Object(r.qb)(t)
          ? t
          : Object(r.rb)(t)
          ? Object(o.a)(Promise.resolve(t))
          : Object(s.a)(t)
      }
      function gt(t, e, n) {
        return n
          ? (function (t, e) {
              return ut(t, e)
            })(t.queryParams, e.queryParams) && bt(t.root, e.root)
          : (function (t, e) {
              return (
                Object.keys(e).length <= Object.keys(t).length &&
                Object.keys(e).every((n) => ht(t[n], e[n]))
              )
            })(t.queryParams, e.queryParams) && _t(t.root, e.root)
      }
      function bt(t, e) {
        if (!xt(t.segments, e.segments)) return !1
        if (t.numberOfChildren !== e.numberOfChildren) return !1
        for (const n in e.children) {
          if (!t.children[n]) return !1
          if (!bt(t.children[n], e.children[n])) return !1
        }
        return !0
      }
      function _t(t, e) {
        return yt(t, e, e.segments)
      }
      function yt(t, e, n) {
        if (t.segments.length > n.length)
          return !!xt(t.segments.slice(0, n.length), n) && !e.hasChildren()
        if (t.segments.length === n.length) {
          if (!xt(t.segments, n)) return !1
          for (const n in e.children) {
            if (!t.children[n]) return !1
            if (!_t(t.children[n], e.children[n])) return !1
          }
          return !0
        }
        {
          const i = n.slice(0, t.segments.length),
            r = n.slice(t.segments.length)
          return (
            !!xt(t.segments, i) &&
            !!t.children.primary &&
            yt(t.children.primary, e, r)
          )
        }
      }
      class vt {
        constructor(t, e, n) {
          ;(this.root = t), (this.queryParams = e), (this.fragment = n)
        }
        get queryParamMap() {
          return (
            this._queryParamMap || (this._queryParamMap = at(this.queryParams)),
            this._queryParamMap
          )
        }
        toString() {
          return Et.serialize(this)
        }
      }
      class wt {
        constructor(t, e) {
          ;(this.segments = t),
            (this.children = e),
            (this.parent = null),
            ft(e, (t, e) => (t.parent = this))
        }
        hasChildren() {
          return this.numberOfChildren > 0
        }
        get numberOfChildren() {
          return Object.keys(this.children).length
        }
        toString() {
          return At(this)
        }
      }
      class Ct {
        constructor(t, e) {
          ;(this.path = t), (this.parameters = e)
        }
        get parameterMap() {
          return (
            this._parameterMap || (this._parameterMap = at(this.parameters)),
            this._parameterMap
          )
        }
        toString() {
          return Lt(this)
        }
      }
      function xt(t, e) {
        return t.length === e.length && t.every((t, n) => t.path === e[n].path)
      }
      function St(t, e) {
        let n = []
        return (
          ft(t.children, (t, i) => {
            i === st && (n = n.concat(e(t, i)))
          }),
          ft(t.children, (t, i) => {
            i !== st && (n = n.concat(e(t, i)))
          }),
          n
        )
      }
      class Ot {}
      class kt {
        parse(t) {
          const e = new Ut(t)
          return new vt(
            e.parseRootSegment(),
            e.parseQueryParams(),
            e.parseFragment()
          )
        }
        serialize(t) {
          return `${'/' + Tt(t.root, !0)}${(function (t) {
            const e = Object.keys(t).map((e) => {
              const n = t[e]
              return Array.isArray(n)
                ? n.map((t) => `${It(e)}=${It(t)}`).join('&')
                : `${It(e)}=${It(n)}`
            })
            return e.length ? '?' + e.join('&') : ''
          })(t.queryParams)}${
            'string' == typeof t.fragment ? '#' + encodeURI(t.fragment) : ''
          }`
        }
      }
      const Et = new kt()
      function At(t) {
        return t.segments.map((t) => Lt(t)).join('/')
      }
      function Tt(t, e) {
        if (!t.hasChildren()) return At(t)
        if (e) {
          const e = t.children.primary ? Tt(t.children.primary, !1) : '',
            n = []
          return (
            ft(t.children, (t, e) => {
              e !== st && n.push(`${e}:${Tt(t, !1)}`)
            }),
            n.length > 0 ? `${e}(${n.join('//')})` : e
          )
        }
        {
          const e = St(t, (e, n) =>
            n === st ? [Tt(t.children.primary, !1)] : [`${n}:${Tt(e, !1)}`]
          )
          return 1 === Object.keys(t.children).length &&
            null != t.children.primary
            ? `${At(t)}/${e[0]}`
            : `${At(t)}/(${e.join('//')})`
        }
      }
      function jt(t) {
        return encodeURIComponent(t)
          .replace(/%40/g, '@')
          .replace(/%3A/gi, ':')
          .replace(/%24/g, '$')
          .replace(/%2C/gi, ',')
      }
      function It(t) {
        return jt(t).replace(/%3B/gi, ';')
      }
      function Pt(t) {
        return jt(t)
          .replace(/\(/g, '%28')
          .replace(/\)/g, '%29')
          .replace(/%26/gi, '&')
      }
      function Rt(t) {
        return decodeURIComponent(t)
      }
      function Dt(t) {
        return Rt(t.replace(/\+/g, '%20'))
      }
      function Lt(t) {
        return `${Pt(t.path)}${
          ((e = t.parameters),
          Object.keys(e)
            .map((t) => `;${Pt(t)}=${Pt(e[t])}`)
            .join(''))
        }`
        var e
      }
      const Ft = /^[^\/()?;=#]+/
      function Nt(t) {
        const e = t.match(Ft)
        return e ? e[0] : ''
      }
      const Mt = /^[^=?&#]+/,
        Vt = /^[^?&#]+/
      class Ut {
        constructor(t) {
          ;(this.url = t), (this.remaining = t)
        }
        parseRootSegment() {
          return (
            this.consumeOptional('/'),
            '' === this.remaining ||
            this.peekStartsWith('?') ||
            this.peekStartsWith('#')
              ? new wt([], {})
              : new wt([], this.parseChildren())
          )
        }
        parseQueryParams() {
          const t = {}
          if (this.consumeOptional('?'))
            do {
              this.parseQueryParam(t)
            } while (this.consumeOptional('&'))
          return t
        }
        parseFragment() {
          return this.consumeOptional('#')
            ? decodeURIComponent(this.remaining)
            : null
        }
        parseChildren() {
          if ('' === this.remaining) return {}
          this.consumeOptional('/')
          const t = []
          for (
            this.peekStartsWith('(') || t.push(this.parseSegment());
            this.peekStartsWith('/') &&
            !this.peekStartsWith('//') &&
            !this.peekStartsWith('/(');

          )
            this.capture('/'), t.push(this.parseSegment())
          let e = {}
          this.peekStartsWith('/(') &&
            (this.capture('/'), (e = this.parseParens(!0)))
          let n = {}
          return (
            this.peekStartsWith('(') && (n = this.parseParens(!1)),
            (t.length > 0 || Object.keys(e).length > 0) &&
              (n.primary = new wt(t, e)),
            n
          )
        }
        parseSegment() {
          const t = Nt(this.remaining)
          if ('' === t && this.peekStartsWith(';'))
            throw new Error(
              `Empty path url segment cannot have parameters: '${this.remaining}'.`
            )
          return this.capture(t), new Ct(Rt(t), this.parseMatrixParams())
        }
        parseMatrixParams() {
          const t = {}
          for (; this.consumeOptional(';'); ) this.parseParam(t)
          return t
        }
        parseParam(t) {
          const e = Nt(this.remaining)
          if (!e) return
          this.capture(e)
          let n = ''
          if (this.consumeOptional('=')) {
            const t = Nt(this.remaining)
            t && ((n = t), this.capture(n))
          }
          t[Rt(e)] = Rt(n)
        }
        parseQueryParam(t) {
          const e = (function (t) {
            const e = t.match(Mt)
            return e ? e[0] : ''
          })(this.remaining)
          if (!e) return
          this.capture(e)
          let n = ''
          if (this.consumeOptional('=')) {
            const t = (function (t) {
              const e = t.match(Vt)
              return e ? e[0] : ''
            })(this.remaining)
            t && ((n = t), this.capture(n))
          }
          const i = Dt(e),
            r = Dt(n)
          if (t.hasOwnProperty(i)) {
            let e = t[i]
            Array.isArray(e) || ((e = [e]), (t[i] = e)), e.push(r)
          } else t[i] = r
        }
        parseParens(t) {
          const e = {}
          for (
            this.capture('(');
            !this.consumeOptional(')') && this.remaining.length > 0;

          ) {
            const n = Nt(this.remaining),
              i = this.remaining[n.length]
            if ('/' !== i && ')' !== i && ';' !== i)
              throw new Error(`Cannot parse url '${this.url}'`)
            let r = void 0
            n.indexOf(':') > -1
              ? ((r = n.substr(0, n.indexOf(':'))),
                this.capture(r),
                this.capture(':'))
              : t && (r = st)
            const s = this.parseChildren()
            ;(e[r] = 1 === Object.keys(s).length ? s.primary : new wt([], s)),
              this.consumeOptional('//')
          }
          return e
        }
        peekStartsWith(t) {
          return this.remaining.startsWith(t)
        }
        consumeOptional(t) {
          return (
            !!this.peekStartsWith(t) &&
            ((this.remaining = this.remaining.substring(t.length)), !0)
          )
        }
        capture(t) {
          if (!this.consumeOptional(t)) throw new Error(`Expected "${t}".`)
        }
      }
      class Bt {
        constructor(t) {
          this._root = t
        }
        get root() {
          return this._root.value
        }
        parent(t) {
          const e = this.pathFromRoot(t)
          return e.length > 1 ? e[e.length - 2] : null
        }
        children(t) {
          const e = zt(t, this._root)
          return e ? e.children.map((t) => t.value) : []
        }
        firstChild(t) {
          const e = zt(t, this._root)
          return e && e.children.length > 0 ? e.children[0].value : null
        }
        siblings(t) {
          const e = Ht(t, this._root)
          return e.length < 2
            ? []
            : e[e.length - 2].children
                .map((t) => t.value)
                .filter((e) => e !== t)
        }
        pathFromRoot(t) {
          return Ht(t, this._root).map((t) => t.value)
        }
      }
      function zt(t, e) {
        if (t === e.value) return e
        for (const n of e.children) {
          const e = zt(t, n)
          if (e) return e
        }
        return null
      }
      function Ht(t, e) {
        if (t === e.value) return [e]
        for (const n of e.children) {
          const i = Ht(t, n)
          if (i.length) return i.unshift(e), i
        }
        return []
      }
      class qt {
        constructor(t, e) {
          ;(this.value = t), (this.children = e)
        }
        toString() {
          return `TreeNode(${this.value})`
        }
      }
      function Wt(t) {
        const e = {}
        return t && t.children.forEach((t) => (e[t.value.outlet] = t)), e
      }
      class $t extends Bt {
        constructor(t, e) {
          super(t), (this.snapshot = e), Zt(this, t)
        }
        toString() {
          return this.snapshot.toString()
        }
      }
      function Gt(t, e) {
        const n = (function (t, e) {
            const n = new Kt([], {}, {}, '', {}, st, e, null, t.root, -1, {})
            return new Yt('', new qt(n, []))
          })(t, e),
          i = new a.a([new Ct('', {})]),
          r = new a.a({}),
          s = new a.a({}),
          o = new a.a({}),
          l = new a.a(''),
          c = new Qt(i, r, o, l, s, st, e, n.root)
        return (c.snapshot = n.root), new $t(new qt(c, []), n)
      }
      class Qt {
        constructor(t, e, n, i, r, s, o, a) {
          ;(this.url = t),
            (this.params = e),
            (this.queryParams = n),
            (this.fragment = i),
            (this.data = r),
            (this.outlet = s),
            (this.component = o),
            (this._futureSnapshot = a)
        }
        get routeConfig() {
          return this._futureSnapshot.routeConfig
        }
        get root() {
          return this._routerState.root
        }
        get parent() {
          return this._routerState.parent(this)
        }
        get firstChild() {
          return this._routerState.firstChild(this)
        }
        get children() {
          return this._routerState.children(this)
        }
        get pathFromRoot() {
          return this._routerState.pathFromRoot(this)
        }
        get paramMap() {
          return (
            this._paramMap ||
              (this._paramMap = this.params.pipe(Object(f.a)((t) => at(t)))),
            this._paramMap
          )
        }
        get queryParamMap() {
          return (
            this._queryParamMap ||
              (this._queryParamMap = this.queryParams.pipe(
                Object(f.a)((t) => at(t))
              )),
            this._queryParamMap
          )
        }
        toString() {
          return this.snapshot
            ? this.snapshot.toString()
            : `Future(${this._futureSnapshot})`
        }
      }
      function Xt(t, e = 'emptyOnly') {
        const n = t.pathFromRoot
        let i = 0
        if ('always' !== e)
          for (i = n.length - 1; i >= 1; ) {
            const t = n[i],
              e = n[i - 1]
            if (t.routeConfig && '' === t.routeConfig.path) i--
            else {
              if (e.component) break
              i--
            }
          }
        return (function (t) {
          return t.reduce(
            (t, e) => ({
              params: Object.assign(Object.assign({}, t.params), e.params),
              data: Object.assign(Object.assign({}, t.data), e.data),
              resolve: Object.assign(
                Object.assign({}, t.resolve),
                e._resolvedData
              ),
            }),
            { params: {}, data: {}, resolve: {} }
          )
        })(n.slice(i))
      }
      class Kt {
        constructor(t, e, n, i, r, s, o, a, l, c, u) {
          ;(this.url = t),
            (this.params = e),
            (this.queryParams = n),
            (this.fragment = i),
            (this.data = r),
            (this.outlet = s),
            (this.component = o),
            (this.routeConfig = a),
            (this._urlSegment = l),
            (this._lastPathIndex = c),
            (this._resolve = u)
        }
        get root() {
          return this._routerState.root
        }
        get parent() {
          return this._routerState.parent(this)
        }
        get firstChild() {
          return this._routerState.firstChild(this)
        }
        get children() {
          return this._routerState.children(this)
        }
        get pathFromRoot() {
          return this._routerState.pathFromRoot(this)
        }
        get paramMap() {
          return (
            this._paramMap || (this._paramMap = at(this.params)), this._paramMap
          )
        }
        get queryParamMap() {
          return (
            this._queryParamMap || (this._queryParamMap = at(this.queryParams)),
            this._queryParamMap
          )
        }
        toString() {
          return `Route(url:'${this.url
            .map((t) => t.toString())
            .join('/')}', path:'${
            this.routeConfig ? this.routeConfig.path : ''
          }')`
        }
      }
      class Yt extends Bt {
        constructor(t, e) {
          super(e), (this.url = t), Zt(this, e)
        }
        toString() {
          return Jt(this._root)
        }
      }
      function Zt(t, e) {
        ;(e.value._routerState = t), e.children.forEach((e) => Zt(t, e))
      }
      function Jt(t) {
        const e =
          t.children.length > 0 ? ` { ${t.children.map(Jt).join(', ')} } ` : ''
        return `${t.value}${e}`
      }
      function te(t) {
        if (t.snapshot) {
          const e = t.snapshot,
            n = t._futureSnapshot
          ;(t.snapshot = n),
            ut(e.queryParams, n.queryParams) ||
              t.queryParams.next(n.queryParams),
            e.fragment !== n.fragment && t.fragment.next(n.fragment),
            ut(e.params, n.params) || t.params.next(n.params),
            (function (t, e) {
              if (t.length !== e.length) return !1
              for (let n = 0; n < t.length; ++n) if (!ut(t[n], e[n])) return !1
              return !0
            })(e.url, n.url) || t.url.next(n.url),
            ut(e.data, n.data) || t.data.next(n.data)
        } else
          (t.snapshot = t._futureSnapshot), t.data.next(t._futureSnapshot.data)
      }
      function ee(t, e) {
        var n, i
        return (
          ut(t.params, e.params) &&
          xt((n = t.url), (i = e.url)) &&
          n.every((t, e) => ut(t.parameters, i[e].parameters)) &&
          !(!t.parent != !e.parent) &&
          (!t.parent || ee(t.parent, e.parent))
        )
      }
      function ne(t, e, n) {
        if (n && t.shouldReuseRoute(e.value, n.value.snapshot)) {
          const i = n.value
          i._futureSnapshot = e.value
          const r = (function (t, e, n) {
            return e.children.map((e) => {
              for (const i of n.children)
                if (t.shouldReuseRoute(e.value, i.value.snapshot))
                  return ne(t, e, i)
              return ne(t, e)
            })
          })(t, e, n)
          return new qt(i, r)
        }
        {
          const n = t.retrieve(e.value)
          if (n) {
            const t = n.route
            return ie(e, t), t
          }
          {
            const n = new Qt(
                new a.a((i = e.value).url),
                new a.a(i.params),
                new a.a(i.queryParams),
                new a.a(i.fragment),
                new a.a(i.data),
                i.outlet,
                i.component,
                i
              ),
              r = e.children.map((e) => ne(t, e))
            return new qt(n, r)
          }
        }
        var i
      }
      function ie(t, e) {
        if (t.value.routeConfig !== e.value.routeConfig)
          throw new Error(
            'Cannot reattach ActivatedRouteSnapshot created from a different route'
          )
        if (t.children.length !== e.children.length)
          throw new Error(
            'Cannot reattach ActivatedRouteSnapshot with a different number of children'
          )
        e.value._futureSnapshot = t.value
        for (let n = 0; n < t.children.length; ++n)
          ie(t.children[n], e.children[n])
      }
      function re(t) {
        return 'object' == typeof t && null != t && !t.outlets && !t.segmentPath
      }
      function se(t) {
        return 'object' == typeof t && null != t && t.outlets
      }
      function oe(t, e, n, i, r) {
        let s = {}
        return (
          i &&
            ft(i, (t, e) => {
              s[e] = Array.isArray(t) ? t.map((t) => '' + t) : '' + t
            }),
          new vt(n.root === t ? e : ae(n.root, t, e), s, r)
        )
      }
      function ae(t, e, n) {
        const i = {}
        return (
          ft(t.children, (t, r) => {
            i[r] = t === e ? n : ae(t, e, n)
          }),
          new wt(t.segments, i)
        )
      }
      class le {
        constructor(t, e, n) {
          if (
            ((this.isAbsolute = t),
            (this.numberOfDoubleDots = e),
            (this.commands = n),
            t && n.length > 0 && re(n[0]))
          )
            throw new Error('Root segment cannot have matrix parameters')
          const i = n.find(se)
          if (i && i !== pt(n))
            throw new Error('{outlets:{}} has to be the last command')
        }
        toRoot() {
          return (
            this.isAbsolute &&
            1 === this.commands.length &&
            '/' == this.commands[0]
          )
        }
      }
      class ce {
        constructor(t, e, n) {
          ;(this.segmentGroup = t), (this.processChildren = e), (this.index = n)
        }
      }
      function ue(t, e, n) {
        if (
          (t || (t = new wt([], {})),
          0 === t.segments.length && t.hasChildren())
        )
          return he(t, e, n)
        const i = (function (t, e, n) {
            let i = 0,
              r = e
            const s = { match: !1, pathIndex: 0, commandIndex: 0 }
            for (; r < t.segments.length; ) {
              if (i >= n.length) return s
              const e = t.segments[r],
                o = n[i]
              if (se(o)) break
              const a = '' + o,
                l = i < n.length - 1 ? n[i + 1] : null
              if (r > 0 && void 0 === a) break
              if (a && l && 'object' == typeof l && void 0 === l.outlets) {
                if (!me(a, l, e)) return s
                i += 2
              } else {
                if (!me(a, {}, e)) return s
                i++
              }
              r++
            }
            return { match: !0, pathIndex: r, commandIndex: i }
          })(t, e, n),
          r = n.slice(i.commandIndex)
        if (i.match && i.pathIndex < t.segments.length) {
          const e = new wt(t.segments.slice(0, i.pathIndex), {})
          return (
            (e.children.primary = new wt(
              t.segments.slice(i.pathIndex),
              t.children
            )),
            he(e, 0, r)
          )
        }
        return i.match && 0 === r.length
          ? new wt(t.segments, {})
          : i.match && !t.hasChildren()
          ? de(t, e, n)
          : i.match
          ? he(t, 0, r)
          : de(t, e, n)
      }
      function he(t, e, n) {
        if (0 === n.length) return new wt(t.segments, {})
        {
          const i = (function (t) {
              return se(t[0]) ? t[0].outlets : { [st]: t }
            })(n),
            r = {}
          return (
            ft(i, (n, i) => {
              'string' == typeof n && (n = [n]),
                null !== n && (r[i] = ue(t.children[i], e, n))
            }),
            ft(t.children, (t, e) => {
              void 0 === i[e] && (r[e] = t)
            }),
            new wt(t.segments, r)
          )
        }
      }
      function de(t, e, n) {
        const i = t.segments.slice(0, e)
        let r = 0
        for (; r < n.length; ) {
          const s = n[r]
          if (se(s)) {
            const t = pe(s.outlets)
            return new wt(i, t)
          }
          if (0 === r && re(n[0])) {
            i.push(new Ct(t.segments[e].path, n[0])), r++
            continue
          }
          const o = se(s) ? s.outlets.primary : '' + s,
            a = r < n.length - 1 ? n[r + 1] : null
          o && a && re(a)
            ? (i.push(new Ct(o, fe(a))), (r += 2))
            : (i.push(new Ct(o, {})), r++)
        }
        return new wt(i, {})
      }
      function pe(t) {
        const e = {}
        return (
          ft(t, (t, n) => {
            'string' == typeof t && (t = [t]),
              null !== t && (e[n] = de(new wt([], {}), 0, t))
          }),
          e
        )
      }
      function fe(t) {
        const e = {}
        return ft(t, (t, n) => (e[n] = '' + t)), e
      }
      function me(t, e, n) {
        return t == n.path && ut(e, n.parameters)
      }
      class ge {
        constructor(t, e, n, i) {
          ;(this.routeReuseStrategy = t),
            (this.futureState = e),
            (this.currState = n),
            (this.forwardEvent = i)
        }
        activate(t) {
          const e = this.futureState._root,
            n = this.currState ? this.currState._root : null
          this.deactivateChildRoutes(e, n, t),
            te(this.futureState.root),
            this.activateChildRoutes(e, n, t)
        }
        deactivateChildRoutes(t, e, n) {
          const i = Wt(e)
          t.children.forEach((t) => {
            const e = t.value.outlet
            this.deactivateRoutes(t, i[e], n), delete i[e]
          }),
            ft(i, (t, e) => {
              this.deactivateRouteAndItsChildren(t, n)
            })
        }
        deactivateRoutes(t, e, n) {
          const i = t.value,
            r = e ? e.value : null
          if (i === r)
            if (i.component) {
              const r = n.getContext(i.outlet)
              r && this.deactivateChildRoutes(t, e, r.children)
            } else this.deactivateChildRoutes(t, e, n)
          else r && this.deactivateRouteAndItsChildren(e, n)
        }
        deactivateRouteAndItsChildren(t, e) {
          this.routeReuseStrategy.shouldDetach(t.value.snapshot)
            ? this.detachAndStoreRouteSubtree(t, e)
            : this.deactivateRouteAndOutlet(t, e)
        }
        detachAndStoreRouteSubtree(t, e) {
          const n = e.getContext(t.value.outlet)
          if (n && n.outlet) {
            const e = n.outlet.detach(),
              i = n.children.onOutletDeactivated()
            this.routeReuseStrategy.store(t.value.snapshot, {
              componentRef: e,
              route: t,
              contexts: i,
            })
          }
        }
        deactivateRouteAndOutlet(t, e) {
          const n = e.getContext(t.value.outlet)
          if (n) {
            const i = Wt(t),
              r = t.value.component ? n.children : e
            ft(i, (t, e) => this.deactivateRouteAndItsChildren(t, r)),
              n.outlet &&
                (n.outlet.deactivate(), n.children.onOutletDeactivated())
          }
        }
        activateChildRoutes(t, e, n) {
          const i = Wt(e)
          t.children.forEach((t) => {
            this.activateRoutes(t, i[t.value.outlet], n),
              this.forwardEvent(new it(t.value.snapshot))
          }),
            t.children.length && this.forwardEvent(new et(t.value.snapshot))
        }
        activateRoutes(t, e, n) {
          const i = t.value,
            r = e ? e.value : null
          if ((te(i), i === r))
            if (i.component) {
              const r = n.getOrCreateContext(i.outlet)
              this.activateChildRoutes(t, e, r.children)
            } else this.activateChildRoutes(t, e, n)
          else if (i.component) {
            const e = n.getOrCreateContext(i.outlet)
            if (this.routeReuseStrategy.shouldAttach(i.snapshot)) {
              const t = this.routeReuseStrategy.retrieve(i.snapshot)
              this.routeReuseStrategy.store(i.snapshot, null),
                e.children.onOutletReAttached(t.contexts),
                (e.attachRef = t.componentRef),
                (e.route = t.route.value),
                e.outlet && e.outlet.attach(t.componentRef, t.route.value),
                be(t.route)
            } else {
              const n = (function (t) {
                  for (let e = t.parent; e; e = e.parent) {
                    const t = e.routeConfig
                    if (t && t._loadedConfig) return t._loadedConfig
                    if (t && t.component) return null
                  }
                  return null
                })(i.snapshot),
                r = n ? n.module.componentFactoryResolver : null
              ;(e.attachRef = null),
                (e.route = i),
                (e.resolver = r),
                e.outlet && e.outlet.activateWith(i, r),
                this.activateChildRoutes(t, null, e.children)
            }
          } else this.activateChildRoutes(t, null, n)
        }
      }
      function be(t) {
        te(t.value), t.children.forEach(be)
      }
      class _e {
        constructor(t, e) {
          ;(this.routes = t), (this.module = e)
        }
      }
      function ye(t) {
        return 'function' == typeof t
      }
      function ve(t) {
        return t instanceof vt
      }
      const we = Symbol('INITIAL_VALUE')
      function Ce() {
        return Object(j.a)((t) =>
          Object(l.b)(
            ...t.map((t) => t.pipe(Object(I.a)(1), Object(P.a)(we)))
          ).pipe(
            (function (t, e) {
              let n = !1
              return (
                arguments.length >= 2 && (n = !0),
                function (i) {
                  return i.lift(new R(t, e, n))
                }
              )
            })((t, e) => {
              let n = !1
              return e.reduce((t, i, r) => {
                if (t !== we) return t
                if ((i === we && (n = !0), !n)) {
                  if (!1 === i) return i
                  if (r === e.length - 1 || ve(i)) return i
                }
                return t
              }, t)
            }, we),
            Object(g.a)((t) => t !== we),
            Object(f.a)((t) => (ve(t) ? t : !0 === t)),
            Object(I.a)(1)
          )
        )
      }
      let xe = (() => {
        class t {}
        return (
          (t.ɵfac = function (e) {
            return new (e || t)()
          }),
          (t.ɵcmp = r.Fb({
            type: t,
            selectors: [['ng-component']],
            decls: 1,
            vars: 0,
            template: function (t, e) {
              1 & t && r.Mb(0, 'router-outlet')
            },
            directives: function () {
              return [gn]
            },
            encapsulation: 2,
          })),
          t
        )
      })()
      function Se(t, e = '') {
        for (let n = 0; n < t.length; n++) {
          const i = t[n]
          Oe(i, ke(e, i))
        }
      }
      function Oe(t, e) {
        t.children && Se(t.children, e)
      }
      function ke(t, e) {
        return e
          ? t || e.path
            ? t && !e.path
              ? t + '/'
              : !t && e.path
              ? e.path
              : `${t}/${e.path}`
            : ''
          : t
      }
      function Ee(t) {
        const e = t.children && t.children.map(Ee),
          n = e
            ? Object.assign(Object.assign({}, t), { children: e })
            : Object.assign({}, t)
        return (
          !n.component &&
            (e || n.loadChildren) &&
            n.outlet &&
            n.outlet !== st &&
            (n.component = xe),
          n
        )
      }
      function Ae(t) {
        return t.outlet || st
      }
      class Te {
        constructor(t) {
          this.segmentGroup = t || null
        }
      }
      class je {
        constructor(t) {
          this.urlTree = t
        }
      }
      function Ie(t) {
        return new c.a((e) => e.error(new Te(t)))
      }
      function Pe(t) {
        return new c.a((e) => e.error(new je(t)))
      }
      function Re(t) {
        return new c.a((e) =>
          e.error(
            new Error(
              `Only absolute redirects can have named outlets. redirectTo: '${t}'`
            )
          )
        )
      }
      class De {
        constructor(t, e, n, i, s) {
          ;(this.configLoader = e),
            (this.urlSerializer = n),
            (this.urlTree = i),
            (this.config = s),
            (this.allowRedirects = !0),
            (this.ngModule = t.get(r.x))
        }
        apply() {
          return this.expandSegmentGroup(
            this.ngModule,
            this.config,
            this.urlTree.root,
            st
          )
            .pipe(
              Object(f.a)((t) =>
                this.createUrlTree(
                  t,
                  this.urlTree.queryParams,
                  this.urlTree.fragment
                )
              )
            )
            .pipe(
              Object(L.a)((t) => {
                if (t instanceof je)
                  return (this.allowRedirects = !1), this.match(t.urlTree)
                if (t instanceof Te) throw this.noMatchError(t)
                throw t
              })
            )
        }
        match(t) {
          return this.expandSegmentGroup(this.ngModule, this.config, t.root, st)
            .pipe(
              Object(f.a)((e) =>
                this.createUrlTree(e, t.queryParams, t.fragment)
              )
            )
            .pipe(
              Object(L.a)((t) => {
                if (t instanceof Te) throw this.noMatchError(t)
                throw t
              })
            )
        }
        noMatchError(t) {
          return new Error(
            `Cannot match any routes. URL Segment: '${t.segmentGroup}'`
          )
        }
        createUrlTree(t, e, n) {
          const i = t.segments.length > 0 ? new wt([], { [st]: t }) : t
          return new vt(i, e, n)
        }
        expandSegmentGroup(t, e, n, i) {
          return 0 === n.segments.length && n.hasChildren()
            ? this.expandChildren(t, e, n).pipe(
                Object(f.a)((t) => new wt([], t))
              )
            : this.expandSegment(t, n, e, n.segments, i, !0)
        }
        expandChildren(t, e, n) {
          return (function (t, e) {
            if (0 === Object.keys(t).length) return Object(s.a)({})
            const n = [],
              i = [],
              r = {}
            return (
              ft(t, (t, s) => {
                const o = e(s, t).pipe(Object(f.a)((t) => (r[s] = t)))
                s === st ? n.push(o) : i.push(o)
              }),
              s.a.apply(null, n.concat(i)).pipe(
                Object(m.a)(),
                (function (t, e) {
                  const n = arguments.length >= 2
                  return (i) =>
                    i.pipe(
                      t ? Object(g.a)((e, n) => t(e, n, i)) : T.a,
                      y(1),
                      n ? k(e) : C(() => new u())
                    )
                })(),
                Object(f.a)(() => r)
              )
            )
          })(n.children, (n, i) => this.expandSegmentGroup(t, e, i, n))
        }
        expandSegment(t, e, n, i, r, a) {
          const c = (function (t) {
            return t.reduce((t, e) => {
              const n = Ae(e)
              return t.has(n) ? t.get(n).push(e) : t.set(n, [e]), t
            }, new Map())
          })(n)
          c.has(r) || c.set(r, [])
          const h = (n) =>
              Object(o.a)(n).pipe(
                Object(F.a)((o) =>
                  this.expandSegmentAgainstRoute(t, e, n, o, i, r, a).pipe(
                    Object(L.a)((t) => {
                      if (t instanceof Te) return Object(s.a)(null)
                      throw t
                    })
                  )
                ),
                N((t) => null !== t),
                Object(L.a)((t) => {
                  if (t instanceof u || 'EmptyError' === t.name) {
                    if (this.noLeftoversInUrl(e, i, r))
                      return Object(s.a)(new wt([], {}))
                    throw new Te(e)
                  }
                  throw t
                })
              ),
            d = Array.from(c.entries()).map(([t, e]) => {
              const n = h(e)
              return t === r
                ? n
                : n.pipe(
                    Object(f.a)(() => null),
                    Object(L.a)(() => Object(s.a)(null))
                  )
            })
          return Object(o.a)(d).pipe(
            (t) => t.lift(new l.a(void 0)),
            N(),
            Object(f.a)((t) => t.find((t) => null !== t))
          )
        }
        noLeftoversInUrl(t, e, n) {
          return 0 === e.length && !t.children[n]
        }
        expandSegmentAgainstRoute(t, e, n, i, r, s, o) {
          return Ae(i) !== s && '' !== i.path
            ? Ie(e)
            : void 0 === i.redirectTo
            ? this.matchSegmentAgainstRoute(t, e, i, r)
            : o && this.allowRedirects
            ? this.expandSegmentAgainstRouteUsingRedirect(t, e, n, i, r, s)
            : Ie(e)
        }
        expandSegmentAgainstRouteUsingRedirect(t, e, n, i, r, s) {
          return '**' === i.path
            ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, n, i, s)
            : this.expandRegularSegmentAgainstRouteUsingRedirect(
                t,
                e,
                n,
                i,
                r,
                s
              )
        }
        expandWildCardWithParamsAgainstRouteUsingRedirect(t, e, n, i) {
          const r = this.applyRedirectCommands([], n.redirectTo, {})
          return n.redirectTo.startsWith('/')
            ? Pe(r)
            : this.lineralizeSegments(n, r).pipe(
                Object(M.a)((n) => {
                  const r = new wt(n, {})
                  return this.expandSegment(t, r, e, n, i, !1)
                })
              )
        }
        expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, i, r, s) {
          const {
            matched: o,
            consumedSegments: a,
            lastChild: l,
            positionalParamSegments: c,
          } = Le(e, i, r)
          if (!o) return Ie(e)
          const u = this.applyRedirectCommands(a, i.redirectTo, c)
          return i.redirectTo.startsWith('/')
            ? Pe(u)
            : this.lineralizeSegments(i, u).pipe(
                Object(M.a)((i) =>
                  this.expandSegment(t, e, n, i.concat(r.slice(l)), s, !1)
                )
              )
        }
        matchSegmentAgainstRoute(t, e, n, i) {
          if ('**' === n.path)
            return n.loadChildren
              ? this.configLoader
                  .load(t.injector, n)
                  .pipe(
                    Object(f.a)((t) => ((n._loadedConfig = t), new wt(i, {})))
                  )
              : Object(s.a)(new wt(i, {}))
          const { matched: r, consumedSegments: o, lastChild: a } = Le(e, n, i)
          if (!r) return Ie(e)
          const l = i.slice(a)
          return this.getChildConfig(t, n, i).pipe(
            Object(M.a)((t) => {
              const n = t.module,
                i = t.routes,
                { segmentGroup: r, slicedSegments: a } = (function (
                  t,
                  e,
                  n,
                  i
                ) {
                  return n.length > 0 &&
                    (function (t, e, n) {
                      return n.some((n) => Ne(t, e, n) && Ae(n) !== st)
                    })(t, n, i)
                    ? {
                        segmentGroup: Fe(
                          new wt(
                            e,
                            (function (t, e) {
                              const n = {}
                              n.primary = e
                              for (const i of t)
                                '' === i.path &&
                                  Ae(i) !== st &&
                                  (n[Ae(i)] = new wt([], {}))
                              return n
                            })(i, new wt(n, t.children))
                          )
                        ),
                        slicedSegments: [],
                      }
                    : 0 === n.length &&
                      (function (t, e, n) {
                        return n.some((n) => Ne(t, e, n))
                      })(t, n, i)
                    ? {
                        segmentGroup: Fe(
                          new wt(
                            t.segments,
                            (function (t, e, n, i) {
                              const r = {}
                              for (const s of n)
                                Ne(t, e, s) &&
                                  !i[Ae(s)] &&
                                  (r[Ae(s)] = new wt([], {}))
                              return Object.assign(Object.assign({}, i), r)
                            })(t, n, i, t.children)
                          )
                        ),
                        slicedSegments: n,
                      }
                    : { segmentGroup: t, slicedSegments: n }
                })(e, o, l, i)
              return 0 === a.length && r.hasChildren()
                ? this.expandChildren(n, i, r).pipe(
                    Object(f.a)((t) => new wt(o, t))
                  )
                : 0 === i.length && 0 === a.length
                ? Object(s.a)(new wt(o, {}))
                : this.expandSegment(n, r, i, a, st, !0).pipe(
                    Object(f.a)((t) => new wt(o.concat(t.segments), t.children))
                  )
            })
          )
        }
        getChildConfig(t, e, n) {
          return e.children
            ? Object(s.a)(new _e(e.children, t))
            : e.loadChildren
            ? void 0 !== e._loadedConfig
              ? Object(s.a)(e._loadedConfig)
              : this.runCanLoadGuards(t.injector, e, n).pipe(
                  Object(M.a)((n) =>
                    n
                      ? this.configLoader
                          .load(t.injector, e)
                          .pipe(Object(f.a)((t) => ((e._loadedConfig = t), t)))
                      : (function (t) {
                          return new c.a((e) =>
                            e.error(
                              lt(
                                `Cannot load children because the guard of the route "path: '${t.path}'" returned false`
                              )
                            )
                          )
                        })(e)
                  )
                )
            : Object(s.a)(new _e([], t))
        }
        runCanLoadGuards(t, e, n) {
          const i = e.canLoad
          if (!i || 0 === i.length) return Object(s.a)(!0)
          const r = i.map((i) => {
            const r = t.get(i)
            let s
            if (
              (function (t) {
                return t && ye(t.canLoad)
              })(r)
            )
              s = r.canLoad(e, n)
            else {
              if (!ye(r)) throw new Error('Invalid CanLoad guard')
              s = r(e, n)
            }
            return mt(s)
          })
          return Object(s.a)(r).pipe(
            Ce(),
            Object(V.a)((t) => {
              if (!ve(t)) return
              const e = lt(
                `Redirecting to "${this.urlSerializer.serialize(t)}"`
              )
              throw ((e.url = t), e)
            }),
            Object(f.a)((t) => !0 === t)
          )
        }
        lineralizeSegments(t, e) {
          let n = [],
            i = e.root
          for (;;) {
            if (((n = n.concat(i.segments)), 0 === i.numberOfChildren))
              return Object(s.a)(n)
            if (i.numberOfChildren > 1 || !i.children.primary)
              return Re(t.redirectTo)
            i = i.children.primary
          }
        }
        applyRedirectCommands(t, e, n) {
          return this.applyRedirectCreatreUrlTree(
            e,
            this.urlSerializer.parse(e),
            t,
            n
          )
        }
        applyRedirectCreatreUrlTree(t, e, n, i) {
          const r = this.createSegmentGroup(t, e.root, n, i)
          return new vt(
            r,
            this.createQueryParams(e.queryParams, this.urlTree.queryParams),
            e.fragment
          )
        }
        createQueryParams(t, e) {
          const n = {}
          return (
            ft(t, (t, i) => {
              if ('string' == typeof t && t.startsWith(':')) {
                const r = t.substring(1)
                n[i] = e[r]
              } else n[i] = t
            }),
            n
          )
        }
        createSegmentGroup(t, e, n, i) {
          const r = this.createSegments(t, e.segments, n, i)
          let s = {}
          return (
            ft(e.children, (e, r) => {
              s[r] = this.createSegmentGroup(t, e, n, i)
            }),
            new wt(r, s)
          )
        }
        createSegments(t, e, n, i) {
          return e.map((e) =>
            e.path.startsWith(':')
              ? this.findPosParam(t, e, i)
              : this.findOrReturn(e, n)
          )
        }
        findPosParam(t, e, n) {
          const i = n[e.path.substring(1)]
          if (!i)
            throw new Error(
              `Cannot redirect to '${t}'. Cannot find '${e.path}'.`
            )
          return i
        }
        findOrReturn(t, e) {
          let n = 0
          for (const i of e) {
            if (i.path === t.path) return e.splice(n), i
            n++
          }
          return t
        }
      }
      function Le(t, e, n) {
        if ('' === e.path)
          return 'full' === e.pathMatch && (t.hasChildren() || n.length > 0)
            ? {
                matched: !1,
                consumedSegments: [],
                lastChild: 0,
                positionalParamSegments: {},
              }
            : {
                matched: !0,
                consumedSegments: [],
                lastChild: 0,
                positionalParamSegments: {},
              }
        const i = (e.matcher || ct)(n, t, e)
        return i
          ? {
              matched: !0,
              consumedSegments: i.consumed,
              lastChild: i.consumed.length,
              positionalParamSegments: i.posParams,
            }
          : {
              matched: !1,
              consumedSegments: [],
              lastChild: 0,
              positionalParamSegments: {},
            }
      }
      function Fe(t) {
        if (1 === t.numberOfChildren && t.children.primary) {
          const e = t.children.primary
          return new wt(t.segments.concat(e.segments), e.children)
        }
        return t
      }
      function Ne(t, e, n) {
        return (
          (!(t.hasChildren() || e.length > 0) || 'full' !== n.pathMatch) &&
          '' === n.path &&
          void 0 !== n.redirectTo
        )
      }
      class Me {
        constructor(t) {
          ;(this.path = t), (this.route = this.path[this.path.length - 1])
        }
      }
      class Ve {
        constructor(t, e) {
          ;(this.component = t), (this.route = e)
        }
      }
      function Ue(t, e, n) {
        const i = t._root
        return ze(i, e ? e._root : null, n, [i.value])
      }
      function Be(t, e, n) {
        const i = (function (t) {
          if (!t) return null
          for (let e = t.parent; e; e = e.parent) {
            const t = e.routeConfig
            if (t && t._loadedConfig) return t._loadedConfig
          }
          return null
        })(e)
        return (i ? i.module.injector : n).get(t)
      }
      function ze(
        t,
        e,
        n,
        i,
        r = { canDeactivateChecks: [], canActivateChecks: [] }
      ) {
        const s = Wt(e)
        return (
          t.children.forEach((t) => {
            !(function (
              t,
              e,
              n,
              i,
              r = { canDeactivateChecks: [], canActivateChecks: [] }
            ) {
              const s = t.value,
                o = e ? e.value : null,
                a = n ? n.getContext(t.value.outlet) : null
              if (o && s.routeConfig === o.routeConfig) {
                const l = (function (t, e, n) {
                  if ('function' == typeof n) return n(t, e)
                  switch (n) {
                    case 'pathParamsChange':
                      return !xt(t.url, e.url)
                    case 'pathParamsOrQueryParamsChange':
                      return (
                        !xt(t.url, e.url) || !ut(t.queryParams, e.queryParams)
                      )
                    case 'always':
                      return !0
                    case 'paramsOrQueryParamsChange':
                      return !ee(t, e) || !ut(t.queryParams, e.queryParams)
                    case 'paramsChange':
                    default:
                      return !ee(t, e)
                  }
                })(o, s, s.routeConfig.runGuardsAndResolvers)
                l
                  ? r.canActivateChecks.push(new Me(i))
                  : ((s.data = o.data), (s._resolvedData = o._resolvedData)),
                  ze(t, e, s.component ? (a ? a.children : null) : n, i, r),
                  l &&
                    a &&
                    a.outlet &&
                    a.outlet.isActivated &&
                    r.canDeactivateChecks.push(new Ve(a.outlet.component, o))
              } else
                o && He(e, a, r),
                  r.canActivateChecks.push(new Me(i)),
                  ze(t, null, s.component ? (a ? a.children : null) : n, i, r)
            })(t, s[t.value.outlet], n, i.concat([t.value]), r),
              delete s[t.value.outlet]
          }),
          ft(s, (t, e) => He(t, n.getContext(e), r)),
          r
        )
      }
      function He(t, e, n) {
        const i = Wt(t),
          r = t.value
        ft(i, (t, i) => {
          He(t, r.component ? (e ? e.children.getContext(i) : null) : e, n)
        }),
          n.canDeactivateChecks.push(
            new Ve(
              r.component && e && e.outlet && e.outlet.isActivated
                ? e.outlet.component
                : null,
              r
            )
          )
      }
      function qe(t, e) {
        return null !== t && e && e(new nt(t)), Object(s.a)(!0)
      }
      function We(t, e) {
        return null !== t && e && e(new tt(t)), Object(s.a)(!0)
      }
      function $e(t, e, n) {
        const i = e.routeConfig ? e.routeConfig.canActivate : null
        if (!i || 0 === i.length) return Object(s.a)(!0)
        const r = i.map((i) =>
          Object(h.a)(() => {
            const r = Be(i, e, n)
            let s
            if (
              (function (t) {
                return t && ye(t.canActivate)
              })(r)
            )
              s = mt(r.canActivate(e, t))
            else {
              if (!ye(r)) throw new Error('Invalid CanActivate guard')
              s = mt(r(e, t))
            }
            return s.pipe(N())
          })
        )
        return Object(s.a)(r).pipe(Ce())
      }
      function Ge(t, e, n) {
        const i = e[e.length - 1],
          r = e
            .slice(0, e.length - 1)
            .reverse()
            .map((t) =>
              (function (t) {
                const e = t.routeConfig ? t.routeConfig.canActivateChild : null
                return e && 0 !== e.length ? { node: t, guards: e } : null
              })(t)
            )
            .filter((t) => null !== t)
            .map((e) =>
              Object(h.a)(() => {
                const r = e.guards.map((r) => {
                  const s = Be(r, e.node, n)
                  let o
                  if (
                    (function (t) {
                      return t && ye(t.canActivateChild)
                    })(s)
                  )
                    o = mt(s.canActivateChild(i, t))
                  else {
                    if (!ye(s))
                      throw new Error('Invalid CanActivateChild guard')
                    o = mt(s(i, t))
                  }
                  return o.pipe(N())
                })
                return Object(s.a)(r).pipe(Ce())
              })
            )
        return Object(s.a)(r).pipe(Ce())
      }
      class Qe {}
      class Xe {
        constructor(t, e, n, i, r, s) {
          ;(this.rootComponentType = t),
            (this.config = e),
            (this.urlTree = n),
            (this.url = i),
            (this.paramsInheritanceStrategy = r),
            (this.relativeLinkResolution = s)
        }
        recognize() {
          try {
            const t = Ze(
                this.urlTree.root,
                [],
                [],
                this.config,
                this.relativeLinkResolution
              ).segmentGroup,
              e = this.processSegmentGroup(this.config, t, st),
              n = new Kt(
                [],
                Object.freeze({}),
                Object.freeze(Object.assign({}, this.urlTree.queryParams)),
                this.urlTree.fragment,
                {},
                st,
                this.rootComponentType,
                null,
                this.urlTree.root,
                -1,
                {}
              ),
              i = new qt(n, e),
              r = new Yt(this.url, i)
            return this.inheritParamsAndData(r._root), Object(s.a)(r)
          } catch (t) {
            return new c.a((e) => e.error(t))
          }
        }
        inheritParamsAndData(t) {
          const e = t.value,
            n = Xt(e, this.paramsInheritanceStrategy)
          ;(e.params = Object.freeze(n.params)),
            (e.data = Object.freeze(n.data)),
            t.children.forEach((t) => this.inheritParamsAndData(t))
        }
        processSegmentGroup(t, e, n) {
          return 0 === e.segments.length && e.hasChildren()
            ? this.processChildren(t, e)
            : this.processSegment(t, e, e.segments, n)
        }
        processChildren(t, e) {
          const n = St(e, (e, n) => this.processSegmentGroup(t, e, n))
          return (
            (function (t) {
              const e = {}
              t.forEach((t) => {
                const n = e[t.value.outlet]
                if (n) {
                  const e = n.url.map((t) => t.toString()).join('/'),
                    i = t.value.url.map((t) => t.toString()).join('/')
                  throw new Error(
                    `Two segments cannot have the same outlet name: '${e}' and '${i}'.`
                  )
                }
                e[t.value.outlet] = t.value
              })
            })(n),
            n.sort((t, e) =>
              t.value.outlet === st
                ? -1
                : e.value.outlet === st
                ? 1
                : t.value.outlet.localeCompare(e.value.outlet)
            ),
            n
          )
        }
        processSegment(t, e, n, i) {
          for (const s of t)
            try {
              return this.processSegmentAgainstRoute(s, e, n, i)
            } catch (r) {
              if (!(r instanceof Qe)) throw r
            }
          if (this.noLeftoversInUrl(e, n, i)) return []
          throw new Qe()
        }
        noLeftoversInUrl(t, e, n) {
          return 0 === e.length && !t.children[n]
        }
        processSegmentAgainstRoute(t, e, n, i) {
          if (t.redirectTo) throw new Qe()
          if ((t.outlet || st) !== i) throw new Qe()
          let r,
            s = [],
            o = []
          if ('**' === t.path) {
            const s = n.length > 0 ? pt(n).parameters : {}
            r = new Kt(
              n,
              s,
              Object.freeze(Object.assign({}, this.urlTree.queryParams)),
              this.urlTree.fragment,
              tn(t),
              i,
              t.component,
              t,
              Ke(e),
              Ye(e) + n.length,
              en(t)
            )
          } else {
            const a = (function (t, e, n) {
              if ('' === e.path) {
                if ('full' === e.pathMatch && (t.hasChildren() || n.length > 0))
                  throw new Qe()
                return { consumedSegments: [], lastChild: 0, parameters: {} }
              }
              const i = (e.matcher || ct)(n, t, e)
              if (!i) throw new Qe()
              const r = {}
              ft(i.posParams, (t, e) => {
                r[e] = t.path
              })
              const s =
                i.consumed.length > 0
                  ? Object.assign(
                      Object.assign({}, r),
                      i.consumed[i.consumed.length - 1].parameters
                    )
                  : r
              return {
                consumedSegments: i.consumed,
                lastChild: i.consumed.length,
                parameters: s,
              }
            })(e, t, n)
            ;(s = a.consumedSegments),
              (o = n.slice(a.lastChild)),
              (r = new Kt(
                s,
                a.parameters,
                Object.freeze(Object.assign({}, this.urlTree.queryParams)),
                this.urlTree.fragment,
                tn(t),
                i,
                t.component,
                t,
                Ke(e),
                Ye(e) + s.length,
                en(t)
              ))
          }
          const a = (function (t) {
              return t.children
                ? t.children
                : t.loadChildren
                ? t._loadedConfig.routes
                : []
            })(t),
            { segmentGroup: l, slicedSegments: c } = Ze(
              e,
              s,
              o,
              a,
              this.relativeLinkResolution
            )
          if (0 === c.length && l.hasChildren()) {
            const t = this.processChildren(a, l)
            return [new qt(r, t)]
          }
          if (0 === a.length && 0 === c.length) return [new qt(r, [])]
          const u = this.processSegment(a, l, c, st)
          return [new qt(r, u)]
        }
      }
      function Ke(t) {
        let e = t
        for (; e._sourceSegment; ) e = e._sourceSegment
        return e
      }
      function Ye(t) {
        let e = t,
          n = e._segmentIndexShift ? e._segmentIndexShift : 0
        for (; e._sourceSegment; )
          (e = e._sourceSegment),
            (n += e._segmentIndexShift ? e._segmentIndexShift : 0)
        return n - 1
      }
      function Ze(t, e, n, i, r) {
        if (
          n.length > 0 &&
          (function (t, e, n) {
            return n.some((n) => Je(t, e, n) && Ae(n) !== st)
          })(t, n, i)
        ) {
          const r = new wt(
            e,
            (function (t, e, n, i) {
              const r = {}
              ;(r.primary = i),
                (i._sourceSegment = t),
                (i._segmentIndexShift = e.length)
              for (const s of n)
                if ('' === s.path && Ae(s) !== st) {
                  const n = new wt([], {})
                  ;(n._sourceSegment = t),
                    (n._segmentIndexShift = e.length),
                    (r[Ae(s)] = n)
                }
              return r
            })(t, e, i, new wt(n, t.children))
          )
          return (
            (r._sourceSegment = t),
            (r._segmentIndexShift = e.length),
            { segmentGroup: r, slicedSegments: [] }
          )
        }
        if (
          0 === n.length &&
          (function (t, e, n) {
            return n.some((n) => Je(t, e, n))
          })(t, n, i)
        ) {
          const s = new wt(
            t.segments,
            (function (t, e, n, i, r, s) {
              const o = {}
              for (const a of i)
                if (Je(t, n, a) && !r[Ae(a)]) {
                  const n = new wt([], {})
                  ;(n._sourceSegment = t),
                    (n._segmentIndexShift =
                      'legacy' === s ? t.segments.length : e.length),
                    (o[Ae(a)] = n)
                }
              return Object.assign(Object.assign({}, r), o)
            })(t, e, n, i, t.children, r)
          )
          return (
            (s._sourceSegment = t),
            (s._segmentIndexShift = e.length),
            { segmentGroup: s, slicedSegments: n }
          )
        }
        const s = new wt(t.segments, t.children)
        return (
          (s._sourceSegment = t),
          (s._segmentIndexShift = e.length),
          { segmentGroup: s, slicedSegments: n }
        )
      }
      function Je(t, e, n) {
        return (
          (!(t.hasChildren() || e.length > 0) || 'full' !== n.pathMatch) &&
          '' === n.path &&
          void 0 === n.redirectTo
        )
      }
      function tn(t) {
        return t.data || {}
      }
      function en(t) {
        return t.resolve || {}
      }
      function nn(t) {
        return function (e) {
          return e.pipe(
            Object(j.a)((e) => {
              const n = t(e)
              return n
                ? Object(o.a)(n).pipe(Object(f.a)(() => e))
                : Object(o.a)([e])
            })
          )
        }
      }
      class rn extends class {
        shouldDetach(t) {
          return !1
        }
        store(t, e) {}
        shouldAttach(t) {
          return !1
        }
        retrieve(t) {
          return null
        }
        shouldReuseRoute(t, e) {
          return t.routeConfig === e.routeConfig
        }
      } {}
      const sn = new r.q('ROUTES')
      class on {
        constructor(t, e, n, i) {
          ;(this.loader = t),
            (this.compiler = e),
            (this.onLoadStartListener = n),
            (this.onLoadEndListener = i)
        }
        load(t, e) {
          return (
            this.onLoadStartListener && this.onLoadStartListener(e),
            this.loadModuleFactory(e.loadChildren).pipe(
              Object(f.a)((n) => {
                this.onLoadEndListener && this.onLoadEndListener(e)
                const i = n.create(t)
                return new _e(dt(i.injector.get(sn)).map(Ee), i)
              })
            )
          )
        }
        loadModuleFactory(t) {
          return 'string' == typeof t
            ? Object(o.a)(this.loader.load(t))
            : mt(t()).pipe(
                Object(M.a)((t) =>
                  t instanceof r.v
                    ? Object(s.a)(t)
                    : Object(o.a)(this.compiler.compileModuleAsync(t))
                )
              )
        }
      }
      class an {
        constructor() {
          ;(this.outlet = null),
            (this.route = null),
            (this.resolver = null),
            (this.children = new ln()),
            (this.attachRef = null)
        }
      }
      class ln {
        constructor() {
          this.contexts = new Map()
        }
        onChildOutletCreated(t, e) {
          const n = this.getOrCreateContext(t)
          ;(n.outlet = e), this.contexts.set(t, n)
        }
        onChildOutletDestroyed(t) {
          const e = this.getContext(t)
          e && (e.outlet = null)
        }
        onOutletDeactivated() {
          const t = this.contexts
          return (this.contexts = new Map()), t
        }
        onOutletReAttached(t) {
          this.contexts = t
        }
        getOrCreateContext(t) {
          let e = this.getContext(t)
          return e || ((e = new an()), this.contexts.set(t, e)), e
        }
        getContext(t) {
          return this.contexts.get(t) || null
        }
      }
      class cn {
        shouldProcessUrl(t) {
          return !0
        }
        extract(t) {
          return t
        }
        merge(t, e) {
          return t
        }
      }
      function un(t) {
        throw t
      }
      function hn(t, e, n) {
        return e.parse('/')
      }
      function dn(t, e) {
        return Object(s.a)(null)
      }
      let pn = (() => {
          class t {
            constructor(t, e, n, i, s, o, l, c) {
              ;(this.rootComponentType = t),
                (this.urlSerializer = e),
                (this.rootContexts = n),
                (this.location = i),
                (this.config = c),
                (this.lastSuccessfulNavigation = null),
                (this.currentNavigation = null),
                (this.lastLocationChangeInfo = null),
                (this.navigationId = 0),
                (this.isNgZoneEnabled = !1),
                (this.events = new p.a()),
                (this.errorHandler = un),
                (this.malformedUriErrorHandler = hn),
                (this.navigated = !1),
                (this.lastSuccessfulId = -1),
                (this.hooks = {
                  beforePreactivation: dn,
                  afterPreactivation: dn,
                }),
                (this.urlHandlingStrategy = new cn()),
                (this.routeReuseStrategy = new rn()),
                (this.onSameUrlNavigation = 'ignore'),
                (this.paramsInheritanceStrategy = 'emptyOnly'),
                (this.urlUpdateStrategy = 'deferred'),
                (this.relativeLinkResolution = 'corrected'),
                (this.ngModule = s.get(r.x)),
                (this.console = s.get(r.Y))
              const u = s.get(r.z)
              ;(this.isNgZoneEnabled = u instanceof r.z),
                this.resetConfig(c),
                (this.currentUrlTree = new vt(new wt([], {}), {}, null)),
                (this.rawUrlTree = this.currentUrlTree),
                (this.browserUrlTree = this.currentUrlTree),
                (this.configLoader = new on(
                  o,
                  l,
                  (t) => this.triggerEvent(new Z(t)),
                  (t) => this.triggerEvent(new J(t))
                )),
                (this.routerState = Gt(
                  this.currentUrlTree,
                  this.rootComponentType
                )),
                (this.transitions = new a.a({
                  id: 0,
                  currentUrlTree: this.currentUrlTree,
                  currentRawUrl: this.currentUrlTree,
                  extractedUrl: this.urlHandlingStrategy.extract(
                    this.currentUrlTree
                  ),
                  urlAfterRedirects: this.urlHandlingStrategy.extract(
                    this.currentUrlTree
                  ),
                  rawUrl: this.currentUrlTree,
                  extras: {},
                  resolve: null,
                  reject: null,
                  promise: Promise.resolve(!0),
                  source: 'imperative',
                  restoredState: null,
                  currentSnapshot: this.routerState.snapshot,
                  targetSnapshot: null,
                  currentRouterState: this.routerState,
                  targetRouterState: null,
                  guards: { canActivateChecks: [], canDeactivateChecks: [] },
                  guardsResult: null,
                })),
                (this.navigations = this.setupNavigations(this.transitions)),
                this.processNavigations()
            }
            setupNavigations(t) {
              const e = this.events
              return t.pipe(
                Object(g.a)((t) => 0 !== t.id),
                Object(f.a)((t) =>
                  Object.assign(Object.assign({}, t), {
                    extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl),
                  })
                ),
                Object(j.a)((t) => {
                  let n = !1,
                    i = !1
                  return Object(s.a)(t).pipe(
                    Object(V.a)((t) => {
                      this.currentNavigation = {
                        id: t.id,
                        initialUrl: t.currentRawUrl,
                        extractedUrl: t.extractedUrl,
                        trigger: t.source,
                        extras: t.extras,
                        previousNavigation: this.lastSuccessfulNavigation
                          ? Object.assign(
                              Object.assign({}, this.lastSuccessfulNavigation),
                              { previousNavigation: null }
                            )
                          : null,
                      }
                    }),
                    Object(j.a)((t) => {
                      const n =
                        !this.navigated ||
                        t.extractedUrl.toString() !==
                          this.browserUrlTree.toString()
                      if (
                        ('reload' === this.onSameUrlNavigation || n) &&
                        this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)
                      )
                        return Object(s.a)(t).pipe(
                          Object(j.a)((t) => {
                            const n = this.transitions.getValue()
                            return (
                              e.next(
                                new H(
                                  t.id,
                                  this.serializeUrl(t.extractedUrl),
                                  t.source,
                                  t.restoredState
                                )
                              ),
                              n !== this.transitions.getValue() ? d.a : [t]
                            )
                          }),
                          Object(j.a)((t) => Promise.resolve(t)),
                          ((i = this.ngModule.injector),
                          (r = this.configLoader),
                          (o = this.urlSerializer),
                          (a = this.config),
                          function (t) {
                            return t.pipe(
                              Object(j.a)((t) =>
                                (function (t, e, n, i, r) {
                                  return new De(t, e, n, i, r).apply()
                                })(i, r, o, t.extractedUrl, a).pipe(
                                  Object(f.a)((e) =>
                                    Object.assign(Object.assign({}, t), {
                                      urlAfterRedirects: e,
                                    })
                                  )
                                )
                              )
                            )
                          }),
                          Object(V.a)((t) => {
                            this.currentNavigation = Object.assign(
                              Object.assign({}, this.currentNavigation),
                              { finalUrl: t.urlAfterRedirects }
                            )
                          }),
                          (function (t, e, n, i, r) {
                            return function (s) {
                              return s.pipe(
                                Object(M.a)((s) =>
                                  (function (
                                    t,
                                    e,
                                    n,
                                    i,
                                    r = 'emptyOnly',
                                    s = 'legacy'
                                  ) {
                                    return new Xe(t, e, n, i, r, s).recognize()
                                  })(
                                    t,
                                    e,
                                    s.urlAfterRedirects,
                                    n(s.urlAfterRedirects),
                                    i,
                                    r
                                  ).pipe(
                                    Object(f.a)((t) =>
                                      Object.assign(Object.assign({}, s), {
                                        targetSnapshot: t,
                                      })
                                    )
                                  )
                                )
                              )
                            }
                          })(
                            this.rootComponentType,
                            this.config,
                            (t) => this.serializeUrl(t),
                            this.paramsInheritanceStrategy,
                            this.relativeLinkResolution
                          ),
                          Object(V.a)((t) => {
                            'eager' === this.urlUpdateStrategy &&
                              (t.extras.skipLocationChange ||
                                this.setBrowserUrl(
                                  t.urlAfterRedirects,
                                  !!t.extras.replaceUrl,
                                  t.id,
                                  t.extras.state
                                ),
                              (this.browserUrlTree = t.urlAfterRedirects))
                          }),
                          Object(V.a)((t) => {
                            const n = new G(
                              t.id,
                              this.serializeUrl(t.extractedUrl),
                              this.serializeUrl(t.urlAfterRedirects),
                              t.targetSnapshot
                            )
                            e.next(n)
                          })
                        )
                      var i, r, o, a
                      if (
                        n &&
                        this.rawUrlTree &&
                        this.urlHandlingStrategy.shouldProcessUrl(
                          this.rawUrlTree
                        )
                      ) {
                        const {
                            id: n,
                            extractedUrl: i,
                            source: r,
                            restoredState: o,
                            extras: a,
                          } = t,
                          l = new H(n, this.serializeUrl(i), r, o)
                        e.next(l)
                        const c = Gt(i, this.rootComponentType).snapshot
                        return Object(s.a)(
                          Object.assign(Object.assign({}, t), {
                            targetSnapshot: c,
                            urlAfterRedirects: i,
                            extras: Object.assign(Object.assign({}, a), {
                              skipLocationChange: !1,
                              replaceUrl: !1,
                            }),
                          })
                        )
                      }
                      return (
                        (this.rawUrlTree = t.rawUrl),
                        (this.browserUrlTree = t.urlAfterRedirects),
                        t.resolve(null),
                        d.a
                      )
                    }),
                    nn((t) => {
                      const {
                        targetSnapshot: e,
                        id: n,
                        extractedUrl: i,
                        rawUrl: r,
                        extras: { skipLocationChange: s, replaceUrl: o },
                      } = t
                      return this.hooks.beforePreactivation(e, {
                        navigationId: n,
                        appliedUrlTree: i,
                        rawUrlTree: r,
                        skipLocationChange: !!s,
                        replaceUrl: !!o,
                      })
                    }),
                    Object(V.a)((t) => {
                      const e = new Q(
                        t.id,
                        this.serializeUrl(t.extractedUrl),
                        this.serializeUrl(t.urlAfterRedirects),
                        t.targetSnapshot
                      )
                      this.triggerEvent(e)
                    }),
                    Object(f.a)((t) =>
                      Object.assign(Object.assign({}, t), {
                        guards: Ue(
                          t.targetSnapshot,
                          t.currentSnapshot,
                          this.rootContexts
                        ),
                      })
                    ),
                    (function (t, e) {
                      return function (n) {
                        return n.pipe(
                          Object(M.a)((n) => {
                            const {
                              targetSnapshot: i,
                              currentSnapshot: r,
                              guards: {
                                canActivateChecks: a,
                                canDeactivateChecks: l,
                              },
                            } = n
                            return 0 === l.length && 0 === a.length
                              ? Object(s.a)(
                                  Object.assign(Object.assign({}, n), {
                                    guardsResult: !0,
                                  })
                                )
                              : (function (t, e, n, i) {
                                  return Object(o.a)(t).pipe(
                                    Object(M.a)((t) =>
                                      (function (t, e, n, i, r) {
                                        const o =
                                          e && e.routeConfig
                                            ? e.routeConfig.canDeactivate
                                            : null
                                        if (!o || 0 === o.length)
                                          return Object(s.a)(!0)
                                        const a = o.map((s) => {
                                          const o = Be(s, e, r)
                                          let a
                                          if (
                                            (function (t) {
                                              return t && ye(t.canDeactivate)
                                            })(o)
                                          )
                                            a = mt(o.canDeactivate(t, e, n, i))
                                          else {
                                            if (!ye(o))
                                              throw new Error(
                                                'Invalid CanDeactivate guard'
                                              )
                                            a = mt(o(t, e, n, i))
                                          }
                                          return a.pipe(N())
                                        })
                                        return Object(s.a)(a).pipe(Ce())
                                      })(t.component, t.route, n, e, i)
                                    ),
                                    N((t) => !0 !== t, !0)
                                  )
                                })(l, i, r, t).pipe(
                                  Object(M.a)((n) =>
                                    n && 'boolean' == typeof n
                                      ? (function (t, e, n, i) {
                                          return Object(o.a)(e).pipe(
                                            Object(F.a)((e) =>
                                              Object(o.a)([
                                                We(e.route.parent, i),
                                                qe(e.route, i),
                                                Ge(t, e.path, n),
                                                $e(t, e.route, n),
                                              ]).pipe(
                                                Object(m.a)(),
                                                N((t) => !0 !== t, !0)
                                              )
                                            ),
                                            N((t) => !0 !== t, !0)
                                          )
                                        })(i, a, t, e)
                                      : Object(s.a)(n)
                                  ),
                                  Object(f.a)((t) =>
                                    Object.assign(Object.assign({}, n), {
                                      guardsResult: t,
                                    })
                                  )
                                )
                          })
                        )
                      }
                    })(this.ngModule.injector, (t) => this.triggerEvent(t)),
                    Object(V.a)((t) => {
                      if (ve(t.guardsResult)) {
                        const e = lt(
                          `Redirecting to "${this.serializeUrl(
                            t.guardsResult
                          )}"`
                        )
                        throw ((e.url = t.guardsResult), e)
                      }
                    }),
                    Object(V.a)((t) => {
                      const e = new X(
                        t.id,
                        this.serializeUrl(t.extractedUrl),
                        this.serializeUrl(t.urlAfterRedirects),
                        t.targetSnapshot,
                        !!t.guardsResult
                      )
                      this.triggerEvent(e)
                    }),
                    Object(g.a)((t) => {
                      if (!t.guardsResult) {
                        this.resetUrlToCurrentUrlTree()
                        const n = new W(
                          t.id,
                          this.serializeUrl(t.extractedUrl),
                          ''
                        )
                        return e.next(n), t.resolve(!1), !1
                      }
                      return !0
                    }),
                    nn((t) => {
                      if (t.guards.canActivateChecks.length)
                        return Object(s.a)(t).pipe(
                          Object(V.a)((t) => {
                            const e = new K(
                              t.id,
                              this.serializeUrl(t.extractedUrl),
                              this.serializeUrl(t.urlAfterRedirects),
                              t.targetSnapshot
                            )
                            this.triggerEvent(e)
                          }),
                          Object(j.a)((t) => {
                            let n = !1
                            return Object(s.a)(t).pipe(
                              ((i = this.paramsInheritanceStrategy),
                              (r = this.ngModule.injector),
                              function (t) {
                                return t.pipe(
                                  Object(M.a)((t) => {
                                    const {
                                      targetSnapshot: e,
                                      guards: { canActivateChecks: n },
                                    } = t
                                    if (!n.length) return Object(s.a)(t)
                                    let a = 0
                                    return Object(o.a)(n).pipe(
                                      Object(F.a)((t) =>
                                        (function (t, e, n, i) {
                                          return (function (t, e, n, i) {
                                            const r = Object.keys(t)
                                            if (0 === r.length)
                                              return Object(s.a)({})
                                            const a = {}
                                            return Object(o.a)(r).pipe(
                                              Object(M.a)((r) =>
                                                (function (t, e, n, i) {
                                                  const r = Be(t, e, i)
                                                  return mt(
                                                    r.resolve
                                                      ? r.resolve(e, n)
                                                      : r(e, n)
                                                  )
                                                })(t[r], e, n, i).pipe(
                                                  Object(V.a)((t) => {
                                                    a[r] = t
                                                  })
                                                )
                                              ),
                                              y(1),
                                              Object(M.a)(() =>
                                                Object.keys(a).length ===
                                                r.length
                                                  ? Object(s.a)(a)
                                                  : d.a
                                              )
                                            )
                                          })(t._resolve, t, e, i).pipe(
                                            Object(f.a)(
                                              (e) => (
                                                (t._resolvedData = e),
                                                (t.data = Object.assign(
                                                  Object.assign({}, t.data),
                                                  Xt(t, n).resolve
                                                )),
                                                null
                                              )
                                            )
                                          )
                                        })(t.route, e, i, r)
                                      ),
                                      Object(V.a)(() => a++),
                                      y(1),
                                      Object(M.a)((e) =>
                                        a === n.length ? Object(s.a)(t) : d.a
                                      )
                                    )
                                  })
                                )
                              }),
                              Object(V.a)({
                                next: () => (n = !0),
                                complete: () => {
                                  if (!n) {
                                    const n = new W(
                                      t.id,
                                      this.serializeUrl(t.extractedUrl),
                                      "At least one route resolver didn't emit any value."
                                    )
                                    e.next(n), t.resolve(!1)
                                  }
                                },
                              })
                            )
                            var i, r
                          }),
                          Object(V.a)((t) => {
                            const e = new Y(
                              t.id,
                              this.serializeUrl(t.extractedUrl),
                              this.serializeUrl(t.urlAfterRedirects),
                              t.targetSnapshot
                            )
                            this.triggerEvent(e)
                          })
                        )
                    }),
                    nn((t) => {
                      const {
                        targetSnapshot: e,
                        id: n,
                        extractedUrl: i,
                        rawUrl: r,
                        extras: { skipLocationChange: s, replaceUrl: o },
                      } = t
                      return this.hooks.afterPreactivation(e, {
                        navigationId: n,
                        appliedUrlTree: i,
                        rawUrlTree: r,
                        skipLocationChange: !!s,
                        replaceUrl: !!o,
                      })
                    }),
                    Object(f.a)((t) => {
                      const e = (function (t, e, n) {
                        const i = ne(t, e._root, n ? n._root : void 0)
                        return new $t(i, e)
                      })(
                        this.routeReuseStrategy,
                        t.targetSnapshot,
                        t.currentRouterState
                      )
                      return Object.assign(Object.assign({}, t), {
                        targetRouterState: e,
                      })
                    }),
                    Object(V.a)((t) => {
                      ;(this.currentUrlTree = t.urlAfterRedirects),
                        (this.rawUrlTree = this.urlHandlingStrategy.merge(
                          this.currentUrlTree,
                          t.rawUrl
                        )),
                        (this.routerState = t.targetRouterState),
                        'deferred' === this.urlUpdateStrategy &&
                          (t.extras.skipLocationChange ||
                            this.setBrowserUrl(
                              this.rawUrlTree,
                              !!t.extras.replaceUrl,
                              t.id,
                              t.extras.state
                            ),
                          (this.browserUrlTree = t.urlAfterRedirects))
                    }),
                    ((r = this.rootContexts),
                    (a = this.routeReuseStrategy),
                    (l = (t) => this.triggerEvent(t)),
                    Object(f.a)(
                      (t) => (
                        new ge(
                          a,
                          t.targetRouterState,
                          t.currentRouterState,
                          l
                        ).activate(r),
                        t
                      )
                    )),
                    Object(V.a)({
                      next() {
                        n = !0
                      },
                      complete() {
                        n = !0
                      },
                    }),
                    Object(U.a)(() => {
                      if (!n && !i) {
                        this.resetUrlToCurrentUrlTree()
                        const n = new W(
                          t.id,
                          this.serializeUrl(t.extractedUrl),
                          `Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`
                        )
                        e.next(n), t.resolve(!1)
                      }
                      this.currentNavigation = null
                    }),
                    Object(L.a)((n) => {
                      if (((i = !0), (r = n) && r.ngNavigationCancelingError)) {
                        const i = ve(n.url)
                        i ||
                          ((this.navigated = !0),
                          this.resetStateAndUrl(
                            t.currentRouterState,
                            t.currentUrlTree,
                            t.rawUrl
                          ))
                        const r = new W(
                          t.id,
                          this.serializeUrl(t.extractedUrl),
                          n.message
                        )
                        e.next(r),
                          i
                            ? setTimeout(() => {
                                const e = this.urlHandlingStrategy.merge(
                                  n.url,
                                  this.rawUrlTree
                                )
                                return this.scheduleNavigation(
                                  e,
                                  'imperative',
                                  null,
                                  {
                                    skipLocationChange:
                                      t.extras.skipLocationChange,
                                    replaceUrl:
                                      'eager' === this.urlUpdateStrategy,
                                  },
                                  {
                                    resolve: t.resolve,
                                    reject: t.reject,
                                    promise: t.promise,
                                  }
                                )
                              }, 0)
                            : t.resolve(!1)
                      } else {
                        this.resetStateAndUrl(
                          t.currentRouterState,
                          t.currentUrlTree,
                          t.rawUrl
                        )
                        const i = new $(
                          t.id,
                          this.serializeUrl(t.extractedUrl),
                          n
                        )
                        e.next(i)
                        try {
                          t.resolve(this.errorHandler(n))
                        } catch (s) {
                          t.reject(s)
                        }
                      }
                      var r
                      return d.a
                    })
                  )
                  var r, a, l
                })
              )
            }
            resetRootComponentType(t) {
              ;(this.rootComponentType = t),
                (this.routerState.root.component = this.rootComponentType)
            }
            getTransition() {
              const t = this.transitions.value
              return (t.urlAfterRedirects = this.browserUrlTree), t
            }
            setTransition(t) {
              this.transitions.next(
                Object.assign(Object.assign({}, this.getTransition()), t)
              )
            }
            initialNavigation() {
              this.setUpLocationChangeListener(),
                0 === this.navigationId &&
                  this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 })
            }
            setUpLocationChangeListener() {
              this.locationSubscription ||
                (this.locationSubscription = this.location.subscribe((t) => {
                  const e = this.extractLocationChangeInfoFromEvent(t)
                  this.shouldScheduleNavigation(
                    this.lastLocationChangeInfo,
                    e
                  ) &&
                    setTimeout(() => {
                      const { source: t, state: n, urlTree: i } = e,
                        r = { replaceUrl: !0 }
                      if (n) {
                        const t = Object.assign({}, n)
                        delete t.navigationId,
                          0 !== Object.keys(t).length && (r.state = t)
                      }
                      this.scheduleNavigation(i, t, n, r)
                    }, 0),
                    (this.lastLocationChangeInfo = e)
                }))
            }
            extractLocationChangeInfoFromEvent(t) {
              var e
              return {
                source: 'popstate' === t.type ? 'popstate' : 'hashchange',
                urlTree: this.parseUrl(t.url),
                state: (
                  null === (e = t.state) || void 0 === e
                    ? void 0
                    : e.navigationId
                )
                  ? t.state
                  : null,
                transitionId: this.getTransition().id,
              }
            }
            shouldScheduleNavigation(t, e) {
              if (!t) return !0
              const n = e.urlTree.toString() === t.urlTree.toString()
              return !(
                e.transitionId === t.transitionId &&
                n &&
                (('hashchange' === e.source && 'popstate' === t.source) ||
                  ('popstate' === e.source && 'hashchange' === t.source))
              )
            }
            get url() {
              return this.serializeUrl(this.currentUrlTree)
            }
            getCurrentNavigation() {
              return this.currentNavigation
            }
            triggerEvent(t) {
              this.events.next(t)
            }
            resetConfig(t) {
              Se(t),
                (this.config = t.map(Ee)),
                (this.navigated = !1),
                (this.lastSuccessfulId = -1)
            }
            ngOnDestroy() {
              this.dispose()
            }
            dispose() {
              this.locationSubscription &&
                (this.locationSubscription.unsubscribe(),
                (this.locationSubscription = void 0))
            }
            createUrlTree(t, e = {}) {
              const {
                  relativeTo: n,
                  queryParams: i,
                  fragment: r,
                  queryParamsHandling: s,
                  preserveFragment: o,
                } = e,
                a = n || this.routerState.root,
                l = o ? this.currentUrlTree.fragment : r
              let c = null
              switch (s) {
                case 'merge':
                  c = Object.assign(
                    Object.assign({}, this.currentUrlTree.queryParams),
                    i
                  )
                  break
                case 'preserve':
                  c = this.currentUrlTree.queryParams
                  break
                default:
                  c = i || null
              }
              return (
                null !== c && (c = this.removeEmptyProps(c)),
                (function (t, e, n, i, r) {
                  if (0 === n.length) return oe(e.root, e.root, e, i, r)
                  const s = (function (t) {
                    if (
                      'string' == typeof t[0] &&
                      1 === t.length &&
                      '/' === t[0]
                    )
                      return new le(!0, 0, t)
                    let e = 0,
                      n = !1
                    const i = t.reduce((t, i, r) => {
                      if ('object' == typeof i && null != i) {
                        if (i.outlets) {
                          const e = {}
                          return (
                            ft(i.outlets, (t, n) => {
                              e[n] = 'string' == typeof t ? t.split('/') : t
                            }),
                            [...t, { outlets: e }]
                          )
                        }
                        if (i.segmentPath) return [...t, i.segmentPath]
                      }
                      return 'string' != typeof i
                        ? [...t, i]
                        : 0 === r
                        ? (i.split('/').forEach((i, r) => {
                            ;(0 == r && '.' === i) ||
                              (0 == r && '' === i
                                ? (n = !0)
                                : '..' === i
                                ? e++
                                : '' != i && t.push(i))
                          }),
                          t)
                        : [...t, i]
                    }, [])
                    return new le(n, e, i)
                  })(n)
                  if (s.toRoot()) return oe(e.root, new wt([], {}), e, i, r)
                  const o = (function (t, e, n) {
                      if (t.isAbsolute) return new ce(e.root, !0, 0)
                      if (-1 === n.snapshot._lastPathIndex) {
                        const t = n.snapshot._urlSegment
                        return new ce(t, t === e.root, 0)
                      }
                      const i = re(t.commands[0]) ? 0 : 1
                      return (function (t, e, n) {
                        let i = t,
                          r = e,
                          s = n
                        for (; s > r; ) {
                          if (((s -= r), (i = i.parent), !i))
                            throw new Error("Invalid number of '../'")
                          r = i.segments.length
                        }
                        return new ce(i, !1, r - s)
                      })(
                        n.snapshot._urlSegment,
                        n.snapshot._lastPathIndex + i,
                        t.numberOfDoubleDots
                      )
                    })(s, e, t),
                    a = o.processChildren
                      ? he(o.segmentGroup, o.index, s.commands)
                      : ue(o.segmentGroup, o.index, s.commands)
                  return oe(o.segmentGroup, a, e, i, r)
                })(a, this.currentUrlTree, t, c, l)
              )
            }
            navigateByUrl(t, e = { skipLocationChange: !1 }) {
              const n = ve(t) ? t : this.parseUrl(t),
                i = this.urlHandlingStrategy.merge(n, this.rawUrlTree)
              return this.scheduleNavigation(i, 'imperative', null, e)
            }
            navigate(t, e = { skipLocationChange: !1 }) {
              return (
                (function (t) {
                  for (let e = 0; e < t.length; e++) {
                    const n = t[e]
                    if (null == n)
                      throw new Error(
                        `The requested path contains ${n} segment at index ${e}`
                      )
                  }
                })(t),
                this.navigateByUrl(this.createUrlTree(t, e), e)
              )
            }
            serializeUrl(t) {
              return this.urlSerializer.serialize(t)
            }
            parseUrl(t) {
              let e
              try {
                e = this.urlSerializer.parse(t)
              } catch (n) {
                e = this.malformedUriErrorHandler(n, this.urlSerializer, t)
              }
              return e
            }
            isActive(t, e) {
              if (ve(t)) return gt(this.currentUrlTree, t, e)
              const n = this.parseUrl(t)
              return gt(this.currentUrlTree, n, e)
            }
            removeEmptyProps(t) {
              return Object.keys(t).reduce((e, n) => {
                const i = t[n]
                return null != i && (e[n] = i), e
              }, {})
            }
            processNavigations() {
              this.navigations.subscribe(
                (t) => {
                  ;(this.navigated = !0),
                    (this.lastSuccessfulId = t.id),
                    this.events.next(
                      new q(
                        t.id,
                        this.serializeUrl(t.extractedUrl),
                        this.serializeUrl(this.currentUrlTree)
                      )
                    ),
                    (this.lastSuccessfulNavigation = this.currentNavigation),
                    (this.currentNavigation = null),
                    t.resolve(!0)
                },
                (t) => {
                  this.console.warn('Unhandled Navigation Error: ')
                }
              )
            }
            scheduleNavigation(t, e, n, i, r) {
              const s = this.getTransition(),
                o =
                  'imperative' !== e &&
                  'imperative' === (null == s ? void 0 : s.source),
                a =
                  (this.lastSuccessfulId === s.id || this.currentNavigation
                    ? s.rawUrl
                    : s.urlAfterRedirects
                  ).toString() === t.toString()
              if (o && a) return Promise.resolve(!0)
              let l, c, u
              r
                ? ((l = r.resolve), (c = r.reject), (u = r.promise))
                : (u = new Promise((t, e) => {
                    ;(l = t), (c = e)
                  }))
              const h = ++this.navigationId
              return (
                this.setTransition({
                  id: h,
                  source: e,
                  restoredState: n,
                  currentUrlTree: this.currentUrlTree,
                  currentRawUrl: this.rawUrlTree,
                  rawUrl: t,
                  extras: i,
                  resolve: l,
                  reject: c,
                  promise: u,
                  currentSnapshot: this.routerState.snapshot,
                  currentRouterState: this.routerState,
                }),
                u.catch((t) => Promise.reject(t))
              )
            }
            setBrowserUrl(t, e, n, i) {
              const r = this.urlSerializer.serialize(t)
              ;(i = i || {}),
                this.location.isCurrentPathEqualTo(r) || e
                  ? this.location.replaceState(
                      r,
                      '',
                      Object.assign(Object.assign({}, i), { navigationId: n })
                    )
                  : this.location.go(
                      r,
                      '',
                      Object.assign(Object.assign({}, i), { navigationId: n })
                    )
            }
            resetStateAndUrl(t, e, n) {
              ;(this.routerState = t),
                (this.currentUrlTree = e),
                (this.rawUrlTree = this.urlHandlingStrategy.merge(
                  this.currentUrlTree,
                  n
                )),
                this.resetUrlToCurrentUrlTree()
            }
            resetUrlToCurrentUrlTree() {
              this.location.replaceState(
                this.urlSerializer.serialize(this.rawUrlTree),
                '',
                { navigationId: this.lastSuccessfulId }
              )
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                r.Ub(r.N),
                r.Ub(Ot),
                r.Ub(ln),
                r.Ub(i.g),
                r.Ub(r.r),
                r.Ub(r.w),
                r.Ub(r.i),
                r.Ub(void 0)
              )
            }),
            (t.ɵprov = r.Hb({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        fn = (() => {
          class t {
            constructor(t, e, n) {
              ;(this.router = t),
                (this.route = e),
                (this.locationStrategy = n),
                (this.commands = []),
                (this.onChanges = new p.a()),
                (this.subscription = t.events.subscribe((t) => {
                  t instanceof q && this.updateTargetUrlAndHref()
                }))
            }
            set routerLink(t) {
              this.commands = null != t ? (Array.isArray(t) ? t : [t]) : []
            }
            ngOnChanges(t) {
              this.updateTargetUrlAndHref(), this.onChanges.next(this)
            }
            ngOnDestroy() {
              this.subscription.unsubscribe()
            }
            onClick(t, e, n, i, r) {
              if (0 !== t || e || n || i || r) return !0
              if ('string' == typeof this.target && '_self' != this.target)
                return !0
              const s = {
                skipLocationChange: mn(this.skipLocationChange),
                replaceUrl: mn(this.replaceUrl),
                state: this.state,
              }
              return this.router.navigateByUrl(this.urlTree, s), !1
            }
            updateTargetUrlAndHref() {
              this.href = this.locationStrategy.prepareExternalUrl(
                this.router.serializeUrl(this.urlTree)
              )
            }
            get urlTree() {
              return this.router.createUrlTree(this.commands, {
                relativeTo: this.route,
                queryParams: this.queryParams,
                fragment: this.fragment,
                queryParamsHandling: this.queryParamsHandling,
                preserveFragment: mn(this.preserveFragment),
              })
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(r.Lb(pn), r.Lb(Qt), r.Lb(i.h))
            }),
            (t.ɵdir = r.Gb({
              type: t,
              selectors: [
                ['a', 'routerLink', ''],
                ['area', 'routerLink', ''],
              ],
              hostVars: 2,
              hostBindings: function (t, e) {
                1 & t &&
                  r.Xb('click', function (t) {
                    return e.onClick(
                      t.button,
                      t.ctrlKey,
                      t.shiftKey,
                      t.altKey,
                      t.metaKey
                    )
                  }),
                  2 & t &&
                    (r.Tb('href', e.href, r.oc), r.Ab('target', e.target))
              },
              inputs: {
                routerLink: 'routerLink',
                target: 'target',
                queryParams: 'queryParams',
                fragment: 'fragment',
                queryParamsHandling: 'queryParamsHandling',
                preserveFragment: 'preserveFragment',
                skipLocationChange: 'skipLocationChange',
                replaceUrl: 'replaceUrl',
                state: 'state',
              },
              features: [r.xb],
            })),
            t
          )
        })()
      function mn(t) {
        return '' === t || !!t
      }
      let gn = (() => {
        class t {
          constructor(t, e, n, i, s) {
            ;(this.parentContexts = t),
              (this.location = e),
              (this.resolver = n),
              (this.changeDetector = s),
              (this.activated = null),
              (this._activatedRoute = null),
              (this.activateEvents = new r.n()),
              (this.deactivateEvents = new r.n()),
              (this.name = i || st),
              t.onChildOutletCreated(this.name, this)
          }
          ngOnDestroy() {
            this.parentContexts.onChildOutletDestroyed(this.name)
          }
          ngOnInit() {
            if (!this.activated) {
              const t = this.parentContexts.getContext(this.name)
              t &&
                t.route &&
                (t.attachRef
                  ? this.attach(t.attachRef, t.route)
                  : this.activateWith(t.route, t.resolver || null))
            }
          }
          get isActivated() {
            return !!this.activated
          }
          get component() {
            if (!this.activated) throw new Error('Outlet is not activated')
            return this.activated.instance
          }
          get activatedRoute() {
            if (!this.activated) throw new Error('Outlet is not activated')
            return this._activatedRoute
          }
          get activatedRouteData() {
            return this._activatedRoute
              ? this._activatedRoute.snapshot.data
              : {}
          }
          detach() {
            if (!this.activated) throw new Error('Outlet is not activated')
            this.location.detach()
            const t = this.activated
            return (this.activated = null), (this._activatedRoute = null), t
          }
          attach(t, e) {
            ;(this.activated = t),
              (this._activatedRoute = e),
              this.location.insert(t.hostView)
          }
          deactivate() {
            if (this.activated) {
              const t = this.component
              this.activated.destroy(),
                (this.activated = null),
                (this._activatedRoute = null),
                this.deactivateEvents.emit(t)
            }
          }
          activateWith(t, e) {
            if (this.isActivated)
              throw new Error('Cannot activate an already activated outlet')
            this._activatedRoute = t
            const n = (e = e || this.resolver).resolveComponentFactory(
                t._futureSnapshot.routeConfig.component
              ),
              i = this.parentContexts.getOrCreateContext(this.name).children,
              r = new bn(t, i, this.location.injector)
            ;(this.activated = this.location.createComponent(
              n,
              this.location.length,
              r
            )),
              this.changeDetector.markForCheck(),
              this.activateEvents.emit(this.activated.instance)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(
              r.Lb(ln),
              r.Lb(r.P),
              r.Lb(r.j),
              r.Vb('name'),
              r.Lb(r.h)
            )
          }),
          (t.ɵdir = r.Gb({
            type: t,
            selectors: [['router-outlet']],
            outputs: {
              activateEvents: 'activate',
              deactivateEvents: 'deactivate',
            },
            exportAs: ['outlet'],
          })),
          t
        )
      })()
      class bn {
        constructor(t, e, n) {
          ;(this.route = t), (this.childContexts = e), (this.parent = n)
        }
        get(t, e) {
          return t === Qt
            ? this.route
            : t === ln
            ? this.childContexts
            : this.parent.get(t, e)
        }
      }
      class _n {}
      class yn {
        preload(t, e) {
          return Object(s.a)(null)
        }
      }
      let vn = (() => {
          class t {
            constructor(t, e, n, i, r) {
              ;(this.router = t),
                (this.injector = i),
                (this.preloadingStrategy = r),
                (this.loader = new on(
                  e,
                  n,
                  (e) => t.triggerEvent(new Z(e)),
                  (e) => t.triggerEvent(new J(e))
                ))
            }
            setUpPreloading() {
              this.subscription = this.router.events
                .pipe(
                  Object(g.a)((t) => t instanceof q),
                  Object(F.a)(() => this.preload())
                )
                .subscribe(() => {})
            }
            preload() {
              const t = this.injector.get(r.x)
              return this.processRoutes(t, this.router.config)
            }
            ngOnDestroy() {
              this.subscription && this.subscription.unsubscribe()
            }
            processRoutes(t, e) {
              const n = []
              for (const i of e)
                if (i.loadChildren && !i.canLoad && i._loadedConfig) {
                  const t = i._loadedConfig
                  n.push(this.processRoutes(t.module, t.routes))
                } else
                  i.loadChildren && !i.canLoad
                    ? n.push(this.preloadConfig(t, i))
                    : i.children && n.push(this.processRoutes(t, i.children))
              return Object(o.a)(n).pipe(
                Object(B.a)(),
                Object(f.a)((t) => {})
              )
            }
            preloadConfig(t, e) {
              return this.preloadingStrategy.preload(e, () =>
                this.loader
                  .load(t.injector, e)
                  .pipe(
                    Object(M.a)(
                      (t) => (
                        (e._loadedConfig = t),
                        this.processRoutes(t.module, t.routes)
                      )
                    )
                  )
              )
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(
                r.Ub(pn),
                r.Ub(r.w),
                r.Ub(r.i),
                r.Ub(r.r),
                r.Ub(_n)
              )
            }),
            (t.ɵprov = r.Hb({ token: t, factory: t.ɵfac })),
            t
          )
        })(),
        wn = (() => {
          class t {
            constructor(t, e, n = {}) {
              ;(this.router = t),
                (this.viewportScroller = e),
                (this.options = n),
                (this.lastId = 0),
                (this.lastSource = 'imperative'),
                (this.restoredId = 0),
                (this.store = {}),
                (n.scrollPositionRestoration =
                  n.scrollPositionRestoration || 'disabled'),
                (n.anchorScrolling = n.anchorScrolling || 'disabled')
            }
            init() {
              'disabled' !== this.options.scrollPositionRestoration &&
                this.viewportScroller.setHistoryScrollRestoration('manual'),
                (this.routerEventsSubscription = this.createScrollEvents()),
                (this.scrollEventsSubscription = this.consumeScrollEvents())
            }
            createScrollEvents() {
              return this.router.events.subscribe((t) => {
                t instanceof H
                  ? ((this.store[
                      this.lastId
                    ] = this.viewportScroller.getScrollPosition()),
                    (this.lastSource = t.navigationTrigger),
                    (this.restoredId = t.restoredState
                      ? t.restoredState.navigationId
                      : 0))
                  : t instanceof q &&
                    ((this.lastId = t.id),
                    this.scheduleScrollEvent(
                      t,
                      this.router.parseUrl(t.urlAfterRedirects).fragment
                    ))
              })
            }
            consumeScrollEvents() {
              return this.router.events.subscribe((t) => {
                t instanceof rt &&
                  (t.position
                    ? 'top' === this.options.scrollPositionRestoration
                      ? this.viewportScroller.scrollToPosition([0, 0])
                      : 'enabled' === this.options.scrollPositionRestoration &&
                        this.viewportScroller.scrollToPosition(t.position)
                    : t.anchor && 'enabled' === this.options.anchorScrolling
                    ? this.viewportScroller.scrollToAnchor(t.anchor)
                    : 'disabled' !== this.options.scrollPositionRestoration &&
                      this.viewportScroller.scrollToPosition([0, 0]))
              })
            }
            scheduleScrollEvent(t, e) {
              this.router.triggerEvent(
                new rt(
                  t,
                  'popstate' === this.lastSource
                    ? this.store[this.restoredId]
                    : null,
                  e
                )
              )
            }
            ngOnDestroy() {
              this.routerEventsSubscription &&
                this.routerEventsSubscription.unsubscribe(),
                this.scrollEventsSubscription &&
                  this.scrollEventsSubscription.unsubscribe()
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(r.Ub(pn), r.Ub(i.q), r.Ub(void 0))
            }),
            (t.ɵprov = r.Hb({ token: t, factory: t.ɵfac })),
            t
          )
        })()
      const Cn = new r.q('ROUTER_CONFIGURATION'),
        xn = new r.q('ROUTER_FORROOT_GUARD'),
        Sn = [
          i.g,
          { provide: Ot, useClass: kt },
          {
            provide: pn,
            useFactory: function (t, e, n, r, s, o, a, l = {}, c, u) {
              const h = new pn(null, t, e, n, r, s, o, dt(a))
              if (
                (c && (h.urlHandlingStrategy = c),
                u && (h.routeReuseStrategy = u),
                (function (t, e) {
                  t.errorHandler && (e.errorHandler = t.errorHandler),
                    t.malformedUriErrorHandler &&
                      (e.malformedUriErrorHandler = t.malformedUriErrorHandler),
                    t.onSameUrlNavigation &&
                      (e.onSameUrlNavigation = t.onSameUrlNavigation),
                    t.paramsInheritanceStrategy &&
                      (e.paramsInheritanceStrategy =
                        t.paramsInheritanceStrategy),
                    t.relativeLinkResolution &&
                      (e.relativeLinkResolution = t.relativeLinkResolution),
                    t.urlUpdateStrategy &&
                      (e.urlUpdateStrategy = t.urlUpdateStrategy)
                })(l, h),
                l.enableTracing)
              ) {
                const t = Object(i.u)()
                h.events.subscribe((e) => {
                  t.logGroup('Router Event: ' + e.constructor.name),
                    t.log(e.toString()),
                    t.log(e),
                    t.logGroupEnd()
                })
              }
              return h
            },
            deps: [
              Ot,
              ln,
              i.g,
              r.r,
              r.w,
              r.i,
              sn,
              Cn,
              [class {}, new r.A()],
              [class {}, new r.A()],
            ],
          },
          ln,
          {
            provide: Qt,
            useFactory: function (t) {
              return t.routerState.root
            },
            deps: [pn],
          },
          { provide: r.w, useClass: r.K },
          vn,
          yn,
          class {
            preload(t, e) {
              return e().pipe(Object(L.a)(() => Object(s.a)(null)))
            }
          },
          { provide: Cn, useValue: { enableTracing: !1 } },
        ]
      function On() {
        return new r.y('Router', pn)
      }
      let kn = (() => {
        class t {
          constructor(t, e) {}
          static forRoot(e, n) {
            return {
              ngModule: t,
              providers: [
                Sn,
                jn(e),
                {
                  provide: xn,
                  useFactory: Tn,
                  deps: [[pn, new r.A(), new r.J()]],
                },
                { provide: Cn, useValue: n || {} },
                {
                  provide: i.h,
                  useFactory: An,
                  deps: [i.p, [new r.p(i.a), new r.A()], Cn],
                },
                { provide: wn, useFactory: En, deps: [pn, i.q, Cn] },
                {
                  provide: _n,
                  useExisting:
                    n && n.preloadingStrategy ? n.preloadingStrategy : yn,
                },
                { provide: r.y, multi: !0, useFactory: On },
                [
                  In,
                  { provide: r.d, multi: !0, useFactory: Pn, deps: [In] },
                  { provide: Dn, useFactory: Rn, deps: [In] },
                  { provide: r.b, multi: !0, useExisting: Dn },
                ],
              ],
            }
          }
          static forChild(e) {
            return { ngModule: t, providers: [jn(e)] }
          }
        }
        return (
          (t.ɵmod = r.Jb({ type: t })),
          (t.ɵinj = r.Ib({
            factory: function (e) {
              return new (e || t)(r.Ub(xn, 8), r.Ub(pn, 8))
            },
          })),
          t
        )
      })()
      function En(t, e, n) {
        return n.scrollOffset && e.setOffset(n.scrollOffset), new wn(t, e, n)
      }
      function An(t, e, n = {}) {
        return n.useHash ? new i.e(t, e) : new i.o(t, e)
      }
      function Tn(t) {
        return 'guarded'
      }
      function jn(t) {
        return [
          { provide: r.a, multi: !0, useValue: t },
          { provide: sn, multi: !0, useValue: t },
        ]
      }
      let In = (() => {
        class t {
          constructor(t) {
            ;(this.injector = t),
              (this.initNavigation = !1),
              (this.resultOfPreactivationDone = new p.a())
          }
          appInitializer() {
            return this.injector.get(i.f, Promise.resolve(null)).then(() => {
              let t = null
              const e = new Promise((e) => (t = e)),
                n = this.injector.get(pn),
                i = this.injector.get(Cn)
              return (
                'disabled' === i.initialNavigation
                  ? (n.setUpLocationChangeListener(), t(!0))
                  : 'enabled' === i.initialNavigation ||
                    'enabledBlocking' === i.initialNavigation
                  ? ((n.hooks.afterPreactivation = () =>
                      this.initNavigation
                        ? Object(s.a)(null)
                        : ((this.initNavigation = !0),
                          t(!0),
                          this.resultOfPreactivationDone)),
                    n.initialNavigation())
                  : t(!0),
                e
              )
            })
          }
          bootstrapListener(t) {
            const e = this.injector.get(Cn),
              n = this.injector.get(vn),
              i = this.injector.get(wn),
              s = this.injector.get(pn),
              o = this.injector.get(r.g)
            t === o.components[0] &&
              (('enabledNonBlocking' !== e.initialNavigation &&
                void 0 !== e.initialNavigation) ||
                s.initialNavigation(),
              n.setUpPreloading(),
              i.init(),
              s.resetRootComponentType(o.componentTypes[0]),
              this.resultOfPreactivationDone.next(null),
              this.resultOfPreactivationDone.complete())
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(r.Ub(r.r))
          }),
          (t.ɵprov = r.Hb({ token: t, factory: t.ɵfac })),
          t
        )
      })()
      function Pn(t) {
        return t.appInitializer.bind(t)
      }
      function Rn(t) {
        return t.bootstrapListener.bind(t)
      }
      const Dn = new r.q('Router Initializer')
    },
    u47x: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return q
      }),
        n.d(e, 'b', function () {
          return O
        }),
        n.d(e, 'c', function () {
          return x
        }),
        n.d(e, 'd', function () {
          return k
        }),
        n.d(e, 'e', function () {
          return M
        }),
        n.d(e, 'f', function () {
          return I
        }),
        n.d(e, 'g', function () {
          return H
        }),
        n.d(e, 'h', function () {
          return D
        }),
        n.d(e, 'i', function () {
          return L
        })
      var i = n('ofXK'),
        r = n('fXoL'),
        s = n('nLfN'),
        o = n('XNiG'),
        a = n('quSY'),
        l = n('LRne'),
        c = n('FtGj'),
        u = n('vkgz'),
        h = n('Kj3r'),
        d = n('pLZG'),
        p = n('lJxs'),
        f = n('IzEk'),
        m = n('8LU1'),
        g = n('GU7r')
      function b(t, e) {
        return (t.getAttribute(e) || '').match(/\S+/g) || []
      }
      const _ = 'cdk-describedby-message-container',
        y = 'cdk-describedby-host'
      let v = 0
      const w = new Map()
      let C = null,
        x = (() => {
          class t {
            constructor(t, e) {
              ;(this._platform = e), (this._document = t)
            }
            describe(t, e) {
              this._canBeDescribed(t, e) &&
                ('string' != typeof e
                  ? (this._setMessageId(e),
                    w.set(e, { messageElement: e, referenceCount: 0 }))
                  : w.has(e) || this._createMessageElement(e),
                this._isElementDescribedByMessage(t, e) ||
                  this._addMessageReference(t, e))
            }
            removeDescription(t, e) {
              if (e && this._isElementNode(t)) {
                if (
                  (this._isElementDescribedByMessage(t, e) &&
                    this._removeMessageReference(t, e),
                  'string' == typeof e)
                ) {
                  const t = w.get(e)
                  t && 0 === t.referenceCount && this._deleteMessageElement(e)
                }
                C &&
                  0 === C.childNodes.length &&
                  this._deleteMessagesContainer()
              }
            }
            ngOnDestroy() {
              const t = this._document.querySelectorAll(
                '[cdk-describedby-host]'
              )
              for (let e = 0; e < t.length; e++)
                this._removeCdkDescribedByReferenceIds(t[e]),
                  t[e].removeAttribute(y)
              C && this._deleteMessagesContainer(), w.clear()
            }
            _createMessageElement(t) {
              const e = this._document.createElement('div')
              this._setMessageId(e),
                (e.textContent = t),
                this._createMessagesContainer(),
                C.appendChild(e),
                w.set(t, { messageElement: e, referenceCount: 0 })
            }
            _setMessageId(t) {
              t.id || (t.id = 'cdk-describedby-message-' + v++)
            }
            _deleteMessageElement(t) {
              const e = w.get(t),
                n = e && e.messageElement
              C && n && C.removeChild(n), w.delete(t)
            }
            _createMessagesContainer() {
              if (!C) {
                const t =
                    !this._platform ||
                    (!this._platform.EDGE && !this._platform.TRIDENT),
                  e = this._document.getElementById(_)
                e && e.parentNode && e.parentNode.removeChild(e),
                  (C = this._document.createElement('div')),
                  (C.id = _),
                  C.classList.add('cdk-visually-hidden'),
                  C.setAttribute('aria-hidden', t + ''),
                  this._document.body.appendChild(C)
              }
            }
            _deleteMessagesContainer() {
              C && C.parentNode && (C.parentNode.removeChild(C), (C = null))
            }
            _removeCdkDescribedByReferenceIds(t) {
              const e = b(t, 'aria-describedby').filter(
                (t) => 0 != t.indexOf('cdk-describedby-message')
              )
              t.setAttribute('aria-describedby', e.join(' '))
            }
            _addMessageReference(t, e) {
              const n = w.get(e)
              !(function (t, e, n) {
                const i = b(t, e)
                i.some((t) => t.trim() == n.trim()) ||
                  (i.push(n.trim()), t.setAttribute(e, i.join(' ')))
              })(t, 'aria-describedby', n.messageElement.id),
                t.setAttribute(y, ''),
                n.referenceCount++
            }
            _removeMessageReference(t, e) {
              const n = w.get(e)
              n.referenceCount--,
                (function (t, e, n) {
                  const i = b(t, e).filter((t) => t != n.trim())
                  i.length
                    ? t.setAttribute(e, i.join(' '))
                    : t.removeAttribute(e)
                })(t, 'aria-describedby', n.messageElement.id),
                t.removeAttribute(y)
            }
            _isElementDescribedByMessage(t, e) {
              const n = b(t, 'aria-describedby'),
                i = w.get(e),
                r = i && i.messageElement.id
              return !!r && -1 != n.indexOf(r)
            }
            _canBeDescribed(t, e) {
              if (!this._isElementNode(t)) return !1
              if (e && 'object' == typeof e) return !0
              const n = null == e ? '' : ('' + e).trim(),
                i = t.getAttribute('aria-label')
              return !(!n || (i && i.trim() === n))
            }
            _isElementNode(t) {
              return t.nodeType === this._document.ELEMENT_NODE
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(r.Ub(i.d), r.Ub(s.a))
            }),
            (t.ɵprov = Object(r.Hb)({
              factory: function () {
                return new t(Object(r.Ub)(i.d), Object(r.Ub)(s.a))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })()
      class S {
        constructor(t) {
          ;(this._items = t),
            (this._activeItemIndex = -1),
            (this._activeItem = null),
            (this._wrap = !1),
            (this._letterKeyStream = new o.a()),
            (this._typeaheadSubscription = a.a.EMPTY),
            (this._vertical = !0),
            (this._allowedModifierKeys = []),
            (this._homeAndEnd = !1),
            (this._skipPredicateFn = (t) => t.disabled),
            (this._pressedLetters = []),
            (this.tabOut = new o.a()),
            (this.change = new o.a()),
            t instanceof r.D &&
              t.changes.subscribe((t) => {
                if (this._activeItem) {
                  const e = t.toArray().indexOf(this._activeItem)
                  e > -1 &&
                    e !== this._activeItemIndex &&
                    (this._activeItemIndex = e)
                }
              })
        }
        skipPredicate(t) {
          return (this._skipPredicateFn = t), this
        }
        withWrap(t = !0) {
          return (this._wrap = t), this
        }
        withVerticalOrientation(t = !0) {
          return (this._vertical = t), this
        }
        withHorizontalOrientation(t) {
          return (this._horizontal = t), this
        }
        withAllowedModifierKeys(t) {
          return (this._allowedModifierKeys = t), this
        }
        withTypeAhead(t = 200) {
          return (
            this._typeaheadSubscription.unsubscribe(),
            (this._typeaheadSubscription = this._letterKeyStream
              .pipe(
                Object(u.a)((t) => this._pressedLetters.push(t)),
                Object(h.a)(t),
                Object(d.a)(() => this._pressedLetters.length > 0),
                Object(p.a)(() => this._pressedLetters.join(''))
              )
              .subscribe((t) => {
                const e = this._getItemsArray()
                for (let n = 1; n < e.length + 1; n++) {
                  const i = (this._activeItemIndex + n) % e.length,
                    r = e[i]
                  if (
                    !this._skipPredicateFn(r) &&
                    0 === r.getLabel().toUpperCase().trim().indexOf(t)
                  ) {
                    this.setActiveItem(i)
                    break
                  }
                }
                this._pressedLetters = []
              })),
            this
          )
        }
        withHomeAndEnd(t = !0) {
          return (this._homeAndEnd = t), this
        }
        setActiveItem(t) {
          const e = this._activeItem
          this.updateActiveItem(t),
            this._activeItem !== e && this.change.next(this._activeItemIndex)
        }
        onKeydown(t) {
          const e = t.keyCode,
            n = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].every(
              (e) => !t[e] || this._allowedModifierKeys.indexOf(e) > -1
            )
          switch (e) {
            case c.k:
              return void this.tabOut.next()
            case c.b:
              if (this._vertical && n) {
                this.setNextItemActive()
                break
              }
              return
            case c.l:
              if (this._vertical && n) {
                this.setPreviousItemActive()
                break
              }
              return
            case c.i:
              if (this._horizontal && n) {
                'rtl' === this._horizontal
                  ? this.setPreviousItemActive()
                  : this.setNextItemActive()
                break
              }
              return
            case c.g:
              if (this._horizontal && n) {
                'rtl' === this._horizontal
                  ? this.setNextItemActive()
                  : this.setPreviousItemActive()
                break
              }
              return
            case c.f:
              if (this._homeAndEnd && n) {
                this.setFirstItemActive()
                break
              }
              return
            case c.c:
              if (this._homeAndEnd && n) {
                this.setLastItemActive()
                break
              }
              return
            default:
              return void (
                (n || Object(c.o)(t, 'shiftKey')) &&
                (t.key && 1 === t.key.length
                  ? this._letterKeyStream.next(t.key.toLocaleUpperCase())
                  : ((e >= c.a && e <= c.m) || (e >= c.n && e <= c.h)) &&
                    this._letterKeyStream.next(String.fromCharCode(e)))
              )
          }
          ;(this._pressedLetters = []), t.preventDefault()
        }
        get activeItemIndex() {
          return this._activeItemIndex
        }
        get activeItem() {
          return this._activeItem
        }
        isTyping() {
          return this._pressedLetters.length > 0
        }
        setFirstItemActive() {
          this._setActiveItemByIndex(0, 1)
        }
        setLastItemActive() {
          this._setActiveItemByIndex(this._items.length - 1, -1)
        }
        setNextItemActive() {
          this._activeItemIndex < 0
            ? this.setFirstItemActive()
            : this._setActiveItemByDelta(1)
        }
        setPreviousItemActive() {
          this._activeItemIndex < 0 && this._wrap
            ? this.setLastItemActive()
            : this._setActiveItemByDelta(-1)
        }
        updateActiveItem(t) {
          const e = this._getItemsArray(),
            n = 'number' == typeof t ? t : e.indexOf(t),
            i = e[n]
          ;(this._activeItem = null == i ? null : i),
            (this._activeItemIndex = n)
        }
        _setActiveItemByDelta(t) {
          this._wrap
            ? this._setActiveInWrapMode(t)
            : this._setActiveInDefaultMode(t)
        }
        _setActiveInWrapMode(t) {
          const e = this._getItemsArray()
          for (let n = 1; n <= e.length; n++) {
            const i = (this._activeItemIndex + t * n + e.length) % e.length
            if (!this._skipPredicateFn(e[i])) return void this.setActiveItem(i)
          }
        }
        _setActiveInDefaultMode(t) {
          this._setActiveItemByIndex(this._activeItemIndex + t, t)
        }
        _setActiveItemByIndex(t, e) {
          const n = this._getItemsArray()
          if (n[t]) {
            for (; this._skipPredicateFn(n[t]); ) if (!n[(t += e)]) return
            this.setActiveItem(t)
          }
        }
        _getItemsArray() {
          return this._items instanceof r.D
            ? this._items.toArray()
            : this._items
        }
      }
      class O extends S {
        setActiveItem(t) {
          this.activeItem && this.activeItem.setInactiveStyles(),
            super.setActiveItem(t),
            this.activeItem && this.activeItem.setActiveStyles()
        }
      }
      class k extends S {
        constructor() {
          super(...arguments), (this._origin = 'program')
        }
        setFocusOrigin(t) {
          return (this._origin = t), this
        }
        setActiveItem(t) {
          super.setActiveItem(t),
            this.activeItem && this.activeItem.focus(this._origin)
        }
      }
      let E = (() => {
        class t {
          constructor(t) {
            this._platform = t
          }
          isDisabled(t) {
            return t.hasAttribute('disabled')
          }
          isVisible(t) {
            return (
              (function (t) {
                return !!(
                  t.offsetWidth ||
                  t.offsetHeight ||
                  ('function' == typeof t.getClientRects &&
                    t.getClientRects().length)
                )
              })(t) && 'visible' === getComputedStyle(t).visibility
            )
          }
          isTabbable(t) {
            if (!this._platform.isBrowser) return !1
            const e = (function (t) {
              try {
                return t.frameElement
              } catch (e) {
                return null
              }
            })(((n = t).ownerDocument && n.ownerDocument.defaultView) || window)
            var n
            if (e) {
              if (-1 === T(e)) return !1
              if (!this.isVisible(e)) return !1
            }
            let i = t.nodeName.toLowerCase(),
              r = T(t)
            return t.hasAttribute('contenteditable')
              ? -1 !== r
              : 'iframe' !== i &&
                  'object' !== i &&
                  !(
                    this._platform.WEBKIT &&
                    this._platform.IOS &&
                    !(function (t) {
                      let e = t.nodeName.toLowerCase(),
                        n = 'input' === e && t.type
                      return (
                        'text' === n ||
                        'password' === n ||
                        'select' === e ||
                        'textarea' === e
                      )
                    })(t)
                  ) &&
                  ('audio' === i
                    ? !!t.hasAttribute('controls') && -1 !== r
                    : 'video' === i
                    ? -1 !== r &&
                      (null !== r ||
                        this._platform.FIREFOX ||
                        t.hasAttribute('controls'))
                    : t.tabIndex >= 0)
          }
          isFocusable(t, e) {
            return (
              (function (t) {
                return (
                  !(function (t) {
                    return (
                      (function (t) {
                        return 'input' == t.nodeName.toLowerCase()
                      })(t) && 'hidden' == t.type
                    )
                  })(t) &&
                  ((function (t) {
                    let e = t.nodeName.toLowerCase()
                    return (
                      'input' === e ||
                      'select' === e ||
                      'button' === e ||
                      'textarea' === e
                    )
                  })(t) ||
                    (function (t) {
                      return (
                        (function (t) {
                          return 'a' == t.nodeName.toLowerCase()
                        })(t) && t.hasAttribute('href')
                      )
                    })(t) ||
                    t.hasAttribute('contenteditable') ||
                    A(t))
                )
              })(t) &&
              !this.isDisabled(t) &&
              ((null == e ? void 0 : e.ignoreVisibility) || this.isVisible(t))
            )
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(r.Ub(s.a))
          }),
          (t.ɵprov = Object(r.Hb)({
            factory: function () {
              return new t(Object(r.Ub)(s.a))
            },
            token: t,
            providedIn: 'root',
          })),
          t
        )
      })()
      function A(t) {
        if (!t.hasAttribute('tabindex') || void 0 === t.tabIndex) return !1
        let e = t.getAttribute('tabindex')
        return '-32768' != e && !(!e || isNaN(parseInt(e, 10)))
      }
      function T(t) {
        if (!A(t)) return null
        const e = parseInt(t.getAttribute('tabindex') || '', 10)
        return isNaN(e) ? -1 : e
      }
      class j {
        constructor(t, e, n, i, r = !1) {
          ;(this._element = t),
            (this._checker = e),
            (this._ngZone = n),
            (this._document = i),
            (this._hasAttached = !1),
            (this.startAnchorListener = () => this.focusLastTabbableElement()),
            (this.endAnchorListener = () => this.focusFirstTabbableElement()),
            (this._enabled = !0),
            r || this.attachAnchors()
        }
        get enabled() {
          return this._enabled
        }
        set enabled(t) {
          ;(this._enabled = t),
            this._startAnchor &&
              this._endAnchor &&
              (this._toggleAnchorTabIndex(t, this._startAnchor),
              this._toggleAnchorTabIndex(t, this._endAnchor))
        }
        destroy() {
          const t = this._startAnchor,
            e = this._endAnchor
          t &&
            (t.removeEventListener('focus', this.startAnchorListener),
            t.parentNode && t.parentNode.removeChild(t)),
            e &&
              (e.removeEventListener('focus', this.endAnchorListener),
              e.parentNode && e.parentNode.removeChild(e)),
            (this._startAnchor = this._endAnchor = null),
            (this._hasAttached = !1)
        }
        attachAnchors() {
          return (
            !!this._hasAttached ||
            (this._ngZone.runOutsideAngular(() => {
              this._startAnchor ||
                ((this._startAnchor = this._createAnchor()),
                this._startAnchor.addEventListener(
                  'focus',
                  this.startAnchorListener
                )),
                this._endAnchor ||
                  ((this._endAnchor = this._createAnchor()),
                  this._endAnchor.addEventListener(
                    'focus',
                    this.endAnchorListener
                  ))
            }),
            this._element.parentNode &&
              (this._element.parentNode.insertBefore(
                this._startAnchor,
                this._element
              ),
              this._element.parentNode.insertBefore(
                this._endAnchor,
                this._element.nextSibling
              ),
              (this._hasAttached = !0)),
            this._hasAttached)
          )
        }
        focusInitialElementWhenReady() {
          return new Promise((t) => {
            this._executeOnStable(() => t(this.focusInitialElement()))
          })
        }
        focusFirstTabbableElementWhenReady() {
          return new Promise((t) => {
            this._executeOnStable(() => t(this.focusFirstTabbableElement()))
          })
        }
        focusLastTabbableElementWhenReady() {
          return new Promise((t) => {
            this._executeOnStable(() => t(this.focusLastTabbableElement()))
          })
        }
        _getRegionBoundary(t) {
          let e = this._element.querySelectorAll(
            `[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`
          )
          for (let n = 0; n < e.length; n++)
            e[n].hasAttribute('cdk-focus-' + t)
              ? console.warn(
                  `Found use of deprecated attribute 'cdk-focus-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`,
                  e[n]
                )
              : e[n].hasAttribute('cdk-focus-region-' + t) &&
                console.warn(
                  `Found use of deprecated attribute 'cdk-focus-region-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`,
                  e[n]
                )
          return 'start' == t
            ? e.length
              ? e[0]
              : this._getFirstTabbableElement(this._element)
            : e.length
            ? e[e.length - 1]
            : this._getLastTabbableElement(this._element)
        }
        focusInitialElement() {
          const t = this._element.querySelector(
            '[cdk-focus-initial], [cdkFocusInitial]'
          )
          if (t) {
            if (
              (t.hasAttribute('cdk-focus-initial') &&
                console.warn(
                  "Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0",
                  t
                ),
              !this._checker.isFocusable(t))
            ) {
              const e = this._getFirstTabbableElement(t)
              return null == e || e.focus(), !!e
            }
            return t.focus(), !0
          }
          return this.focusFirstTabbableElement()
        }
        focusFirstTabbableElement() {
          const t = this._getRegionBoundary('start')
          return t && t.focus(), !!t
        }
        focusLastTabbableElement() {
          const t = this._getRegionBoundary('end')
          return t && t.focus(), !!t
        }
        hasAttached() {
          return this._hasAttached
        }
        _getFirstTabbableElement(t) {
          if (this._checker.isFocusable(t) && this._checker.isTabbable(t))
            return t
          let e = t.children || t.childNodes
          for (let n = 0; n < e.length; n++) {
            let t =
              e[n].nodeType === this._document.ELEMENT_NODE
                ? this._getFirstTabbableElement(e[n])
                : null
            if (t) return t
          }
          return null
        }
        _getLastTabbableElement(t) {
          if (this._checker.isFocusable(t) && this._checker.isTabbable(t))
            return t
          let e = t.children || t.childNodes
          for (let n = e.length - 1; n >= 0; n--) {
            let t =
              e[n].nodeType === this._document.ELEMENT_NODE
                ? this._getLastTabbableElement(e[n])
                : null
            if (t) return t
          }
          return null
        }
        _createAnchor() {
          const t = this._document.createElement('div')
          return (
            this._toggleAnchorTabIndex(this._enabled, t),
            t.classList.add('cdk-visually-hidden'),
            t.classList.add('cdk-focus-trap-anchor'),
            t.setAttribute('aria-hidden', 'true'),
            t
          )
        }
        _toggleAnchorTabIndex(t, e) {
          t ? e.setAttribute('tabindex', '0') : e.removeAttribute('tabindex')
        }
        toggleAnchors(t) {
          this._startAnchor &&
            this._endAnchor &&
            (this._toggleAnchorTabIndex(t, this._startAnchor),
            this._toggleAnchorTabIndex(t, this._endAnchor))
        }
        _executeOnStable(t) {
          this._ngZone.isStable
            ? t()
            : this._ngZone.onStable.pipe(Object(f.a)(1)).subscribe(t)
        }
      }
      let I = (() => {
        class t {
          constructor(t, e, n) {
            ;(this._checker = t), (this._ngZone = e), (this._document = n)
          }
          create(t, e = !1) {
            return new j(t, this._checker, this._ngZone, this._document, e)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(r.Ub(E), r.Ub(r.z), r.Ub(i.d))
          }),
          (t.ɵprov = Object(r.Hb)({
            factory: function () {
              return new t(
                Object(r.Ub)(E),
                Object(r.Ub)(r.z),
                Object(r.Ub)(i.d)
              )
            },
            token: t,
            providedIn: 'root',
          })),
          t
        )
      })()
      'undefined' != typeof Element && Element
      const P = new r.q('liveAnnouncerElement', {
          providedIn: 'root',
          factory: function () {
            return null
          },
        }),
        R = new r.q('LIVE_ANNOUNCER_DEFAULT_OPTIONS')
      let D = (() => {
        class t {
          constructor(t, e, n, i) {
            ;(this._ngZone = e),
              (this._defaultOptions = i),
              (this._document = n),
              (this._liveElement = t || this._createLiveElement())
          }
          announce(t, ...e) {
            const n = this._defaultOptions
            let i, r
            return (
              1 === e.length && 'number' == typeof e[0]
                ? (r = e[0])
                : ([i, r] = e),
              this.clear(),
              clearTimeout(this._previousTimeout),
              i || (i = n && n.politeness ? n.politeness : 'polite'),
              null == r && n && (r = n.duration),
              this._liveElement.setAttribute('aria-live', i),
              this._ngZone.runOutsideAngular(
                () =>
                  new Promise((e) => {
                    clearTimeout(this._previousTimeout),
                      (this._previousTimeout = setTimeout(() => {
                        ;(this._liveElement.textContent = t),
                          e(),
                          'number' == typeof r &&
                            (this._previousTimeout = setTimeout(
                              () => this.clear(),
                              r
                            ))
                      }, 100))
                  })
              )
            )
          }
          clear() {
            this._liveElement && (this._liveElement.textContent = '')
          }
          ngOnDestroy() {
            clearTimeout(this._previousTimeout),
              this._liveElement &&
                this._liveElement.parentNode &&
                (this._liveElement.parentNode.removeChild(this._liveElement),
                (this._liveElement = null))
          }
          _createLiveElement() {
            const t = 'cdk-live-announcer-element',
              e = this._document.getElementsByClassName(t),
              n = this._document.createElement('div')
            for (let i = 0; i < e.length; i++) e[i].parentNode.removeChild(e[i])
            return (
              n.classList.add(t),
              n.classList.add('cdk-visually-hidden'),
              n.setAttribute('aria-atomic', 'true'),
              n.setAttribute('aria-live', 'polite'),
              this._document.body.appendChild(n),
              n
            )
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(r.Ub(P, 8), r.Ub(r.z), r.Ub(i.d), r.Ub(R, 8))
          }),
          (t.ɵprov = Object(r.Hb)({
            factory: function () {
              return new t(
                Object(r.Ub)(P, 8),
                Object(r.Ub)(r.z),
                Object(r.Ub)(i.d),
                Object(r.Ub)(R, 8)
              )
            },
            token: t,
            providedIn: 'root',
          })),
          t
        )
      })()
      function L(t) {
        return 0 === t.buttons
      }
      const F = new r.q('cdk-focus-monitor-default-options'),
        N = Object(s.e)({ passive: !0, capture: !0 })
      let M = (() => {
        class t {
          constructor(t, e, n, i) {
            ;(this._ngZone = t),
              (this._platform = e),
              (this._origin = null),
              (this._windowFocused = !1),
              (this._elementInfo = new Map()),
              (this._monitoredElementCount = 0),
              (this._rootNodeFocusListenerCount = new Map()),
              (this._documentKeydownListener = () => {
                ;(this._lastTouchTarget = null),
                  this._setOriginForCurrentEventQueue('keyboard')
              }),
              (this._documentMousedownListener = (t) => {
                if (!this._lastTouchTarget) {
                  const e = L(t) ? 'keyboard' : 'mouse'
                  this._setOriginForCurrentEventQueue(e)
                }
              }),
              (this._documentTouchstartListener = (t) => {
                null != this._touchTimeoutId &&
                  clearTimeout(this._touchTimeoutId),
                  (this._lastTouchTarget = V(t)),
                  (this._touchTimeoutId = setTimeout(
                    () => (this._lastTouchTarget = null),
                    650
                  ))
              }),
              (this._windowFocusListener = () => {
                ;(this._windowFocused = !0),
                  (this._windowFocusTimeoutId = setTimeout(
                    () => (this._windowFocused = !1)
                  ))
              }),
              (this._rootNodeFocusAndBlurListener = (t) => {
                const e = V(t),
                  n = 'focus' === t.type ? this._onFocus : this._onBlur
                for (let i = e; i; i = i.parentElement) n.call(this, t, i)
              }),
              (this._document = n),
              (this._detectionMode =
                (null == i ? void 0 : i.detectionMode) || 0)
          }
          monitor(t, e = !1) {
            const n = Object(m.d)(t)
            if (!this._platform.isBrowser || 1 !== n.nodeType)
              return Object(l.a)(null)
            const i = Object(s.c)(n) || this._getDocument(),
              r = this._elementInfo.get(n)
            if (r) return e && (r.checkChildren = !0), r.subject
            const a = { checkChildren: e, subject: new o.a(), rootNode: i }
            return (
              this._elementInfo.set(n, a),
              this._registerGlobalListeners(a),
              a.subject
            )
          }
          stopMonitoring(t) {
            const e = Object(m.d)(t),
              n = this._elementInfo.get(e)
            n &&
              (n.subject.complete(),
              this._setClasses(e),
              this._elementInfo.delete(e),
              this._removeGlobalListeners(n))
          }
          focusVia(t, e, n) {
            const i = Object(m.d)(t)
            i === this._getDocument().activeElement && this._elementInfo.has(i)
              ? this._originChanged(i, e, this._elementInfo.get(i))
              : (this._setOriginForCurrentEventQueue(e),
                'function' == typeof i.focus && i.focus(n))
          }
          ngOnDestroy() {
            this._elementInfo.forEach((t, e) => this.stopMonitoring(e))
          }
          _getDocument() {
            return this._document || document
          }
          _getWindow() {
            return this._getDocument().defaultView || window
          }
          _toggleClass(t, e, n) {
            n ? t.classList.add(e) : t.classList.remove(e)
          }
          _getFocusOrigin(t) {
            return this._origin
              ? this._origin
              : this._windowFocused && this._lastFocusOrigin
              ? this._lastFocusOrigin
              : this._wasCausedByTouch(t)
              ? 'touch'
              : 'program'
          }
          _setClasses(t, e) {
            this._toggleClass(t, 'cdk-focused', !!e),
              this._toggleClass(t, 'cdk-touch-focused', 'touch' === e),
              this._toggleClass(t, 'cdk-keyboard-focused', 'keyboard' === e),
              this._toggleClass(t, 'cdk-mouse-focused', 'mouse' === e),
              this._toggleClass(t, 'cdk-program-focused', 'program' === e)
          }
          _setOriginForCurrentEventQueue(t) {
            this._ngZone.runOutsideAngular(() => {
              ;(this._origin = t),
                0 === this._detectionMode &&
                  (this._originTimeoutId = setTimeout(
                    () => (this._origin = null),
                    1
                  ))
            })
          }
          _wasCausedByTouch(t) {
            const e = V(t)
            return (
              this._lastTouchTarget instanceof Node &&
              e instanceof Node &&
              (e === this._lastTouchTarget || e.contains(this._lastTouchTarget))
            )
          }
          _onFocus(t, e) {
            const n = this._elementInfo.get(e)
            n &&
              (n.checkChildren || e === V(t)) &&
              this._originChanged(e, this._getFocusOrigin(t), n)
          }
          _onBlur(t, e) {
            const n = this._elementInfo.get(e)
            !n ||
              (n.checkChildren &&
                t.relatedTarget instanceof Node &&
                e.contains(t.relatedTarget)) ||
              (this._setClasses(e), this._emitOrigin(n.subject, null))
          }
          _emitOrigin(t, e) {
            this._ngZone.run(() => t.next(e))
          }
          _registerGlobalListeners(t) {
            if (!this._platform.isBrowser) return
            const e = t.rootNode,
              n = this._rootNodeFocusListenerCount.get(e) || 0
            n ||
              this._ngZone.runOutsideAngular(() => {
                e.addEventListener(
                  'focus',
                  this._rootNodeFocusAndBlurListener,
                  N
                ),
                  e.addEventListener(
                    'blur',
                    this._rootNodeFocusAndBlurListener,
                    N
                  )
              }),
              this._rootNodeFocusListenerCount.set(e, n + 1),
              1 == ++this._monitoredElementCount &&
                this._ngZone.runOutsideAngular(() => {
                  const t = this._getDocument(),
                    e = this._getWindow()
                  t.addEventListener(
                    'keydown',
                    this._documentKeydownListener,
                    N
                  ),
                    t.addEventListener(
                      'mousedown',
                      this._documentMousedownListener,
                      N
                    ),
                    t.addEventListener(
                      'touchstart',
                      this._documentTouchstartListener,
                      N
                    ),
                    e.addEventListener('focus', this._windowFocusListener)
                })
          }
          _removeGlobalListeners(t) {
            const e = t.rootNode
            if (this._rootNodeFocusListenerCount.has(e)) {
              const t = this._rootNodeFocusListenerCount.get(e)
              t > 1
                ? this._rootNodeFocusListenerCount.set(e, t - 1)
                : (e.removeEventListener(
                    'focus',
                    this._rootNodeFocusAndBlurListener,
                    N
                  ),
                  e.removeEventListener(
                    'blur',
                    this._rootNodeFocusAndBlurListener,
                    N
                  ),
                  this._rootNodeFocusListenerCount.delete(e))
            }
            if (!--this._monitoredElementCount) {
              const t = this._getDocument(),
                e = this._getWindow()
              t.removeEventListener(
                'keydown',
                this._documentKeydownListener,
                N
              ),
                t.removeEventListener(
                  'mousedown',
                  this._documentMousedownListener,
                  N
                ),
                t.removeEventListener(
                  'touchstart',
                  this._documentTouchstartListener,
                  N
                ),
                e.removeEventListener('focus', this._windowFocusListener),
                clearTimeout(this._windowFocusTimeoutId),
                clearTimeout(this._touchTimeoutId),
                clearTimeout(this._originTimeoutId)
            }
          }
          _originChanged(t, e, n) {
            this._setClasses(t, e),
              this._emitOrigin(n.subject, e),
              (this._lastFocusOrigin = e)
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(r.Ub(r.z), r.Ub(s.a), r.Ub(i.d, 8), r.Ub(F, 8))
          }),
          (t.ɵprov = Object(r.Hb)({
            factory: function () {
              return new t(
                Object(r.Ub)(r.z),
                Object(r.Ub)(s.a),
                Object(r.Ub)(i.d, 8),
                Object(r.Ub)(F, 8)
              )
            },
            token: t,
            providedIn: 'root',
          })),
          t
        )
      })()
      function V(t) {
        return t.composedPath ? t.composedPath()[0] : t.target
      }
      const U = 'cdk-high-contrast-black-on-white',
        B = 'cdk-high-contrast-white-on-black',
        z = 'cdk-high-contrast-active'
      let H = (() => {
          class t {
            constructor(t, e) {
              ;(this._platform = t), (this._document = e)
            }
            getHighContrastMode() {
              if (!this._platform.isBrowser) return 0
              const t = this._document.createElement('div')
              ;(t.style.backgroundColor = 'rgb(1,2,3)'),
                (t.style.position = 'absolute'),
                this._document.body.appendChild(t)
              const e = this._document.defaultView || window,
                n = e && e.getComputedStyle ? e.getComputedStyle(t) : null,
                i = ((n && n.backgroundColor) || '').replace(/ /g, '')
              switch ((this._document.body.removeChild(t), i)) {
                case 'rgb(0,0,0)':
                  return 2
                case 'rgb(255,255,255)':
                  return 1
              }
              return 0
            }
            _applyBodyHighContrastModeCssClasses() {
              if (this._platform.isBrowser && this._document.body) {
                const t = this._document.body.classList
                t.remove(z), t.remove(U), t.remove(B)
                const e = this.getHighContrastMode()
                1 === e ? (t.add(z), t.add(U)) : 2 === e && (t.add(z), t.add(B))
              }
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(r.Ub(s.a), r.Ub(i.d))
            }),
            (t.ɵprov = Object(r.Hb)({
              factory: function () {
                return new t(Object(r.Ub)(s.a), Object(r.Ub)(i.d))
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        q = (() => {
          class t {
            constructor(t) {
              t._applyBodyHighContrastModeCssClasses()
            }
          }
          return (
            (t.ɵmod = r.Jb({ type: t })),
            (t.ɵinj = r.Ib({
              factory: function (e) {
                return new (e || t)(r.Ub(H))
              },
              imports: [[s.b, g.c]],
            })),
            t
          )
        })()
    },
    vkgz: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return o
      })
      var i = n('7o/Q'),
        r = n('KqfI'),
        s = n('n6bG')
      function o(t, e, n) {
        return function (i) {
          return i.lift(new a(t, e, n))
        }
      }
      class a {
        constructor(t, e, n) {
          ;(this.nextOrObserver = t), (this.error = e), (this.complete = n)
        }
        call(t, e) {
          return e.subscribe(
            new l(t, this.nextOrObserver, this.error, this.complete)
          )
        }
      }
      class l extends i.a {
        constructor(t, e, n, i) {
          super(t),
            (this._tapNext = r.a),
            (this._tapError = r.a),
            (this._tapComplete = r.a),
            (this._tapError = n || r.a),
            (this._tapComplete = i || r.a),
            Object(s.a)(e)
              ? ((this._context = this), (this._tapNext = e))
              : e &&
                ((this._context = e),
                (this._tapNext = e.next || r.a),
                (this._tapError = e.error || r.a),
                (this._tapComplete = e.complete || r.a))
        }
        _next(t) {
          try {
            this._tapNext.call(this._context, t)
          } catch (e) {
            return void this.destination.error(e)
          }
          this.destination.next(t)
        }
        _error(t) {
          try {
            this._tapError.call(this._context, t)
          } catch (t) {
            return void this.destination.error(t)
          }
          this.destination.error(t)
        }
        _complete() {
          try {
            this._tapComplete.call(this._context)
          } catch (t) {
            return void this.destination.error(t)
          }
          return this.destination.complete()
        }
      }
    },
    vxfF: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return S
      }),
        n.d(e, 'b', function () {
          return k
        }),
        n.d(e, 'c', function () {
          return x
        }),
        n.d(e, 'd', function () {
          return E
        }),
        n.d(e, 'e', function () {
          return O
        }),
        n('8LU1')
      var i = n('fXoL'),
        r = n('XNiG'),
        s = n('LRne'),
        o = n('HDdC'),
        a = n('xgIS')
      n('3N8a'), n('IjjT'), n('quSY'), n('7+OI'), n('/uUt')
      var l = n('D0XW'),
        c = n('l7GE'),
        u = n('ZUHj')
      class h {
        constructor(t) {
          this.durationSelector = t
        }
        call(t, e) {
          return e.subscribe(new d(t, this.durationSelector))
        }
      }
      class d extends c.a {
        constructor(t, e) {
          super(t), (this.durationSelector = e), (this.hasValue = !1)
        }
        _next(t) {
          if (((this.value = t), (this.hasValue = !0), !this.throttled)) {
            let n
            try {
              const { durationSelector: e } = this
              n = e(t)
            } catch (e) {
              return this.destination.error(e)
            }
            const i = Object(u.a)(this, n)
            !i || i.closed
              ? this.clearThrottle()
              : this.add((this.throttled = i))
          }
        }
        clearThrottle() {
          const { value: t, hasValue: e, throttled: n } = this
          n && (this.remove(n), (this.throttled = null), n.unsubscribe()),
            e &&
              ((this.value = null),
              (this.hasValue = !1),
              this.destination.next(t))
        }
        notifyNext(t, e, n, i) {
          this.clearThrottle()
        }
        notifyComplete() {
          this.clearThrottle()
        }
      }
      var p = n('DH7j')
      function f(t) {
        return !Object(p.a)(t) && t - parseFloat(t) + 1 >= 0
      }
      var m = n('z+Ro')
      function g(t) {
        const { index: e, period: n, subscriber: i } = t
        if ((i.next(e), !i.closed)) {
          if (-1 === n) return i.complete()
          ;(t.index = e + 1), this.schedule(t, n)
        }
      }
      function b(t, e = l.a) {
        return (
          (n = () =>
            (function (t = 0, e, n) {
              let i = -1
              return (
                f(e)
                  ? (i = Number(e) < 1 ? 1 : Number(e))
                  : Object(m.a)(e) && (n = e),
                Object(m.a)(n) || (n = l.a),
                new o.a((e) => {
                  const r = f(t) ? t : +t - n.now()
                  return n.schedule(g, r, {
                    index: 0,
                    period: i,
                    subscriber: e,
                  })
                })
              )
            })(t, e)),
          function (t) {
            return t.lift(new h(n))
          }
        )
        var n
      }
      var _ = n('pLZG'),
        y = n('1G5W')
      n('JX91'), n('7o/Q'), n('eIep'), n('WMd4'), n('9ppp'), n('Ylt2')
      var v = n('nLfN'),
        w = n('ofXK'),
        C = n('cH1L')
      n('0EQZ')
      let x = (() => {
          class t {
            constructor(t, e, n) {
              ;(this._ngZone = t),
                (this._platform = e),
                (this._scrolled = new r.a()),
                (this._globalSubscription = null),
                (this._scrolledCount = 0),
                (this.scrollContainers = new Map()),
                (this._document = n)
            }
            register(t) {
              this.scrollContainers.has(t) ||
                this.scrollContainers.set(
                  t,
                  t.elementScrolled().subscribe(() => this._scrolled.next(t))
                )
            }
            deregister(t) {
              const e = this.scrollContainers.get(t)
              e && (e.unsubscribe(), this.scrollContainers.delete(t))
            }
            scrolled(t = 20) {
              return this._platform.isBrowser
                ? new o.a((e) => {
                    this._globalSubscription || this._addGlobalListener()
                    const n =
                      t > 0
                        ? this._scrolled.pipe(b(t)).subscribe(e)
                        : this._scrolled.subscribe(e)
                    return (
                      this._scrolledCount++,
                      () => {
                        n.unsubscribe(),
                          this._scrolledCount--,
                          this._scrolledCount || this._removeGlobalListener()
                      }
                    )
                  })
                : Object(s.a)()
            }
            ngOnDestroy() {
              this._removeGlobalListener(),
                this.scrollContainers.forEach((t, e) => this.deregister(e)),
                this._scrolled.complete()
            }
            ancestorScrolled(t, e) {
              const n = this.getAncestorScrollContainers(t)
              return this.scrolled(e).pipe(
                Object(_.a)((t) => !t || n.indexOf(t) > -1)
              )
            }
            getAncestorScrollContainers(t) {
              const e = []
              return (
                this.scrollContainers.forEach((n, i) => {
                  this._scrollableContainsElement(i, t) && e.push(i)
                }),
                e
              )
            }
            _getWindow() {
              return this._document.defaultView || window
            }
            _scrollableContainsElement(t, e) {
              let n = e.nativeElement,
                i = t.getElementRef().nativeElement
              do {
                if (n == i) return !0
              } while ((n = n.parentElement))
              return !1
            }
            _addGlobalListener() {
              this._globalSubscription = this._ngZone.runOutsideAngular(() => {
                const t = this._getWindow()
                return Object(a.a)(t.document, 'scroll').subscribe(() =>
                  this._scrolled.next()
                )
              })
            }
            _removeGlobalListener() {
              this._globalSubscription &&
                (this._globalSubscription.unsubscribe(),
                (this._globalSubscription = null))
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Ub(i.z), i.Ub(v.a), i.Ub(w.d, 8))
            }),
            (t.ɵprov = Object(i.Hb)({
              factory: function () {
                return new t(
                  Object(i.Ub)(i.z),
                  Object(i.Ub)(v.a),
                  Object(i.Ub)(w.d, 8)
                )
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        S = (() => {
          class t {
            constructor(t, e, n, i) {
              ;(this.elementRef = t),
                (this.scrollDispatcher = e),
                (this.ngZone = n),
                (this.dir = i),
                (this._destroyed = new r.a()),
                (this._elementScrolled = new o.a((t) =>
                  this.ngZone.runOutsideAngular(() =>
                    Object(a.a)(this.elementRef.nativeElement, 'scroll')
                      .pipe(Object(y.a)(this._destroyed))
                      .subscribe(t)
                  )
                ))
            }
            ngOnInit() {
              this.scrollDispatcher.register(this)
            }
            ngOnDestroy() {
              this.scrollDispatcher.deregister(this),
                this._destroyed.next(),
                this._destroyed.complete()
            }
            elementScrolled() {
              return this._elementScrolled
            }
            getElementRef() {
              return this.elementRef
            }
            scrollTo(t) {
              const e = this.elementRef.nativeElement,
                n = this.dir && 'rtl' == this.dir.value
              null == t.left && (t.left = n ? t.end : t.start),
                null == t.right && (t.right = n ? t.start : t.end),
                null != t.bottom &&
                  (t.top = e.scrollHeight - e.clientHeight - t.bottom),
                n && 0 != Object(v.d)()
                  ? (null != t.left &&
                      (t.right = e.scrollWidth - e.clientWidth - t.left),
                    2 == Object(v.d)()
                      ? (t.left = t.right)
                      : 1 == Object(v.d)() &&
                        (t.left = t.right ? -t.right : t.right))
                  : null != t.right &&
                    (t.left = e.scrollWidth - e.clientWidth - t.right),
                this._applyScrollToOptions(t)
            }
            _applyScrollToOptions(t) {
              const e = this.elementRef.nativeElement
              Object(v.f)()
                ? e.scrollTo(t)
                : (null != t.top && (e.scrollTop = t.top),
                  null != t.left && (e.scrollLeft = t.left))
            }
            measureScrollOffset(t) {
              const e = 'left',
                n = 'right',
                i = this.elementRef.nativeElement
              if ('top' == t) return i.scrollTop
              if ('bottom' == t)
                return i.scrollHeight - i.clientHeight - i.scrollTop
              const r = this.dir && 'rtl' == this.dir.value
              return (
                'start' == t ? (t = r ? n : e) : 'end' == t && (t = r ? e : n),
                r && 2 == Object(v.d)()
                  ? t == e
                    ? i.scrollWidth - i.clientWidth - i.scrollLeft
                    : i.scrollLeft
                  : r && 1 == Object(v.d)()
                  ? t == e
                    ? i.scrollLeft + i.scrollWidth - i.clientWidth
                    : -i.scrollLeft
                  : t == e
                  ? i.scrollLeft
                  : i.scrollWidth - i.clientWidth - i.scrollLeft
              )
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Lb(i.l), i.Lb(x), i.Lb(i.z), i.Lb(C.b, 8))
            }),
            (t.ɵdir = i.Gb({
              type: t,
              selectors: [
                ['', 'cdk-scrollable', ''],
                ['', 'cdkScrollable', ''],
              ],
            })),
            t
          )
        })(),
        O = (() => {
          class t {
            constructor(t, e, n) {
              ;(this._platform = t),
                (this._change = new r.a()),
                (this._changeListener = (t) => {
                  this._change.next(t)
                }),
                (this._document = n),
                e.runOutsideAngular(() => {
                  if (t.isBrowser) {
                    const t = this._getWindow()
                    t.addEventListener('resize', this._changeListener),
                      t.addEventListener(
                        'orientationchange',
                        this._changeListener
                      )
                  }
                  this.change().subscribe(() => this._updateViewportSize())
                })
            }
            ngOnDestroy() {
              if (this._platform.isBrowser) {
                const t = this._getWindow()
                t.removeEventListener('resize', this._changeListener),
                  t.removeEventListener(
                    'orientationchange',
                    this._changeListener
                  )
              }
              this._change.complete()
            }
            getViewportSize() {
              this._viewportSize || this._updateViewportSize()
              const t = {
                width: this._viewportSize.width,
                height: this._viewportSize.height,
              }
              return this._platform.isBrowser || (this._viewportSize = null), t
            }
            getViewportRect() {
              const t = this.getViewportScrollPosition(),
                { width: e, height: n } = this.getViewportSize()
              return {
                top: t.top,
                left: t.left,
                bottom: t.top + n,
                right: t.left + e,
                height: n,
                width: e,
              }
            }
            getViewportScrollPosition() {
              if (!this._platform.isBrowser) return { top: 0, left: 0 }
              const t = this._document,
                e = this._getWindow(),
                n = t.documentElement,
                i = n.getBoundingClientRect()
              return {
                top:
                  -i.top || t.body.scrollTop || e.scrollY || n.scrollTop || 0,
                left:
                  -i.left ||
                  t.body.scrollLeft ||
                  e.scrollX ||
                  n.scrollLeft ||
                  0,
              }
            }
            change(t = 20) {
              return t > 0 ? this._change.pipe(b(t)) : this._change
            }
            _getWindow() {
              return this._document.defaultView || window
            }
            _updateViewportSize() {
              const t = this._getWindow()
              this._viewportSize = this._platform.isBrowser
                ? { width: t.innerWidth, height: t.innerHeight }
                : { width: 0, height: 0 }
            }
          }
          return (
            (t.ɵfac = function (e) {
              return new (e || t)(i.Ub(v.a), i.Ub(i.z), i.Ub(w.d, 8))
            }),
            (t.ɵprov = Object(i.Hb)({
              factory: function () {
                return new t(
                  Object(i.Ub)(v.a),
                  Object(i.Ub)(i.z),
                  Object(i.Ub)(w.d, 8)
                )
              },
              token: t,
              providedIn: 'root',
            })),
            t
          )
        })(),
        k = (() => {
          class t {}
          return (
            (t.ɵmod = i.Jb({ type: t })),
            (t.ɵinj = i.Ib({
              factory: function (e) {
                return new (e || t)()
              },
            })),
            t
          )
        })(),
        E = (() => {
          class t {}
          return (
            (t.ɵmod = i.Jb({ type: t })),
            (t.ɵinj = i.Ib({
              factory: function (e) {
                return new (e || t)()
              },
              imports: [[C.a, v.b, k], C.a, k],
            })),
            t
          )
        })()
    },
    w1tV: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return a
      })
      var i = n('oB13'),
        r = n('x+ZX'),
        s = n('XNiG')
      function o() {
        return new s.a()
      }
      function a() {
        return (t) => Object(r.a)()(Object(i.a)(o)(t))
      }
    },
    'x+ZX': function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return r
      })
      var i = n('7o/Q')
      function r() {
        return function (t) {
          return t.lift(new s(t))
        }
      }
      class s {
        constructor(t) {
          this.connectable = t
        }
        call(t, e) {
          const { connectable: n } = this
          n._refCount++
          const i = new o(t, n),
            r = e.subscribe(i)
          return i.closed || (i.connection = n.connect()), r
        }
      }
      class o extends i.a {
        constructor(t, e) {
          super(t), (this.connectable = e)
        }
        _unsubscribe() {
          const { connectable: t } = this
          if (!t) return void (this.connection = null)
          this.connectable = null
          const e = t._refCount
          if (e <= 0) return void (this.connection = null)
          if (((t._refCount = e - 1), e > 1))
            return void (this.connection = null)
          const { connection: n } = this,
            i = t._connection
          ;(this.connection = null), !i || (n && i !== n) || i.unsubscribe()
        }
      }
    },
    xgIS: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return a
      })
      var i = n('HDdC'),
        r = n('DH7j'),
        s = n('n6bG'),
        o = n('lJxs')
      function a(t, e, n, c) {
        return (
          Object(s.a)(n) && ((c = n), (n = void 0)),
          c
            ? a(t, e, n).pipe(
                Object(o.a)((t) => (Object(r.a)(t) ? c(...t) : c(t)))
              )
            : new i.a((i) => {
                l(
                  t,
                  e,
                  function (t) {
                    i.next(
                      arguments.length > 1
                        ? Array.prototype.slice.call(arguments)
                        : t
                    )
                  },
                  i,
                  n
                )
              })
        )
      }
      function l(t, e, n, i, r) {
        let s
        if (
          (function (t) {
            return (
              t &&
              'function' == typeof t.addEventListener &&
              'function' == typeof t.removeEventListener
            )
          })(t)
        ) {
          const i = t
          t.addEventListener(e, n, r),
            (s = () => i.removeEventListener(e, n, r))
        } else if (
          (function (t) {
            return t && 'function' == typeof t.on && 'function' == typeof t.off
          })(t)
        ) {
          const i = t
          t.on(e, n), (s = () => i.off(e, n))
        } else if (
          (function (t) {
            return (
              t &&
              'function' == typeof t.addListener &&
              'function' == typeof t.removeListener
            )
          })(t)
        ) {
          const i = t
          t.addListener(e, n), (s = () => i.removeListener(e, n))
        } else {
          if (!t || !t.length) throw new TypeError('Invalid event target')
          for (let s = 0, o = t.length; s < o; s++) l(t[s], e, n, i, r)
        }
        i.add(s)
      }
    },
    yCtX: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return o
      })
      var i = n('HDdC'),
        r = n('ngJS'),
        s = n('jZKg')
      function o(t, e) {
        return e ? Object(s.a)(t, e) : new i.a(Object(r.a)(t))
      }
    },
    yXgJ: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return u
      })
      var i = n('R0Ic')
      const r = {
        fadeOverlog: Object(i.n)('fadeAnimation', [
          Object(i.k)('default', Object(i.l)({ opacity: 1 })),
          Object(i.m)('void => *', [
            Object(i.l)({ opacity: 0 }),
            Object(i.e)('{{ fadeIn }}ms'),
          ]),
          Object(i.m)(
            'default => closing',
            Object(i.e)('{{ fadeOut }}ms', Object(i.l)({ opacity: 0 }))
          ),
        ]),
      }
      Object(i.g)([
        Object(i.l)({ transform: 'scale(1)' }),
        Object(i.e)(
          '{{ timings }}',
          Object(i.h)([
            Object(i.l)({ transform: 'scale(1)', offset: 0 }),
            Object(i.l)({ transform: 'scale(2)', offset: 0.5 }),
            Object(i.l)({ transform: 'scale(1)', offset: 1 }),
          ])
        ),
      ]),
        Object(i.g)([
          Object(i.l)({ transform: 'translateY({{ from }})', opacity: 0 }),
          Object(i.e)('{{ timings }}', Object(i.l)('*')),
        ]),
        Object(i.g)([
          Object(i.e)(
            '{{ timings }}',
            Object(i.l)({ transform: 'translateY({{ to }})', opacity: 0 })
          ),
        ])
      var s = n('cPJY'),
        o = n('ZL+G'),
        a = n('fXoL')
      const l = function (t, e) {
          return { fadeIn: t, fadeOut: e }
        },
        c = function (t, e) {
          return { value: t, params: e }
        }
      let u = (() => {
        class t {
          constructor(t, e, n) {
            ;(this.data = t),
              (this.ref = e),
              (this.overlogConfig = n),
              (this.animationState = 'default'),
              (this.iconType = 'success' === t.type ? 'done' : t.type)
          }
          ngOnInit() {
            const { duration: t } = this.data
            this.intervalId = window.setTimeout(() => {
              this.animationState = 'closing'
            }, t || 5e3)
          }
          ngOnDestroy() {
            window.clearTimeout(this.intervalId)
          }
          close() {
            this.ref.close()
          }
          onFadeFinished(t) {
            const { toState: e } = t
            'closing' === e && 'closing' === this.animationState && this.close()
          }
        }
        return (
          (t.ɵfac = function (e) {
            return new (e || t)(a.Lb(s.b), a.Lb(o.a), a.Lb(s.a))
          }),
          (t.ɵcmp = a.Fb({
            type: t,
            selectors: [['quertc-overlog']],
            decls: 4,
            vars: 10,
            consts: [[1, 'material-icons', 3, 'click']],
            template: function (t, e) {
              1 & t &&
                (a.Qb(0, 'i', 0),
                a.Xb('click', function () {
                  return e.close()
                }),
                a.xc(1, 'close'),
                a.Pb(),
                a.Qb(2, 'div'),
                a.Xb('@fadeAnimation.done', function (t) {
                  return e.onFadeFinished(t)
                }),
                a.xc(3),
                a.Pb()),
                2 & t &&
                  (a.zb(2),
                  a.Bb('overlog ' + e.data.type),
                  a.gc(
                    '@fadeAnimation',
                    a.ic(
                      7,
                      c,
                      e.animationState,
                      a.ic(
                        4,
                        l,
                        e.overlogConfig.animation.fadeIn,
                        e.overlogConfig.animation.fadeOut
                      )
                    )
                  ),
                  a.zb(1),
                  a.zc(' ', e.data.text, ' '))
            },
            styles: [
              '[_nghost-%COMP%]{display:block;position:relative;padding:8px 16px;border-radius:6px;margin-bottom:8px;background-color:hsla(0,0%,100%,.4392156862745098);transition:background-color .2s ease-in-out}[_nghost-%COMP%]:hover{background-color:#fff}[_nghost-%COMP%]   .material-icons[_ngcontent-%COMP%]{cursor:pointer;position:absolute;color:#111;font-size:16px;height:16px;width:16px;right:0;top:0}',
            ],
            data: { animation: [r.fadeOverlog] },
          })),
          t
        )
      })()
    },
    yeub: function (t, e) {
      try {
        t.exports =
          'undefined' != typeof XMLHttpRequest &&
          'withCredentials' in new XMLHttpRequest()
      } catch (n) {
        t.exports = !1
      }
    },
    ypnn: function (t, e) {
      t.exports = function (t, e, n) {
        var i = t.byteLength
        if (((e = e || 0), (n = n || i), t.slice)) return t.slice(e, n)
        if (
          (e < 0 && (e += i),
          n < 0 && (n += i),
          n > i && (n = i),
          e >= i || e >= n || 0 === i)
        )
          return new ArrayBuffer(0)
        for (
          var r = new Uint8Array(t), s = new Uint8Array(n - e), o = e, a = 0;
          o < n;
          o++, a++
        )
          s[a] = r[o]
        return s.buffer
      }
    },
    'z+Ro': function (t, e, n) {
      'use strict'
      function i(t) {
        return t && 'function' == typeof t.schedule
      }
      n.d(e, 'a', function () {
        return i
      })
    },
    z6cu: function (t, e, n) {
      'use strict'
      n.d(e, 'a', function () {
        return r
      })
      var i = n('HDdC')
      function r(t, e) {
        return new i.a(
          e
            ? (n) => e.schedule(s, 0, { error: t, subscriber: n })
            : (e) => e.error(t)
        )
      }
      function s({ error: t, subscriber: e }) {
        e.error(t)
      }
    },
    zJ60: function (t, e, n) {
      var i = n('Uxeu'),
        r = n('NOtv')('socket.io-client:url')
      t.exports = function (t, e) {
        var n = t
        ;(e = e || ('undefined' != typeof location && location)),
          null == t && (t = e.protocol + '//' + e.host),
          'string' == typeof t &&
            ('/' === t.charAt(0) &&
              (t = '/' === t.charAt(1) ? e.protocol + t : e.host + t),
            /^(https?|wss?):\/\//.test(t) ||
              (r('protocol-less url %s', t),
              (t = void 0 !== e ? e.protocol + '//' + t : 'https://' + t)),
            r('parse %s', t),
            (n = i(t))),
          n.port ||
            (/^(http|ws)$/.test(n.protocol)
              ? (n.port = '80')
              : /^(http|ws)s$/.test(n.protocol) && (n.port = '443')),
          (n.path = n.path || '/')
        var s = -1 !== n.host.indexOf(':') ? '[' + n.host + ']' : n.host
        return (
          (n.id = n.protocol + '://' + s + ':' + n.port),
          (n.href =
            n.protocol +
            '://' +
            s +
            (e && e.port === n.port ? '' : ':' + n.port)),
          n
        )
      }
    },
    zMFY: function (t, e) {
      function n() {}
      t.exports = function (t, e, i) {
        var r = !1
        return (i = i || n), (s.count = t), 0 === t ? e() : s
        function s(t, n) {
          if (s.count <= 0) throw new Error('after called too many times')
          --s.count,
            t ? ((r = !0), e(t), (e = i)) : 0 !== s.count || r || e(null, n)
        }
      }
    },
  },
  [[0, 0]],
])
